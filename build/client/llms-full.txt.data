[{"_1":2},"routes/_api/llms-full",{"_3":4},"data","# Access Control Matrix (/docs/acl-matrix)\n## Interpreting the ACL Matrix Table\n\nThe following conventions are used in the ACL Matrix table:\n\n### Scopes\n\nPermissions are evaluated starting at the widest scope and working to the narrowest scope.\n\nA scope corresponds to a level of the data model. From broadest to narrowest, the scopes are as follows:\n\n#### Scopes\n\n* Global\n* Namespace (NS)\n* Table\n* Column Family (CF)\n* Column Qualifier (CQ)\n* Cell\n\nFor instance, a permission granted at table level dominates any grants done at the Column Family, Column Qualifier, or cell level. The user can do what that grant implies at any location in the table. A permission granted at global scope dominates all: the user is always allowed to take that action everywhere.\n\n### Permissions\n\nPossible permissions include the following:\n\n#### Permissions\n\n* Superuser - a special user that belongs to group \"supergroup\" and has unlimited access\n* Admin (A)\n* Create (C)\n* Write (W)\n* Read (R)\n* Execute (X)\n\nFor the most part, permissions work in an expected way, with the following caveats:\n\n**Having Write permission does not imply Read permission.**\\\nIt is possible and sometimes desirable for a user to be able to write data that same user cannot read. One such example is a log-writing process.\n\n**The `hbase:meta` table is readable by every user, regardless of the user's other grants or restrictions.**\\\nThis is a requirement for HBase to function correctly.\n\n**`CheckAndPut` and `CheckAndDelete` operations will fail if the user does not have both Write and Read permission.**\\\n**`Increment` and `Append` operations do not require Read access.**\\\n**The `superuser`, as the name suggests has permissions to perform all possible operations.**\\\n**And for the operations marked with \\*, the checks are done in post hook and only subset of results satisfying access checks are returned back to the user.**\\\nThe following table is sorted by the interface that provides each operation.\nIn case the table goes out of date, the unit tests which check for accuracy of permissions can be found in *hbase-server/src/test/java/org/apache/hadoop/hbase/security/access/TestAccessController.java*, and the access controls themselves can be examined in *hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java*.\n\n## ACL Matrix\n\n| Interface        | Operation                           | Permissions                                                                                         |\n| ---------------- | ----------------------------------- | --------------------------------------------------------------------------------------------------- |\n| Master           | createTable                         | superuser\\|global(C)\\|NS(C)                                                                         |\n|                  | modifyTable                         | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | deleteTable                         | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | truncateTable                       | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | addColumn                           | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | modifyColumn                        | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)\\|column(A)\\|column(C) |\n|                  | deleteColumn                        | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)\\|column(A)\\|column(C) |\n|                  | enableTable                         | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | disableTable                        | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | disableAclTable                     | Not allowed                                                                                         |\n|                  | move                                | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | assign                              | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | unassign                            | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | regionOffline                       | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | balance                             | superuser\\|global(A)                                                                                |\n|                  | balanceSwitch                       | superuser\\|global(A)                                                                                |\n|                  | shutdown                            | superuser\\|global(A)                                                                                |\n|                  | stopMaster                          | superuser\\|global(A)                                                                                |\n|                  | snapshot                            | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | listSnapshot                        | superuser\\|global(A)\\|SnapshotOwner                                                                 |\n|                  | cloneSnapshot                       | superuser\\|global(A)\\|(SnapshotOwner & TableName matches)                                           |\n|                  | restoreSnapshot                     | superuser\\|global(A)\\|SnapshotOwner & (NS(A)\\|TableOwner\\|table(A))                                 |\n|                  | deleteSnapshot                      | superuser\\|global(A)\\|SnapshotOwner                                                                 |\n|                  | createNamespace                     | superuser\\|global(A)                                                                                |\n|                  | deleteNamespace                     | superuser\\|global(A)                                                                                |\n|                  | modifyNamespace                     | superuser\\|global(A)                                                                                |\n|                  | getNamespaceDescriptor              | superuser\\|global(A)\\|NS(A)                                                                         |\n|                  | listNamespaceDescriptors\\*          | superuser\\|global(A)\\|NS(A)                                                                         |\n|                  | flushTable                          | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | getTableDescriptors\\*               | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | getTableNames\\*                     | superuser\\|TableOwner\\|Any global or table perm                                                     |\n|                  | setUserQuota(global level)          | superuser\\|global(A)                                                                                |\n|                  | setUserQuota(namespace level)       | superuser\\|global(A)                                                                                |\n|                  | setUserQuota(Table level)           | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | setTableQuota                       | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | setNamespaceQuota                   | superuser\\|global(A)                                                                                |\n|                  | addReplicationPeer                  | superuser\\|global(A)                                                                                |\n|                  | removeReplicationPeer               | superuser\\|global(A)                                                                                |\n|                  | enableReplicationPeer               | superuser\\|global(A)                                                                                |\n|                  | disableReplicationPeer              | superuser\\|global(A)                                                                                |\n|                  | getReplicationPeerConfig            | superuser\\|global(A)                                                                                |\n|                  | updateReplicationPeerConfig         | superuser\\|global(A)                                                                                |\n|                  | listReplicationPeers                | superuser\\|global(A)                                                                                |\n|                  | getClusterStatus                    | any user                                                                                            |\n| Region           | openRegion                          | superuser\\|global(A)                                                                                |\n|                  | closeRegion                         | superuser\\|global(A)                                                                                |\n|                  | flush                               | superuser\\|global(A)\\|global(C)\\|TableOwner\\|table(A)\\|table(C)                                     |\n|                  | split                               | superuser\\|global(A)\\|TableOwner\\|TableOwner\\|table(A)                                              |\n|                  | compact                             | superuser\\|global(A)\\|global(C)\\|TableOwner\\|table(A)\\|table(C)                                     |\n|                  | getClosestRowBefore                 | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | getOp                               | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | exists                              | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | put                                 | superuser\\|global(W)\\|NS(W)\\|table(W)\\|TableOwner\\|CF(W)\\|CQ(W)                                     |\n|                  | delete                              | superuser\\|global(W)\\|NS(W)\\|table(W)\\|TableOwner\\|CF(W)\\|CQ(W)                                     |\n|                  | batchMutate                         | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | checkAndPut                         | superuser\\|global(RW)\\|NS(RW)\\|TableOwner\\|table(RW)\\|CF(RW)\\|CQ(RW)                                |\n|                  | checkAndPutAfterRowLock             | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|Table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | checkAndDelete                      | superuser\\|global(RW)\\|NS(RW)\\|TableOwner\\|table(RW)\\|CF(RW)\\|CQ(RW)                                |\n|                  | checkAndDeleteAfterRowLock          | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | incrementColumnValue                | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | append                              | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | appendAfterRowLock                  | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | increment                           | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | incrementAfterRowLock               | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | scannerOpen                         | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | scannerNext                         | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | scannerClose                        | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | bulkLoadHFile                       | superuser\\|global(C)\\|TableOwner\\|table(C)\\|CF(C)                                                   |\n|                  | prepareBulkLoad                     | superuser\\|global(C)\\|TableOwner\\|table(C)\\|CF(C)                                                   |\n|                  | cleanupBulkLoad                     | superuser\\|global(C)\\|TableOwner\\|table(C)\\|CF(C)                                                   |\n| Endpoint         | invoke                              | superuser\\|global(X)\\|NS(X)\\|TableOwner\\|table(X)                                                   |\n| AccessController | grant(global level)                 | global(A)                                                                                           |\n|                  | grant(namespace level)              | global(A)\\|NS(A)                                                                                    |\n|                  | grant(table level)                  | global(A)\\|NS(A)\\|TableOwner\\|table(A)\\|CF(A)\\|CQ(A)                                                |\n|                  | revoke(global level)                | global(A)                                                                                           |\n|                  | revoke(namespace level)             | global(A)\\|NS(A)                                                                                    |\n|                  | revoke(table level)                 | global(A)\\|NS(A)\\|TableOwner\\|table(A)\\|CF(A)\\|CQ(A)                                                |\n|                  | getUserPermissions(global level)    | global(A)                                                                                           |\n|                  | getUserPermissions(namespace level) | global(A)\\|NS(A)                                                                                    |\n|                  | getUserPermissions(table level)     | global(A)\\|NS(A)\\|TableOwner\\|table(A)\\|CF(A)\\|CQ(A)                                                |\n|                  | hasPermission(table level)          | global(A)\\|SelfUserCheck                                                                            |\n| RegionServer     | stopRegionServer                    | superuser\\|global(A)                                                                                |\n|                  | mergeRegions                        | superuser\\|global(A)                                                                                |\n|                  | rollWALWriterRequest                | superuser\\|global(A)                                                                                |\n|                  | replicateLogEntries                 | superuser\\|global(W)                                                                                |\n| RSGroup          | addRSGroup                          | superuser\\|global(A)                                                                                |\n|                  | balanceRSGroup                      | superuser\\|global(A)                                                                                |\n|                  | getRSGroupInfo                      | superuser\\|global(A)                                                                                |\n|                  | getRSGroupInfoOfTable               | superuser\\|global(A)                                                                                |\n|                  | getRSGroupOfServer                  | superuser\\|global(A)                                                                                |\n|                  | listRSGroups                        | superuser\\|global(A)                                                                                |\n|                  | moveServers                         | superuser\\|global(A)                                                                                |\n|                  | moveServersAndTables                | superuser\\|global(A)                                                                                |\n|                  | moveTables                          | superuser\\|global(A)                                                                                |\n|                  | removeRSGroup                       | superuser\\|global(A)                                                                                |\n|                  | removeServers                       | superuser\\|global(A)                                                                                |\n\n\n# AMv2 Description for Devs (/docs/amv2)\nThe AMv2 project is a redo of Assignment in an attempt at addressing the root cause of many of our operational issues in production, namely slow assignment and problematic accounting such that Regions are misplaced stuck offline in the notorious *Regions-In-Transition (RIT)* limbo state.\n\nBelow are notes for devs on key aspects of AMv2 in no particular order.\n\n## Background\n\nAssignment in HBase 1.x has been problematic in operation. It is not hard to see why. Region state is kept at the other end of an RPC in ZooKeeper (Terminal states — i.e. OPEN or CLOSED — are published to the *hbase:meta* table). In HBase-1.x.x, state has multiple writers with Master and RegionServers all able to make state edits concurrently (in *hbase:meta* table and out on ZooKeeper). If clocks are awry or watchers missed, state changes can be skipped or overwritten. Locking of HBase Entities — tables, regions — is not comprehensive so a table operation — disable/enable — could clash with a region-level operation; a split or merge. Region state is distributed and hard to reason about and test. Assignment is slow in operation because each assign involves moving remote znodes through transitions. Cluster size tends to top out at a couple of hundred thousand regions; beyond this, cluster start/stop takes hours and is prone to corruption.\n\nAMv2 (AssignmentManager Version 2) is a refactor ([HBASE-14350](https://issues.apache.org/jira/browse/HBASE-14350)) of the hbase-1.x AssignmentManager putting it up on a [ProcedureV2 (HBASE-12439)](https://issues.apache.org/jira/browse/HBASE-12439) basis. ProcedureV2 (Pv2), is an awkwardly named system that allows describing and running multi-step state machines. It is performant and persists all state to a Store which is recoverable post crash. See the companion chapter on [Procedure Framework (Pv2)](/docs/pv2), to learn more about the ProcedureV2 system.\n\nIn AMv2, all assignment, crash handling, splits and merges are recast as Procedures(v2). ZooKeeper is purged from the mix. As before, the final assignment state gets published to *hbase:meta* for non-Master participants to read (all-clients) with intermediate state kept in the local Pv2 WAL-based 'store' but only the active Master, a single-writer, evolves state. The Master's in-memory cluster image is the authority and if disagreement, RegionServers are forced to comply. Pv2 adds shared/exclusive locking of all core HBase Entities — namespace, tables, and regions — to ensure one actor at a time access and to prevent operations contending over resources (move/split, disable/assign, etc.).\n\nThis redo of AM atop of a purposed, performant state machine with all operations taking on the common Procedure form with a single state writer only moves our AM to a new level of resilience and scale.\n\n## New System\n\nEach Region Assign or Unassign of a Region is now a Procedure. A Move (Region) Procedure is a compound of Procedures; it is the running of an Unassign Procedure followed by an Assign Procedure. The Move Procedure spawns the Assign and Unassign in series and then waits on their completions.\n\nAnd so on. ServerCrashProcedure spawns the WAL splitting tasks and then the reassign of all regions that were hosted on the crashed server as subprocedures.\n\nAMv2 Procedures are run by the Master in a ProcedureExecutor instance. All Procedures make use of utility provided by the Pv2 framework.\n\nFor example, Procedures persist each state transition to the frameworks' Procedure Store. The default implementation is done as a WAL kept on HDFS. On crash, we reopen the Store and rerun all WALs of Procedure transitions to put the Assignment State Machine back into the attitude it had just before crash. We then continue Procedure execution.\n\nIn the new system, the Master is the Authority on all things Assign. Previous we were ambiguous; e.g. the RegionServer was in charge of Split operations. Master keeps an in-memory image of Region states and servers. If disagreement, the Master always prevails; at an extreme it will kill the RegionServer that is in disagreement.\n\nA new RegionStateStore class takes care of publishing the terminal Region state, whether OPEN or CLOSED, out to the *hbase:meta* table.\n\nRegionServers now report their run version on Connection. This version is available inside the AM for use running migrating rolling restarts.\n\n## Procedures Detail\n\n### Assign/Unassign\n\nAssign and Unassign subclass a common RegionTransitionProcedure. There can only be one RegionTransitionProcedure per region running at a time since the RTP instance takes a lock on the region. The RTP base Procedure has three steps; a store the procedure step (REGION\\_TRANSITION\\_QUEUE); a dispatch of the procedure open or close followed by a suspend waiting on the remote regionserver to report successful open or fail (REGION\\_TRANSITION\\_DISPATCH) or notification that the server fielding the request crashed; and finally registration of the successful open/close in hbase:meta (REGION\\_TRANSITION\\_FINISH).\n\nHere is how the assign of a region 56f985a727afe80a184dac75fbf6860c looks in the logs. The assign was provoked by a Server Crash (Process ID 1176 or pid=1176 which when it is the parent of a procedure, it is identified as ppid=1176). The assign is pid=1179, the second region of the two being assigned by this Server Crash.\n\n```\n2017-05-23 12:04:24,175 INFO  [ProcExecWrkr-30] procedure2.ProcedureExecutor: Initialized subprocedures=[{pid=1178, ppid=1176, state=RUNNABLE:REGION_TRANSITION_QUEUE; AssignProcedure table=IntegrationTestBigLinkedList, region=bfd57f0b72fd3ca77e9d3c5e3ae48d76, target=ve0540.halxg.example.org,16020,1495525111232}, {pid=1179, ppid=1176, state=RUNNABLE:REGION_TRANSITION_QUEUE; AssignProcedure table=IntegrationTestBigLinkedList, region=56f985a727afe80a184dac75fbf6860c, target=ve0540.halxg.example.org,16020,1495525111232}]\n```\n\nNext we start the assign by queuing ('registering') the Procedure with the framework.\n\n```\n2017-05-23 12:04:24,241 INFO  [ProcExecWrkr-30] assignment.AssignProcedure: Start pid=1179, ppid=1176, state=RUNNABLE:REGION_TRANSITION_QUEUE; AssignProcedure table=IntegrationTestBigLinkedList, region=56f985a727afe80a184dac75fbf6860c, target=ve0540.halxg.example.org,16020,1495525111232; rit=OFFLINE, location=ve0540.halxg.example.org,16020,1495525111232; forceNewPlan=false, retain=false\n```\n\nTrack the running of Procedures in logs by tracing their process id — here pid=1179.\n\nNext we move to the dispatch phase where we update hbase:meta table setting the region state as OPENING on server ve540. We then dispatch an rpc to ve540 asking it to open the region. Thereafter we suspend the Assign until we get a message back from ve540 on whether it has opened the region successfully (or not).\n\n```\n2017-05-23 12:04:24,494 INFO  [ProcExecWrkr-38] assignment.RegionStateStore: pid=1179 updating hbase:meta row=IntegrationTestBigLinkedList,H\\xE3@\\x8D\\x964\\x9D\\xDF\\x8F@9\\x0F\\xC8\\xCC\\xC2,1495566261066.56f985a727afe80a184dac75fbf6860c., regionState=OPENING, regionLocation=ve0540.halxg.example.org,16020,1495525111232\n2017-05-23 12:04:24,498 INFO  [ProcExecWrkr-38] assignment.RegionTransitionProcedure: Dispatch pid=1179, ppid=1176, state=RUNNABLE:REGION_TRANSITION_DISPATCH; AssignProcedure table=IntegrationTestBigLinkedList, region=56f985a727afe80a184dac75fbf6860c, target=ve0540.halxg.example.org,16020,1495525111232; rit=OPENING, location=ve0540.halxg.example.org,16020,1495525111232\n```\n\nBelow we log the incoming report that the region opened successfully on ve540. The Procedure is woken up (you can tell it the procedure is running by the name of the thread, its a ProcedureExecutor thread, ProcExecWrkr-9). The woken up Procedure updates state in hbase:meta to denote the region as open on ve0540. It then reports finished and exits.\n\n```\n2017-05-23 12:04:26,643 DEBUG [RpcServer.default.FPBQ.Fifo.handler=46,queue=1,port=16000] assignment.RegionTransitionProcedure: Received report OPENED seqId=11984985, pid=1179, ppid=1176, state=RUNNABLE:REGION_TRANSITION_DISPATCH; AssignProcedure table=IntegrationTestBigLinkedList, region=56f985a727afe80a184dac75fbf6860c, target=ve0540.halxg.example.org,16020,1495525111232; rit=OPENING, location=ve0540.halxg.example.org,16020,1495525111232\n2017-05-23 12:04:26,643 INFO  [ProcExecWrkr-9] assignment.RegionStateStore: pid=1179 updating hbase:meta row=IntegrationTestBigLinkedList,H\\xE3@\\x8D\\x964\\x9D\\xDF\\x8F@9\\x0F\\xC8\\xCC\\xC2,1495566261066.56f985a727afe80a184dac75fbf6860c., regionState=OPEN, openSeqNum=11984985, regionLocation=ve0540.halxg.example.org,16020,1495525111232\n2017-05-23 12:04:26,836 INFO  [ProcExecWrkr-9] procedure2.ProcedureExecutor: Finish suprocedure pid=1179, ppid=1176, state=SUCCESS; AssignProcedure table=IntegrationTestBigLinkedList, region=56f985a727afe80a184dac75fbf6860c, target=ve0540.halxg.example.org,16020,1495525111232\n```\n\nUnassign looks similar given it is based on the base RegionTransitionProcedure. It has the same state transitions and does basically the same steps but with different state name (CLOSING, CLOSED).\n\nMost other procedures are subclasses of a Pv2 StateMachine implementation. We have both Table and Region focused StateMachines types.\n\n## UI\n\nAlong the top-bar on the Master, you can now find a 'Procedures\\&Locks' tab which takes you to a page that is ugly but useful. It dumps currently running procedures and framework locks. Look at this when you can't figure what stuff is stuck; it will at least identify problematic procedures (take the pid and grep the logs...). Look for ROLLEDBACK or pids that have been RUNNING for a long time.\n\n## Logging\n\nProcedures log their process ids as pid= and their parent ids (ppid=) everywhere. Work has been done so you can grep the pid and see history of a procedure operation.\n\n## Implementation Notes\n\nIn this section we note some idiosyncrasies of operation as an attempt at saving you some head-scratching.\n\n### Region Transition RPC and RS Heartbeat can arrive at \\~same time on Master\n\nReporting Region Transition on a RegionServer is now a RPC distinct from RS heartbeating ('RegionServerServices' Service). An heartbeat and a status update can arrive at the Master at about the same time. The Master will update its internal state for a Region but this same state is checked when heartbeat processing. We may find the unexpected; i.e. a Region just reported as CLOSED so heartbeat is surprised to find region OPEN on the back of the RS report. In the new system, all slaves must cow to the Masters' understanding of cluster state; the Master will kill/close any misaligned entities.\n\nTo address the above, we added a lastUpdate for in-memory Master state. Let a region state have some vintage before we act on it (one second currently).\n\n### Master as RegionServer or as RegionServer that just does system tables\n\nAMv2 enforces current master branch default of HMaster carrying system tables only; i.e. the Master in an HBase cluster acts also as a RegionServer only it is the exclusive host for tables such as *hbase:meta*, *hbase:namespace*, etc., the core system tables. This is causing a couple of test failures as AMv1, though it is not supposed to, allows moving hbase:meta off Master while AMv2 does not.\n\n## New Configs\n\nThese configs all need doc on when you'd change them.\n\n#### hbase.procedure.remote.dispatcher.threadpool.size \\[!toc]\n\nDefaults 128\n\n#### hbase.procedure.remote.dispatcher.delay.msec \\[!toc]\n\nDefault 150ms\n\n#### hbase.procedure.remote.dispatcher.max.queue.size \\[!toc]\n\nDefault 32\n\n#### hbase.regionserver.rpc.startup.waittime \\[!toc]\n\nDefault 60 seconds.\n\n## Tools\n\nHBASE-15592 Print Procedure WAL Content\n\nPatch in [HBASE-18152](https://issues.apache.org/jira/browse/HBASE-18152) \\[AMv2] Corrupt Procedure WAL file; procedure data stored out of order [https://issues.apache.org/jira/secure/attachment/12871066/reading\\_bad\\_wal.patch](https://issues.apache.org/jira/secure/attachment/12871066/reading_bad_wal.patch)\n\n### MasterProcedureSchedulerPerformanceEvaluation\n\nTool to test performance of locks and queues in procedure scheduler independently from other framework components. Run this after any substantial changes in proc system. Prints nice output:\n\n```text\n******************************************\nTime - addBack     : 5.0600sec\nOps/sec - addBack  : 1.9M\nTime - poll        : 19.4590sec\nOps/sec - poll     : 501.9K\nNum Operations     : 10000000\n\nCompleted          : 10000006\nYield              : 22025876\n\nNum Tables         : 5\nRegions per table  : 10\nOperations type    : both\nThreads            : 10\n******************************************\nRaw format for scripts\n\nRESULT [num_ops=10000000, ops_type=both, num_table=5, regions_per_table=10, threads=10, num_yield=22025876, time_addback_ms=5060, time_poll_ms=19459]\n```\n\n\n# Bulk Loading (/docs/architecture/bulk-loading)\n## Overview\n\nHBase includes several methods of loading data into tables. The most straightforward method is to either use the `TableOutputFormat` class from a MapReduce job, or use the normal client APIs; however, these are not always the most efficient methods.\n\nThe bulk load feature uses a MapReduce job to output table data in HBase's internal data format, and then directly load the generated StoreFiles into a running cluster. Using bulk load will use less CPU and network resources than loading via the HBase API.\n\n## Bulk Load Architecture\n\nThe HBase bulk load process consists of two main steps.\n\n### Preparing data via a MapReduce job\n\nThe first step of a bulk load is to generate HBase data files (StoreFiles) from a MapReduce job using `HFileOutputFormat2`. This output format writes out data in HBase's internal storage format so that they can be later loaded efficiently into the cluster.\n\nIn order to function efficiently, `HFileOutputFormat2` must be configured such that each output HFile fits within a single region. In order to do this, jobs whose output will be bulk loaded into HBase use Hadoop's `TotalOrderPartitioner` class to partition the map output into disjoint ranges of the key space, corresponding to the key ranges of the regions in the table.\n\n`HFileOutputFormat2` includes a convenience function, `configureIncrementalLoad()`, which automatically sets up a `TotalOrderPartitioner` based on the current region boundaries of a table.\n\n### Completing the data load\n\nAfter a data import has been prepared, either by using the `importtsv` tool with the “importtsv.bulk.output” option or by some other MapReduce job using the `HFileOutputFormat`, the `completebulkload` tool is used to import the data into the running cluster. This command line tool iterates through the prepared data files, and for each one determines the region the file belongs to. It then contacts the appropriate RegionServer which adopts the HFile, moving it into its storage directory and making the data available to clients.\n\nIf the region boundaries have changed during the course of bulk load preparation, or between the preparation and completion steps, the `completebulkload` utility will automatically split the data files into pieces corresponding to the new boundaries. This process is not optimally efficient, so users should take care to minimize the delay between preparing a bulk load and importing it into the cluster, especially if other clients are simultaneously loading data through other means.\n\n```bash\n$ hadoop jar hbase-mapreduce-VERSION.jar completebulkload [-c /path/to/hbase/config/hbase-site.xml] /user/todd/myoutput mytable\n```\n\nThe `-c config-file` option can be used to specify a file containing the appropriate hbase parameters (e.g., hbase-site.xml) if not supplied already on the CLASSPATH (In addition, the CLASSPATH must contain the directory that has the zookeeper configuration file if zookeeper is NOT managed by HBase).\n\n## See Also\n\nFor more information about the referenced utilities, see [ImportTsv](/docs/operational-management/tools#importtsv) and [CompleteBulkLoad](/docs/operational-management/tools#completebulkload).\n\nSee [How-to: Use HBase Bulk Loading, and Why](http://blog.cloudera.com/blog/2013/09/how-to-use-hbase-bulk-loading-and-why/) for an old blog post on loading.\n\n## Advanced Usage\n\nAlthough the `importtsv` tool is useful in many cases, advanced users may want to generate data programmatically, or import data from other formats. To get started doing so, dig into `ImportTsv.java` and check the JavaDoc for HFileOutputFormat.\n\nThe import step of the bulk load can also be done programmatically. See the `LoadIncrementalHFiles` class for more information.\n\n### 'Adopting' Stray Data\n\nShould an HBase cluster lose account of regions or files during an outage or error, you can use the `completebulkload` tool to add back the dropped data. HBase operator tooling such as [HBCK2](https://github.com/apache/hbase-operator-tools/tree/master/hbase-hbck2) or the reporting added to the Master's UI under the `HBCK Report` (Since HBase 2.0.6/2.1.6/2.2.1) can identify such 'orphan' directories.\n\nBefore you begin the 'adoption', ensure the `hbase:meta` table is in a healthy state. Run the `CatalogJanitor` by executing the `catalogjanitor_run` command on the HBase shell. When finished, check the `HBCK Report` page on the Master UI. Work on fixing any inconsistencies, holes, or overlaps found before proceeding. The `hbase:meta` table is the authority on where all data is to be found and must be consistent for the `completebulkload` tool to work properly.\n\nThe `completebulkload` tool takes a directory and a `tablename`. The directory has subdirectories named for column families of the targeted `tablename`. In these subdirectories are `hfiles` to load. Given this structure, you can pass errant region directories (and the table name to which the region directory belongs) and the tool will bring the data files back into the fold by moving them under the approprate serving directory. If stray files, then you will need to mock up this structure before invoking the `completebulkload` tool; you may have to look at the file content using the [HFile Tool](/docs/operational-management/tools#operational-management-tools-hfile-tool) to see what the column family to use is. When the tool completes its run, you will notice that the source errant directory has had its storefiles moved/removed. It is now desiccated since its data has been drained, and the pointed-to directory can be safely removed. It may still have `.regioninfo` files and other subdirectories but they are of no relevance now (There may be content still under the *recovered\\_edits* directory; a TODO is tooling to replay the content of *recovered\\_edits* if needed; see [Add RecoveredEditsPlayer](https://issues.apache.org/jira/browse/HBASE-22976)). If you pass `completebulkload` a directory without store files, it will run and note the directory is storefile-free. Just remove such 'empty' directories.\n\nFor example, presuming a directory at the top level in HDFS named `eb3352fb5c9c9a05feeb2caba101e1cc` has data we need to re-add to the HBase `TestTable`:\n\n```bash\n$ ${HBASE_HOME}/bin/hbase --config ~/hbase-conf completebulkload hdfs://server.example.org:9000/eb3352fb5c9c9a05feeb2caba101e1cc TestTable\n```\n\nAfter it successfully completes, any files that were in `eb3352fb5c9c9a05feeb2caba101e1cc` have been moved under hbase and the `eb3352fb5c9c9a05feeb2caba101e1cc` directory can be deleted (Check content before and after by running `ls -r` on the HDFS directory).\n\n## Bulk Loading Replication\n\nHBASE-13153 adds replication support for bulk loaded HFiles, available since HBase 1.3/2.0. This feature is enabled by setting `hbase.replication.bulkload.enabled` to `true` (default is `false`). You also need to copy the source cluster configuration files to the destination cluster.\n\nAdditional configurations are required too:\n\n1. `hbase.replication.source.fs.conf.provider`\\\n   This defines the class which loads the source cluster file system client configuration in the destination cluster. This should be configured for all the RS in the destination cluster. Default is `org.apache.hadoop.hbase.replication.regionserver.DefaultSourceFSConfigurationProvider`.\n2. `hbase.replication.conf.dir`\\\n   This represents the base directory where the file system client configurations of the source cluster are copied to the destination cluster. This should be configured for all the RS in the destination cluster. Default is `$HBASE_CONF_DIR`.\n3. `hbase.replication.cluster.id`\\\n   This configuration is required in the cluster where replication for bulk loaded data is enabled. A source cluster is uniquely identified by the destination cluster using this id. This should be configured for all the RS in the source cluster configuration file for all the RS.\n\nFor example: If source cluster FS client configurations are copied to the destination cluster under directory `/home/user/dc1/`, then `hbase.replication.cluster.id` should be configured as `dc1` and `hbase.replication.conf.dir` as `/home/user`.\n\n<Callout type=\"info\">\n  `DefaultSourceFSConfigurationProvider` supports only `xml` type files. It loads source cluster FS\n  client configuration only once, so if source cluster FS client configuration files are updated,\n  every peer(s) cluster RS must be restarted to reload the configuration.\n</Callout>\n\n\n# Catalog Tables (/docs/architecture/catalog-tables)\nThe catalog table `hbase:meta` exists as an HBase table and is filtered out of the HBase shell's `list` command, but is in fact a table just like any other.\n\n## hbase:meta\n\nThe `hbase:meta` table (previously called `.META.`) keeps a list of all regions in the system, and the location of `hbase:meta` is stored in ZooKeeper.\n\nThe `hbase:meta` table structure is as follows:\n\n**Key:**\n\n* Region key of the format (`[table],[region start key],[region id]`)\n\n**Values:**\n\n* `info:regioninfo` (serialized [RegionInfo](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/RegionInfo.html) instance for this region)\n* `info:server` (server:port of the RegionServer containing this region)\n* `info:serverstartcode` (start-time of the RegionServer process containing this region)\n\nWhen a table is in the process of splitting, two other columns will be created, called `info:splitA` and `info:splitB`. These columns represent the two daughter regions. The values for these columns are also serialized HRegionInfo instances. After the region has been split, eventually this row will be deleted.\n\n<Callout type=\"info\" title=\"Note on HRegionInfo\">\n  The empty key is used to denote table start and table end. A region with an empty start key is the\n  first region in a table. If a region has both an empty start and an empty end key, it is the only\n  region in the table\n</Callout>\n\nIn the (hopefully unlikely) event that programmatic processing of catalog metadata is required, see the [RegionInfo.parseFrom](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/RegionInfo.html#parseFrom\\(byte%5B%5D\\)) utility.\n\n## Startup Sequencing\n\nFirst, the location of `hbase:meta` is looked up in ZooKeeper. Next, `hbase:meta` is updated with server and startcode values.\n\nFor information on region-RegionServer assignment, see [Region-RegionServer Assignment](/docs/architecture/regions#region-regionserver-assignment).\n\n\n# Client Request Filters (/docs/architecture/client-request-filters)\n[Get](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html) and [Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) instances can be optionally configured with [filters](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/Filter.html) which are applied on the RegionServer.\n\nFilters can be confusing because there are many different types, and it is best to approach them by understanding the groups of Filter functionality.\n\n## Structural\n\nStructural Filters contain other Filters.\n\n### FilterList\n\n[FilterList](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/FilterList.html) represents a list of Filters with a relationship of `FilterList.Operator.MUST_PASS_ALL` or `FilterList.Operator.MUST_PASS_ONE` between the Filters. The following example shows an 'or' between two Filters (checking for either 'my value' or 'my other value' on the same attribute).\n\n```java\nFilterList list = new FilterList(FilterList.Operator.MUST_PASS_ONE);\nSingleColumnValueFilter filter1 = new SingleColumnValueFilter(\n  cf,\n  column,\n  CompareOperator.EQUAL,\n  Bytes.toBytes(\"my value\")\n  );\nlist.add(filter1);\nSingleColumnValueFilter filter2 = new SingleColumnValueFilter(\n  cf,\n  column,\n  CompareOperator.EQUAL,\n  Bytes.toBytes(\"my other value\")\n  );\nlist.add(filter2);\nscan.setFilter(list);\n```\n\n## Column Value\n\n### SingleColumnValueFilter\n\nA SingleColumnValueFilter (see: [https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.html](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.html)) can be used to test column values for equivalence (`CompareOperaor.EQUAL`), inequality (`CompareOperaor.NOT_EQUAL`), or ranges (e.g., `CompareOperaor.GREATER`). The following is an example of testing equivalence of a column to a String value \"my value\"...\n\n```java\nSingleColumnValueFilter filter = new SingleColumnValueFilter(\n  cf,\n  column,\n  CompareOperaor.EQUAL,\n  Bytes.toBytes(\"my value\")\n  );\nscan.setFilter(filter);\n```\n\n### ColumnValueFilter\n\nIntroduced in HBase-2.0.0 version as a complementation of SingleColumnValueFilter, ColumnValueFilter gets matched cell only, while SingleColumnValueFilter gets the entire row (has other columns and values) to which the matched cell belongs. Parameters of constructor of ColumnValueFilter are the same as SingleColumnValueFilter.\n\n```java\nColumnValueFilter filter = new ColumnValueFilter(\n  cf,\n  column,\n  CompareOperaor.EQUAL,\n  Bytes.toBytes(\"my value\")\n  );\nscan.setFilter(filter);\n```\n\nNote. For simple query like \"equals to a family:qualifier:value\", we highly recommend to use the following way instead of using SingleColumnValueFilter or ColumnValueFilter:\n\n```java\nScan scan = new Scan();\nscan.addColumn(Bytes.toBytes(\"family\"), Bytes.toBytes(\"qualifier\"));\nValueFilter vf = new ValueFilter(CompareOperator.EQUAL,\n  new BinaryComparator(Bytes.toBytes(\"value\")));\nscan.setFilter(vf);\n...\n```\n\nThis scan will restrict to the specified column 'family:qualifier', avoiding scan of unrelated families and columns, which has better performance, and `ValueFilter` is the condition used to do the value filtering.\n\nBut if query is much more complicated beyond this book, then please make your good choice case by case.\n\n## Column Value Comparators\n\nThere are several Comparator classes in the Filter package that deserve special mention. These Comparators are used in concert with other Filters, such as [SingleColumnValueFilter](/docs/architecture/client-request-filters#singlecolumnvaluefilter).\n\n### RegexStringComparator\n\n[RegexStringComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/RegexStringComparator.html) supports regular expressions for value comparisons.\n\n```java\nRegexStringComparator comp = new RegexStringComparator(\"my.\");   // any value that starts with 'my'\nSingleColumnValueFilter filter = new SingleColumnValueFilter(\n  cf,\n  column,\n  CompareOperaor.EQUAL,\n  comp\n  );\nscan.setFilter(filter);\n```\n\nSee the Oracle JavaDoc for [supported RegEx patterns in Java](http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html).\n\n### SubstringComparator\n\n[SubstringComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/SubstringComparator.html) can be used to determine if a given substring exists in a value. The comparison is case-insensitive.\n\n```java\nSubstringComparator comp = new SubstringComparator(\"y val\");   // looking for 'my value'\nSingleColumnValueFilter filter = new SingleColumnValueFilter(\n  cf,\n  column,\n  CompareOperaor.EQUAL,\n  comp\n  );\nscan.setFilter(filter);\n```\n\n### BinaryPrefixComparator\n\nSee [BinaryPrefixComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/BinaryPrefixComparator.html).\n\n### BinaryComparator\n\nSee [BinaryComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/BinaryComparator.html).\n\n### BinaryComponentComparator\n\n[BinaryComponentComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/BinaryComponentComparator.html) can be used to compare specific value at specific location with in the cell value. The comparison can be done for both ascii and binary data.\n\n```java\nbyte[] partialValue = Bytes.toBytes(\"partial_value\");\nint partialValueOffset = 0;\nFilter partialValueFilter = new ValueFilter(CompareFilter.CompareOp.GREATER,\n        new BinaryComponentComparator(partialValue,partialValueOffset));\n```\n\nSee [HBASE-22969](https://issues.apache.org/jira/browse/HBASE-22969) for other use cases and details.\n\n## KeyValue Metadata\n\nAs HBase stores data internally as KeyValue pairs, KeyValue Metadata Filters evaluate the existence of keys (i.e., ColumnFamily:Column qualifiers) for a row, as opposed to values the previous section.\n\n### FamilyFilter\n\n[FamilyFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/FamilyFilter.html) can be used to filter on the ColumnFamily. It is generally a better idea to select ColumnFamilies in the Scan than to do it with a Filter.\n\n### QualifierFilter\n\n[QualifierFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/QualifierFilter.html) can be used to filter based on Column (aka Qualifier) name.\n\n### ColumnPrefixFilter\n\n[ColumnPrefixFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.html) can be used to filter based on the lead portion of Column (aka Qualifier) names.\n\nA ColumnPrefixFilter seeks ahead to the first column matching the prefix in each row and for each involved column family. It can be used to efficiently get a subset of the columns in very wide rows.\n\nNote: The same column qualifier can be used in different column families. This filter returns all matching columns.\n\nExample: Find all columns in a row and family that start with \"abc\"\n\n```java\nTable t = ...;\nbyte[] row = ...;\nbyte[] family = ...;\nbyte[] prefix = Bytes.toBytes(\"abc\");\nScan scan = new Scan(row, row); // (optional) limit to one row\nscan.addFamily(family); // (optional) limit to one family\nFilter f = new ColumnPrefixFilter(prefix);\nscan.setFilter(f);\nscan.setBatch(10); // set this if there could be many columns returned\nResultScanner rs = t.getScanner(scan);\nfor (Result r = rs.next(); r != null; r = rs.next()) {\n  for (Cell cell : result.listCells()) {\n    // each cell represents a column\n  }\n}\nrs.close();\n```\n\n### MultipleColumnPrefixFilter\n\n[MultipleColumnPrefixFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.html) behaves like ColumnPrefixFilter but allows specifying multiple prefixes.\n\nLike ColumnPrefixFilter, MultipleColumnPrefixFilter efficiently seeks ahead to the first column matching the lowest prefix and also seeks past ranges of columns between prefixes. It can be used to efficiently get discontinuous sets of columns from very wide rows.\n\nExample: Find all columns in a row and family that start with \"abc\" or \"xyz\"\n\n```java\nTable t = ...;\nbyte[] row = ...;\nbyte[] family = ...;\nbyte[][] prefixes = new byte[][] {Bytes.toBytes(\"abc\"), Bytes.toBytes(\"xyz\")};\nScan scan = new Scan(row, row); // (optional) limit to one row\nscan.addFamily(family); // (optional) limit to one family\nFilter f = new MultipleColumnPrefixFilter(prefixes);\nscan.setFilter(f);\nscan.setBatch(10); // set this if there could be many columns returned\nResultScanner rs = t.getScanner(scan);\nfor (Result r = rs.next(); r != null; r = rs.next()) {\n  for (Cell cell : result.listCells()) {\n    // each cell represents a column\n  }\n}\nrs.close();\n```\n\n### ColumnRangeFilter\n\nA [ColumnRangeFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/ColumnRangeFilter.html) allows efficient intra row scanning.\n\nA ColumnRangeFilter can seek ahead to the first matching column for each involved column family. It can be used to efficiently get a 'slice' of the columns of a very wide row. i.e. you have a million columns in a row but you only want to look at columns bbbb-bbdd.\n\nNote: The same column qualifier can be used in different column families. This filter returns all matching columns.\n\nExample: Find all columns in a row and family between \"bbbb\" (inclusive) and \"bbdd\" (inclusive)\n\n```java\nTable t = ...;\nbyte[] row = ...;\nbyte[] family = ...;\nbyte[] startColumn = Bytes.toBytes(\"bbbb\");\nbyte[] endColumn = Bytes.toBytes(\"bbdd\");\nScan scan = new Scan(row, row); // (optional) limit to one row\nscan.addFamily(family); // (optional) limit to one family\nFilter f = new ColumnRangeFilter(startColumn, true, endColumn, true);\nscan.setFilter(f);\nscan.setBatch(10); // set this if there could be many columns returned\nResultScanner rs = t.getScanner(scan);\nfor (Result r = rs.next(); r != null; r = rs.next()) {\n  for (Cell cell : result.listCells()) {\n    // each cell represents a column\n  }\n}\nrs.close();\n```\n\nNote: Introduced in HBase 0.92\n\n## RowKey\n\n### RowFilter\n\nIt is generally a better idea to use the startRow/stopRow methods on Scan for row selection, however [RowFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/RowFilter.html) can also be used.\n\nYou can supplement a scan (both bounded and unbounded) with RowFilter constructed from [BinaryComponentComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/BinaryComponentComparator.html) for further filtering out or filtering in rows. See [HBASE-22969](https://issues.apache.org/jira/browse/HBASE-22969) for use cases and other details.\n\n## Utility\n\n### FirstKeyOnlyFilter\n\nThis is primarily used for rowcount jobs. See [FirstKeyOnlyFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html).\n\n\n# Client (/docs/architecture/client)\nThe HBase client finds the RegionServers that are serving the particular row range of interest. It does this by querying the `hbase:meta` table. See [hbase:meta](/docs/architecture/catalog-tables#hbasemeta) for details. After locating the required region(s), the client contacts the RegionServer serving that region, rather than going through the master, and issues the read or write request. This information is cached in the client so that subsequent requests need not go through the lookup process. Should a region be reassigned either by the master load balancer or because a RegionServer has died, the client will requery the catalog tables to determine the new location of the user region.\n\nSee [Runtime Impact](/docs/architecture/master#runtime-impact) for more information about the impact of the Master on HBase Client communication.\n\nAdministrative functions are done via an instance of [Admin](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Admin.html)\n\n## Cluster Connections\n\nThe API changed in HBase 1.0. For connection configuration information, see [Client configuration and dependencies connecting to an HBase cluster](/docs/configuration/default#client-configuration-and-dependencies-connecting-to-an-hbase-cluster).\n\n### API as of HBase 1.0.0\n\nIt's been cleaned up and users are returned Interfaces to work against rather than particular types. In HBase 1.0, obtain a `Connection` object from `ConnectionFactory` and thereafter, get from it instances of `Table`, `Admin`, and `RegionLocator` on an as-need basis. When done, close the obtained instances. Finally, be sure to cleanup your `Connection` instance before exiting. `Connections` are heavyweight objects but thread-safe so you can create one for your application and keep the instance around. `Table`, `Admin` and `RegionLocator` instances are lightweight. Create as you go and then let go as soon as you are done by closing them. See the [Client Package Javadoc Description](https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/package-summary.html) for example usage of the new HBase 1.0 API.\n\n### API before HBase 1.0.0\n\nInstances of `HTable` are the way to interact with an HBase cluster earlier than 1.0.0. *[Table](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html) instances are not thread-safe*. Only one thread can use an instance of Table at any given time. When creating Table instances, it is advisable to use the same [HBaseConfiguration](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/HBaseConfiguration) instance. This will ensure sharing of ZooKeeper and socket instances to the RegionServers which is usually what you want. For example, this is preferred:\n\n```java\nHBaseConfiguration conf = HBaseConfiguration.create();\nHTable table1 = new HTable(conf, \"myTable\");\nHTable table2 = new HTable(conf, \"myTable\");\n```\n\nas opposed to this:\n\n```java\nHBaseConfiguration conf1 = HBaseConfiguration.create();\nHTable table1 = new HTable(conf1, \"myTable\");\nHBaseConfiguration conf2 = HBaseConfiguration.create();\nHTable table2 = new HTable(conf2, \"myTable\");\n```\n\nFor more information about how connections are handled in the HBase client, see [ConnectionFactory](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ConnectionFactory.html).\n\n#### Connection Pooling\n\nFor applications which require high-end multithreaded access (e.g., web-servers or application servers that may serve many application threads in a single JVM), you can pre-create a `Connection`, as shown in the following example:\n\n**Example 24. Pre-Creating a `Connection`**\n\n```java\n// Create a connection to the cluster.\nConfiguration conf = HBaseConfiguration.create();\ntry (Connection connection = ConnectionFactory.createConnection(conf);\n     Table table = connection.getTable(TableName.valueOf(tablename))) {\n  // use table as needed, the table returned is lightweight\n}\n```\n\n<Callout type=\"warn\" title=\"HTablePool is Deprecated\">\n  Previous versions of this guide discussed `HTablePool`, which was deprecated in HBase 0.94, 0.95,\n  and 0.96, and removed in 0.98.1, by\n  [HBASE-6580](https://issues.apache.org/jira/browse/HBASE-6580), or `HConnection`, which is\n  deprecated in HBase 1.0 by `Connection`. Please use\n  [Connection](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Connection.html)\n  instead.\n</Callout>\n\n## WriteBuffer and Batch Methods\n\nIn HBase 1.0 and later, [HTable](https://hbase.apache.org/1.4/devapidocs/org/apache/hadoop/hbase/client/HTable.html) is deprecated in favor of [Table](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html). `Table` does not use autoflush. To do buffered writes, use the BufferedMutator class.\n\nIn HBase 2.0 and later, [HTable](https://hbase.apache.org/2.6/devapidocs/org/apache/hadoop/hbase/client/HTable.html) does not use BufferedMutator to execute the `Put` operation. Refer to [HBASE-18500](https://issues.apache.org/jira/browse/HBASE-18500) for more information.\n\nFor additional information on write durability, review the [ACID semantics](/acid-semantics) page.\n\nFor fine-grained control of batching of `Put`s or `Delete`s, see the [batch](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#batch\\(java.util.List,java.lang.Object%5B%5D\\)) methods on Table.\n\n## Asynchronous Client\n\nIt is a new API introduced in HBase 2.0 which aims to provide the ability to access HBase asynchronously.\n\nYou can obtain an `AsyncConnection` from `ConnectionFactory`, and then get a asynchronous table instance from it to access HBase. When done, close the `AsyncConnection` instance(usually when your program exits).\n\nFor the asynchronous table, most methods have the same meaning with the old `Table` interface, expect that the return value is wrapped with a CompletableFuture usually. We do not have any buffer here so there is no close method for asynchronous table, you do not need to close it. And it is thread safe.\n\nThere are several differences for scan:\n\n* There is still a `getScanner` method which returns a `ResultScanner`. You can use it in the old way and it works like the old `ClientAsyncPrefetchScanner`.\n* There is a `scanAll` method which will return all the results at once. It aims to provide a simpler way for small scans which you want to get the whole results at once usually.\n* The Observer Pattern. There is a scan method which accepts a `ScanResultConsumer` as a parameter. It will pass the results to the consumer.\n\nNotice that `AsyncTable` interface is templatized. The template parameter specifies the type of `ScanResultConsumerBase` used by scans, which means the observer style scan APIs are different. The two types of scan consumers are - `ScanResultConsumer` and `AdvancedScanResultConsumer`.\n\n`ScanResultConsumer` needs a separate thread pool which is used to execute the callbacks registered to the returned CompletableFuture. Because the use of separate thread pool frees up RPC threads, callbacks are free to do anything. Use this if the callbacks are not quick, or when in doubt.\n\n`AdvancedScanResultConsumer` executes callbacks inside the framework thread. It is not allowed to do time consuming work in the callbacks else it will likely block the framework threads and cause very bad performance impact. As its name, it is designed for advanced users who want to write high performance code. See `org.apache.hadoop.hbase.client.example.HttpProxyExample` for how to write fully asynchronous code with it.\n\n## Asynchronous Admin\n\nYou can obtain an `AsyncConnection` from `ConnectionFactory`, and then get a `AsyncAdmin` instance from it to access HBase. Notice that there are two `getAdmin` methods to get a `AsyncAdmin` instance. One method has one extra thread pool parameter which is used to execute callbacks. It is designed for normal users. Another method doesn't need a thread pool and all the callbacks are executed inside the framework thread so it is not allowed to do time consuming works in the callbacks. It is designed for advanced users.\n\nThe default `getAdmin` methods will return a `AsyncAdmin` instance which use default configs. If you want to customize some configs, you can use `getAdminBuilder` methods to get a `AsyncAdminBuilder` for creating `AsyncAdmin` instance. Users are free to only set the configs they care about to create a new `AsyncAdmin` instance.\n\nFor the `AsyncAdmin` interface, most methods have the same meaning with the old `Admin` interface, expect that the return value is wrapped with a CompletableFuture usually.\n\nFor most admin operations, when the returned CompletableFuture is done, it means the admin operation has also been done. But for compact operation, it only means the compact request was sent to HBase and may need some time to finish the compact operation. For `rollWALWriter` method, it only means the rollWALWriter request was sent to the region server and may need some time to finish the `rollWALWriter` operation.\n\nFor region name, we only accept `byte[]` as the parameter type and it may be a full region name or a encoded region name. For server name, we only accept `ServerName` as the parameter type. For table name, we only accept `TableName` as the parameter type. For `list*` operations, we only accept `Pattern` as the parameter type if you want to do regex matching.\n\n## External Clients\n\nInformation on non-Java clients and custom protocols is covered in [Apache HBase External APIs](/docs/external-apis)\n\n## Master Registry (new as of 2.3.0)\n\nStarting from 2.5.0, MasterRegistry is deprecated. It's functionality is completely superseded by the RpcConnectionRegistry. Please see [Rpc Connection Registry (new as of 2.5.0)](/docs/architecture/client#rpc-connection-registry-new-as-of-250) for more details.\n\nClient internally works with a *connection registry* to fetch the metadata needed by connections. This connection registry implementation is responsible for fetching the following metadata.\n\n* Active master address\n* Current meta region(s) locations\n* Cluster ID (unique to this cluster)\n\nThis information is needed as a part of various client operations like connection set up, scans, gets, etc. Traditionally, the connection registry implementation has been based on ZooKeeper as the source of truth and clients fetched the metadata directly from the ZooKeeper quorum. HBase 2.3.0 introduces a new connection registry implementation based on direct communication with the Masters. With this implementation, clients now fetch required metadata via master RPC end points instead of maintaining connections to ZooKeeper. This change was done for the following reasons.\n\n* Reduce load on ZooKeeper since that is critical for cluster operation.\n* Holistic client timeout and retry configurations since the new registry brings all the client operations under HBase rpc framework.\n* Remove the ZooKeeper client dependency on HBase client library.\n\nThis means:\n\n* At least a single active or stand by master is needed for cluster connection setup. Refer to [Runtime Impact](/docs/architecture/master#runtime-impact) for more details.\n* Master can be in a critical path of read/write operations, especially if the client metadata cache is empty or stale.\n* There is higher connection load on the masters that before since the clients talk directly to HMasters instead of ZooKeeper ensemble\\`\n\nTo reduce hot-spotting on a single master, all the masters (active & stand-by) expose the needed service to fetch the connection metadata. This lets the client connect to any master (not just active). Both ZooKeeper-based and Master-based connection registry implementations are available in 2.3+. For 2.x and earlier, the ZooKeeper-based implementation remains the default configuration. For 3.0.0, RpcConnectionRegistry becomes the default configuration, as the alternate to MasterRegistry.\n\nChange the connection registry implementation by updating the value configured for `hbase.client.registry.impl`. To explicitly enable the ZooKeeper-based registry, use\n\n```xml\n<property>\n  <name>hbase.client.registry.impl</name>\n  <value>org.apache.hadoop.hbase.client.ZKConnectionRegistry</value>\n</property>\n```\n\nTo explicitly enable the Master-based registry, use\n\n```xml\n<property>\n  <name>hbase.client.registry.impl</name>\n  <value>org.apache.hadoop.hbase.client.MasterRegistry</value>\n</property>\n```\n\n### MasterRegistry RPC hedging\n\nMasterRegistry implements hedging of connection registry RPCs across active and stand-by masters. This lets the client make the same request to multiple servers and which ever responds first is returned back to the client immediately. This improves performance, especially when a subset of servers are under load. The hedging fan out size is configurable, meaning the number of requests that are hedged in a single attempt, using the configuration key *hbase.client.master\\_registry.hedged.fanout* in the client configuration. It defaults to 2. With this default, the RPCs are tried in batches of 2. The hedging policy is still primitive and does not adapt to any sort of live rpc performance metrics.\n\n### Additional Notes\n\n* Clients hedge the requests in a randomized order to avoid hot-spotting a single master.\n* Cluster internal connections (masters ↔ regionservers) still use ZooKeeper based connection registry.\n* Cluster internal state is still tracked in Zookeeper, hence ZK availability requirements are same as before.\n* Inter cluster replication still uses ZooKeeper based connection registry to simplify configuration management.\n\nFor more implementation details, please refer to the [design doc](https://github.com/apache/hbase/tree/master/dev-support/design-docs) and [HBASE-18095](https://issues.apache.org/jira/browse/HBASE-18095).\n\n## Rpc Connection Registry (new as of 2.5.0)\n\nAs said in the [Master Registry (new as of 2.3.0)](/docs/architecture/client#masterregistry-rpc-hedging) section, there are some disadvantages and limitations for MasterRegistry, especially that it puts master in the critical path of read/write operations. In order to address these problems, we introduced a more generic RpcConnectionRegistry.\n\nIt is also rpc based, like MasterRegistry, with several differences\n\n1. Region server also implements the necessary rpc service, so you can config any nodes in the cluster as bootstrap nodes, not only masters\n2. Support refreshing bootstrap nodes, for spreading loads across the nodes in the cluster, and also remove the dead nodes in bootstrap nodes.\n\nTo explicitly enable the rpc-based registry, use\n\n```xml\n<property>\n  <name>hbase.client.registry.impl</name>\n  <value>org.apache.hadoop.hbase.client.RpcConnectionRegistry</value>\n</property>\n```\n\nTo configure the bootstrap nodes, use\n\n```xml\n<property>\n  <name>hbase.client.bootstrap.servers</name>\n  <value>server1:16020,server2:16020,server3:16020</value>\n</property>\n```\n\nIf not configured, we will fallback to use master addresses as the bootstrap nodes.\n\nRpcConnectionRegistry is available in 2.5+, and becomes the default client registry implementation in 3.0.0.\n\n### RpcConnectionRegistry RPC hedging\n\nHedged read is still supported, the configuration key is now *hbase.client.bootstrap.hedged.fanout*, and its default value is still 2.\n\n### RpcConnectionRegistry bootstrap nodes refreshing\n\nThere are basically two reasons for us to refresh the bootstrap nodes\n\n* Periodically. This is for spreading loads across the nodes in the cluster. There are two configurations\n  1. *hbase.client.bootstrap.refresh\\_interval\\_secs*: the refresh interval in seconds, default 300. A value less than or equal to zero means disable refreshing.\n  2. *hbase.client.bootstrap.initial\\_refresh\\_delay\\_secs*: the initial refresh interval in seconds, the default value is 1/10 of *hbase.client.bootstrap.refresh\\_interval\\_secs*. The reason why we want to introduce a separated configuration for the delay for first refreshing is that, as end users could configure any nodes in a cluster as the initial bootstrap nodes, it is possible that different end users will configure the same machine which makes the machine over load. So we should have a shorter delay for the initial refresh, to let users quickly switch to the bootstrap nodes we want them to connect to.\n\n* When there is a connection error while requesting the nodes, we will refresh immediately, to remove the dead nodes. To avoid putting too much pressure to the cluster, there is a configuration *hbase.client.bootstrap.min\\_secs\\_between\\_refreshes*, to control the minimum interval between two refreshings. The default value is 60, but notice that, if you change *hbase.client.bootstrap.refresh\\_interval\\_secs* to a small value, you need to make sure to also change *hbase.client.bootstrap.min\\_secs\\_between\\_refreshes* to a value smaller than *hbase.client.bootstrap.refresh\\_interval\\_secs*, otherwise an IllegalArgumentException will be thrown.\n\n<Callout type=\"info\">\n  (Advanced) In case of any issues with the rpc/master based registry, use the following\n  configuration to fallback to the ZooKeeper based connection registry implementation.\n</Callout>\n\n```xml\n<property>\n  <name>hbase.client.registry.impl</name>\n  <value>org.apache.hadoop.hbase.client.ZKConnectionRegistry</value>\n</property>\n```\n\n## Connection URI\n\nStarting from 2.7.0, we add the support for specifying the connection information for a HBase cluster through an URI, which we call a \"connection URI\". And we've added several methods in *ConnectionFactory* to let you get a connection to the cluster specified by the URI. It looks like:\n\n```java\nURI uri = new URI(\"hbase+rpc://server1:16020,server2:16020,server3:16020\");\ntry (Connection conn = ConnectionFactory.createConnection(uri)) {\n  ...\n}\n```\n\n### Supported Schemes\n\nCurrently there are two schemes supported, *hbase+rpc* for *RpcConnectionRegistry* and *hbase+zk* for *ZKConnectionRegistry*. *MasterRegistry* is deprecated so we do not expose it through connection URI.\n\nFor *hbase+rpc*, it looks like\n\n```shell\nhbase+rpc://server1:16020,server2:16020,server3:16020\n```\n\nThe authority part *server1:16020,server2:16020,server3:16020* specifies the bootstrap nodes and their rpc ports, i.e, the configuration value for *hbase.client.bootstrap.servers* in the past.\n\nFor *hbase+zk*, it looks like\n\n```shell\nhbase+zk://zk1:2181,zk2:2181,zk3:2181/hbase\n```\n\nThe authority part *zk1:2181,zk2:2181,zk3:2181* is the zk quorum, i.e, the configuration value for *hbase.zookeeper.quorum* in the past. The path part */hbase* is the znode parent, i.e, the configuration value for *zookeeper.znode.parent* in the past.\n\n### Specify Configuration through URI Queries\n\nTo let users fully specify the connection information through a connection URI, we support specifying configuration values through URI Queries. It looks like:\n\n```shell\nhbase+rpc://server1:16020?hbase.client.operation.timeout=10000\n```\n\nIn this way you can set the operation timeout to 10 seconds. Notice that, the configuration values specified in the connection URI will override the ones in the configuration file.\n\n### Implement Your Own Connection Registry\n\nWe use *ServiceLoader* to load different connection registry implementations, the entry point is *org.apache.hadoop.hbase.client.ConnectionRegistryURIFactory*. So if you implement your own *ConnectionRegistryURIFactory* which has a different scheme, and register it in the services file, we can load it at runtime.\n\nConnection URI is still a very new feature which has not been used extensively in production, so we do not want to expose the ability to customize *ConnectionRegistryURIFactory* yet as the API may be changed frequently in the beginning.\n\nIf you really want to implement your own connection registry, you can use the above way but take your own risk.\n\n\n# Storing Medium-sized Objects (MOB) (/docs/architecture/hbase-mob)\nData comes in many sizes, and saving all of your data in HBase, including binary\ndata such as images and documents, is ideal. While HBase can technically handle\nbinary objects with cells that are larger than 100 KB in size, HBase's normal\nread and write paths are optimized for values smaller than 100KB in size. When\nHBase deals with large numbers of objects over this threshold, referred to here\nas medium objects, or MOBs, performance is degraded due to write amplification\ncaused by splits and compactions. When using MOBs, ideally your objects will be between\n100KB and 10MB (see the [faq](/docs/faq)). HBase 2 added special internal handling of MOBs\nto maintain performance, consistency, and low operational overhead. MOB support is\nprovided by the work done in [HBASE-11339](https://issues.apache.org/jira/browse/HBASE-11339).\nTo take advantage of MOB, you need to use [HFile version 3](/docs/hfile-format#hbase-file-format-with-security-enhancements-version-3). Optionally,\nconfigure the MOB file reader's cache settings for each RegionServer (see\n[Configure the MOB Cache](/docs/architecture/hbase-mob#configuring-the-mob-cache)), then configure specific columns to hold MOB data.\nClient code does not need to change to take advantage of HBase MOB support. The\nfeature is transparent to the client.\n\n## Configuring Columns for MOB\n\nYou can configure columns to support MOB during table creation or alteration,\neither in HBase Shell or via the Java API. The two relevant properties are the\nboolean `IS_MOB` and the `MOB_THRESHOLD`, which is the number of bytes at which\nan object is considered to be a MOB. Only `IS_MOB` is required. If you do not\nspecify the `MOB_THRESHOLD`, the default threshold value of 100 KB is used.\n\n### Configure a Column for MOB Using HBase Shell\n\n```bash\nhbase> create 't1', {NAME => 'f1', IS_MOB => true, MOB_THRESHOLD => 102400}\nhbase> alter 't1', {NAME => 'f1', IS_MOB => true, MOB_THRESHOLD => 102400}\n```\n\n### Configure a Column for MOB Using the Java API\n\n```java\n...\nHColumnDescriptor hcd = new HColumnDescriptor(\"f\");\nhcd.setMobEnabled(true);\n...\nhcd.setMobThreshold(102400L);\n...\n```\n\n## Testing MOB\n\nThe utility `org.apache.hadoop.hbase.IntegrationTestIngestWithMOB` is provided to assist with testing\nthe MOB feature. The utility is run as follows:\n\n```bash\n$ sudo -u hbase hbase org.apache.hadoop.hbase.IntegrationTestIngestWithMOB \\\n        -threshold 1024 \\\n        -minMobDataSize 512 \\\n        -maxMobDataSize 5120\n```\n\n* **`threshold`** is the threshold at which cells are considered to be MOBs.\n  The default is 1 kB, expressed in bytes.\n* **`minMobDataSize`** is the minimum value for the size of MOB data.\n  The default is 512 B, expressed in bytes.\n* **`maxMobDataSize`** is the maximum value for the size of MOB data.\n  The default is 5 kB, expressed in bytes.\n\n## MOB architecture\n\nThis section is derived from information found in\n[HBASE-11339](https://issues.apache.org/jira/browse/HBASE-11339), which covered the initial GA\nimplementation of MOB in HBase and\n[HBASE-22749](https://issues.apache.org/jira/browse/HBASE-22749), which improved things by\nparallelizing MOB maintenance across the RegionServers. For more information see\nthe last version of the design doc created during the initial work,\n\"[HBASE-11339 MOB GA design.pdf](https://github.com/apache/hbase/blob/master/dev-support/design-docs/HBASE-11339%20MOB%20GA%20design.pdf)\",\nand the design doc for the distributed mob compaction feature,\n\"[HBASE-22749 MOB distributed compaction.pdf](https://github.com/apache/hbase/blob/master/dev-support/design-docs/HBASE-22749%20MOB%20distributed%20compaction.pdf)\".\n\n### Overview\n\nThe MOB feature reduces the overall IO load for configured column families by storing values that\nare larger than the configured threshold outside of the normal regions to avoid splits, merges, and\nmost importantly normal compactions.\n\nWhen a cell is first written to a region it is stored in the WAL and memstore regardless of value\nsize. When memstores from a column family configured to use MOB are eventually flushed two hfiles\nare written simultaneously. Cells with a value smaller than the threshold size are written to a\nnormal region hfile. Cells with a value larger than the threshold are written into a special MOB\nhfile and also have a MOB reference cell written into the normal region HFile. As the Region Server\nflushes a MOB enabled memstore and closes a given normal region HFile it appends metadata that lists\neach of the special MOB hfiles referenced by the cells within.\n\nMOB reference cells have the same key as the cell they are based on. The value of the reference cell\nis made up of two pieces of metadata: the size of the actual value and the MOB hfile that contains\nthe original cell. In addition to any tags originally written to HBase, the reference cell prepends\ntwo additional tags. The first is a marker tag that says the cell is a MOB reference. This can be\nused later to scan specifically just for reference cells. The second stores the namespace and table\nat the time the MOB hfile is written out. This tag is used to optimize how the MOB system finds\nthe underlying value in MOB hfiles after a series of HBase snapshot operations (ref HBASE-12332).\nNote that tags are only available within HBase servers and by default are not sent over RPCs.\n\nAll MOB hfiles for a given table are managed within a logical region that does not directly serve\nrequests. When these MOB hfiles are created from a flush or MOB compaction they are placed in a\ndedicated mob data area under the hbase root directory specific to the namespace, table, mob\nlogical region, and column family. In general that means a path structured like:\n\n```\n%HBase Root Dir%/mobdir/data/%namespace%/%table%/%logical region%/%column family%/\n```\n\nWith default configs, an example table named 'some\\_table' in the\ndefault namespace with a MOB enabled column family named 'foo' this HDFS directory would be\n\n```\n/hbase/mobdir/data/default/some_table/372c1b27e3dc0b56c3a031926e5efbe9/foo/\n```\n\nThese MOB hfiles are maintained by special chores in the HBase Master and across the individual\nRegion Servers. Specifically those chores take care of enforcing TTLs and compacting them. Note that\nthis compaction is primarily a matter of controlling the total number of files in HDFS because our\noperational assumptions for MOB data is that it will seldom update or delete.\n\nWhen a given MOB hfile is no longer needed as a result of our compaction process then a chore in\nthe Master will take care of moving it to the archive just\nlike any normal hfile. Because the table's mob region is independent of all the normal regions it\ncan coexist with them in the regular archive storage area:\n\n```\n/hbase/archive/data/default/some_table/372c1b27e3dc0b56c3a031926e5efbe9/foo/\n```\n\nThe same hfile cleaning chores that take care of eventually deleting unneeded archived files from\nnormal regions thus also will take care of these MOB hfiles. As such, if there is a snapshot of a\nMOB enabled table then the cleaning system will make sure those MOB files stick around in the\narchive area as long as they are needed by a snapshot or a clone of a snapshot.\n\n### MOB compaction\n\nEach time the memstore for a MOB enabled column family performs a flush HBase will write values over\nthe MOB threshold into MOB specific hfiles. When normal region compaction occurs the Region Server\nrewrites the normal data files while maintaining references to these MOB files without rewriting\nthem. Normal client lookups for MOB values transparently will receive the original values because\nthe Region Server internals take care of using the reference data to then pull the value out of a\nspecific MOB file. This indirection means that building up a large number of MOB hfiles doesn't\nimpact the overall time to retrieve any specific MOB cell. Thus, we need not perform compactions of\nthe MOB hfiles nearly as often as normal hfiles. As a result, HBase saves IO by not rewriting MOB\nhfiles as a part of the periodic compactions a Region Server does on its own.\n\nHowever, if deletes and updates of MOB cells are frequent then this indirection will begin to waste\nspace. The only way to stop using the space of a particular MOB hfile is to ensure no cells still\nhold references to it. To do that we need to ensure we have written the current values into a new\nMOB hfile. If our backing filesystem has a limitation on the number of files that can be present, as\nHDFS does, then even if we do not have deletes or updates of MOB cells eventually there will be a\nsufficient number of MOB hfiles that we will need to coalesce them.\n\nPeriodically a chore in the master coordinates having the region servers\nperform a special major compaction that also handles rewriting new MOB files. Like all compactions\nthe Region Server will create updated hfiles that hold both the cells that are smaller than the MOB\nthreshold and cells that hold references to the newly rewritten MOB file. Because this rewriting has\nthe advantage of looking across all active cells for the region our several small MOB files should\nend up as a single MOB file per region. The chore defaults to running weekly and can be\nconfigured by setting `hbase.mob.compaction.chore.period` to the desired period in seconds.\n\n```xml\n<property>\n  <name>hbase.mob.compaction.chore.period</name>\n  <value>2592000</value>\n  <description>Example of changing the chore period from a week to a month.</description>\n</property>\n```\n\nBy default, the periodic MOB compaction coordination chore will attempt to keep every region\nbusy doing compactions in parallel in order to maximize the amount of work done on the cluster.\nIf you need to tune the amount of IO this compaction generates on the underlying filesystem, you\ncan control how many concurrent region-level compaction requests are allowed by setting\n`hbase.mob.major.compaction.region.batch.size` to an integer number greater than zero. If you set\nthe configuration to 0 then you will get the default behavior of attempting to do all regions in\nparallel.\n\n```xml\n<property>\n  <name>hbase.mob.major.compaction.region.batch.size</name>\n  <value>1</value>\n  <description>Example of switching from \"as parallel as possible\" to \"serially\"</description>\n</property>\n```\n\n### MOB file archiving\n\nEventually we will have MOB hfiles that are no longer needed. Either clients will overwrite the\nvalue or a MOB-rewriting compaction will store a reference to a newer larger MOB hfile. Because any\ngiven MOB cell could have originally been written either in the current region or in a parent region\nthat existed at some prior point in time, individual Region Servers do not decide when it is time\nto archive MOB hfiles. Instead a periodic chore in the Master evaluates MOB hfiles for archiving.\n\nA MOB HFile will be subject to archiving under any of the following conditions:\n\n* Any MOB HFile older than the column family's TTL\n* Any MOB HFile older than a \"too recent\" threshold with no references to it from the regular hfiles\n  for all regions in a column family\n\nTo determine if a MOB HFile meets the second criteria the chore extracts metadata from the regular\nHFiles for each MOB enabled column family for a given table. That metadata enumerates the complete\nset of MOB HFiles needed to satisfy the references stored in the normal HFile area.\n\nThe period of the cleaner chore can be configured by setting `hbase.master.mob.cleaner.period` to a\npositive integer number of seconds. It defaults to running daily. You should not need to tune it\nunless you have a very aggressive TTL or a very high rate of MOB updates with a correspondingly\nhigh rate of non-MOB compactions.\n\n## MOB Optimization Tasks\n\n### Further limiting write amplification\n\nIf your MOB workload has few to no updates or deletes then you can opt-in to MOB compactions that\noptimize for limiting the amount of write amplification. It achieves this by setting a\nsize threshold to ignore MOB files during the compaction process. When a given region goes\nthrough MOB compaction it will evaluate the size of the MOB file that currently holds the actual\nvalue and skip rewriting the value if that file is over threshold.\n\nThe bound of write amplification in this mode can be approximated as\n\"Write Amplification\" = $\\log_{K}\\!\\left(\\frac{M}{S}\\right)$ where **K** is the number of files in compaction\nselection, **M** is the configurable threshold for MOB files size, and **S** is the minmum size of\nmemstore flushes that create MOB files in the first place. For example given 5 files picked up per\ncompaction, a threshold of 1 GB, and a flush size of 10MB the write amplification will be\n$\\log\\\\_{5}\\!\\left(\\frac{1\\,\\text{GB}}{10\\,\\text{MB}}\\right) = \\log\\\\_{5}(100) \\approx 2.86$.\n\nIf we are using an underlying filesystem with a limitation on the number of files, such as HDFS,\nand we know our expected data set size we can choose our maximum file size in order to approach\nthis limit but stay within it in order to minimize write amplification. For example, if we expect to\nstore a petabyte and we have a conservative limitation of a million files in our HDFS instance, then\n$\\frac{1\\,\\text{PB}}{1\\,\\text{M}} = 1\\,\\text{GB}$ gives us a target limitation of a gigabyte per MOB file.\n\nTo opt-in to this compaction mode you must set `hbase.mob.compaction.type` to `optimized`. The\ndefault MOB size threshold in this mode is set to 1GB. It can be changed by setting\n`hbase.mob.compactions.max.file.size` to a positive integer number of bytes.\n\n```xml\n<property>\n  <name>hbase.mob.compaction.type</name>\n  <value>optimized</value>\n  <description>opt-in to write amplification optimized mob compaction.</description>\n</property>\n<property>\n  <name>hbase.mob.compactions.max.file.size</name>\n  <value>10737418240</value>\n  <description>Example of tuning the max mob file size to 10GB</description>\n</property>\n```\n\nAdditionally, when operating in this mode the compaction process will seek to avoid writing MOB\nfiles that are over the max file threshold. As it is writing out a additional MOB values into a MOB\nhfile it will check to see if the additional data causes the hfile to be over the max file size.\nWhen the hfile of MOB values reaches limit, the MOB hfile is committed to the MOB storage area and\na new one is created. The hfile with reference cells will track the complete set of MOB hfiles it\nneeds in its metadata.\n\n<Callout type=\"warn\" title=\"Be mindful of total time to complete compaction of a region\">\n  When using the write amplification optimized compaction mode you need to watch for the maximum\n  time to compact a single region. If it nears an hour you should read through the troubleshooting\n  section below [Adjusting the MOB cleaner's tolerance for new\n  hfiles](/docs/architecture/hbase-mob#adjusting-the-mob-cleaners-tolerance-for-new-hfiles). Failure\n  to make the adjustments discussed there could lead to dataloss.\n</Callout>\n\n### Configuring the MOB Cache\n\nBecause there can be a large number of MOB files at any time, as compared to the number of HFiles,\nMOB files are not always kept open. The MOB file reader cache is a LRU cache which keeps the most\nrecently used MOB files open. To configure the MOB file reader's cache on each RegionServer, add\nthe following properties to the RegionServer's `hbase-site.xml`, customize the configuration to\nsuit your environment, and restart or rolling restart the RegionServer.\n\n#### Example MOB Cache Configuration\n\n```xml\n<property>\n  <name>hbase.mob.file.cache.size</name>\n  <value>1000</value>\n  <description>\n    Number of opened file handlers to cache.\n    A larger value will benefit reads by providing more file handlers per mob\n    file cache and would reduce frequent file opening and closing.\n    However, if this is set too high, this could lead to a \"too many opened file handers\"\n    The default value is 1000.\n  </description>\n</property>\n<property>\n  <name>hbase.mob.cache.evict.period</name>\n  <value>3600</value>\n  <description>\n    The amount of time in seconds after which an unused file is evicted from the\n    MOB cache. The default value is 3600 seconds.\n  </description>\n</property>\n<property>\n  <name>hbase.mob.cache.evict.remain.ratio</name>\n  <value>0.5f</value>\n  <description>\n    A multiplier (between 0.0 and 1.0), which determines how many files remain cached\n    after the threshold of files that remains cached after a cache eviction occurs\n    which is triggered by reaching the `hbase.mob.file.cache.size` threshold.\n    The default value is 0.5f, which means that half the files (the least-recently-used\n    ones) are evicted.\n  </description>\n</property>\n```\n\n### Manually Compacting MOB Files\n\nTo manually compact MOB files, rather than waiting for the\nperiodic chore to trigger compaction, use the\n`major_compact` HBase shell commands. These commands\nrequire the first argument to be the table name, and take a column\nfamily as the second argument. If used with a column family that includes MOB data, then\nthese operator requests will result in the MOB data being compacted.\n\n```bash\nhbase> major_compact 't1'\nhbase> major_compact 't2', 'c1'\n```\n\nThis same request can be made via the `Admin.majorCompact` Java API.\n\n## MOB Troubleshooting\n\n### Adjusting the MOB cleaner's tolerance for new hfiles\n\nThe MOB cleaner chore ignores all MOB hfiles that were created more recently than an hour prior to\nthe start of the chore to ensure we don't miss the reference metadata from the corresponding regular\nhfile. Without this safety check it would be possible for the cleaner chore to see a MOB hfile for\nan in progress flush or compaction and prematurely archive the MOB data. This default buffer should\nbe sufficient for normal use.\n\nYou will need to adjust the tolerance if you use write amplification optimized MOB compaction and\nthe combination of your underlying filesystem performance and data shape is such that it could take\nmore than an hour to complete major compaction of a single region. For example, if your MOB data is\ndistributed such that your largest region adds 80GB of MOB data between compactions that include\nrewriting MOB data and your HDFS cluster is only capable of writing 20MB/s for a single file then\nwhen performing the optimized compaction the Region Server will take about a minute to write the\nfirst 1GB MOB hfile and then another hour and seven minutes to write the remaining seventy-nine 1GB\nMOB hfiles before finally committing the new reference hfile at the end of the compaction. Given\nthis example, you would need a larger tolerance window.\n\nYou will also need to adjust the tolerance if Region Server flush operations take longer than an\nhour for the two HDFS move operations needed to commit both the MOB hfile and the normal hfile that\nreferences it. Such a delay should not happen with a normally configured and healthy HDFS and HBase.\n\nThe cleaner's window for \"too recent\" is controlled by setting `hbase.mob.min.age.archive` to a\npositive integer number of milliseconds.\n\n```xml\n<property>\n  <name>hbase.mob.min.age.archive</name>\n  <value>86400000</value>\n  <description>Example of tuning the cleaner to only archive files older than a day.</description>\n</property>\n```\n\n### Retrieving MOB metadata through the HBase Shell\n\nWhile working on troubleshooting failures in the MOB system you can retrieve some of the internal\ninformation through the HBase shell by specifying special attributes on a scan.\n\n```ruby\nhbase(main):112:0> scan 'some_table', {STARTROW => '00012-example-row-key', LIMIT => 1,\nhbase(main):113:1*     CACHE_BLOCKS => false, ATTRIBUTES => { 'hbase.mob.scan.raw' => '1',\nhbase(main):114:2*     'hbase.mob.scan.ref.only' => '1' } }\n```\n\nThe MOB internal information is stored as four bytes for the size of the underlying cell value and\nthen a UTF8 string with the name of the MOB HFile that contains the underlying cell value. Note that\nby default the entirety of this serialized structure will be passed through the HBase shell's binary\nstring converter. That means the bytes that make up the value size will most likely be written as\nescaped non-printable byte values, e.g. '\\x03', unless they happen to correspond to ASCII\ncharacters.\n\nLet's look at a specific example:\n\n```ruby\nhbase(main):112:0> scan 'some_table', {STARTROW => '00012-example-row-key', LIMIT => 1,\nhbase(main):113:1*     CACHE_BLOCKS => false, ATTRIBUTES => { 'hbase.mob.scan.raw' => '1',\nhbase(main):114:2*     'hbase.mob.scan.ref.only' => '1' } }\nROW                        COLUMN+CELL\n 00012-example-row-key     column=foo:bar, timestamp=1511179764, value=\\x00\\x02|\\x94d41d8cd98f00b204\n                       e9800998ecf8427e19700118ffd9c244fe69488bbc9f2c77d24a3e6a\n1 row(s) in 0.0130 seconds\n```\n\nIn this case the first four bytes are `\\x00\\x02|\\x94` which corresponds to the bytes\n`[0x00, 0x02, 0x7C, 0x94]`. (Note that the third byte was printed as the ASCII character '|'.)\nDecoded as an integer this gives us an underlying value size of 162,964 bytes.\n\nThe remaining bytes give us an HFile name,\n'd41d8cd98f00b204e9800998ecf8427e19700118ffd9c244fe69488bbc9f2c77d24a3e6a'. This HFile will most\nlikely be stored in the designated MOB storage area for this specific table. However, the file could\nalso be in the archive area if this table is from a restored snapshot. Furthermore, if the table is\nfrom a cloned snapshot of a different table then the file could be in either the active or archive\narea of that source table. As mentioned in the explanation of MOB reference cells above, the Region\nServer will use a server side tag to optimize looking at the mob and archive area of the correct\noriginal table when finding the MOB HFile. Since your scan is client side it can't retrieve that tag\nand you'll either need to already know the lineage of your table or you'll need to search across all\ntables.\n\nAssuming you are authenticated as a user with HBase superuser rights, you can search for it:\n\n```bash\n$> hdfs dfs -find /hbase -name \\\nd41d8cd98f00b204e9800998ecf8427e19700118ffd9c244fe69488bbc9f2c77d24a3e6a\n/hbase/mobdir/data/default/some_table/372c1b27e3dc0b56c3a031926e5efbe9/foo/d41d8cd98f00b204e9800998ecf8427e19700118ffd9c244fe69488bbc9f2c77d24a3e6a\n```\n\n### Moving a column family out of MOB\n\nIf you want to disable MOB on a column family you must ensure you instruct HBase to migrate the data\nout of the MOB system prior to turning the feature off. If you fail to do this HBase will return the\ninternal MOB metadata to applications because it will not know that it needs to resolve the actual\nvalues.\n\nThe following procedure will safely migrate the underlying data without requiring a cluster outage.\nClients will see a number of retries when configuration settings are applied and regions are\nreloaded.\n\n#### Procedure: Stop MOB maintenance, change MOB threshold, rewrite data via compaction\n\n<Steps>\n  <Step>\n    Ensure the MOB compaction chore in the Master is off by setting\n    `hbase.mob.compaction.chore.period` to `0`. Applying this configuration change will require a\n    rolling restart of HBase Masters. That will require at least one fail-over of the active master,\n    which may cause retries for clients doing HBase administrative operations.\n  </Step>\n\n  <Step>\n    Ensure no MOB compactions are issued for the table via the HBase shell for the duration of this\n    migration.\n  </Step>\n\n  <Step>\n    ##### Change the MOB size threshold\n\n    Use the HBase shell to change the MOB size threshold for the column family you are migrating to a\n    value that is larger than the largest cell present in the column family. E.g. given a table named\n    'some\\_table' and a column family named 'foo' we can pick one gigabyte as an arbitrary \"bigger than\n    what we store\" value:\n\n    ```ruby\n     hbase(main):011:0> alter 'some_table', {NAME => 'foo', MOB_THRESHOLD => '1000000000'}\n     Updating all regions with the new schema...\n     9/25 regions updated.\n     25/25 regions updated.\n     Done.\n     0 row(s) in 3.4940 seconds\n    ```\n\n    Note that if you are still ingesting data you must ensure this threshold is larger than any cell value you might write; MAX\\_INT would be a safe choice.\n  </Step>\n\n  <Step>\n    ##### Perform a major compaction on the table\n\n    Specifically you are performing a \"normal\" compaction and not a MOB compaction.\n\n    ```ruby\n    hbase(main):012:0> major_compact 'some_table'\n    0 row(s) in 0.2600 seconds\n    ```\n  </Step>\n\n  <Step>\n    ##### Monitor for the end of the major compaction\n\n    Since compaction is handled asynchronously you'll need to use the shell to first see the compaction start and then see it end.\n\n    HBase should first say that a \"MAJOR\" compaction is happening.\n\n    ```ruby\n    hbase(main):015:0> @hbase.admin(@formatter).instance_eval do\n    hbase(main):016:1*   p @admin.get_compaction_state('some_table').to_string\n    hbase(main):017:2* end\n    \"MAJOR\"\n    ```\n\n    When the compaction has finished the result should print out \"NONE\".\n\n    ```ruby\n    hbase(main):015:0> @hbase.admin(@formatter).instance_eval do\n    hbase(main):016:1*   p @admin.get_compaction_state('some_table').to_string\n    hbase(main):017:2* end\n    \"NONE\"\n    ```\n  </Step>\n\n  <Step>\n    Run the *mobrefs* utility to ensure there are no MOB cells. Specifically, the tool will launch a\n    Hadoop MapReduce job that will show a job counter of 0 input records when we've successfully\n    rewritten all of the data.\n\n    ```bash\n    $> HADOOP_CLASSPATH=/etc/hbase/conf:$(hbase mapredcp) yarn jar \\\n    /some/path/to/hbase-shaded-mapreduce.jar mobrefs mobrefs-report-output some_table foo\n    ...\n    19/12/10 11:38:47 INFO impl.YarnClientImpl: Submitted application application_1575695902338_0004\n    19/12/10 11:38:47 INFO mapreduce.Job: The url to track the job: https://rm-2.example.com:8090/proxy application_1575695902338_0004/\n    19/12/10 11:38:47 INFO mapreduce.Job: Running job: job_1575695902338_0004\n    19/12/10 11:38:57 INFO mapreduce.Job: Job job_1575695902338_0004 running in uber mode : false\n    19/12/10 11:38:57 INFO mapreduce.Job:  map 0% reduce 0%\n    19/12/10 11:39:07 INFO mapreduce.Job:  map 7% reduce 0%\n    19/12/10 11:39:17 INFO mapreduce.Job:  map 13% reduce 0%\n    19/12/10 11:39:19 INFO mapreduce.Job:  map 33% reduce 0%\n    19/12/10 11:39:21 INFO mapreduce.Job:  map 40% reduce 0%\n    19/12/10 11:39:22 INFO mapreduce.Job:  map 47% reduce 0%\n    19/12/10 11:39:23 INFO mapreduce.Job:  map 60% reduce 0%\n    19/12/10 11:39:24 INFO mapreduce.Job:  map 73% reduce 0%\n    19/12/10 11:39:27 INFO mapreduce.Job:  map 100% reduce 0%\n    19/12/10 11:39:35 INFO mapreduce.Job:  map 100% reduce 100%\n    19/12/10 11:39:35 INFO mapreduce.Job: Job job_1575695902338_0004 completed successfully\n    19/12/10 11:39:35 INFO mapreduce.Job: Counters: 54\n    ...\n           Map-Reduce Framework\n                   Map input records=0\n    ...\n    19/12/09 22:41:28 INFO mapreduce.MobRefReporter: Finished creating report for 'some_table', family='foo'\n    ```\n\n    If the data has not successfully been migrated out, this report will show both a non-zero number\n    of input records and a count of mob cells.\n\n    ```bash\n    $> HADOOP_CLASSPATH=/etc/hbase/conf:$(hbase mapredcp) yarn jar \\\n    /some/path/to/hbase-shaded-mapreduce.jar mobrefs mobrefs-report-output some_table foo\n    ...\n    19/12/10 11:44:18 INFO impl.YarnClientImpl: Submitted application application_1575695902338_0005\n    19/12/10 11:44:18 INFO mapreduce.Job: The url to track the job: https://busbey-2.gce.cloudera.com:8090 proxy/application_1575695902338_0005/\n    19/12/10 11:44:18 INFO mapreduce.Job: Running job: job_1575695902338_0005\n    19/12/10 11:44:26 INFO mapreduce.Job: Job job_1575695902338_0005 running in uber mode : false\n    19/12/10 11:44:26 INFO mapreduce.Job:  map 0% reduce 0%\n    19/12/10 11:44:36 INFO mapreduce.Job:  map 7% reduce 0%\n    19/12/10 11:44:45 INFO mapreduce.Job:  map 13% reduce 0%\n    19/12/10 11:44:47 INFO mapreduce.Job:  map 27% reduce 0%\n    19/12/10 11:44:48 INFO mapreduce.Job:  map 33% reduce 0%\n    19/12/10 11:44:50 INFO mapreduce.Job:  map 40% reduce 0%\n    19/12/10 11:44:51 INFO mapreduce.Job:  map 53% reduce 0%\n    19/12/10 11:44:52 INFO mapreduce.Job:  map 73% reduce 0%\n    19/12/10 11:44:54 INFO mapreduce.Job:  map 100% reduce 0%\n    19/12/10 11:44:59 INFO mapreduce.Job:  map 100% reduce 100%\n    19/12/10 11:45:00 INFO mapreduce.Job: Job job_1575695902338_0005 completed successfully\n    19/12/10 11:45:00 INFO mapreduce.Job: Counters: 54\n    ...\n           Map-Reduce Framework\n                   Map input records=1\n    ...\n           MOB\n                   NUM_CELLS=1\n    ...\n    19/12/10 11:45:00 INFO mapreduce.MobRefReporter: Finished creating report for 'some_table', family='foo'\n    ```\n\n    If this happens you should verify that MOB compactions are disabled, verify that you have picked a sufficiently large MOB threshold, and redo the major compaction step.\n  </Step>\n\n  <Step>\n    ##### Disable the MOB feature for the column family\n\n    When the *mobrefs* report shows that no more data is stored in the MOB system then you can safely alter the column family configuration so that the MOB feature is disabled.\n\n    ```ruby\n    hbase(main):017:0> alter 'some_table', {NAME => 'foo', IS_MOB => 'false'}\n    Updating all regions with the new schema...\n    8/25 regions updated.\n    25/25 regions updated.\n    Done.\n    0 row(s) in 2.9370 seconds\n    ```\n\n    The MOB feature will be disabled on a column family only after altering the column family and performing a major compaction. Before performing the major compaction after altering the column family, the MOB cells will still be present in the MOB storage.\n  </Step>\n\n  <Step>\n    After the column family no longer shows the MOB feature enabled, it is safe to start MOB maintenance chores again. You can allow the default to be used for `hbase.mob.compaction.chore.period` by removing it from your configuration files or restore it to whatever custom value you had prior to starting this process.\n  </Step>\n\n  <Step>\n    ##### Clean up residual MOB data\n\n    Once the MOB feature is disabled for the column family there will be no internal HBase process\n    looking for data in the MOB storage area specific to this column family. There will still be data\n    present there from prior to the compaction process that rewrote the values into HBase's data area.\n    You can check for this residual data directly in HDFS as an HBase superuser.\n\n    ```bash\n    $ hdfs dfs -count /hbase/mobdir/data/default/some_table\n               4           54         9063269081 /hbase/mobdir/data/default/some_table\n    ```\n\n    This data is spurious and may be reclaimed. You should sideline it, verify your application's view of the table, and then delete it.\n  </Step>\n</Steps>\n\n### Data values over than the MOB threshold show up stored in non-MOB hfiles\n\nBulk load and WAL split-to-HFile don't consider MOB threshold and write data into normal hfile (under /hbase/data directory).\n\n<Callout type=\"info\">\n  This won't cause any functional problem, during next compaction such data will be written out to\n  the MOB hfiles.\n</Callout>\n\n## MOB Upgrade Considerations\n\nGenerally, data stored using the MOB feature should transparently continue to work correctly across\nHBase upgrades.\n\n### Upgrading to a version with the \"distributed MOB compaction\" feature\n\nPrior to the work in HBASE-22749, \"Distributed MOB compactions\", HBase had the Master coordinate all\ncompaction maintenance of the MOB hfiles. Centralizing management of the MOB data allowed for space\noptimizations but safely coordinating that management with Region Servers resulted in edge cases that\ncaused data loss (ref [HBASE-22075](https://issues.apache.org/jira/browse/HBASE-22075)).\n\nUsers of the MOB feature upgrading to a version of HBase that includes HBASE-22749 should be aware\nof the following changes:\n\n* The MOB system no longer allows setting \"MOB Compaction Policies\"\n* The MOB system no longer attempts to group MOB values by the date of the original cell's timestamp\n  according to said compaction policies, daily or otherwise\n* The MOB system no longer needs to track individual cell deletes through the use of special\n  files in the MOB storage area with the suffix `_del`. After upgrading you should sideline these\n  files.\n* Under default configuration the MOB system should take much less time to perform a compaction of\n  MOB stored values. This is a direct consequence of the fact that HBase will place a much larger\n  load on the underlying filesystem when doing compactions of MOB stored values; the additional load\n  should be a multiple on the order of magnitude of number of region servers. I.e. for a cluster\n  with three region servers and two masters the default configuration should have HBase put three\n  times the load on HDFS during major compactions that rewrite MOB data when compared to Master\n  handled MOB compaction; it should also be approximately three times as fast.\n* When the MOB system detects that a table has hfiles with references to MOB data but the reference\n  hfiles do not yet have the needed file level metadata (i.e. from use of the MOB feature prior to\n  HBASE-22749) then it will refuse to archive *any* MOB hfiles from that table. The normal course of\n  periodic compactions done by Region Servers will update existing hfiles with MOB references, but\n  until a given table has been through the needed compactions operators should expect to see an\n  increased amount of storage used by the MOB feature.\n* Performing a compaction with type \"MOB\" no longer has special handling to compact specifically the\n  MOB hfiles. Instead it will issue a warning and do a compaction of the table. For example using\n  the HBase shell as follows will result in a warning in the Master logs followed by a major\n  compaction of the 'example' table in its entirety or for the 'big' column respectively.\n  ```ruby\n  hbase> major_compact 'example', nil, 'MOB'\n  hbase> major_compact 'example', 'big', 'MOB'\n  ```\n  The same is true for directly using the Java API for `admin.majorCompact(TableName.valueOf(\"example\"), CompactType.MOB)`.\n* Similarly, manually performing a major compaction on a table or region will also handle compacting\n  the MOB stored values for that table or region respectively.\n\nThe following configuration setting has been deprecated and replaced:\n\n* `hbase.master.mob.ttl.cleaner.period` has been replaced with `hbase.master.mob.cleaner.period`\n\nThe following configuration settings are no longer used:\n\n* `hbase.mob.compaction.mergeable.threshold`\n* `hbase.mob.delfile.max.count`\n* `hbase.mob.compaction.batch.size`\n* `hbase.mob.compactor.class`\n* `hbase.mob.compaction.threads.max`\n\n\n# HDFS (/docs/architecture/hdfs)\nAs HBase runs on HDFS (and each StoreFile is written as a file on HDFS), it is important to have an understanding of the HDFS Architecture especially in terms of how it stores files, handles failovers, and replicates blocks.\n\nSee the Hadoop documentation on [HDFS Architecture](https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) for more information.\n\n## NameNode\n\nThe NameNode is responsible for maintaining the filesystem metadata. See the above HDFS Architecture link for more information.\n\n## DataNode\n\nThe DataNodes are responsible for storing HDFS blocks. See the above HDFS Architecture link for more information.\n\n\n# Architecture (/docs/architecture)\n## Resources\n\n1. More information about the design and implementation can be found at the jira issue: [HBASE-10070](https://issues.apache.org/jira/browse/HBASE-10070)\n\n2. HBaseCon 2014 talk: [HBase Read High Availability Using Timeline-Consistent Region Replicas](https://hbase.apache.org/www.hbasecon.com/#2014-PresentationsRecordings) also contains some details and [slides](http://www.slideshare.net/enissoz/hbase-high-availability-for-reads-with-time).\n\n\n# Master (/docs/architecture/master)\n`HMaster` is the implementation of the Master Server. The Master server is responsible for monitoring all RegionServer instances in the cluster, and is the interface for all metadata changes. In a distributed cluster, the Master typically runs on the [NameNode](/docs/architecture/hdfs#hdfs-namenode). J Mohamed Zahoor goes into some more detail on the Master Architecture in this blog posting, [HBase HMaster Architecture](https://web.archive.org/web/20191211053128/http://blog.zahoor.in/2012/08/hbase-hmaster-architecture/).\n\n## Startup Behavior\n\nIf run in a multi-Master environment, all Masters compete to run the cluster. If the active Master loses its lease in ZooKeeper (or the Master shuts down), then the remaining Masters jostle to take over the Master role.\n\n## Runtime Impact\n\nA common dist-list question involves what happens to an HBase cluster when the Master goes down. This information has changed starting 3.0.0.\n\n### Up until releases 2.x.y\n\nBecause the HBase client talks directly to the RegionServers, the cluster can still function in a \"steady state\". Additionally, per [Catalog Tables](/docs/architecture/catalog-tables), `hbase:meta` exists as an HBase table and is not resident in the Master. However, the Master controls critical functions such as RegionServer failover and completing region splits. So while the cluster can still run for a short time without the Master, the Master should be restarted as soon as possible.\n\n### Staring release 3.0.0\n\nAs mentioned in section [Master Registry (new as of 2.3.0)](/docs/architecture/client#masterregistry-rpc-hedging), the default connection registry for clients is now based on master rpc end points. Hence the requirements for masters' uptime are even tighter starting this release.\n\n* At least one active or stand by master is needed for a connection set up, unlike before when all the clients needed was a ZooKeeper ensemble.\n* Master is now in critical path for read/write operations. For example, if the meta region bounces off to a different region server, clients need master to fetch the new locations. Earlier this was done by fetching this information directly from ZooKeeper.\n* Masters will now have higher connection load than before. So, the server side configuration might need adjustment depending on the load.\n\nOverall, the master uptime requirements, when this feature is enabled, are even higher for the client operations to go through.\n\n## Interface\n\nThe methods exposed by `HMasterInterface` are primarily metadata-oriented methods:\n\n* Table (createTable, modifyTable, removeTable, enable, disable)\n* ColumnFamily (addColumn, modifyColumn, removeColumn)\n* Region (move, assign, unassign) For example, when the `Admin` method `disableTable` is invoked, it is serviced by the Master server.\n\n## Processes\n\nThe Master runs several background threads:\n\n### LoadBalancer\n\nPeriodically, and when there are no regions in transition, a load balancer will run and move regions around to balance the cluster's load. See [Balancer](/docs/configuration/important#balancer) for configuring this property.\n\nSee [Region-RegionServer Assignment](/docs/architecture/regions#region-regionserver-assignment) for more information on region assignment.\n\n### CatalogJanitor\n\nPeriodically checks and cleans up the `hbase:meta` table. See [hbase:meta](/docs/architecture/catalog-tables#hbasemeta) for more information on the meta table.\n\n## MasterProcWAL\n\n*MasterProcWAL is replaced in hbase-2.3.0 by an alternate Procedure Store implementation; see [in-master-procedure-store-region](/docs/upgrading/paths#new-in-master-procedure-store). This section pertains to hbase-2.0.0 through hbase-2.2.x*\n\nHMaster records administrative operations and their running states, such as the handling of a crashed server, table creation, and other DDLs, into a Procedure Store. The Procedure Store WALs are stored under the MasterProcWALs directory. The Master WALs are not like RegionServer WALs. Keeping up the Master WAL allows us to run a state machine that is resilient across Master failures. For example, if a HMaster was in the middle of creating a table encounters an issue and fails, the next active HMaster can take up where the previous left off and carry the operation to completion. Since hbase-2.0.0, a new AssignmentManager (A.K.A AMv2) was introduced and the HMaster handles region assignment operations, server crash processing, balancing, etc., all via AMv2 persisting all state and transitions into MasterProcWALs rather than up into ZooKeeper, as we do in hbase-1.x.\n\nSee [AMv2 Description for Devs](/docs/amv2) (and [Procedure Framework (Pv2): HBASE-12439](/docs/pv2) for its basis) if you would like to learn more about the new AssignmentManager.\n\n### Configurations for MasterProcWAL\n\nHere are the list of configurations that effect MasterProcWAL operation. You should not have to change your defaults.\n\n* **`hbase.procedure.store.wal.periodic.roll.msec`**\\\n  **Description:** Frequency of generating a new WAL\\\n  **Default:** `1h (3600000 in msec)`\n\n* **`hbase.procedure.store.wal.roll.threshold`**\\\n  **Description:** Threshold in size before the WAL rolls. Every time the WAL reaches this size or the above period, 1 hour, passes since last log roll, the HMaster will generate a new WAL.\\\n  **Default:** `32MB (33554432 in byte)`\n\n* **`hbase.procedure.store.wal.warn.threshold`**\\\n  **Description:** If the number of WALs goes beyond this threshold, the following message should appear in the HMaster log with WARN level when rolling.\n\n  ```\n  procedure WALs count=xx above the warning threshold 64. check running procedures to see if something is stuck.\n  ```\n\n  **Default:** `64`\n\n* **`hbase.procedure.store.wal.max.retries.before.roll`**\\\n  **Description:** Max number of retry when syncing slots (records) to its underlying storage, such as HDFS. Every attempt, the following message should appear in the HMaster log.\n\n  ```\n  unable to sync slots, retry=xx\n  ```\n\n  **Default:** `3`\n\n* **`hbase.procedure.store.wal.sync.failure.roll.max`**\\\n  **Description:** After the above 3 retrials, the log is rolled and the retry count is reset to 0, thereon a new set of retrial starts. This configuration controls the max number of attempts of log rolling upon sync failure. That is, HMaster is allowed to fail to sync 9 times in total. Once it exceeds, the following log should appear in the HMaster log.\n  ```\n  Sync slots after log roll failed, abort.\n  ```\n  **Default:** `3`\n\n\n# Overview (/docs/architecture/overview)\n## NoSQL?\n\nHBase is a type of \"NoSQL\" database. \"NoSQL\" is a general term meaning that the database isn't an RDBMS which supports SQL as its primary access language, but there are many types of NoSQL databases: BerkeleyDB is an example of a local NoSQL database, whereas HBase is very much a distributed database. Technically speaking, HBase is really more a \"Data Store\" than \"Data Base\" because it lacks many of the features you find in an RDBMS, such as typed columns, secondary indexes, triggers, and advanced query languages, etc.\n\nHowever, HBase has many features which supports both linear and modular scaling. HBase clusters expand by adding RegionServers that are hosted on commodity class servers. If a cluster expands from 10 to 20 RegionServers, for example, it doubles both in terms of storage and as well as processing capacity. An RDBMS can scale well, but only up to a point - specifically, the size of a single database server - and for the best performance requires specialized hardware and storage devices. HBase features of note are:\n\n* Strongly consistent reads/writes: HBase is not an \"eventually consistent\" DataStore. This makes it very suitable for tasks such as high-speed counter aggregation.\n* Automatic sharding: HBase tables are distributed on the cluster via regions, and regions are automatically split and re-distributed as your data grows.\n* Automatic RegionServer failover\n* Hadoop/HDFS Integration: HBase supports HDFS out of the box as its distributed file system.\n* MapReduce: HBase supports massively parallelized processing via MapReduce for using HBase as both source and sink.\n* Java Client API: HBase supports an easy to use Java API for programmatic access.\n* Thrift/REST API: HBase also supports Thrift and REST for non-Java front-ends.\n* Block Cache and Bloom Filters: HBase supports a Block Cache and Bloom Filters for high volume query optimization.\n* Operational Management: HBase provides build-in web-pages for operational insight as well as JMX metrics.\n\n## When Should I Use HBase?\n\nHBase isn't suitable for every problem.\n\nFirst, make sure you have enough data. If you have hundreds of millions or billions of rows, then HBase is a good candidate. If you only have a few thousand/million rows, then using a traditional RDBMS might be a better choice due to the fact that all of your data might wind up on a single node (or two) and the rest of the cluster may be sitting idle.\n\nSecond, make sure you can live without all the extra features that an RDBMS provides (e.g., typed columns, secondary indexes, transactions, advanced query languages, etc.) An application built against an RDBMS cannot be \"ported\" to HBase by simply changing a JDBC driver, for example. Consider moving from an RDBMS to HBase as a complete redesign as opposed to a port.\n\nThird, make sure you have enough hardware. Even HDFS doesn't do well with anything less than 5 DataNodes (due to things such as HDFS block replication which has a default of 3), plus a NameNode.\n\nHBase can run quite well stand-alone on a laptop - but this should be considered a development configuration only.\n\n## What Is The Difference Between HBase and Hadoop/HDFS?\n\n[HDFS](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) is a distributed file system that is well suited for the storage of large files. Its documentation states that it is not, however, a general purpose file system, and does not provide fast individual record lookups in files. HBase, on the other hand, is built on top of HDFS and provides fast record lookups (and updates) for large tables. This can sometimes be a point of conceptual confusion. HBase internally puts your data in indexed \"StoreFiles\" that exist on HDFS for high-speed lookups. See the [Data Model](/docs/datamodel) and the rest of this chapter for more information on how HBase achieves its goals.\n\n\n# Regions (/docs/architecture/regions)\n\n\nRegions are the basic element of availability and distribution for tables, and are comprised of a Store per Column Family. The hierarchy of objects is as follows:\n\n```\nTable                    (HBase table)\n    Region               (Regions for the table)\n        Store            (Store per ColumnFamily for each Region for the table)\n            MemStore     (MemStore for each Store for each Region for the table)\n            StoreFile    (StoreFiles for each Store for each Region for the table)\n                Block    (Blocks within a StoreFile within a Store for each Region for the table)\n```\n\nFor a description of what HBase files look like when written to HDFS, see [Browsing HDFS for HBase Objects](/docs/troubleshooting#browsing-hdfs-for-hbase-objects).\n\n## Considerations for Number of Regions\n\nIn general, HBase is designed to run with a small (20-200) number of relatively large (5-20Gb) regions per server. The considerations for this are as follows:\n\n### Why should I keep my Region count low?\n\nTypically you want to keep your region count low on HBase for numerous reasons. Usually right around 100 regions per RegionServer has yielded the best results. Here are some of the reasons below for keeping region count low:\n\n1. MSLAB (MemStore-local allocation buffer) requires 2MB per MemStore (that's 2MB per family per region). 1000 regions that have 2 families each is 3.9GB of heap used, and it's not even storing data yet. NB: the 2MB value is configurable.\n2. If you fill all the regions at somewhat the same rate, the global memory usage makes it that it forces tiny flushes when you have too many regions which in turn generates compactions. Rewriting the same data tens of times is the last thing you want. An example is filling 1000 regions (with one family) equally and let's consider a lower bound for global MemStore usage of 5GB (the region server would have a big heap). Once it reaches 5GB it will force flush the biggest region, at that point they should almost all have about 5MB of data so it would flush that amount. 5MB inserted later, it would flush another region that will now have a bit over 5MB of data, and so on. This is currently the main limiting factor for the number of regions; see [Number of regions per RS - upper bound](/docs/operational-management/region-and-capacity#number-of-regions-per-rs---upper-bound) for detailed formula.\n3. The master as is is allergic to tons of regions, and will take a lot of time assigning them and moving them around in batches. The reason is that it's heavy on ZK usage, and it's not very async at the moment (could really be improved — and has been improved a bunch in 0.96 HBase).\n4. In older versions of HBase (pre-HFile v2, 0.90 and previous), tons of regions on a few RS can cause the store file index to rise, increasing heap usage and potentially creating memory pressure or OOME on the RSs\n\nAnother issue is the effect of the number of regions on MapReduce jobs; it is typical to have one mapper per HBase region. Thus, hosting only 5 regions per RS may not be enough to get sufficient number of tasks for a MapReduce job, while 1000 regions will generate far too many tasks.\n\nSee [Determining region count and size](/docs/operational-management/region-and-capacity#determining-region-count-and-size) for configuration guidelines.\n\n## Region-RegionServer Assignment\n\nThis section describes how Regions are assigned to RegionServers.\n\n### Startup\n\nWhen HBase starts regions are assigned as follows (short version):\n\n1. The Master invokes the `AssignmentManager` upon startup.\n2. The `AssignmentManager` looks at the existing region assignments in `hbase:meta`.\n3. If the region assignment is still valid (i.e., if the RegionServer is still online) then the assignment is kept.\n4. If the assignment is invalid, then the `LoadBalancerFactory` is invoked to assign the region. The load balancer (`StochasticLoadBalancer` by default in HBase 1.0) assign the region to a RegionServer.\n5. `hbase:meta` is updated with the RegionServer assignment (if needed) and the RegionServer start codes (start time of the RegionServer process) upon region opening by the RegionServer.\n\n### Failover\n\nWhen a RegionServer fails:\n\n1. The regions immediately become unavailable because the RegionServer is down.\n2. The Master will detect that the RegionServer has failed.\n3. The region assignments will be considered invalid and will be re-assigned just like the startup sequence.\n4. In-flight queries are re-tried, and not lost.\n5. Operations are switched to a new RegionServer within the following amount of time:\n   ```text\n   ZooKeeper session timeout + split time + assignment/replay time\n   ```\n\n### Region Load Balancing\n\nRegions can be periodically moved by the [LoadBalancer](/docs/architecture/master#loadbalancer).\n\n### Region State Transition\n\nHBase maintains a state for each region and persists the state in `hbase:meta`. The state of the `hbase:meta` region itself is persisted in ZooKeeper. You can see the states of regions in transition in the Master web UI. Following is the list of possible region states.\n\n**Possible Region States:**\n\n* `OFFLINE`: the region is offline and not opening\n* `OPENING`: the region is in the process of being opened\n* `OPEN`: the region is open and the RegionServer has notified the master\n* `FAILED_OPEN`: the RegionServer failed to open the region\n* `CLOSING`: the region is in the process of being closed\n* `CLOSED`: the RegionServer has closed the region and notified the master\n* `FAILED_CLOSE`: the RegionServer failed to close the region\n* `SPLITTING`: the RegionServer notified the master that the region is splitting\n* `SPLIT`: the RegionServer notified the master that the region has finished splitting\n* `SPLITTING_NEW`: this region is being created by a split which is in progress\n* `MERGING`: the RegionServer notified the master that this region is being merged with another region\n* `MERGED`: the RegionServer notified the master that this region has been merged\n* `MERGING_NEW`: this region is being created by a merge of two regions\n\n<img alt=\"Region states\" src={__img0} placeholder=\"blur\" />\n\n**Graph Legend:**\n\n* Brown: Offline state, a special state that can be transient (after closed before opening), terminal (regions of disabled tables), or initial (regions of newly created tables)\n* Palegreen: Online state that regions can serve requests\n* Lightblue: Transient states\n* Red: Failure states that need OPS attention\n* Gold: Terminal states of regions split/merged\n* Grey: Initial states of regions created through split/merge\n\n**Transition State Descriptions:**\n\n1. The master moves a region from `OFFLINE` to `OPENING` state and tries to assign the region to a RegionServer. The RegionServer may or may not have received the open region request. The master retries sending the open region request to the RegionServer until the RPC goes through or the master runs out of retries. After the RegionServer receives the open region request, the RegionServer begins opening the region.\n2. If the master is running out of retries, the master prevents the RegionServer from opening the region by moving the region to `CLOSING` state and trying to close it, even if the RegionServer is starting to open the region.\n3. After the RegionServer opens the region, it continues to try to notify the master until the master moves the region to `OPEN` state and notifies the RegionServer. The region is now open.\n4. If the RegionServer cannot open the region, it notifies the master. The master moves the region to `CLOSED` state and tries to open the region on a different RegionServer.\n5. If the master cannot open the region on any of a certain number of regions, it moves the region to `FAILED_OPEN` state, and takes no further action until an operator intervenes from the HBase shell, or the server is dead.\n6. The master moves a region from `OPEN` to `CLOSING` state. The RegionServer holding the region may or may not have received the close region request. The master retries sending the close request to the server until the RPC goes through or the master runs out of retries.\n7. If the RegionServer is not online, or throws `NotServingRegionException`, the master moves the region to `OFFLINE` state and re-assigns it to a different RegionServer.\n8. If the RegionServer is online, but not reachable after the master runs out of retries, the master moves the region to `FAILED_CLOSE` state and takes no further action until an operator intervenes from the HBase shell, or the server is dead.\n9. If the RegionServer gets the close region request, it closes the region and notifies the master. The master moves the region to `CLOSED` state and re-assigns it to a different RegionServer.\n10. Before assigning a region, the master moves the region to `OFFLINE` state automatically if it is in `CLOSED` state.\n11. When a RegionServer is about to split a region, it notifies the master. The master moves the region to be split from `OPEN` to `SPLITTING` state and add the two new regions to be created to the RegionServer. These two regions are in `SPLITTING_NEW` state initially.\n12. After notifying the master, the RegionServer starts to split the region. Once past the point of no return, the RegionServer notifies the master again so the master can update the `hbase:meta` table. However, the master does not update the region states until it is notified by the server that the split is done. If the split is successful, the splitting region is moved from `SPLITTING` to `SPLIT` state and the two new regions are moved from `SPLITTING_NEW` to `OPEN` state.\n13. If the split fails, the splitting region is moved from `SPLITTING` back to `OPEN` state, and the two new regions which were created are moved from `SPLITTING_NEW` to `OFFLINE` state.\n14. When a RegionServer is about to merge two regions, it notifies the master first. The master moves the two regions to be merged from `OPEN` to `MERGING` state, and adds the new region which will hold the contents of the merged regions region to the RegionServer. The new region is in `MERGING_NEW` state initially.\n15. After notifying the master, the RegionServer starts to merge the two regions. Once past the point of no return, the RegionServer notifies the master again so the master can update the META. However, the master does not update the region states until it is notified by the RegionServer that the merge has completed. If the merge is successful, the two merging regions are moved from `MERGING` to `MERGED` state and the new region is moved from `MERGING_NEW` to `OPEN` state.\n16. If the merge fails, the two merging regions are moved from `MERGING` back to `OPEN` state, and the new region which was created to hold the contents of the merged regions is moved from `MERGING_NEW` to `OFFLINE` state.\n17. For regions in `FAILED_OPEN` or `FAILED_CLOSE` states, the master tries to close them again when they are reassigned by an operator via HBase Shell.\n\n## Region-RegionServer Locality\n\nOver time, Region-RegionServer locality is achieved via HDFS block replication. The HDFS client does the following by default when choosing locations to write replicas:\n\n1. First replica is written to local node\n2. Second replica is written to a random node on another rack\n3. Third replica is written on the same rack as the second, but on a different node chosen randomly\n4. Subsequent replicas are written on random nodes on the cluster. See *Replica Placement: The First Baby Steps* on this page: [HDFS Architecture](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html)\n\nThus, HBase eventually achieves locality for a region after a flush or a compaction. In a RegionServer failover situation a RegionServer may be assigned regions with non-local StoreFiles (because none of the replicas are local), however as new data is written in the region, or the table is compacted and StoreFiles are re-written, they will become \"local\" to the RegionServer.\n\nFor more information, see *Replica Placement: The First Baby Steps* on this page: [HDFS Architecture](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) and also Lars George's blog on [HBase and HDFS locality](http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html).\n\n## Region Splits\n\nRegions split when they reach a configured threshold. Below we treat the topic in short. For a longer exposition, see [Apache HBase Region Splitting and Merging](http://hortonworks.com/blog/apache-hbase-region-splitting-and-merging/) by our Enis Soztutar.\n\nSplits run unaided on the RegionServer; i.e. the Master does not participate. The RegionServer splits a region, offlines the split region and then adds the daughter regions to `hbase:meta`, opens daughters on the parent's hosting RegionServer and then reports the split to the Master. See [Managed Splitting](/docs/configuration/important#managed-splitting) for how to manually manage splits (and for why you might do this).\n\n### Custom Split Policies\n\nYou can override the default split policy using a custom [RegionSplitPolicy](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/regionserver/RegionSplitPolicy.html) (HBase 0.94+). Typically a custom split policy should extend HBase's default split policy: [IncreasingToUpperBoundRegionSplitPolicy](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/regionserver/IncreasingToUpperBoundRegionSplitPolicy.html).\n\nThe policy can set globally through the HBase configuration or on a per-table basis.\n\n#### Configuring the Split Policy Globally in *hbase-site.xml*\n\n```xml\n<property>\n  <name>hbase.regionserver.region.split.policy</name>\n  <value>org.apache.hadoop.hbase.regionserver.IncreasingToUpperBoundRegionSplitPolicy</value>\n</property>\n```\n\n#### Configuring a Split Policy On a Table Using the Java API\n\n```java\nHTableDescriptor tableDesc = new HTableDescriptor(\"test\");\ntableDesc.setValue(HTableDescriptor.SPLIT_POLICY, ConstantSizeRegionSplitPolicy.class.getName());\ntableDesc.addFamily(new HColumnDescriptor(Bytes.toBytes(\"cf1\")));\nadmin.createTable(tableDesc);\n```\n\n#### Configuring the Split Policy On a Table Using HBase Shell\n\n```ruby\nhbase> create 'test', {METADATA => {'SPLIT_POLICY' => 'org.apache.hadoop.hbase.regionserver.ConstantSizeRegionSplitPolicy'}},{NAME => 'cf1'}\n```\n\nThe policy can be set globally through the HBaseConfiguration used or on a per table basis:\n\n```java\nHTableDescriptor myHtd = ...;\nmyHtd.setValue(HTableDescriptor.SPLIT_POLICY, MyCustomSplitPolicy.class.getName());\n```\n\n<Callout type=\"info\">\n  The `DisabledRegionSplitPolicy` policy blocks manual region splitting.\n</Callout>\n\n## Manual Region Splitting\n\nIt is possible to manually split your table, either at table creation (pre-splitting), or at a later time as an administrative action. You might choose to split your region for one or more of the following reasons. There may be other valid reasons, but the need to manually split your table might also point to problems with your schema design.\n\n**Reasons to Manually Split Your Table:**\n\n* Your data is sorted by timeseries or another similar algorithm that sorts new data at the end of the table. This means that the Region Server holding the last region is always under load, and the other Region Servers are idle, or mostly idle. See also [Monotonically Increasing Row Keys/Timeseries Data](/docs/regionserver-sizing#monotonically-increasing-row-keystimeseries-data).\n* You have developed an unexpected hotspot in one region of your table. For instance, an application which tracks web searches might be inundated by a lot of searches for a celebrity in the event of news about that celebrity. See [perf.one.region](/docs/performance#anti-pattern-one-hot-region) for more discussion about this particular scenario.\n* After a big increase in the number of RegionServers in your cluster, to get the load spread out quickly.\n* Before a bulk-load which is likely to cause unusual and uneven load across regions.\n\nSee [Managed Splitting](/docs/configuration/important#managed-splitting) for a discussion about the dangers and possible benefits of managing splitting completely manually.\n\n<Callout type=\"info\">\n  The `DisabledRegionSplitPolicy` policy blocks manual region splitting.\n</Callout>\n\n### Determining Split Points\n\nThe goal of splitting your table manually is to improve the chances of balancing the load across the cluster in situations where good rowkey design alone won't get you there. Keeping that in mind, the way you split your regions is very dependent upon the characteristics of your data. It may be that you already know the best way to split your table. If not, the way you split your table depends on what your keys are like.\n\n**Alphanumeric Rowkeys**\\\nIf your rowkeys start with a letter or number, you can split your table at letter or number boundaries. For instance, the following command creates a table with regions that split at each vowel, so the first region has A-D, the second region has E-H, the third region has I-N, the fourth region has O-V, and the fifth region has U-Z.\n\n**Using a Custom Algorithm**\\\nThe RegionSplitter tool is provided with HBase, and uses a *SplitAlgorithm* to determine split points for you. As parameters, you give it the algorithm, desired number of regions, and column families. It includes three split algorithms. The first is the [`HexStringSplit`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/util/RegionSplitter.HexStringSplit.html) algorithm, which assumes the row keys are hexadecimal strings. The second is the [`DecimalStringSplit`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/util/RegionSplitter.DecimalStringSplit.html) algorithm, which assumes the row keys are decimal strings in the range 00000000 to 99999999. The third, [`UniformSplit`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/util/RegionSplitter.UniformSplit.html), assumes the row keys are random byte arrays. You will probably need to develop your own [`SplitAlgorithm`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/util/RegionSplitter.SplitAlgorithm.html), using the provided ones as models.\n\n## Online Region Merges\n\nBoth Master and RegionServer participate in the event of online region merges. Client sends merge RPC to the master, then the master moves the regions together to the RegionServer where the more heavily loaded region resided. Finally the master sends the merge request to this RegionServer which then runs the merge. Similar to process of region splitting, region merges run as a local transaction on the RegionServer. It offlines the regions and then merges two regions on the file system, atomically delete merging regions from `hbase:meta` and adds the merged region to `hbase:meta`, opens the merged region on the RegionServer and reports the merge to the Master.\n\nAn example of region merges in the HBase shell\n\n```ruby\n$ hbase> merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME'\n$ hbase> merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME', true\n```\n\nIt's an asynchronous operation and call returns immediately without waiting merge completed. Passing `true` as the optional third parameter will force a merge. Normally only adjacent regions can be merged. The `force` parameter overrides this behaviour and is for expert use only.\n\n## Store\n\nA Store hosts a MemStore and 0 or more StoreFiles (HFiles). A Store corresponds to a column family for a table for a given region.\n\n### MemStore\n\nThe MemStore holds in-memory modifications to the Store. Modifications are Cells/KeyValues. When a flush is requested, the current MemStore is moved to a snapshot and is cleared. HBase continues to serve edits from the new MemStore and backing snapshot until the flusher reports that the flush succeeded. At this point, the snapshot is discarded. Note that when the flush happens, MemStores that belong to the same region will all be flushed.\n\n### MemStore Flush\n\nA MemStore flush can be triggered under any of the conditions listed below. The minimum flush unit is per region, not at individual MemStore level.\n\n1. When a MemStore reaches the size specified by `hbase.hregion.memstore.flush.size`, all MemStores that belong to its region will be flushed out to disk.\n2. When the overall MemStore usage reaches the value specified by `hbase.regionserver.global.memstore.upperLimit`, MemStores from various regions will be flushed out to disk to reduce overall MemStore usage in a RegionServer.\\\n   The flush order is based on the descending order of a region's MemStore usage. Regions will have their MemStores flushed until the overall MemStore usage drops to or slightly below `hbase.regionserver.global.memstore.lowerLimit`.\n3. When the number of WAL log entries in a given region server's WAL reaches the value specified in `hbase.regionserver.max.logs`, MemStores from various regions will be flushed out to disk to reduce the number of logs in the WAL.\\\n   The flush order is based on time. Regions with the oldest MemStores are flushed first until WAL count drops below `hbase.regionserver.max.logs`.\n\n### Scans\n\n* When a client issues a scan against a table, HBase generates `RegionScanner` objects, one per region, to serve the scan request.\n* The `RegionScanner` object contains a list of `StoreScanner` objects, one per column family.\n* Each `StoreScanner` object further contains a list of `StoreFileScanner` objects, corresponding to each StoreFile and HFile of the corresponding column family, and a list of `KeyValueScanner` objects for the MemStore.\n* The two lists are merged into one, which is sorted in ascending order with the scan object for the MemStore at the end of the list.\n* When a `StoreFileScanner` object is constructed, it is associated with a `MultiVersionConcurrencyControl` read point, which is the current `memstoreTS`, filtering out any new updates beyond the read point.\n\n### StoreFile (HFile)\n\nStoreFiles are where your data lives.\n\n#### HFile Format\n\nThe *HFile* file format is based on the SSTable file described in the [BigTable \\[2006](http://research.google.com/archive/bigtable.html)] paper and on Hadoop's [TFile](https://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/file/tfile/TFile.html) (The unit test suite and the compression harness were taken directly from TFile). Schubert Zhang's blog post on [HFile: A Block-Indexed File Format to Store Sorted Key-Value Pairs](http://cloudepr.blogspot.com/2009/09/hfile-block-indexed-file-format-to.html) makes for a thorough introduction to HBase's HFile. Matteo Bertozzi has also put up a helpful description, [HBase I/O: HFile](http://th30z.blogspot.com/2011/02/hbase-io-hfile.html?spref=tw).\n\nFor more information, see the HFile source code. Also see [HBase file format with inline blocks (version 2)](/docs/hfile-format#hbase-file-format-with-inline-blocks-version-2) for information about the HFile v2 format that was included in 0.92.\n\n#### HFile Tool\n\nTo view a textualized version of HFile content, you can use the `hbase hfile` tool. Type the following to see usage:\n\n```bash\n$ ${HBASE_HOME}/bin/hbase hfile\n```\n\nFor example, to view the content of the file *hdfs\\://10.81.47.41:9000/hbase/default/TEST/1418428042/DSMP/4759508618286845475*, type the following:\n\n```bash\n$ ${HBASE_HOME}/bin/hbase hfile -v -f hdfs://10.81.47.41:9000/hbase/default/TEST/1418428042/DSMP/4759508618286845475\n```\n\nIf you leave off the option -v to see just a summary on the HFile. See usage for other things to do with the `hfile` tool.\n\n<Callout type=\"info\">\n  In the output of this tool, you might see 'seqid=0' for certain keys in places such as\n  'Mid-key'/'firstKey'/'lastKey'. These are 'KeyOnlyKeyValue' type instances - meaning their seqid\n  is irrelevant & we just need the keys of these Key-Value instances.\n</Callout>\n\n#### StoreFile Directory Structure on HDFS\n\nFor more information of what StoreFiles look like on HDFS with respect to the directory structure, see [Browsing HDFS for HBase Objects](/docs/troubleshooting#browsing-hdfs-for-hbase-objects).\n\n### Blocks\n\nStoreFiles are composed of blocks. The blocksize is configured on a per-ColumnFamily basis.\n\nCompression happens at the block level within StoreFiles. For more information on compression, see [Compression and Data Block Encoding In HBase](/docs/compression).\n\nFor more information on blocks, see the HFileBlock source code.\n\n### KeyValue\n\nThe KeyValue class is the heart of data storage in HBase. KeyValue wraps a byte array and takes offsets and lengths into the passed array which specify where to start interpreting the content as KeyValue.\n\nThe KeyValue format inside a byte array is:\n\n* keylength\n* valuelength\n* key\n* value\n\nThe Key is further decomposed as:\n\n* rowlength\n* row (i.e., the rowkey)\n* columnfamilylength\n* columnfamily\n* columnqualifier\n* timestamp\n* keytype (e.g., Put, Delete, DeleteColumn, DeleteFamily)\n\nKeyValue instances are *not* split across blocks. For example, if there is an 8 MB KeyValue, even if the block-size is 64kb this KeyValue will be read in as a coherent block. For more information, see the KeyValue source code.\n\n#### Example\n\nTo emphasize the points above, examine what happens with two Puts for two different columns for the same row:\n\n* Put #1: `rowkey=row1, cf:attr1=value1`\n* Put #2: `rowkey=row1, cf:attr2=value2`\n\nEven though these are for the same row, a KeyValue is created for each column:\n\nKey portion for Put #1:\n\n* `rowlength -----------→ 4`\n* `row -----------------→ row1`\n* `columnfamilylength --→ 2`\n* `columnfamily --------→ cf`\n* `columnqualifier -----→ attr1`\n* `timestamp -----------→ server time of Put`\n* `keytype -------------→ Put`\n\nKey portion for Put #2:\n\n* `rowlength -----------→ 4`\n* `row -----------------→ row1`\n* `columnfamilylength --→ 2`\n* `columnfamily --------→ cf`\n* `columnqualifier -----→ attr2`\n* `timestamp -----------→ server time of Put`\n* `keytype -------------→ Put`\n\nIt is critical to understand that the rowkey, ColumnFamily, and column (aka columnqualifier) are embedded within the KeyValue instance. The longer these identifiers are, the bigger the KeyValue is.\n\n### Compaction\n\n**Ambiguous Terminology:**\n\n* A *StoreFile* is a facade of HFile. In terms of compaction, use of StoreFile seems to have prevailed in the past.\n* A *Store* is the same thing as a ColumnFamily. StoreFiles are related to a Store, or ColumnFamily.\n* If you want to read more about StoreFiles versus HFiles and Stores versus ColumnFamilies, see [HBASE-11316](https://issues.apache.org/jira/browse/HBASE-11316).\n\nWhen the MemStore reaches a given size (`hbase.hregion.memstore.flush.size`), it flushes its contents to a StoreFile. The number of StoreFiles in a Store increases over time. *Compaction* is an operation which reduces the number of StoreFiles in a Store, by merging them together, in order to increase performance on read operations. Compactions can be resource-intensive to perform, and can either help or hinder performance depending on many factors.\n\nCompactions fall into two categories: minor and major. Minor and major compactions differ in the following ways.\n\n*Minor compactions* usually select a small number of small, adjacent StoreFiles and rewrite them as a single StoreFile. Minor compactions do not drop (filter out) deletes or expired versions, because of potential side effects. See [Compaction and Deletions](/docs/architecture/regions#compaction-and-deletions) and [Compaction and Versions](/docs/architecture/regions#compaction-and-versions) for information on how deletes and versions are handled in relation to compactions. The end result of a minor compaction is fewer, larger StoreFiles for a given Store.\n\nThe end result of a *major compaction* is a single StoreFile per Store. Major compactions also process delete markers and max versions. See [Compaction and Deletions](/docs/architecture/regions#compaction-and-deletions) and [Compaction and Versions](/docs/architecture/regions#compaction-and-versions) for information on how deletes and versions are handled in relation to compactions.\n\n#### Compaction and Deletions\n\nWhen an explicit deletion occurs in HBase, the data is not actually deleted. Instead, a *tombstone* marker is written. The tombstone marker prevents the data from being returned with queries. During a major compaction, the data is actually deleted, and the tombstone marker is removed from the StoreFile. If the deletion happens because of an expired TTL, no tombstone is created. Instead, the expired data is filtered out and is not written back to the compacted StoreFile.\n\n#### Compaction and Versions\n\nWhen you create a Column Family, you can specify the maximum number of versions to keep, by specifying `ColumnFamilyDescriptorBuilder.setMaxVersions(int versions)`. The default value is `1`. If more versions than the specified maximum exist, the excess versions are filtered out and not written back to the compacted StoreFile.\n\n<Callout type=\"info\">\n  In some situations, older versions can be inadvertently resurrected if a newer version is\n  explicitly deleted. See [Major compactions change query\n  results](/docs/datamodel#major-compactions-change-query-results) for a more in-depth explanation.\n  This situation is only possible before the compaction finishes.\n</Callout>\n\nIn theory, major compactions improve performance. However, on a highly loaded system, major compactions can require an inappropriate number of resources and adversely affect performance. In a default configuration, major compactions are scheduled automatically to run once in a 7-day period. This is sometimes inappropriate for systems in production. You can manage major compactions manually. See [Managed Compactions](/docs/configuration/important#managed-compactions).\n\nCompactions do not perform region merges. See [Merge](/docs/operational-management/region-and-capacity#merge) for more information on region merging.\n\n#### Compaction Switch\n\nWe can switch on and off the compactions at region servers. Switching off compactions will also interrupt any currently ongoing compactions. It can be done dynamically using the \"compaction\\_switch\" command from hbase shell. If done from the command line, this setting will be lost on restart of the server. To persist the changes across region servers modify the configuration hbase.regionserver .compaction.enabled in hbase-site.xml and restart HBase.\n\n#### Compaction Policy - HBase 0.96.x and newer\n\nCompacting large StoreFiles, or too many StoreFiles at once, can cause more IO load than your cluster is able to handle without causing performance problems. The method by which HBase selects which StoreFiles to include in a compaction (and whether the compaction is a minor or major compaction) is called the *compaction policy*.\n\nPrior to HBase 0.96.x, there was only one compaction policy. That original compaction policy is still available as `RatioBasedCompactionPolicy`. The new compaction default policy, called `ExploringCompactionPolicy`, was subsequently backported to HBase 0.94 and HBase 0.95, and is the default in HBase 0.96 and newer. It was implemented in [HBASE-7842](https://issues.apache.org/jira/browse/HBASE-7842). In short, `ExploringCompactionPolicy` attempts to select the best possible set of StoreFiles to compact with the least amount of work, while the `RatioBasedCompactionPolicy` selects the first set that meets the criteria.\n\nRegardless of the compaction policy used, file selection is controlled by several configurable parameters and happens in a multi-step approach. These parameters will be explained in context, and then will be given in a table which shows their descriptions, defaults, and implications of changing them.\n\n#### Being Stuck\n\nWhen the MemStore gets too large, it needs to flush its contents to a StoreFile. However, Stores are configured with a bound on the number StoreFiles, `hbase.hstore.blockingStoreFiles`, and if in excess, the MemStore flush must wait until the StoreFile count is reduced by one or more compactions. If the MemStore is too large and the number of StoreFiles is also too high, the algorithm is said to be \"stuck\". By default we'll wait on compactions up to `hbase.hstore.blockingWaitTime` milliseconds. If this period expires, we'll flush anyways even though we are in excess of the `hbase.hstore.blockingStoreFiles` count.\n\nUpping the `hbase.hstore.blockingStoreFiles` count will allow flushes to happen but a Store with many StoreFiles in will likely have higher read latencies. Try to figure why Compactions are not keeping up. Is it a write spurt that is bringing about this situation or is a regular occurance and the cluster is under-provisioned for the volume of writes?\n\n#### The ExploringCompactionPolicy Algorithm\n\nThe ExploringCompactionPolicy algorithm considers each possible set of adjacent StoreFiles before choosing the set where compaction will have the most benefit.\n\nOne situation where the ExploringCompactionPolicy works especially well is when you are bulk-loading data and the bulk loads create larger StoreFiles than the StoreFiles which are holding data older than the bulk-loaded data. This can \"trick\" HBase into choosing to perform a major compaction each time a compaction is needed, and cause a lot of extra overhead. With the ExploringCompactionPolicy, major compactions happen much less frequently because minor compactions are more efficient.\n\nIn general, ExploringCompactionPolicy is the right choice for most situations, and thus is the default compaction policy. You can also use ExploringCompactionPolicy along with [Experimental: Stripe Compactions](/docs/architecture/regions#experimental-stripe-compactions).\n\nThe logic of this policy can be examined in hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/ExploringCompactionPolicy.java. The following is a walk-through of the logic of the ExploringCompactionPolicy.\n\n1. Make a list of all existing StoreFiles in the Store. The rest of the algorithm filters this list to come up with the subset of HFiles which will be chosen for compaction.\n\n2. If this was a user-requested compaction, attempt to perform the requested compaction type, regardless of what would normally be chosen. Note that even if the user requests a major compaction, it may not be possible to perform a major compaction. This may be because not all StoreFiles in the Column Family are available to compact or because there are too many Stores in the Column Family.\n\n3. Some StoreFiles are automatically excluded from consideration. These include:\n   * StoreFiles that are larger than `hbase.hstore.compaction.max.size`\n   * StoreFiles that were created by a bulk-load operation which explicitly excluded compaction. You may decide to exclude StoreFiles resulting from bulk loads, from compaction. To do this, specify the `hbase.mapreduce.hfileoutputformat.compaction.exclude` parameter during the bulk load operation.\n\n4. Iterate through the list from step 1, and make a list of all potential sets of StoreFiles to compact together. A potential set is a grouping of `hbase.hstore.compaction.min` contiguous StoreFiles in the list. For each set, perform some sanity-checking and figure out whether this is the best compaction that could be done:\n   * If the number of StoreFiles in this set (not the size of the StoreFiles) is fewer than `hbase.hstore.compaction.min` or more than `hbase.hstore.compaction.max`, take it out of consideration.\n   * Compare the size of this set of StoreFiles with the size of the smallest possible compaction that has been found in the list so far. If the size of this set of StoreFiles represents the smallest compaction that could be done, store it to be used as a fall-back if the algorithm is \"stuck\" and no StoreFiles would otherwise be chosen. See [Being Stuck](/docs/architecture/regions#being-stuck).\n   * Do size-based sanity checks against each StoreFile in this set of StoreFiles.\n\n     * If the size of this StoreFile is larger than `hbase.hstore.compaction.max.size`, take it out of consideration.\n     * If the size is greater than or equal to `hbase.hstore.compaction.min.size`, sanity-check it against the file-based ratio to see whether it is too large to be considered.\n\n     The sanity-checking is successful if:\n\n     * There is only one StoreFile in this set, or\n     * For each StoreFile, its size multiplied by `hbase.hstore.compaction.ratio` (or `hbase.hstore.compaction.ratio.offpeak` if off-peak hours are configured and it is during off-peak hours) is less than the sum of the sizes of the other HFiles in the set.\n\n5. If this set of StoreFiles is still in consideration, compare it to the previously-selected best compaction. If it is better, replace the previously-selected best compaction with this one.\n\n6. When the entire list of potential compactions has been processed, perform the best compaction that was found. If no StoreFiles were selected for compaction, but there are multiple StoreFiles, assume the algorithm is stuck (see [Being Stuck](/docs/architecture/regions#being-stuck)) and if so, perform the smallest compaction that was found in step 3.\n\n#### RatioBasedCompactionPolicy Algorithm\n\nThe RatioBasedCompactionPolicy was the only compaction policy prior to HBase 0.96, though ExploringCompactionPolicy has now been backported to HBase 0.94 and 0.95. To use the RatioBasedCompactionPolicy rather than the ExploringCompactionPolicy, set `hbase.hstore.defaultengine.compactionpolicy.class` to `RatioBasedCompactionPolicy` in the *hbase-site.xml* file. To switch back to the ExploringCompactionPolicy, remove the setting from the *hbase-site.xml*.\n\nThe following section walks you through the algorithm used to select StoreFiles for compaction in the RatioBasedCompactionPolicy.\n\n1. The first phase is to create a list of all candidates for compaction. A list is created of all StoreFiles not already in the compaction queue, and all StoreFiles newer than the newest file that is currently being compacted. This list of StoreFiles is ordered by the sequence ID. The sequence ID is generated when a Put is appended to the write-ahead log (WAL), and is stored in the metadata of the HFile.\n2. Check to see if the algorithm is stuck (see [Being Stuck](/docs/architecture/regions#being-stuck), and if so, a major compaction is forced. This is a key area where [The ExploringCompactionPolicy Algorithm](/docs/architecture/regions#the-exploringcompactionpolicy-algorithm) is often a better choice than the RatioBasedCompactionPolicy.\n3. If the compaction was user-requested, try to perform the type of compaction that was requested. Note that a major compaction may not be possible if all HFiles are not available for compaction or if too many StoreFiles exist (more than `hbase.hstore.compaction.max`).\n4. Some StoreFiles are automatically excluded from consideration. These include:\n   * StoreFiles that are larger than `hbase.hstore.compaction.max.size`\n   * StoreFiles that were created by a bulk-load operation which explicitly excluded compaction. You may decide to exclude StoreFiles resulting from bulk loads, from compaction. To do this, specify the `hbase.mapreduce.hfileoutputformat.compaction.exclude` parameter during the bulk load operation.\n5. The maximum number of StoreFiles allowed in a major compaction is controlled by the `hbase.hstore.compaction.max` parameter. If the list contains more than this number of StoreFiles, a minor compaction is performed even if a major compaction would otherwise have been done. However, a user-requested major compaction still occurs even if there are more than `hbase.hstore.compaction.max` StoreFiles to compact.\n6. If the list contains fewer than `hbase.hstore.compaction.min` StoreFiles to compact, a minor compaction is aborted. Note that a major compaction can be performed on a single HFile. Its function is to remove deletes and expired versions, and reset locality on the StoreFile.\n7. The value of the `hbase.hstore.compaction.ratio` parameter is multiplied by the sum of StoreFiles smaller than a given file, to determine whether that StoreFile is selected for compaction during a minor compaction. For instance, if hbase.hstore.compaction.ratio is 1.2, FileX is 5MB, FileY is 2MB, and FileZ is 3MB:\n   ```\n   5 <= 1.2 x (2 + 3)            or            5 <= 6\n   ```\n   In this scenario, FileX is eligible for minor compaction. If FileX were 7MB, it would not be eligible for minor compaction. This ratio favors smaller StoreFile. You can configure a different ratio for use in off-peak hours, using the parameter `hbase.hstore.compaction.ratio.offpeak`, if you also configure `hbase.offpeak.start.hour` and `hbase.offpeak.end.hour`.\n8. If the last major compaction was too long ago and there is more than one StoreFile to be compacted, a major compaction is run, even if it would otherwise have been minor. By default, the maximum time between major compactions is 7 days, plus or minus a 4.8 hour period, and determined randomly within those parameters. Prior to HBase 0.96, the major compaction period was 24 hours. See `hbase.hregion.majorcompaction` in the table below to tune or disable time-based major compactions.\n\n#### Parameters Used by Compaction Algorithm\n\nThis table contains the main configuration parameters for compaction. This list is not exhaustive. To tune these parameters from the defaults, edit the *hbase-default.xml* file. For a full list of all configuration parameters available, see [config.files](/docs/configuration/default#configuration-default-hbase-default-configuration)\n\n* `hbase.hstore.compaction.min`\\\n  The minimum number of StoreFiles which must be eligible for compaction before compaction can run. The goal of tuning `hbase.hstore.compaction.min` is to avoid ending up with too many tiny StoreFiles to compact. Setting this value to 2 would cause a minor compaction each time you have two StoreFiles in a Store, and this is probably not appropriate. If you set this value too high, all the other values will need to be adjusted accordingly. For most cases, the default value is appropriate. In previous versions of HBase, the parameter `hbase.hstore.compaction.min` was called `hbase.hstore.compactionThreshold`.\\\n  **Default**: 3\n\n* `hbase.hstore.compaction.max`\n  The maximum number of StoreFiles which will be selected for a single minor compaction, regardless of the number of eligible StoreFiles. Effectively, the value of `hbase.hstore.compaction.max` controls the length of time it takes a single compaction to complete. Setting it larger means that more StoreFiles are included in a compaction. For most cases, the default value is appropriate.\\\n  **Default**: 10\n\n* `hbase.hstore.compaction.min.size`\\\n  A StoreFile smaller than this size will always be eligible for minor compaction. StoreFiles this size or larger are evaluated by `hbase.hstore.compaction.ratio` to determine if they are eligible. Because this limit represents the \"automatic include\" limit for all StoreFiles smaller than this value, this value may need to be reduced in write-heavy environments where many files in the 1-2 MB range are being flushed, because every StoreFile will be targeted for compaction and the resulting StoreFiles may still be under the minimum size and require further compaction. If this parameter is lowered, the ratio check is triggered more quickly. This addressed some issues seen in earlier versions of HBase but changing this parameter is no longer necessary in most situations.\\\n  **Default**:128 MB\n\n* `hbase.hstore.compaction.max.size`\\\n  A StoreFile larger than this size will be excluded from compaction. The effect of raising `hbase.hstore.compaction.max.size` is fewer, larger StoreFiles that do not get compacted often. If you feel that compaction is happening too often without much benefit, you can try raising this value.\\\n  **Default**: `Long.MAX_VALUE`\n\n* `hbase.hstore.compaction.ratio`\\\n  For minor compaction, this ratio is used to determine whether a given StoreFile which is larger than `hbase.hstore.compaction.min.size` is eligible for compaction. Its effect is to limit compaction of large StoreFile. The value of `hbase.hstore.compaction.ratio` is expressed as a floating-point decimal.\n  * A large ratio, such as 10, will produce a single giant StoreFile. Conversely, a value of .25, will produce behavior similar to the BigTable compaction algorithm, producing four StoreFiles.\n  * A moderate value of between 1.0 and 1.4 is recommended. When tuning this value, you are balancing write costs with read costs. Raising the value (to something like 1.4) will have more write costs, because you will compact larger StoreFiles. However, during reads, HBase will need to seek through fewer StoreFiles to accomplish the read. Consider this approach if you cannot take advantage of [Bloom Filters](/docs/performance#bloom-filters).\n  * Alternatively, you can lower this value to something like 1.0 to reduce the background cost of writes, and use to limit the number of StoreFiles touched during reads. For most cases, the default value is appropriate.\\\n    **Default**: `1.2F`\n\n* `hbase.hstore.compaction.ratio.offpeak`\\\n  The compaction ratio used during off-peak compactions, if off-peak hours are also configured (see below). Expressed as a floating-point decimal. This allows for more aggressive (or less aggressive, if you set it lower than `hbase.hstore.compaction.ratio`) compaction during a set time period. Ignored if off-peak is disabled (default). This works the same as `hbase.hstore.compaction.ratio`.\\\n  **Default**: `5.0F`\n\n* `hbase.offpeak.start.hour`\\\n  The start of off-peak hours, expressed as an integer between 0 and 23, inclusive. Set to -1 to disable off-peak.\\\n  **Default**: `-1` (disabled)\n\n* `hbase.offpeak.end.hour`\\\n  The end of off-peak hours, expressed as an integer between 0 and 23, inclusive. Set to -1 to disable off-peak.\\\n  **Default**: `-1` (disabled)\n\n* `hbase.regionserver.thread.compaction.throttle`\\\n  There are two different thread pools for compactions, one for large compactions and the other for small compactions. This helps to keep compaction of lean tables (such as `hbase:meta`) fast. If a compaction is larger than this threshold, it goes into the large compaction pool. In most cases, the default value is appropriate.\\\n  **Default**: `2 x hbase.hstore.compaction.max x hbase.hregion.memstore.flush.size` (which defaults to `128`)\n\n* `hbase.hregion.majorcompaction`\\\n  Time between major compactions, expressed in milliseconds. Set to 0 to disable time-based automatic major compactions. User-requested and size-based major compactions will still run. This value is multiplied by `hbase.hregion.majorcompaction.jitter` to cause compaction to start at a somewhat-random time during a given window of time.\\\n  **Default**: 7 days (`604800000` milliseconds)\n\n* `hbase.hregion.majorcompaction.jitter`\\\n  A multiplier applied to hbase.hregion.majorcompaction to cause compaction to occur a given amount of time either side of `hbase.hregion.majorcompaction`. The smaller the number, the closer the compactions will happen to the `hbase.hregion.majorcompaction` interval. Expressed as a floating-point decimal.\\\n  **Default**: `.50F`\n\n#### Compaction File Selection\n\n<Callout type=\"info\" title=\"Legacy Information\">\n  This section has been preserved for historical reasons and refers to the way compaction worked\n  prior to HBase 0.96.x. You can still use this behavior if you enable [RatioBasedCompactionPolicy\n  Algorithm](/docs/architecture/regions#ratiobasedcompactionpolicy-algorithm). For information on\n  the way that compactions work in HBase 0.96.x and later, see\n  [Compaction](/docs/architecture/regions#compaction).\n</Callout>\n\nTo understand the core algorithm for StoreFile selection, there is some ASCII-art in the Store source code that will serve as useful reference.\n\nIt has been copied below:\n\n```java\n/* normal skew:\n *\n *         older ----> newer\n *     _\n *    | |   _\n *    | |  | |   _\n *  --|-|- |-|- |-|---_-------_-------  minCompactSize\n *    | |  | |  | |  | |  _  | |\n *    | |  | |  | |  | | | | | |\n *    | |  | |  | |  | | | | | |\n */\n```\n\n**Important knobs:**\n\n* `hbase.hstore.compaction.ratio` Ratio used in compaction file selection algorithm (default 1.2f).\n* `hbase.hstore.compaction.min` (in HBase v 0.90 this is called `hbase.hstore.compactionThreshold`) (files) Minimum number of StoreFiles per Store to be selected for a compaction to occur (default 2).\n* `hbase.hstore.compaction.max` (files) Maximum number of StoreFiles to compact per minor compaction (default 10).\n* `hbase.hstore.compaction.min.size` (bytes) Any StoreFile smaller than this setting with automatically be a candidate for compaction. Defaults to `hbase.hregion.memstore.flush.size` (128 mb).\n* `hbase.hstore.compaction.max.size` (.92) (bytes) Any StoreFile larger than this setting with automatically be excluded from compaction (default Long.MAX\\_VALUE).\n\nThe minor compaction StoreFile selection logic is size based, and selects a file for compaction when the `file ⇐ sum(smaller_files) * hbase.hstore.compaction.ratio`.\n\n#### Minor Compaction File Selection - Example #1 (Basic Example)\n\nThis example mirrors an example from the unit test `TestCompactSelection`.\n\n* `hbase.hstore.compaction.ratio` = 1.0f\n* `hbase.hstore.compaction.min` = 3 (files)\n* `hbase.hstore.compaction.max` = 5 (files)\n* `hbase.hstore.compaction.min.size` = 10 (bytes)\n* `hbase.hstore.compaction.max.size` = 1000 (bytes)\n\nThe following StoreFiles exist: 100, 50, 23, 12, and 12 bytes apiece (oldest to newest). With the above parameters, the files that would be selected for minor compaction are 23, 12, and 12.\n\nWhy?\n\n* 100 → No, because sum(50, 23, 12, 12) \\* 1.0 = 97.\n* 50 → No, because sum(23, 12, 12) \\* 1.0 = 47.\n* 23 → Yes, because sum(12, 12) \\* 1.0 = 24.\n* 12 → Yes, because the previous file has been included, and because this does not exceed the max-file limit of 5\n* 12 → Yes, because the previous file had been included, and because this does not exceed the max-file limit of 5.\n\n#### Minor Compaction File Selection - Example #2 (Not Enough Files ToCompact)\n\nThis example mirrors an example from the unit test `TestCompactSelection`.\n\n* `hbase.hstore.compaction.ratio` = 1.0f\n* `hbase.hstore.compaction.min` = 3 (files)\n* `hbase.hstore.compaction.max` = 5 (files)\n* `hbase.hstore.compaction.min.size` = 10 (bytes)\n* `hbase.hstore.compaction.max.size` = 1000 (bytes)\n\nThe following StoreFiles exist: 100, 25, 12, and 12 bytes apiece (oldest to newest). With the above parameters, no compaction will be started.\n\nWhy?\n\n* 100 → No, because sum(25, 12, 12) \\* 1.0 = 47\n* 25 → No, because sum(12, 12) \\* 1.0 = 24\n* 12 → No. Candidate because sum(12) \\* 1.0 = 12, there are only 2 files to compact and that is less than the threshold of 3\n* 12 → No. Candidate because the previous StoreFile was, but there are not enough files to compact\n\n#### Minor Compaction File Selection - Example #3 (Limiting Files To Compact)\n\nThis example mirrors an example from the unit test `TestCompactSelection`.\n\n* `hbase.hstore.compaction.ratio` = 1.0f\n* `hbase.hstore.compaction.min` = 3 (files)\n* `hbase.hstore.compaction.max` = 5 (files)\n* `hbase.hstore.compaction.min.size` = 10 (bytes)\n* `hbase.hstore.compaction.max.size` = 1000 (bytes)\n\nThe following StoreFiles exist: 7, 6, 5, 4, 3, 2, and 1 bytes apiece (oldest to newest). With the above parameters, the files that would be selected for minor compaction are 7, 6, 5, 4, 3.\n\nWhy?\n\n* 7 → Yes, because sum(6, 5, 4, 3, 2, 1) \\* 1.0 = 21. Also, 7 is less than the min-size\n* 6 → Yes, because sum(5, 4, 3, 2, 1) \\* 1.0 = 15. Also, 6 is less than the min-size.\n* 5 → Yes, because sum(4, 3, 2, 1) \\* 1.0 = 10. Also, 5 is less than the min-size.\n* 4 → Yes, because sum(3, 2, 1) \\* 1.0 = 6. Also, 4 is less than the min-size.\n* 3 → Yes, because sum(2, 1) \\* 1.0 = 3. Also, 3 is less than the min-size.\n* 2 → No. Candidate because previous file was selected and 2 is less than the min-size, but the max-number of files to compact has been reached.\n* 1 → No. Candidate because previous file was selected and 1 is less than the min-size, but max-number of files to compact has been reached.\n\n<Callout type=\"info\" title=\"Impact of Key Configuration Options\">\n  This information is now included in the configuration parameter table in [Parameters Used by\n  Compaction Algorithm](/docs/architecture/regions#parameters-used-by-compaction-algorithm).\n</Callout>\n\n#### Date Tiered Compaction\n\nDate tiered compaction is a date-aware store file compaction strategy that is beneficial for time-range scans for time-series data.\n\n#### When To Use Date Tiered Compactions\n\nConsider using Date Tiered Compaction for reads for limited time ranges, especially scans of recent data\n\nDon't use it for\n\n* random gets without a limited time range\n* frequent deletes and updates\n* Frequent out of order data writes creating long tails, especially writes with future timestamps\n* frequent bulk loads with heavily overlapping time ranges\n\n**Performance Improvements**\\\nPerformance testing has shown that the performance of time-range scans improve greatly for limited time ranges, especially scans of recent data.\n\n#### Enabling Date Tiered Compaction\n\nYou can enable Date Tiered compaction for a table or a column family, by setting its `hbase.hstore.engine.class` to `org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine`.\n\nYou also need to set `hbase.hstore.blockingStoreFiles` to a high number, such as 60, if using all default settings, rather than the default value of 12). Use 1.5\\~2 x projected file count if changing the parameters, Projected file count = windows per tier x tier count + incoming window min + files older than max age\n\nYou also need to set `hbase.hstore.compaction.max` to the same value as `hbase.hstore.blockingStoreFiles` to unblock major compaction.\n\n**Procedure: Enable Date Tiered Compaction**\n\n<Steps>\n  <Step>\n    Run one of following commands in the HBase shell. Replace the table name `orders_table` with the name of your table.\n\n    ```ruby\n    alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine', 'hbase.hstore.blockingStoreFiles' => '60', 'hbase.hstore.compaction.min'=>'2', 'hbase.hstore.compaction.max'=>'60'}\n    alter 'orders_table', {NAME => 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine', 'hbase.hstore.blockingStoreFiles' => '60', 'hbase.hstore.compaction.min'=>'2', 'hbase.hstore.compaction.max'=>'60'}}\n    create 'orders_table', 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine', 'hbase.hstore.blockingStoreFiles' => '60', 'hbase.hstore.compaction.min'=>'2', 'hbase.hstore.compaction.max'=>'60'}\n    ```\n  </Step>\n\n  <Step>\n    Configure other options if needed. See [Configuring Date Tiered Compaction](/docs/architecture/regions#configuring-date-tiered-compaction) for more information.\n  </Step>\n</Steps>\n\n**Procedure: Disable Date Tiered Compaction**\n\n<Steps>\n  <Step>\n    Set the `hbase.hstore.engine.class` option to either nil or `org.apache.hadoop.hbase.regionserver.DefaultStoreEngine`. Either option has the same effect. Make sure you set the other options you changed to the original settings too.\n\n    ```ruby\n    alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DefaultStoreEngine', 'hbase.hstore.blockingStoreFiles' => '12', 'hbase.hstore.compaction.min'=>'6', 'hbase.hstore.compaction.max'=>'12'}\n    ```\n  </Step>\n</Steps>\n\nWhen you change the store engine either way, a major compaction will likely be performed on most regions. This is not necessary on new tables.\n\n#### Configuring Date Tiered Compaction\n\nEach of the settings for date tiered compaction should be configured at the table or column family level. If you use HBase shell, the general command pattern is as follows:\n\n```ruby\nalter 'orders_table', CONFIGURATION => {'key' => 'value', ..., 'key' => 'value'}}\n```\n\n**Data Tier Parameters**\\\nYou can configure your date tiers by changing the settings for the following parameters:\n\n| Setting                                                        | Notes                                                                                                                                                                         |\n| -------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `hbase.hstore.compaction.date.tiered.max.storefile.age.millis` | Files with max-timestamp smaller than this will no longer be compacted.Default at Long.MAX\\_VALUE.                                                                            |\n| `hbase.hstore.compaction.date.tiered.base.window.millis`       | Base window size in milliseconds. Default at 6 hours.                                                                                                                         |\n| `hbase.hstore.compaction.date.tiered.windows.per.tier`         | Number of windows per tier. Default at 4.                                                                                                                                     |\n| `hbase.hstore.compaction.date.tiered.incoming.window.min`      | Minimal number of files to compact in the incoming window. Set it to expected number of files in the window to avoid wasteful compaction. Default at 6.                       |\n| `hbase.hstore.compaction.date.tiered.window.policy.class`      | The policy to select store files within the same time window. It doesn't apply to the incoming window. Default at exploring compaction. This is to avoid wasteful compaction. |\n\n**Compaction Throttler**\\\nWith tiered compaction all servers in the cluster will promote windows to higher tier at the same time, so using a compaction throttle is recommended: Set `hbase.regionserver.throughput.controller` to `org.apache.hadoop.hbase.regionserver.compactions.PressureAwareCompactionThroughputController`.\n\n<Callout type=\"info\">\n  For more information about date tiered compaction, please refer to the design specification at\n  [https://docs.google.com/document/d/1\\_AmlNb2N8Us1xICsTeGDLKIqL6T-oHoRLZ323MG\\_uy8](https://docs.google.com/document/d/1_AmlNb2N8Us1xICsTeGDLKIqL6T-oHoRLZ323MG_uy8)\n</Callout>\n\n#### Experimental: Stripe Compactions\n\nStripe compactions is an experimental feature added in HBase 0.98 which aims to improve compactions for large regions or non-uniformly distributed row keys. In order to achieve smaller and/or more granular compactions, the StoreFiles within a region are maintained separately for several row-key sub-ranges, or \"stripes\", of the region. The stripes are transparent to the rest of HBase, so other operations on the HFiles or data work without modification.\n\nStripe compactions change the HFile layout, creating sub-regions within regions. These sub-regions are easier to compact, and should result in fewer major compactions. This approach alleviates some of the challenges of larger regions.\n\nStripe compaction is fully compatible with [Compaction](/docs/architecture/regions#compaction) and works in conjunction with either the ExploringCompactionPolicy or RatioBasedCompactionPolicy. It can be enabled for existing tables, and the table will continue to operate normally if it is disabled later.\n\n#### When To Use Stripe Compactions\n\nConsider using stripe compaction if you have either of the following:\n\n* Large regions. You can get the positive effects of smaller regions without additional overhead for MemStore and region management overhead.\n* Non-uniform keys, such as time dimension in a key. Only the stripes receiving the new keys will need to compact. Old data will not compact as often, if at all\n\n**Performance Improvements**\\\nPerformance testing has shown that the performance of reads improves somewhat, and variability of performance of reads and writes is greatly reduced. An overall long-term performance improvement is seen on large non-uniform-row key regions, such as a hash-prefixed timestamp key. These performance gains are the most dramatic on a table which is already large. It is possible that the performance improvement might extend to region splits.\n\n#### Enabling Stripe Compaction\n\nYou can enable stripe compaction for a table or a column family, by setting its `hbase.hstore.engine.class` to `org.apache.hadoop.hbase.regionserver.StripeStoreEngine`. You also need to set the `hbase.hstore.blockingStoreFiles` to a high number, such as 100 (rather than the default value of 10).\n\n**Procedure: Enable Stripe Compaction**\n\n<Steps>\n  <Step>\n    Run one of following commands in the HBase shell. Replace the table name `orders_table` with the name of your table.\n\n    ```ruby\n    alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}\n    alter 'orders_table', {NAME => 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}}\n    create 'orders_table', 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}\n    ```\n  </Step>\n\n  <Step>\n    Configure other options if needed. See [Configuring Stripe Compaction](/docs/architecture/regions#configuring-stripe-compaction) for more information.\n  </Step>\n\n  <Step>\n    Enable the table.\n  </Step>\n</Steps>\n\n**Procedure: Disable Stripe Compaction**\n\n<Steps>\n  <Step>\n    Set the `hbase.hstore.engine.class` option to either nil or `org.apache.hadoop.hbase.regionserver.DefaultStoreEngine`. Either option has the same effect.\n\n    ```ruby\n    alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DefaultStoreEngine'}\n    ```\n  </Step>\n\n  <Step>\n    Enable the table.\n  </Step>\n</Steps>\n\nWhen you enable a large table after changing the store engine either way, a major compaction will likely be performed on most regions. This is not necessary on new tables.\n\n#### Configuring Stripe Compaction\n\nEach of the settings for stripe compaction should be configured at the table or column family level. If you use HBase shell, the general command pattern is as follows:\n\n```ruby\nalter 'orders_table', CONFIGURATION => {'key' => 'value', ..., 'key' => 'value'}}\n```\n\n**Region and stripe sizing**\\\nYou can configure your stripe sizing based upon your region sizing. By default, your new regions will start with one stripe. On the next compaction after the stripe has grown too large (16 x MemStore flushes size), it is split into two stripes. Stripe splitting continues as the region grows, until the region is large enough to split.\n\nYou can improve this pattern for your own data. A good rule is to aim for a stripe size of at least 1 GB, and about 8-12 stripes for uniform row keys. For example, if your regions are 30 GB, 12 x 2.5 GB stripes might be a good starting point.\n\n**Stripe Sizing Settings**\n\n| Setting                                 | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `hbase.store.stripe.initialStripeCount` | The number of stripes to create when stripe compaction is enabled. You can use it as follows:<br />- For relatively uniform row keys, if you know the approximate target number of stripes from the above, you can avoid some splitting overhead by starting with several stripes (2, 5, 10...). If the early data is not representative of overall row key distribution, this will not be as efficient.<br />- For existing tables with a large amount of data, this setting will effectively pre-split your stripes.<br />- For keys such as hash-prefixed sequential keys, with more than one hash prefix per region, pre-splitting may make sense. |\n| `hbase.store.stripe.sizeToSplit`        | The maximum size a stripe grows before splitting. Use this in conjunction with `hbase.store.stripe.splitPartCount` to control the target stripe size (`sizeToSplit = splitPartsCount * target stripe size`), according to the above sizing considerations.                                                                                                                                                                                                                                                                                                                                                                                             |\n| `hbase.store.stripe.splitPartCount`     | The number of new stripes to create when splitting a stripe. The default is 2, which is appropriate for most cases. For non-uniform row keys, you can experiment with increasing the number to 3 or 4, to isolate the arriving updates into narrower slice of the region without additional splits being required.                                                                                                                                                                                                                                                                                                                                     |\n\n**MemStore Size Settings**\\\nBy default, the flush creates several files from one MemStore, according to existing stripe boundaries and row keys to flush. This approach minimizes write amplification, but can be undesirable if the MemStore is small and there are many stripes, because the files will be too small.\\\nIn this type of situation, you can set `hbase.store.stripe.compaction.flushToL0` to `true`. This will cause a MemStore flush to create a single file instead. When at least `hbase.store.stripe.compaction.minFilesL0` such files (by default, 4) accumulate, they will be compacted into striped files.\n\n**Normal Compaction Configuration and Stripe Compaction**\\\nAll the settings that apply to normal compactions (see [Parameters Used by Compaction Algorithm](/docs/architecture/regions#parameters-used-by-compaction-algorithm)) apply to stripe compactions. The exceptions are the minimum and maximum number of files, which are set to higher values by default because the files in stripes are smaller. To control these for stripe compactions, use `hbase.store.stripe.compaction.minFiles` and `hbase.store.stripe.compaction.maxFiles`, rather than `hbase.hstore.compaction.min` and `hbase.hstore.compaction.max`.\n\n#### FIFO Compaction\n\nFIFO compaction policy selects only files which have all cells expired. The column family **MUST** have non-default TTL. Essentially, FIFO compactor only collects expired store files.\n\nBecause we don't do any real compaction, we do not use CPU and IO (disk and network) and evict hot data from a block cache. As a result, both RW throughput and latency can be improved.\n\n#### When To Use FIFO Compaction\n\nConsider using FIFO Compaction when your use case is\n\n* Very high volume raw data which has low TTL and which is the source of another data (after additional processing).\n* Data which can be kept entirely in a a block cache (RAM/SSD). No need for compaction of a raw data at all.\n\nDo not use FIFO compaction when\n\n* Table/ColumnFamily has MIN\\_VERSION > 0\n* Table/ColumnFamily has TTL = FOREVER (HColumnDescriptor.DEFAULT\\_TTL)\n\n#### Enabling FIFO Compaction\n\nFor Table:\n\n```java\nHTableDescriptor desc = new HTableDescriptor(tableName);\ndesc.setConfiguration(DefaultStoreEngine.DEFAULT_COMPACTION_POLICY_CLASS_KEY,\n  FIFOCompactionPolicy.class.getName());\n```\n\nFor Column Family:\n\n```java\nHColumnDescriptor desc = new HColumnDescriptor(family);\ndesc.setConfiguration(DefaultStoreEngine.DEFAULT_COMPACTION_POLICY_CLASS_KEY,\n  FIFOCompactionPolicy.class.getName());\n```\n\nFrom HBase Shell:\n\n```bash\ncreate 'x',{NAME=>'y', TTL=>'30'}, {CONFIGURATION => {'hbase.hstore.defaultengine.compactionpolicy.class' => 'org.apache.hadoop.hbase.regionserver.compactions.FIFOCompactionPolicy', 'hbase.hstore.blockingStoreFiles' => 1000}}\n```\n\nAlthough region splitting is still supported, for optimal performance it should be disabled, either by setting explicitly `DisabledRegionSplitPolicy` or by setting `ConstantSizeRegionSplitPolicy` and very large max region size. You will have to increase to a very large number store's blocking file (`hbase.hstore.blockingStoreFiles`) as well. There is a sanity check on table/column family configuration in case of FIFO compaction and minimum value for number of blocking file is 1000.\n\n\n# RegionServer (/docs/architecture/regionserver)\n\n\n\n\n`HRegionServer` is the RegionServer implementation. It is responsible for serving and managing regions. In a distributed cluster, a RegionServer runs on a [DataNode](/docs/architecture/hdfs#hdfs-datanode).\n\n## Interface\n\nThe methods exposed by `HRegionRegionInterface` contain both data-oriented and region-maintenance methods:\n\n* Data (get, put, delete, next, etc.)\n* Region (splitRegion, compactRegion, etc.) For example, when the `Admin` method `majorCompact` is invoked on a table, the client is actually iterating through all regions for the specified table and requesting a major compaction directly to each region.\n\n## Processes\n\nThe RegionServer runs a variety of background threads:\n\n### CompactSplitThread\n\nChecks for splits and handle minor compactions.\n\n### MajorCompactionChecker\n\nChecks for major compactions.\n\n### MemStoreFlusher\n\nPeriodically flushes in-memory writes in the MemStore to StoreFiles.\n\n### LogRoller\n\nPeriodically checks the RegionServer's WAL.\n\n## Coprocessors\n\nCoprocessors were added in 0.92. There is a thorough [Blog Overview of CoProcessors](https://blogs.apache.org/hbase/entry/coprocessor_introduction) posted. Documentation will eventually move to this reference guide, but the blog is the most current information available at this time.\n\n## Block Cache\n\nHBase provides two different BlockCache implementations to cache data read from HDFS: the default on-heap `LruBlockCache` and the `BucketCache`, which is (usually) off-heap. This section discusses benefits and drawbacks of each implementation, how to choose the appropriate option, and configuration options for each.\n\n<Callout type=\"info\" title=\"Block Cache Reporting: UI\">\n  See the RegionServer UI for detail on caching deploy. See configurations, sizings, current usage,\n  time-in-the-cache, and even detail on block counts and types.\n</Callout>\n\n### Cache Choices\n\n`LruBlockCache` is the original implementation, and is entirely within the Java heap. `BucketCache` is optional and mainly intended for keeping block cache data off-heap, although `BucketCache` can also be a file-backed cache. In file-backed we can either use it in the file mode or the mmaped mode. We also have pmem mode where the bucket cache resides on the persistent memory device.\n\nWhen you enable BucketCache, you are enabling a two tier caching system. We used to describe the tiers as \"L1\" and \"L2\" but have deprecated this terminology as of hbase-2.0.0. The \"L1\" cache referred to an instance of LruBlockCache and \"L2\" to an off-heap BucketCache. Instead, when BucketCache is enabled, all DATA blocks are kept in the BucketCache tier and meta blocks — INDEX and BLOOM blocks — are on-heap in the `LruBlockCache`. Management of these two tiers and the policy that dictates how blocks move between them is done by `CombinedBlockCache`.\n\n### General Cache Configurations\n\nApart from the cache implementation itself, you can set some general configuration options to control how the cache performs. See [CacheConfig](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html). After setting any of these options, restart or rolling restart your cluster for the configuration to take effect. Check logs for errors or unexpected behavior.\n\nSee also [Prefetch Option for Blockcache](/docs/performance#prefetch-option-for-blockcache), which discusses a new option introduced in [HBASE-9857](https://issues.apache.org/jira/browse/HBASE-9857).\n\n### LruBlockCache Design\n\nThe LruBlockCache is an LRU cache that contains three levels of block priority to allow for scan-resistance and in-memory ColumnFamilies:\n\n* Single access priority: The first time a block is loaded from HDFS it normally has this priority and it will be part of the first group to be considered during evictions. The advantage is that scanned blocks are more likely to get evicted than blocks that are getting more usage.\n* Multi access priority: If a block in the previous priority group is accessed again, it upgrades to this priority. It is thus part of the second group considered during evictions.\n* In-memory access priority: If the block's family was configured to be \"in-memory\", it will be part of this priority disregarding the number of times it was accessed. Catalog tables are configured like this. This group is the last one considered during evictions.\\\n  To mark a column family as in-memory, call\n  ```java\n  HColumnDescriptor.setInMemory(true);\n  ```\n  if creating a table from java, or set `IN_MEMORY ⇒ true` when creating or altering a table in the shell: e.g.\n  ```java\n  hbase(main):003:0> create  't', {NAME => 'f', IN_MEMORY => 'true'}\n  ```\n  For more information, see the LruBlockCache source\n\n### LruBlockCache Usage\n\nBlock caching is enabled by default for all the user tables which means that any read operation will load the LRU cache. This might be good for a large number of use cases, but further tunings are usually required in order to achieve better performance. An important concept is the [working set size](http://en.wikipedia.org/wiki/Working_set_size), or WSS, which is: \"the amount of memory needed to compute the answer to a problem\". For a website, this would be the data that's needed to answer the queries over a short amount of time.\n\nThe way to calculate how much memory is available in HBase for caching is:\n\n```java\nnumber of region servers * heap size * hfile.block.cache.size * 0.99\n```\n\nThe default value for the block cache is 0.4 which represents 40% of the available heap. The last value (99%) is the default acceptable loading factor in the LRU cache after which eviction is started. The reason it is included in this equation is that it would be unrealistic to say that it is possible to use 100% of the available memory since this would make the process blocking from the point where it loads new blocks. Here are some examples:\n\n* One region server with the heap size set to 1 GB and the default block cache size will have 405 MB of block cache available.\n* 20 region servers with the heap size set to 8 GB and a default block cache size will have 63.3 GB of block cache.\n* 100 region servers with the heap size set to 24 GB and a block cache size of 0.5 will have about 1.16 TB of block cache.\n\nYour data is not the only resident of the block cache. Here are others that you may have to take into account:\n\n* **Catalog Tables**\\\n  The `hbase:meta` table is forced into the block cache and have the in-memory priority which means that they are harder to evict.\n\n  <Callout type=\"info\">\n    The hbase:meta tables can occupy a few MBs depending on the number of regions.\n  </Callout>\n\n* **HFiles Indexes**\\\n  An *HFile* is the file format that HBase uses to store data in HDFS. It contains a multi-layered index which allows HBase to seek the data without having to read the whole file. The size of those indexes is a factor of the block size (64KB by default), the size of your keys and the amount of data you are storing. For big data sets it's not unusual to see numbers around 1GB per region server, although not all of it will be in cache because the LRU will evict indexes that aren't used.\n\n* **Keys**\\\n  The values that are stored are only half the picture, since each value is stored along with its keys (row key, family qualifier, and timestamp). See [Try to minimize row and column sizes](/docs/regionserver-sizing#try-to-minimize-row-and-column-sizes).\n\n* **Bloom Filters**\\\n  Just like the HFile indexes, those data structures (when enabled) are stored in the LRU.\n\nCurrently the recommended way to measure HFile indexes and bloom filters sizes is to look at the region server web UI and checkout the relevant metrics. For keys, sampling can be done by using the HFile command line tool and look for the average key size metric. Since HBase 0.98.3, you can view details on BlockCache stats and metrics in a special Block Cache section in the UI. As of HBase 2.4.14, you can estimate HFile indexes and bloom filters vs other DATA blocks using blockCacheCount and blockCacheDataBlockCount in JMX. The formula `(blockCacheCount - blockCacheDataBlockCount) * blockSize` will give you an estimate which can be useful when trying to enable the BucketCache. You should make sure the post-BucketCache config gives enough memory to the on-heap LRU cache to hold at least the same number of non-DATA blocks from pre-BucketCache. Once BucketCache is enabled, the L1 metrics like l1CacheSize, l1CacheCount, and l1CacheEvictionCount can help you further tune the size.\n\nIt's generally bad to use block caching when the WSS doesn't fit in memory. This is the case when you have for example 40GB available across all your region servers' block caches but you need to process 1TB of data. One of the reasons is that the churn generated by the evictions will trigger more garbage collections unnecessarily. Here are two use cases:\n\n* Fully random reading pattern: This is a case where you almost never access the same row twice within a short amount of time such that the chance of hitting a cached block is close to 0. Setting block caching on such a table is a waste of memory and CPU cycles, more so that it will generate more garbage to pick up by the JVM. For more information on monitoring GC, see [JVM Garbage Collection Logs](/docs/troubleshooting#jvm-garbage-collection-logs).\n* Mapping a table: In a typical MapReduce job that takes a table in input, every row will be read only once so there's no need to put them into the block cache. The Scan object has the option of turning this off via the setCacheBlocks method (set it to false). You can still keep block caching turned on on this table if you need fast random read access. An example would be counting the number of rows in a table that serves live traffic, caching every block of that table would create massive churn and would surely evict data that's currently in use.\n\n#### Caching META blocks only (DATA blocks in fscache)\n\nAn interesting setup is one where we cache META blocks only and we read DATA blocks in on each access. If the DATA blocks fit inside fscache, this alternative may make sense when access is completely random across a very large dataset. To enable this setup, alter your table and for each column family set `BLOCKCACHE ⇒ 'false'`. You are 'disabling' the BlockCache for this column family only. You can never disable the caching of META blocks. Since [HBASE-4683 Always cache index and bloom blocks](https://issues.apache.org/jira/browse/HBASE-4683), we will cache META blocks even if the BlockCache is disabled.\n\n### Off-heap Block Cache\n\n#### How to Enable BucketCache\n\nThe usual deployment of BucketCache is via a managing class that sets up two caching tiers: an on-heap cache implemented by LruBlockCache and a second cache implemented with BucketCache. The managing class is [CombinedBlockCache](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CombinedBlockCache.html) by default. The previous link describes the caching 'policy' implemented by CombinedBlockCache. In short, it works by keeping meta blocks — INDEX and BLOOM in the on-heap LruBlockCache tier — and DATA blocks are kept in the BucketCache tier.\n\n* **Pre-hbase-2.0.0 versions**\n\n  Fetching will always be slower when fetching from BucketCache in pre-hbase-2.0.0, as compared to the native on-heap LruBlockCache. However, latencies tend to be less erratic across time, because there is less garbage collection when you use BucketCache since it is managing BlockCache allocations, not the GC. If the BucketCache is deployed in off-heap mode, this memory is not managed by the GC at all. This is why you'd use BucketCache in pre-2.0.0, so your latencies are less erratic, to mitigate GCs and heap fragmentation, and so you can safely use more memory. See Nick Dimiduk's [BlockCache 101](http://www.n10k.com/blog/blockcache-101/) for comparisons running on-heap vs off-heap tests. Also see [Comparing BlockCache Deploys](https://web.archive.org/web/20231109025243/http://people.apache.org/~stack/bc/) which finds that if your dataset fits inside your LruBlockCache deploy, use it otherwise if you are experiencing cache churn (or you want your cache to exist beyond the vagaries of java GC), use BucketCache.\n\n  In pre-2.0.0, one can configure the BucketCache so it receives the `victim` of an LruBlockCache eviction. All Data and index blocks are cached in L1 first. When eviction happens from L1, the blocks (or `victims`) will get moved to L2. Set `cacheDataInL1` via `(HColumnDescriptor.setCacheDataInL1(true)` or in the shell, creating or amending column families setting `CACHE_DATA_IN_L1` to true: e.g.\n\n  ```java\n  hbase(main):003:0> create 't', {NAME => 't', CONFIGURATION => {CACHE_DATA_IN_L1 => 'true'}}\n  ```\n\n* **hbase-2.0.0+ versions**\n\n  HBASE-11425 changed the HBase read path so it could hold the read-data off-heap avoiding copying of cached data on to the java heap. See [Offheap read-path](/docs/offheap-read-write#offheap-read-path). In hbase-2.0.0, off-heap latencies approach those of on-heap cache latencies with the added benefit of NOT provoking GC.\n\n  From HBase 2.0.0 onwards, the notions of L1 and L2 have been deprecated. When BucketCache is turned on, the DATA blocks will always go to BucketCache and INDEX/BLOOM blocks go to on heap LRUBlockCache. `cacheDataInL1` support has been removed.\n\n#### BucketCache Deploy Modes\n\nThe BucketCache Block Cache can be deployed *offheap*, *file* or *mmaped* file mode.\n\nYou set which via the `hbase.bucketcache.ioengine` setting. Setting it to `offheap` will have BucketCache make its allocations off-heap, and an ioengine setting of `file:PATH_TO_FILE` will direct BucketCache to use file caching (Useful in particular if you have some fast I/O attached to the box such as SSDs). From 2.0.0, it is possible to have more than one file backing the BucketCache. This is very useful especially when the Cache size requirement is high. For multiple backing files, configure ioengine as `files:PATH_TO_FILE1,PATH_TO_FILE2,PATH_TO_FILE3`. BucketCache can be configured to use an mmapped file also. Configure ioengine as `mmap:PATH_TO_FILE` for this.\n\nIt is possible to deploy a tiered setup where we bypass the CombinedBlockCache policy and have BucketCache working as a strict L2 cache to the L1 LruBlockCache. For such a setup, set `hbase.bucketcache.combinedcache.enabled` to `false`. In this mode, on eviction from L1, blocks go to L2. When a block is cached, it is cached first in L1. When we go to look for a cached block, we look first in L1 and if none found, then search L2. Let us call this deploy format, *Raw L1+L2*. NOTE: This L1+L2 mode is removed from 2.0.0. When BucketCache is used, it will be strictly the DATA cache and the LruBlockCache will cache INDEX/META blocks.\n\nOther BucketCache configs include: specifying a location to persist cache to across restarts, how many threads to use writing the cache, etc. See the [CacheConfig.html](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html) class for configuration options and descriptions.\n\nTo check it enabled, look for the log line describing cache setup; it will detail how BucketCache has been deployed. Also see the UI. It will detail the cache tiering and their configuration.\n\n#### BucketCache Example Configuration\n\nThis sample provides a configuration for a 4 GB off-heap BucketCache with a 1 GB on-heap cache.\n\nConfiguration is performed on the RegionServer.\n\nSetting `hbase.bucketcache.ioengine` and `hbase.bucketcache.size` > 0 enables `CombinedBlockCache`. Let us presume that the RegionServer has been set to run with a 5G heap: i.e. `HBASE_HEAPSIZE=5g`.\n\n1. First, edit the RegionServer's *hbase-env.sh* and set `HBASE_OFFHEAPSIZE` to a value greater than the off-heap size wanted, in this case, 4 GB (expressed as 4G). Let's set it to 5G. That'll be 4G for our off-heap cache and 1G for any other uses of off-heap memory (there are other users of off-heap memory other than BlockCache; e.g. DFSClient in RegionServer can make use of off-heap memory). See Direct Memory Usage In HBase below.\n\n   ```java\n   HBASE_OFFHEAPSIZE=5G\n   ```\n\n2. Next, add the following configuration to the RegionServer's *hbase-site.xml*.\n\n   ```xml\n   <property>\n     <name>hbase.bucketcache.ioengine</name>\n     <value>offheap</value>\n   </property>\n   <property>\n     <name>hfile.block.cache.size</name>\n     <value>0.2</value>\n   </property>\n   <property>\n     <name>hbase.bucketcache.size</name>\n     <value>4196</value>\n   </property>\n   ```\n\n3. Restart or rolling restart your cluster, and check the logs for any issues.\n\nIn the above, we set the BucketCache to be 4G. We configured the on-heap LruBlockCache have 20% (0.2) of the RegionServer's heap size (0.2 \\* 5G = 1G). In other words, you configure the L1 LruBlockCache as you would normally (as if there were no L2 cache present).\n\n[HBASE-10641](https://issues.apache.org/jira/browse/HBASE-10641) introduced the ability to configure multiple sizes for the buckets of the BucketCache, in HBase 0.98 and newer. To configurable multiple bucket sizes, configure the new property `hbase.bucketcache.bucket.sizes` to a comma-separated list of block sizes, ordered from smallest to largest, with no spaces. The goal is to optimize the bucket sizes based on your data access patterns. The following example configures buckets of size 4096 and 8192.\n\n```xml\n<property>\n  <name>hbase.bucketcache.bucket.sizes</name>\n  <value>4096,8192</value>\n</property>\n```\n\n<Callout type=\"info\" title=\"Direct Memory Usage In HBase\">\n  The default maximum direct memory varies by JVM. Traditionally it is 64M or some relation to allocated heap size (-Xmx) or no limit at all (JDK7 apparently). HBase servers use direct memory, in particular short-circuit reading (See [Leveraging local data](/docs/performance#leveraging-local-data)), the hosted DFSClient will allocate direct memory buffers. How much the DFSClient uses is not easy to quantify; it is the number of open HFiles \\* `hbase.dfs.client.read.shortcircuit.buffer.size` where `hbase.dfs.client.read.shortcircuit.buffer.size` is set to 128k in HBase — see *hbase-default.xml* default configurations. If you do off-heap block caching, you'll be making use of direct memory. The RPCServer uses a ByteBuffer pool. From 2.0.0, these buffers are off-heap ByteBuffers. Starting your JVM, make sure the `-XX:MaxDirectMemorySize` setting in *conf/hbase-env.sh* considers off-heap BlockCache (`hbase.bucketcache.size`), DFSClient usage, RPC side ByteBufferPool max size. This has to be bit higher than sum of off heap BlockCache size and max ByteBufferPool size. Allocating an extra of 1-2 GB for the max direct memory size has worked in tests. Direct memory, which is part of the Java process heap, is separate from the object heap allocated by -Xmx. The value allocated by `MaxDirectMemorySize` must not exceed physical RAM, and is likely to be less than the total available RAM due to other memory requirements and system constraints.\n\n  You can see how much memory — on-heap and off-heap/direct — a RegionServer is configured to use and how much it is using at any one time by looking at the *Server Metrics: Memory* tab in the UI. It can also be gotten via JMX. In particular the direct memory currently used by the server can be found on the `java.nio.type=BufferPool,name=direct` bean. Terracotta has a [good write up](https://web.archive.org/web/20170907032911/http://terracotta.org/documentation/4.0/bigmemorygo/configuration/storage-options) on using off-heap memory in Java. It is for their product BigMemory but a lot of the issues noted apply in general to any attempt at going off-heap. Check it out.\n</Callout>\n\n<Callout type=\"info\" title=\"hbase.bucketcache.percentage.in.combinedcache\">\n  This is a pre-HBase 1.0 configuration removed because it was confusing. It was a float that you would set to some value between 0.0 and 1.0. Its default was 0.9. If the deploy was using CombinedBlockCache, then the LruBlockCache L1 size was calculated to be `(1 - hbase.bucketcache.percentage.in.combinedcache) * size-of-bucketcache` and the BucketCache size was `hbase.bucketcache.percentage.in.combinedcache * size-of-bucket-cache`. where size-of-bucket-cache itself is EITHER the value of the configuration `hbase.bucketcache.size` IF it was specified as Megabytes OR `hbase.bucketcache.size` \\* `-XX:MaxDirectMemorySize` if `hbase.bucketcache.size` is between 0 and 1.0.\n\n  In 1.0, it should be more straight-forward. Onheap LruBlockCache size is set as a fraction of java heap using `hfile.block.cache.size setting` (not the best name) and BucketCache is set as above in absolute Megabytes.\n</Callout>\n\n### Time Based Priority for BucketCache\n\n[HBASE-28463](https://issues.apache.org/jira/browse/HBASE-28463) introduced time based priority for blocks in BucketCache. It allows for defining an age threshold at individual column families' configuration, whereby blocks older than this configured threshold would be targeted first for eviction.\n\nBlocks from column families that don't define the age threshold wouldn't be evaluated by the time based priority, and would only be evicted following the LRU eviction logic.\n\nThis feature is mostly useful for use cases where most recent data is more frequently accessed, and therefore should get higher priority in the cache. Configuring Time Based Priority with the \"age\" of most accessed data would then give a finer control over blocks allocation in the BucketCache than the built-in LRU eviction logic.\n\nTime Based Priority for BucketCache provides three different strategies for defining data age:\n\n* Cell timestamps: Uses the timestamp portion of HBase cells for comparing the data age.\n* Custom cell qualifiers: Uses a custom-defined date qualifier for comparing the data age. It uses that value to tier the entire row containing the given qualifier value. This requires that the custom qualifier be a valid Java long timestamp.\n* Custom value provider: Allows for defining a pluggable implementation that contains the logic for identifying the date value to be used for comparison. This also provides additional flexibility for different use cases that might have the date stored in other formats or embedded with other data in various portions of a given row.\n\nFor use cases where priority is determined by the order of record ingestion in HBase (with the most recent being the most relevant), the built-in cell timestamp offers the most convenient and efficient method for configuring age-based priority. See [Using Cell timestamps for Time Based Priority](/docs/architecture/regionserver#using-cell-timestamps-for-time-based-priority).\n\nSome applications may utilize a custom date column to define the priority of table records. In such instances, a custom cell qualifier-based priority is advisable. See [Using Custom Cell Qualifiers for Time Based Priority](/docs/architecture/regionserver#using-custom-cell-qualifiers-for-time-based-priority).\n\nFinally, more intricate schemas may incorporate domain-specific logic for defining the age of each record. The custom value provider facilitates the integration of custom code to implement the appropriate parsing of the date value that should be used for the priority comparison. See [Using a Custom value provider for Time Based Priority](/docs/architecture/regionserver#using-a-custom-value-provider-for-time-based-priority).\n\nWith Time Based Priority for BucketCache, blocks age is evaluated when deciding if a block should be cached (i.e. during reads, writes, compaction and prefetch), as well as during the cache freeSpace run (mass eviction), prior to executing the LRU logic.\n\nBecause blocks don't hold any specific meta information other than type, it's necessary to group blocks of the same \"age group\" on separate files, using specialized compaction implementations (see more details in the configuration section below). The time range of all blocks in each file is then appended at the file meta info section, and is used for evaluating the age of blocks that should be considered in the Time Based Priority logic.\n\n#### Configuring Time Based Priority for BucketCache\n\nFinding the age of each block involves an extra overhead, therefore the feature is disabled by default at a global configuration level.\n\nTo enable it, the following configuration should be set on RegionServers' *hbase-site.xml*:\n\n```xml\n<property>\n  <name>hbase.regionserver.datatiering.enable</name>\n  <value>true</value>\n</property>\n```\n\nOnce enabled globally, it's necessary to define the desired strategy-specific settings at the individual column family level.\n\n#### Using Cell timestamps for Time Based Priority\n\nThis strategy is the most efficient to run, as it uses the timestamp portion of each cell containing the data for comparing the age of blocks. It requires DateTieredCompaction for splitting the blocks into separate files according to blocks' ages.\n\nThe example below sets the hot age threshold to one week (in milliseconds) for the column family 'cf1' in table 'orders':\n\n```java\nhbase(main):003:0> alter 'orders', {NAME => 'cf1',\n  CONFIGURATION => {'hbase.hstore.datatiering.type' => 'TIME_RANGE',\n    'hbase.hstore.datatiering.hot.age.millis' => '604800000',\n    'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine',\n    'hbase.hstore.blockingStoreFiles' => '60',\n    'hbase.hstore.compaction.min' => '2',\n    'hbase.hstore.compaction.max' => '60'\n  }\n}\n```\n\n<Callout type=\"info\" title=\"Date Tiered Compaction specific tunings\">\n  In the example above, the properties governing the number of windows and period of each window in the date tiered compaction were not set. With the default settings, the compaction will create initially four windows of six hours, then four windows of one day each, then another four windows of four days each and so on until the minimum timestamp among the selected files is covered. This can create a large number of files, therefore, additional changes to the 'hbase.hstore.blockingStoreFiles', 'hbase.hstore.compaction.min' and 'hbase.hstore.compaction.max' are recommended.\n\n  Alternatively, consider adjusting the initial window size to the same as the hot age threshold, and two windows only per tier:\n\n  ```java\n  hbase(main):003:0> alter 'orders', {NAME => 'cf1',\n    CONFIGURATION => {'hbase.hstore.datatiering.type' => 'TIME_RANGE',\n      'hbase.hstore.datatiering.hot.age.millis' => '604800000',\n      'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine',\n      'hbase.hstore.compaction.date.tiered.base.window.millis' => '604800000',\n      'hbase.hstore.compaction.date.tiered.windows.per.tier' => '2'\n    }\n  }\n  ```\n</Callout>\n\n#### Using Custom Cell Qualifiers for Time Based Priority\n\nThis strategy uses a new compaction implementation designed for Time Based Priority. It extends date tiered compaction, but instead of producing multiple tiers of various time windows, it simply splits files into two groups: the \"cold\" group, where all blocks are older than the defined threshold age, and the \"hot\" group, where all blocks are newer than the threshold age.\n\nThe example below defines a cell qualifier 'event\\_date' to be used for comparing the age of blocks within the custom cell qualifier strategy:\n\n```java\nhbase(main):003:0> alter 'orders', {NAME => 'cf1',\n  CONFIGURATION => {'hbase.hstore.datatiering.type' => 'CUSTOM',\n    'TIERING_CELL_QUALIFIER' => 'event_date',\n    'hbase.hstore.datatiering.hot.age.millis' => '604800000',\n    'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.CustomTieredStoreEngine',\n    'hbase.hstore.compaction.date.tiered.custom.age.limit.millis' => '604800000'\n  }\n}\n```\n\n<Callout type=\"info\" title=\"Time Based Priority x Compaction Age Threshold Configurations\">\n  Note that there are two different configurations for defining the hot age threshold. This is\n  because the Time Based Priority enforcer operates independently of the compaction implementation.\n</Callout>\n\n#### Using a Custom value provider for Time Based Priority\n\nIt's also possible to hook in domain-specific logic for defining the data age of each row to be used for comparing blocks priorities. The Custom Time Based Priority framework defines the `CustomTieredCompactor.TieringValueProvider` interface, which can be implemented to provide the specific date value to be used by compaction for grouping the blocks according to the threshold age.\n\nIn the following example, the `RowKeyPortionTieringValueProvider` implements the `getTieringValue` method. This method parses the date from a segment of the row key value, specifically between positions 14 and 29, using the \"yyyyMMddHHmmss\" format. The parsed date is then returned as a long timestamp, which is then used by custom tiered compaction to group the blocks based on the defined hot age threshold:\n\n```java\npublic class RowKeyPortionTieringValueProvider implements CustomTieredCompactor.TieringValueProvider {\n   private SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n   @Override\n   public void init(Configuration configuration) throws Exception {}\n\n   @Override\n   public long getTieringValue(Cell cell) {\n     byte[] rowArray = new byte[cell.getRowLength()];\n     System.arraycopy(cell.getRowArray(), cell.getRowOffset(), rowArray, 0, cell.getRowLength());\n     String datePortion = Bytes.toString(rowArray).substring(14, 29).trim();\n     try {\n       return sdf.parse(datePortion).getTime();\n     } catch (ParseException e) {\n       //handle error\n     }\n     return Long.MAX_VALUE;\n   }\n}\n```\n\nThe Tiering Value Provider above can then be configured for Time Based Priority as follows:\n\n```java\nhbase(main):003:0> alter 'orders', {NAME => 'cf1',\n  CONFIGURATION => {'hbase.hstore.datatiering.type' => 'CUSTOM',\n    'hbase.hstore.custom-tiering-value.provider.class' =>\n      'org.apache.hbase.client.example.RowKeyPortionTieringValueProvider',\n    'hbase.hstore.datatiering.hot.age.millis' => '604800000',\n    'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.CustomTieredStoreEngine',\n    'hbase.hstore.compaction.date.tiered.custom.age.limit.millis' => '604800000'\n  }\n}\n```\n\n<Callout type=\"info\">\n  Upon enabling Custom Time Based Priority (either the custom qualifier or custom value provider) in\n  the column family configuration, it is imperative that major compaction be executed twice on the\n  specified tables to ensure the effective application of the newly configured priorities within the\n  bucket cache.\n</Callout>\n\n<Callout type=\"info\">\n  Time Based Priority was originally implemented with the cell timestamp strategy only. The original design covering cell timestamp based strategy is available [here](https://docs.google.com/document/d/1Qd3kvZodBDxHTFCIRtoePgMbvyuUSxeydi2SEWQFQro/edit?tab=t.0#heading=h.gjdgxs).\n\n  The second phase including the two custom strategies mentioned above is detailed in [this separate design doc](https://docs.google.com/document/d/1uBGIO9IQ-FbSrE5dnUMRtQS23NbCbAmRVDkAOADcU_E/edit?tab=t.0).\n</Callout>\n\n### Compressed BlockCache\n\n[HBASE-11331](https://issues.apache.org/jira/browse/HBASE-11331) introduced lazy BlockCache decompression, more simply referred to as compressed BlockCache. When compressed BlockCache is enabled data and encoded data blocks are cached in the BlockCache in their on-disk format, rather than being decompressed and decrypted before caching.\n\nFor a RegionServer hosting more data than can fit into cache, enabling this feature with SNAPPY compression has been shown to result in 50% increase in throughput and 30% improvement in mean latency while, increasing garbage collection by 80% and increasing overall CPU load by 2%. See HBASE-11331 for more details about how performance was measured and achieved. For a RegionServer hosting data that can comfortably fit into cache, or if your workload is sensitive to extra CPU or garbage-collection load, you may receive less benefit.\n\nThe compressed BlockCache is disabled by default. To enable it, set `hbase.block.data.cachecompressed` to `true` in *hbase-site.xml* on all RegionServers.\n\n### Cache Aware Load Balancer\n\nDepending on the data size and the configured cache size, the cache warm up can take anywhere from a few minutes to a few hours. This becomes even more critical for HBase deployments over cloud storage, where compute is separated from storage. Doing this everytime the region server starts can be a very expensive process. To eliminate this, [HBASE-27313](https://issues.apache.org/jira/browse/HBASE-27313) implemented the cache persistence feature where the region servers periodically persist the blocks cached in the bucket cache. This persisted information is then used to resurrect the cache in the event of a region server restart because of normal restart or crash.\n\n[HBASE-27999](https://issues.apache.org/jira/browse/HBASE-27999) implements the cache aware load balancer, which adds to the load balancer the ability to consider the cache allocation of each region on region servers when calculating a new assignment plan, using the region/region server cache allocation information reported by region servers to calculate the percentage of HFiles cached for each region on the hosting server. This information is then used by the balancer as a factor when deciding on an optimal, new assignment plan.\n\nThe master node captures the caching information from all the region servers and uses this information to decide on new region assignments while ensuring a minimal impact on the current cache allocation. A region is assigned to the region server where it has a better cache ratio as compared to the region server where it is currently hosted.\n\nThe CacheAwareLoadBalancer uses two cost elements for deciding the region allocation. These are described below:\n\n1. **Cache Cost**\\\n   The cache cost is calculated as the percentage of data for a region cached on the region server where it is either currently hosted or was previously hosted. A region may have multiple HFiles, each of different sizes. A HFile is considered to be fully prefetched when all the data blocks in this file are in the cache. The region server hosting this region calculates the ratio of number of HFiles fully cached in the cache to the total number of HFiles in the region. This ratio will vary from 0 (region hosted on this server, but none of its HFiles are cached into the cache) to 1 (region hosted on this server and all the HFiles for this region are cached into the cache).\\\n   Every region server maintains this information for all the regions currently hosted there. In addition to that, this cache ratio is also maintained for the regions which were previously hosted on this region server giving historical information about the regions.\n2. Skewness Cost\n\nThe cache aware balancer will consider cache cost with the skewness cost to decide on the region assignment plan under following conditions:\n\n1. There is an idle server in the cluster. This can happen when an existing server is restarted or a new server is added to the cluster.\n2. When the cost of maintaining the balance in the cluster is greater than the minimum threshold defined by the configuration *hbase.master.balancer.stochastic.minCostNeedBalance*.\n\nThe CacheAwareLoadBalancer can be enabled in the cluster by setting the following configuration properties in the master master configuration:\n\n```xml\n<property>\n  <name>hbase.master.loadbalancer.class</name>\n  <value>org.apache.hadoop.hbase.master.balancer.CacheAwareLoadBalancer</value>\n</property>\n<property>\n  <name>hbase.bucketcache.persistent.path</name>\n  <value>/path/to/bucketcache_persistent_file</value>\n</property>\n```\n\nWithin HBASE-29168, the CacheAwareLoadBalancer implements region move throttling. This mitigates the impact of \"losing\" cache factor when balancing mainly due to region skewness, i.e. when new region servers are added to the cluster, a large bulk of cached regions may move to the new servers at once, which can cause noticeable read performance impacts for cache sensitive use cases. The throttling sleep time is determined by the **hbase.master.balancer.move.throttlingMillis** property, and it defaults to 60000 millis. If a region planned to be moved has a cache ratio on the target server above the thershold configurable by the **hbase.master.balancer.stochastic.throttling.cacheRatio** property (80% by default), no throttling will be applied in this region move.\n\n## RegionServer Splitting Implementation\n\nAs write requests are handled by the region server, they accumulate in an in-memory storage system called the *memstore*. Once the memstore fills, its content are written to disk as additional store files. This event is called a *memstore flush*. As store files accumulate, the RegionServer will [compact](/docs/architecture/regions#compaction) them into fewer, larger files. After each flush or compaction finishes, the amount of data stored in the region has changed. The RegionServer consults the region split policy to determine if the region has grown too large or should be split for another policy-specific reason. A region split request is enqueued if the policy recommends it.\n\nLogically, the process of splitting a region is simple. We find a suitable point in the keyspace of the region where we should divide the region in half, then split the region's data into two new regions at that point. The details of the process however are not simple. When a split happens, the newly created *daughter regions* do not rewrite all the data into new files immediately. Instead, they create small files similar to symbolic link files, named [Reference files](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/Reference.html), which point to either the top or bottom part of the parent store file according to the split point. The reference file is used just like a regular data file, but only half of the records are considered. The region can only be split if there are no more references to the immutable data files of the parent region. Those reference files are cleaned gradually by compactions, so that the region will stop referring to its parents files, and can be split further.\n\nAlthough splitting the region is a local decision made by the RegionServer, the split process itself must coordinate with many actors. The RegionServer notifies the Master before and after the split, updates the `.META.` table so that clients can discover the new daughter regions, and rearranges the directory structure and data files in HDFS. Splitting is a multi-task process. To enable rollback in case of an error, the RegionServer keeps an in-memory journal about the execution state. The steps taken by the RegionServer to execute the split are illustrated in the \"RegionServer Split Process\" schema below. Each step is labeled with its step number. Actions from RegionServers or Master are shown in red, while actions from the clients are shown in green.\n\n<img alt=\"Region Split Process\" src={__img0} placeholder=\"blur\" />\n\n1. The RegionServer decides locally to split the region, and prepares the split. **THE SPLIT TRANSACTION IS STARTED.** As a first step, the RegionServer acquires a shared read lock on the table to prevent schema modifications during the splitting process. Then it creates a znode in zookeeper under `/hbase/region-in-transition/region-name`, and sets the znode's state to `SPLITTING`.\n2. The Master learns about this znode, since it has a watcher for the parent `region-in-transition` znode.\n3. The RegionServer creates a sub-directory named `.splits` under the parent's `region` directory in HDFS.\n4. The RegionServer closes the parent region and marks the region as offline in its local data structures. **THE SPLITTING REGION IS NOW OFFLINE.** At this point, client requests coming to the parent region will throw `NotServingRegionException`. The client will retry with some backoff. The closing region is flushed.\n5. The RegionServer creates region directories under the `.splits` directory, for daughter regions A and B, and creates necessary data structures. Then it splits the store files, in the sense that it creates two Reference files per store file in the parent region. Those reference files will point to the parent region's files.\n6. The RegionServer creates the actual region directory in HDFS, and moves the reference files for each daughter.\n7. The RegionServer sends a `Put` request to the `.META.` table, to set the parent as offline in the `.META.` table and add information about daughter regions. At this point, there won't be individual entries in `.META.` for the daughters. Clients will see that the parent region is split if they scan `.META.`, but won't know about the daughters until they appear in `.META.`. Also, if this `Put` to `.META`. succeeds, the parent will be effectively split. If the RegionServer fails before this RPC succeeds, Master and the next Region Server opening the region will clean dirty state about the region split. After the `.META.` update, though, the region split will be rolled-forward by Master.\n8. The RegionServer opens daughters A and B in parallel.\n9. The RegionServer adds the daughters A and B to `.META.`, together with information that it hosts the regions. **THE SPLIT REGIONS (DAUGHTERS WITH REFERENCES TO PARENT) ARE NOW ONLINE.** After this point, clients can discover the new regions and issue requests to them. Clients cache the `.META.` entries locally, but when they make requests to the RegionServer or `.META.`, their caches will be invalidated, and they will learn about the new regions from `.META.`.\n10. The RegionServer updates znode `/hbase/region-in-transition/region-name` in ZooKeeper to state `SPLIT`, so that the master can learn about it. The balancer can freely re-assign the daughter regions to other region servers if necessary. **THE SPLIT TRANSACTION IS NOW FINISHED.**\n11. After the split, `.META.` and HDFS will still contain references to the parent region. Those references will be removed when compactions in daughter regions rewrite the data files. Garbage collection tasks in the master periodically check whether the daughter regions still refer to the parent region's files. If not, the parent region will be removed.\n\n## Write Ahead Log (WAL)\n\n### Purpose\n\nThe *Write Ahead Log (WAL)* records all changes to data in HBase, to file-based storage. Under normal operations, the WAL is not needed because data changes move from the MemStore to StoreFiles. However, if a RegionServer crashes or becomes unavailable before the MemStore is flushed, the WAL ensures that the changes to the data can be replayed. If writing to the WAL fails, the entire operation to modify the data fails.\n\nHBase uses an implementation of the [WAL](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/wal/WAL.html) interface. Usually, there is only one instance of a WAL per RegionServer. An exception is the RegionServer that is carrying *hbase:meta*; the *meta* table gets its own dedicated WAL. The RegionServer records Puts and Deletes to its WAL, before recording them these Mutations [MemStore](/docs/architecture/regions#memstore) for the affected [Store](/docs/architecture/regions#store).\n\n<Callout type=\"info\" title=\"The HLog\">\n  Prior to 2.0, the interface for WALs in HBase was named `HLog`. In 0.94, HLog was the name of the\n  implementation of the WAL. You will likely find references to the HLog in documentation tailored\n  to these older versions.\n</Callout>\n\nThe WAL resides in HDFS in the */hbase/WALs/* directory, with subdirectories per RegionServer.\n\nFor more general information about the concept of write ahead logs, see the Wikipedia [Write-Ahead Log](http://en.wikipedia.org/wiki/Write-ahead_logging) article.\n\n### WAL Providers\n\nIn HBase, there are a number of WAL implementations (or 'Providers'). Each is known by a short name label (that unfortunately is not always descriptive). You set the provider in *hbase-site.xml* passing the WAL provider short-name as the value on the *hbase.wal.provider* property (Set the provider for *hbase:meta* using the *hbase.wal.meta\\_provider* property, otherwise it uses the same provider configured by *hbase.wal.provider*).\n\n* *asyncfs*: The **default**. New since hbase-2.0.0 (HBASE-15536, HBASE-14790). This *AsyncFSWAL* provider, as it identifies itself in RegionServer logs, is built on a new non-blocking dfsclient implementation. It is currently resident in the hbase codebase but intent is to move it back up into HDFS itself. WALs edits are written concurrently (\"fan-out\") style to each of the WAL-block replicas on each DataNode rather than in a chained pipeline as the default client does. Latencies should be better. See [Apache HBase Improvements and Practices at Xiaomi](https://www.slideshare.net/HBaseCon/apache-hbase-improvements-and-practices-at-xiaomi) at slide 14 onward for more detail on implementation.\n* *filesystem*: This was the default in hbase-1.x releases. It is built on the blocking *DFSClient* and writes to replicas in classic *DFSCLient* pipeline mode. In logs it identifies as *FSHLog* or *FSHLogProvider*.\n* *multiwal*: This provider is made of multiple instances of *asyncfs* or *filesystem*. See the next section for more on *multiwal*.\n\nLook for the lines like the below in the RegionServer log to see which provider is in place (The below shows the default AsyncFSWALProvider):\n\n```java\n2018-04-02 13:22:37,983 INFO  [regionserver/ve0528:16020] wal.WALFactory: Instantiating WALProvider of type class org.apache.hadoop.hbase.wal.AsyncFSWALProvider\n```\n\n<Callout type=\"info\">\n  As the *AsyncFSWAL* hacks into the internal of DFSClient implementation, it will be easily broken\n  by upgrading the hadoop dependencies, even for a simple patch release. So if you do not specify\n  the wal provider explicitly, we will first try to use the *asyncfs*, if failed, we will fall back\n  to use *filesystem*. And notice that this may not always work, so if you still have problem\n  starting HBase due to the problem of starting *AsyncFSWAL*, please specify *filesystem* explicitly\n  in the config file.\n</Callout>\n\n<Callout type=\"info\">\n  EC support has been added to hadoop-3.x, and it is incompatible with WAL as the EC output stream\n  does not support hflush/hsync. In order to create a non-EC file in an EC directory, we need to use\n  the new builder-based create API for *FileSystem*, but it is only introduced in hadoop-2.9+ and\n  for HBase we still need to support hadoop-2.7.x. So please do not enable EC for the WAL directory\n  until we find a way to deal with it.\n</Callout>\n\n### MultiWAL\n\nWith a single WAL per RegionServer, the RegionServer must write to the WAL serially, because HDFS files must be sequential. This causes the WAL to be a performance bottleneck.\n\nHBase 1.0 introduces support MultiWal in [HBASE-5699](https://issues.apache.org/jira/browse/HBASE-5699). MultiWAL allows a RegionServer to write multiple WAL streams in parallel, by using multiple pipelines in the underlying HDFS instance, which increases total throughput during writes. This parallelization is done by partitioning incoming edits by their Region. Thus, the current implementation will not help with increasing the throughput to a single Region.\n\nRegionServers using the original WAL implementation and those using the MultiWAL implementation can each handle recovery of either set of WALs, so a zero-downtime configuration update is possible through a rolling restart.\n\n#### Configure MultiWAL\n\nTo configure MultiWAL for a RegionServer, set the value of the property `hbase.wal.provider` to `multiwal` by pasting in the following XML:\n\n```xml\n<property>\n  <name>hbase.wal.provider</name>\n  <value>multiwal</value>\n</property>\n```\n\nRestart the RegionServer for the changes to take effect.\n\nTo disable MultiWAL for a RegionServer, unset the property and restart the RegionServer.\n\n### WAL Flushing\n\nTODO (describe).\n\n### WAL Splitting\n\nA RegionServer serves many regions. All of the regions in a region server share the same active WAL file. Each edit in the WAL file includes information about which region it belongs to. When a region is opened, the edits in the WAL file which belong to that region need to be replayed. Therefore, edits in the WAL file must be grouped by region so that particular sets can be replayed to regenerate the data in a particular region. The process of grouping the WAL edits by region is called *log splitting*. It is a critical process for recovering data if a region server fails.\n\nLog splitting is done by the HMaster during cluster start-up or by the ServerShutdownHandler as a region server shuts down. So that consistency is guaranteed, affected regions are unavailable until data is restored. All WAL edits need to be recovered and replayed before a given region can become available again. As a result, regions affected by log splitting are unavailable until the process completes.\n\n#### Procedure: Log Splitting, Step by Step\n\n<Steps>\n  <Step>\n    ##### The `/hbase/WALs/HOST,PORT,STARTCODE` directory is renamed\n\n    Renaming the directory is important because a RegionServer may still be up and accepting requests even if the HMaster thinks it is down. If the RegionServer does not respond immediately and does not heartbeat its ZooKeeper session, the HMaster may interpret this as a RegionServer failure. Renaming the logs directory ensures that existing, valid WAL files which are still in use by an active but busy RegionServer are not written to by accident.\n\n    The new directory is named according to the following pattern:\n\n    ```text\n    /hbase/WALs/HOST,PORT,STARTCODE-splitting\n    ```\n\n    An example of such a renamed directory might look like the following:\n\n    ```text\n    /hbase/WALs/srv.example.com,60020,1254173957298-splitting\n    ```\n  </Step>\n\n  <Step>\n    ##### Each log file is split, one at a time\n\n    The log splitter reads the log file one edit entry at a time and puts each edit entry into the buffer corresponding to the edit's region. At the same time, the splitter starts several writer threads. Writer threads pick up a corresponding buffer and write the edit entries in the buffer to a temporary recovered edit file. The temporary edit file is stored to disk with the following naming pattern:\n\n    ```text\n    /hbase/TABLE_NAME/REGION_ID/recovered.edits/.temp\n    ```\n\n    This file is used to store all the edits in the WAL log for this region. After log splitting completes, the *.temp* file is renamed to the sequence ID of the first log written to the file.\n\n    To determine whether all edits have been written, the sequence ID is compared to the sequence of the last edit that was written to the HFile. If the sequence of the last edit is greater than or equal to the sequence ID included in the file name, it is clear that all writes from the edit file have been completed.\n  </Step>\n\n  <Step>\n    ##### After log splitting is complete, each affected region is assigned to a RegionServer\n\n    When the region is opened, the *recovered.edits* folder is checked for recovered edits files. If any such files are present, they are replayed by reading the edits and saving them to the MemStore. After all edit files are replayed, the contents of the MemStore are written to disk (HFile) and the edit files are deleted.\n  </Step>\n</Steps>\n\n#### Handling of Errors During Log Splitting\n\nIf you set the `hbase.hlog.split.skip.errors` option to `true`, errors are treated as follows:\n\n* Any error encountered during splitting will be logged.\n* The problematic WAL log will be moved into the *.corrupt* directory under the hbase `rootdir`,\n* Processing of the WAL will continue\n\nIf the `hbase.hlog.split.skip.errors` option is set to `false`, the default, the exception will be propagated and the split will be logged as failed. See [HBASE-2958 When hbase.hlog.split.skip.errors is set to false, we fail the split but that's it](https://issues.apache.org/jira/browse/HBASE-2958). We need to do more than just fail split if this flag is set.\n\n#### How EOFExceptions are treated when splitting a crashed RegionServer's WALs\n\nIf an EOFException occurs while splitting logs, the split proceeds even when `hbase.hlog.split.skip.errors` is set to `false`. An EOFException while reading the last log in the set of files to split is likely, because the RegionServer was likely in the process of writing a record at the time of a crash. For background, see [HBASE-2643 Figure how to deal with eof splitting logs](https://issues.apache.org/jira/browse/HBASE-2643)\n\n#### Performance Improvements during Log Splitting\n\nWAL log splitting and recovery can be resource intensive and take a long time, depending on the number of RegionServers involved in the crash and the size of the regions. [Distributed log splitting](/docs/architecture/regionserver#enabling-or-disabling-distributed-log-splitting) was developed to improve performance during log splitting.\n\n#### Enabling or Disabling Distributed Log Splitting\n\nDistributed log processing is enabled by default since HBase 0.92. The setting is controlled by the `hbase.master.distributed.log.splitting` property, which can be set to `true` or `false`, but defaults to `true`.\n\n### WAL splitting based on procedureV2\n\nAfter HBASE-20610, we introduce a new way to do WAL splitting coordination by procedureV2 framework. This can simplify the process of WAL splitting and no need to connect zookeeper any more.\n\n#### Background \\[!toc]\n\nCurrently, splitting WAL processes are coordinated by zookeeper. Each region server are trying to grab tasks from zookeeper. And the burden becomes heavier when the number of region server increase.\n\n#### Implementation on Master side \\[!toc]\n\nDuring ServerCrashProcedure, SplitWALManager will create one SplitWALProcedure for each WAL file which should be split. Then each SplitWALProcedure will spawn a SplitWalRemoteProcedure to send the request to region server. SplitWALProcedure is a StateMachineProcedure and here is the state transfer diagram.\n\n<img alt=\"WAL splitting\" src={__img1} placeholder=\"blur\" />\n\n#### Implementation on Region Server side \\[!toc]\n\nRegion Server will receive a SplitWALCallable and execute it, which is much more straightforward than before. It will return null if success and return exception if there is any error.\n\n#### Performance \\[!toc]\n\nAccording to tests on a cluster which has 5 regionserver and 1 master. procedureV2 coordinated WAL splitting has a better performance than ZK coordinated WAL splitting no master when restarting the whole cluster or one region server crashing.\n\n#### Enable this feature \\[!toc]\n\nTo enable this feature, first we should ensure our package of HBase already contains these code. If not, please upgrade the package of HBase cluster without any configuration change first. Then change configuration 'hbase.split.wal.zk.coordinated' to false. Rolling upgrade the master with new configuration. Now WAL splitting are handled by our new implementation. But region server are still trying to grab tasks from zookeeper, we can rolling upgrade the region servers with the new configuration to stop that.\n\n* Steps as follows:\n  * Upgrade whole cluster to get the new Implementation.\n  * Upgrade Master with new configuration 'hbase.split.wal.zk.coordinated'=false.\n  * Upgrade region server to stop grab tasks from zookeeper.\n\n### WAL Compression\n\nThe content of the WAL can be compressed using LRU Dictionary compression. This can be used to speed up WAL replication to different datanodes. The dictionary can store up to 2<sup>15</sup> elements; eviction starts after this number is exceeded.\n\nTo enable WAL compression, set the `hbase.regionserver.wal.enablecompression` property to `true`. The default value for this property is `false`. By default, WAL tag compression is turned on when WAL compression is enabled. You can turn off WAL tag compression by setting the `hbase.regionserver.wal.tags.enablecompression` property to 'false'.\n\nA possible downside to WAL compression is that we lose more data from the last block in the WAL if it is ill-terminated mid-write. If entries in this last block were added with new dictionary entries but we failed persist the amended dictionary because of an abrupt termination, a read of this last block may not be able to resolve last-written entries.\n\n### Durability\n\nIt is possible to set *durability* on each Mutation or on a Table basis. Options include:\n\n* *SKIP\\_WAL*: Do not write Mutations to the WAL (See the next section, [Disabling the WAL](/docs/architecture/regionserver#disabling-the-wal)).\n* *ASYNC\\_WAL*: Write the WAL asynchronously; do not hold-up clients waiting on the sync of their write to the filesystem but return immediately. The edit becomes visible. Meanwhile, in the background, the Mutation will be flushed to the WAL at some time later. This option currently may lose data. See HBASE-16689.\n* *SYNC\\_WAL*: The **default**. Each edit is sync'd to HDFS before we return success to the client.\n* *FSYNC\\_WAL*: Each edit is fsync'd to HDFS and the filesystem before we return success to the client.\n\nDo not confuse the *ASYNC\\_WAL* option on a Mutation or Table with the *AsyncFSWAL* writer; they are distinct options unfortunately closely named\n\n### Custom WAL Directory\n\nHBASE-17437 added support for specifying a WAL directory outside the HBase root directory or even in a different FileSystem since 1.3.3/2.0+. Some FileSystems (such as Amazon S3) don't support append or consistent writes, in such scenario WAL directory needs to be configured in a different FileSystem to avoid loss of writes.\n\nFollowing configurations are added to accomplish this:\n\n1. `hbase.wal.dir`\\\n   This defines where the root WAL directory is located, could be on a different FileSystem than the root directory. WAL directory can not be set to a subdirectory of the root directory. The default value of this is the root directory if unset.\n2. `hbase.rootdir.perms`\\\n   Configures FileSystem permissions to set on the root directory. This is '700' by default.\n3. `hbase.wal.dir.perms`\\\n   Configures FileSystem permissions to set on the WAL directory FileSystem. This is '700' by default.\n\n<Callout type=\"info\">\n  While migrating to custom WAL dir (outside the HBase root directory or a different FileSystem)\n  existing WAL files must be copied manually to new WAL dir, otherwise it may lead to data\n  loss/inconsistency as HMaster has no information about previous WAL directory.\n</Callout>\n\n### Disabling the WAL\n\nIt is possible to disable the WAL, to improve performance in certain specific situations. However, disabling the WAL puts your data at risk. The only situation where this is recommended is during a bulk load. This is because, in the event of a problem, the bulk load can be re-run with no risk of data loss.\n\nThe WAL is disabled by calling the HBase client field `Mutation.writeToWAL(false)`. Use the `Mutation.setDurability(Durability.SKIP_WAL)` and Mutation.getDurability() methods to set and get the field's value. There is no way to disable the WAL for only a specific table.\n\n<Callout type=\"warn\">\n  If you disable the WAL for anything other than bulk loads, your data is at risk.\n</Callout>\n\n\n# Scan Over Snapshot (/docs/architecture/snapshot-scanner)\nIn HBase, a scan of a table costs server-side HBase resources reading, formating, and returning data back to the client.\nLuckily, HBase provides a TableSnapshotScanner and TableSnapshotInputFormat (introduced by [HBASE-8369](https://issues.apache.org/jira/browse/HBASE-8369)),\nwhich can scan HBase-written HFiles directly in the HDFS filesystem completely by-passing hbase. This access mode\nperforms better than going via HBase and can be used with an offline HBase with in-place or exported\nsnapshot HFiles.\n\nTo read HFiles directly, the user must have sufficient permissions to access snapshots or in-place hbase HFiles.\n\n## TableSnapshotScanner\n\nTableSnapshotScanner provides a means for running a single client-side scan over snapshot files.\nWhen using TableSnapshotScanner, we must specify a temporary directory to copy the snapshot files into.\nThe client user should have write permissions to this directory, and the dir should not be a subdirectory of\nthe hbase.rootdir. The scanner deletes the contents of the directory once the scanner is closed.\n\n### Use TableSnapshotScanner\n\n```java\nPath restoreDir = new Path(\"XX\"); // restore dir should not be a subdirectory of hbase.rootdir\nScan scan = new Scan();\ntry (TableSnapshotScanner scanner = new TableSnapshotScanner(conf, restoreDir, snapshotName, scan)) {\n    Result result = scanner.next();\n    while (result != null) {\n        ...\n        result = scanner.next();\n    }\n}\n```\n\n## TableSnapshotInputFormat\n\nTableSnapshotInputFormat provides a way to scan over snapshot HFiles in a MapReduce job.\n\n### Use TableSnapshotInputFormat\n\n```java\nJob job = new Job(conf);\nPath restoreDir = new Path(\"XX\"); // restore dir should not be a subdirectory of hbase.rootdir\nScan scan = new Scan();\nTableMapReduceUtil.initTableSnapshotMapperJob(snapshotName, scan, MyTableMapper.class, MyMapKeyOutput.class, MyMapOutputValueWritable.class, job, true, restoreDir);\n```\n\n## Permission to access snapshot and data files\n\nGenerally, only the HBase owner or the HDFS admin have the permission to access HFiles.\n\n[HBASE-18659](https://issues.apache.org/jira/browse/HBASE-18659) uses HDFS ACLs to make HBase granted user have permission to access snapshot files.\n\n### HDFS ACLs\n\n[HDFS ACLs](https://hadoop.apache.org/docs/r2.7.1/hadoop-project-dist/hadoop-hdfs/HdfsPermissionsGuide.html#ACLs_Access_Control_Lists) supports an \"access ACL\", which defines the rules to enforce during permission checks, and a \"default ACL\", which defines the ACL entries that new child files or sub-directories receive automatically during creation. Via HDFS ACLs, HBase syncs granted users with read permission to HFiles.\n\n### Basic idea\n\nThe HBase files are organized in the following ways:\n\n* `{hbase-rootdir}/.tmp/data/{namespace}/{table}`\n* `{hbase-rootdir}/data/{namespace}/{table}`\n* `{hbase-rootdir}/archive/data/{namespace}/{table}`\n* `{hbase-rootdir}/.hbase-snapshot/{snapshotName}`\n\nSo the basic idea is to add or remove HDFS ACLs to files of the global/namespace/table directory\nwhen grant or revoke permission to global/namespace/table.\n\nSee the design doc in [HBASE-18659](https://issues.apache.org/jira/browse/HBASE-18659) for more details.\n\n### Configuration to use this feature\n\n* Firstly, make sure that HDFS ACLs are enabled and umask is set to 027\n\n  ```\n  dfs.namenode.acls.enabled = true\n  fs.permissions.umask-mode = 027\n  ```\n\n* Add master coprocessor, please make sure the SnapshotScannerHDFSAclController is configured after AccessController\n\n  ```\n  hbase.coprocessor.master.classes = \"org.apache.hadoop.hbase.security.access.AccessController\n  ,org.apache.hadoop.hbase.security.access.SnapshotScannerHDFSAclController\"\n  ```\n\n* Enable this feature\n\n  ```\n  hbase.acl.sync.to.hdfs.enable=true\n  ```\n\n* Modify table scheme to enable this feature for a specified table, this config is\n  false by default for every table, this means the HBase granted ACLs will not be synced to HDFS\n\n  ```ruby\n  alter 't1', CONFIGURATION => {'hbase.acl.sync.to.hdfs.enable' => 'true'}\n  ```\n\n### Limitation\n\nThere are some limitations for this feature:\n\n* If we enable this feature, some master operations such as grant, revoke, snapshot... (See the design doc for more details) will be slower as we need to sync HDFS ACLs to related hfiles.\n* HDFS has a config which limits the max ACL entries num for one directory or file:\n  ```\n  dfs.namenode.acls.max.entries = 32(default value)\n  ```\n  The 32 entries include four fixed users for each directory or file: owner, group, other, and mask. For a directory, the four users contain 8 ACL entries(access and default) and for a file, the four users contain 4 ACL entries(access). This means there are 24 ACL entries left for named users or groups.\\\n  Based on this limitation, we can only sync up to 12 HBase granted users' ACLs. This means, if a table enables this feature, then the total users with table, namespace of this table, global READ permission should not be greater than 12.\n* There are some cases that this coprocessor has not handled or could not handle, so the user HDFS ACLs are not synced normally. It will not make a reference link to another hfile of other tables.\n\n\n# Timeline-consistent High Available Reads (/docs/architecture/timeline-consistent-reads)\n\n\n## Introduction\n\nHBase, architecturally, always had the strong consistency guarantee from the start. All reads and writes are routed through a single region server, which guarantees that all writes happen in an order, and all reads are seeing the most recent committed data.\n\nHowever, because of this single homing of the reads to a single location, if the server becomes unavailable, the regions of the table that were hosted in the region server become unavailable for some time. There are three phases in the region recovery process - detection, assignment, and recovery. Of these, the detection is usually the longest and is presently in the order of 20-30 seconds depending on the ZooKeeper session timeout. During this time and before the recovery is complete, the clients will not be able to read the region data.\n\nHowever, for some use cases, either the data may be read-only, or doing reads against some stale data is acceptable. With timeline-consistent high available reads, HBase can be used for these kind of latency-sensitive use cases where the application can expect to have a time bound on the read completion.\n\nFor achieving high availability for reads, HBase provides a feature called *region replication*. In this model, for each region of a table, there will be multiple replicas that are opened in different RegionServers. By default, the region replication is set to 1, so only a single region replica is deployed and there will not be any changes from the original model. If region replication is set to 2 or more, then the master will assign replicas of the regions of the table. The Load Balancer ensures that the region replicas are not co-hosted in the same region servers and also in the same rack (if possible).\n\nAll of the replicas for a single region will have a unique replica*id, starting from 0. The region replica having replica\\_id==0 is called the primary region, and the others \\_secondary regions* or secondaries. Only the primary can accept writes from the client, and the primary will always contain the latest changes. Since all writes still have to go through the primary region, the writes are not highly-available (meaning they might block for some time if the region becomes unavailable).\n\n## Timeline Consistency\n\nWith this feature, HBase introduces a Consistency definition, which can be provided per read operation (get or scan).\n\n```java\npublic enum Consistency {\n    STRONG,\n    TIMELINE\n}\n```\n\n`Consistency.STRONG` is the default consistency model provided by HBase. In case the table has region replication = 1, or in a table with region replicas but the reads are done with this consistency, the read is always performed by the primary regions, so that there will not be any change from the previous behaviour, and the client always observes the latest data.\n\nIn case a read is performed with `Consistency.TIMELINE`, then the read RPC will be sent to the primary region server first. After a short interval (`hbase.client.primaryCallTimeout.get`, 10ms by default), parallel RPC for secondary region replicas will also be sent if the primary does not respond back. After this, the result is returned from whichever RPC is finished first. If the response came back from the primary region replica, we can always know that the data is latest. For this Result.isStale() API has been added to inspect the staleness. If the result is from a secondary region, then Result.isStale() will be set to true. The user can then inspect this field to possibly reason about the data.\n\nIn terms of semantics, TIMELINE consistency as implemented by HBase differs from pure eventual consistency in these respects:\n\n* Single homed and ordered updates: Region replication or not, on the write side, there is still only 1 defined replica (primary) which can accept writes. This replica is responsible for ordering the edits and preventing conflicts. This guarantees that two different writes are not committed at the same time by different replicas and the data diverges. With this, there is no need to do read-repair or last-timestamp-wins kind of conflict resolution.\n* The secondaries also apply the edits in the order that the primary committed them. This way the secondaries will contain a snapshot of the primaries data at any point in time. This is similar to RDBMS replications and even HBase's own multi-datacenter replication, however in a single cluster.\n* On the read side, the client can detect whether the read is coming from up-to-date data or is stale data. Also, the client can issue reads with different consistency requirements on a per-operation basis to ensure its own semantic guarantees.\n* The client can still observe edits out-of-order, and can go back in time, if it observes reads from one secondary replica first, then another secondary replica. There is no stickiness to region replicas or a transaction-id based guarantee. If required, this can be implemented later though.\n\n**Timeline Consistency**\n<img alt=\"Timeline Consistency\" src={__img0} placeholder=\"blur\" />\n\nTo better understand the TIMELINE semantics, let's look at the above diagram. Let's say that there are two clients, and the first one writes x=1 at first, then x=2 and x=3 later. As above, all writes are handled by the primary region replica. The writes are saved in the write ahead log (WAL), and replicated to the other replicas asynchronously. In the above diagram, notice that replica\\_id=1 received 2 updates, and its data shows that x=2, while the replica\\_id=2 only received a single update, and its data shows that x=1.\n\nIf client1 reads with STRONG consistency, it will only talk with the replica\\_id=0, and thus is guaranteed to observe the latest value of x=3. In case of a client issuing TIMELINE consistency reads, the RPC will go to all replicas (after primary timeout) and the result from the first response will be returned back. Thus the client can see either 1, 2 or 3 as the value of x. Let's say that the primary region has failed and log replication cannot continue for some time. If the client does multiple reads with TIMELINE consistency, she can observe x=2 first, then x=1, and so on.\n\n## Tradeoffs\n\nHaving secondary regions hosted for read availability comes with some tradeoffs which should be carefully evaluated per use case. Following are advantages and disadvantages.\n\n**Advantages:**\n\n* High availability for read-only tables\n* High availability for stale reads\n* Ability to do very low latency reads with very high percentile (99.9%+) latencies for stale reads\n\n**Disadvantages:**\n\n* Double / Triple MemStore usage (depending on region replication count) for tables with region replication > 1\n* Increased block cache usage\n* Extra network traffic for log replication\n* Extra backup RPCs for replicas\n\nTo serve the region data from multiple replicas, HBase opens the regions in secondary mode in the region servers. The regions opened in secondary mode will share the same data files with the primary region replica, however each secondary region replica will have its own MemStore to keep the unflushed data (only primary region can do flushes). Also to serve reads from secondary regions, the blocks of data files may be also cached in the block caches for the secondary regions.\n\n## Where is the code\n\nThis feature is delivered in two phases, Phase 1 and 2. The first phase is done in time for HBase-1.0.0 release. Meaning that using HBase-1.0.x, you can use all the features that are marked for Phase 1. Phase 2 is committed in HBase-1.1.0, meaning all HBase versions after 1.1.0 should contain Phase 2 items.\n\n## Propagating writes to region replicas\n\nAs discussed above writes only go to the primary region replica. For propagating the writes from the primary region replica to the secondaries, there are two different mechanisms. For read-only tables, you do not need to use any of the following methods. Disabling and enabling the table should make the data available in all region replicas. For mutable tables, you have to use **only** one of the following mechanisms: storefile refresher, or async wal replication. The latter is recommended.\n\n### StoreFile Refresher\n\nThe first mechanism is store file refresher which is introduced in HBase-1.0+. Store file refresher is a thread per region server, which runs periodically, and does a refresh operation for the store files of the primary region for the secondary region replicas. If enabled, the refresher will ensure that the secondary region replicas see the new flushed, compacted or bulk loaded files from the primary region in a timely manner. However, this means that only flushed data can be read back from the secondary region replicas, and after the refresher is run, making the secondaries lag behind the primary for an a longer time.\n\nFor turning this feature on, you should configure `hbase.regionserver.storefile.refresh.period` to a non-zero value. See Configuration section below.\n\n### Async WAL replication\n\nThe second mechanism for propagation of writes to secondaries is done via the “Async WAL Replication” feature. It is only available in HBase-1.1+. This works similarly to HBase's multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as “in-cluster replication”, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region's in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n\nCommitting writes in the same order as in primary ensures that the secondaries won't diverge from the primary regions data, but since the log replication is asynchronous, the data might still be stale in secondary regions.\n\nAsync WAL Replication is **disabled** by default. You can enable this feature by setting `hbase.region.replica.replication.enabled` to `true`.\n\nBefore 3.0.0, this feature works as a replication endpoint, the performance and latency characteristics is expected to be similar to inter-cluster replication. And once enabled, it will create a replication peer named `region_replica_replication` as a replication peer when you create a table with region replication > 1 for the first time.\n\nif you want to disable this feature, you need to do two actions in the following order: \\* Set configuration property `hbase.region.replica.replication.enabled` to false in `hbase-site.xml` (see Configuration section below) \\* Disable the replication peer named `region_replica_replication` in the cluster using hbase shell or `Admin` class:\n\n```ruby\nhbase> disable_peer 'region_replica_replication'\n```\n\nIn 3.0.0, this feature is re-implemented to decouple with the general replication framework. Now we do not need to create a special replication peer. And during rolling upgrading, we will remove this replication peer automatically if it is present. See [HBASE-26233](https://issues.apache.org/jira/browse/HBASE-26233) and the design doc in our git repo for more details.\n\nAsync WAL Replication and the `hbase:meta` table is a little more involved and gets its own section below; see [Region replication for META table's region](/docs/architecture/timeline-consistent-reads#region-replication-for-meta-tables-region)\n\n## Store File TTL\n\nIn both of the write propagation approaches mentioned above, store files of the primary will be opened in secondaries independent of the primary region. So for files that the primary compacted away, the secondaries might still be referring to these files for reading. Both features are using HFileLinks to refer to files, but there is no protection (yet) for guaranteeing that the file will not be deleted prematurely. Thus, as a guard, you should set the configuration property `hbase.master.hfilecleaner.ttl` to a larger value, such as 1 hour to guarantee that you will not receive IOExceptions for requests going to replicas.\n\n## Region replication for META table's region\n\nThe general Async WAL Replication does not work for the META table's WAL. The meta table's secondary replicas refresh themselves from the persistent store files every `hbase.regionserver.meta.storefile.refresh.period`, (a non-zero value). Note how the META replication period is distinct from the user-space `hbase.regionserver.storefile.refresh.period` value.\n\n### Async WAL Replication for META table as of hbase-2.4.0+\n\nAsync WAL replication for META is added as a new feature in 2.4.0. Set `hbase.region.replica.replication.catalog.enabled` to enable async WAL Replication for META region replicas. It is off by default.\n\nRegarding META replicas count, up to hbase-2.4.0, you would set the special property 'hbase.meta.replica.count'. Now you can alter the META table as you would a user-space table (if `hbase.meta.replica.count` is set, it will take precedent over what is set for replica count in the META table updating META replica count to match).\n\n### Async WAL Replication for META table as of hbase-3.0.0+\n\nIn [HBASE-26233](https://issues.apache.org/jira/browse/HBASE-26233) we re-implemented the region replication framework to not rely on the general replication framework, so it can work together with META table as well. The code described in the above section have been removed mostly, but the config `hbase.region.replica.replication.catalog.enabled` is still kept, you could still use it to control whether to enable async wal replication for META table. And the ability to alter META table is also kept.\n\n### Load Balancing META table load\n\nhbase-2.4.0 also adds a new client-side `LoadBalance` mode. When enabled client-side, clients will try to read META replicas first before falling back on the primary. Before this, the replica lookup mode — now named `HedgedRead` in hbase-2.4.0 — had clients read the primary and if no response after a configurable amount of time had elapsed, it would start up reads against the replicas. Starting from hbase-2.4.12(and all higher minor versions), with client-side `LoadBalance` mode, clients load balance META scan requests across all META replica regions, including the primary META region. In case of exceptions such as NotServingRegionException, it will fall back on the primary META region.\n\nThe new 'LoadBalance' mode helps alleviate hotspotting on the META table distributing META read load.\n\nTo enable the meta replica locator's load balance mode, please set the following configuration at on the **client-side** (only): set 'hbase.locator.meta.replicas.mode' to \"LoadBalance\". Valid options for this configuration are `None`, `HedgedRead`, and `LoadBalance`. Option parse is case insensitive. The default mode is `None` (which falls through to `HedgedRead`, the current default). Do NOT put this configuration in any hbase server-side's configuration, Master or RegionServer (Master could make decisions based off stale state — to be avoided).\n\n## Memory accounting\n\nThe secondary region replicas refer to the data files of the primary region replica, but they have their own memstores (in HBase-1.1+) and uses block cache as well. However, one distinction is that the secondary region replicas cannot flush the data when there is memory pressure for their memstores. They can only free up memstore memory when the primary region does a flush and this flush is replicated to the secondary. Since in a region server hosting primary replicas for some regions and secondaries for some others, the secondaries might cause extra flushes to the primary regions in the same host. In extreme situations, there can be no memory left for adding new writes coming from the primary via wal replication. For unblocking this situation (and since secondary cannot flush by itself), the secondary is allowed to do a “store file refresh” by doing a file system list operation to pick up new files from primary, and possibly dropping its memstore. This refresh will only be performed if the memstore size of the biggest secondary region replica is at least `hbase.region.replica.storefile.refresh.memstore.multiplier` (default 4) times bigger than the biggest memstore of a primary replica. One caveat is that if this is performed, the secondary can observe partial row updates across column families (since column families are flushed independently). The default should be good to not do this operation frequently. You can set this value to a large number to disable this feature if desired, but be warned that it might cause the replication to block forever.\n\n## Secondary replica failover\n\nWhen a secondary region replica first comes online, or fails over, it may have served some edits from its memstore. Since the recovery is handled differently for secondary replicas, the secondary has to ensure that it does not go back in time before it starts serving requests after assignment. For doing that, the secondary waits until it observes a full flush cycle (start flush, commit flush) or a “region open event” replicated from the primary. Until this happens, the secondary region replica will reject all read requests by throwing an IOException with message “The region's reads are disabled”. However, the other replicas will probably still be available to read, thus not causing any impact for the rpc with TIMELINE consistency. To facilitate faster recovery, the secondary region will trigger a flush request from the primary when it is opened. The configuration property `hbase.region.replica.wait.for.primary.flush` (enabled by default) can be used to disable this feature if needed.\n\n## Configuration properties\n\nTo use highly available reads, you should set the following properties in `hbase-site.xml` file. There is no specific configuration to enable or disable region replicas. Instead you can change the number of region replicas per table to increase or decrease at the table creation or with alter table. The following configuration is for using async wal replication and using meta replicas of 3.\n\n### Server side properties\n\n```xml\n<property>\n  <name>hbase.regionserver.storefile.refresh.period</name>\n  <value>0</value>\n  <description>\n    The period (in milliseconds) for refreshing the store files for the secondary regions. 0 means this feature is disabled. Secondary regions sees new files (from flushes and compactions) from primary once the secondary region refreshes the list of files in the region (there is no notification mechanism). But too frequent refreshes might cause extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger value is also recommended with this setting.\n  </description>\n</property>\n\n<property>\n  <name>hbase.regionserver.meta.storefile.refresh.period</name>\n  <value>300000</value>\n  <description>\n    The period (in milliseconds) for refreshing the store files for the hbase:meta tables secondary regions. 0 means this feature is disabled. Secondary regions sees new files (from flushes and compactions) from primary once the secondary region refreshes the list of files in the region (there is no notification mechanism). But too frequent refreshes might cause extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger value is also recommended with this setting. This should be a non-zero number if meta replicas are enabled.\n  </description>\n</property>\n\n<property>\n  <name>hbase.region.replica.replication.enabled</name>\n  <value>true</value>\n  <description>\n    Whether asynchronous WAL replication to the secondary region replicas is enabled or not. If this is enabled, a replication peer named \"region_replica_replication\" will be created which will tail the logs and replicate the mutations to region replicas for tables that have region replication > 1. If this is enabled once, disabling this replication also requires disabling the replication peer using shell or Admin java class. Replication to secondary region replicas works over standard inter-cluster replication.\n  </description>\n</property>\n\n<property>\n  <name>hbase.master.hfilecleaner.ttl</name>\n  <value>3600000</value>\n  <description>\n    The period (in milliseconds) to keep store files in the archive folder before deleting them from the file system.\n  </description>\n</property>\n\n<property>\n  <name>hbase.region.replica.storefile.refresh.memstore.multiplier</name>\n  <value>4</value>\n  <description>\n    The multiplier for a \"store file refresh\" operation for the secondary region replica. If a region server has memory pressure, the secondary region will refresh it's store files if the memstore size of the biggest secondary replica is bigger this many times than the memstore size of the biggest primary replica. Set this to a very big value to disable this feature (not recommended).\n  </description>\n</property>\n\n<property>\n  <name>hbase.region.replica.wait.for.primary.flush</name>\n  <value>true</value>\n  <description>\n    Whether to wait for observing a full flush cycle from the primary before start serving data in a secondary. Disabling this might cause the secondary region replicas to go back in time for reads between region movements.Please note that if you set per-table property `REGION_MEMSTORE_REPLICATION` to false,`hbase.region.replica.wait.for.primary.flush` will be ignored.\n  </description>\n</property>\n```\n\nOne thing to keep in mind also is that, region replica placement policy is only enforced by the `StochasticLoadBalancer` which is the default balancer. If you are using a custom load balancer property in hbase-site.xml (`hbase.master.loadbalancer.class`) replicas of regions might end up being hosted in the same server.\n\n### Client side properties\n\nEnsure to set the following for all clients (and servers) that will use region replicas.\n\n```xml\n<property>\n  <name>hbase.ipc.client.specificThreadForWriting</name>\n  <value>true</value>\n  <description>\n    Whether to enable interruption of RPC threads at the client side. This is required for region replicas with fallback RPC's to secondary regions.\n  </description>\n</property>\n<property>\n  <name>hbase.client.primaryCallTimeout.get</name>\n  <value>10000</value>\n  <description>\n    The timeout (in microseconds), before secondary fallback RPC's are submitted for get requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC's, but will lower the p99 latencies.\n  </description>\n</property>\n<property>\n  <name>hbase.client.primaryCallTimeout.multiget</name>\n  <value>10000</value>\n  <description>\n    The timeout (in microseconds), before secondary fallback RPC's are submitted for multi-get requests (Table.get(List<Get>)) with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC's, but will lower the p99 latencies.\n  </description>\n</property>\n<property>\n  <name>hbase.client.replicaCallTimeout.scan</name>\n  <value>1000000</value>\n  <description>\n    The timeout (in microseconds), before secondary fallback RPC's are submitted for scan requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 1 sec. Setting this lower will increase the number of RPC's, but will lower the p99 latencies.\n  </description>\n</property>\n<property>\n  <name>hbase.meta.replicas.use</name>\n  <value>true</value>\n  <description>\n    Whether to use meta table replicas or not. Default is false.\n  </description>\n</property>\n```\n\nNote HBase-1.0.x users should use `hbase.ipc.client.allowsInterrupt` rather than `hbase.ipc.client.specificThreadForWriting`.\n\n## User Interface\n\nIn the masters user interface, the region replicas of a table are also shown together with the primary regions. You can notice that the replicas of a region will share the same start and end keys and the same region name prefix. The only difference would be the appended replica\\_id (which is encoded as hex), and the region encoded name will be different. You can also see the replica ids shown explicitly in the UI.\n\n## Creating a table with region replication\n\nRegion replication is a per-table property. All tables have `REGION_REPLICATION = 1` by default, which means that there is only one replica per region. You can set and change the number of replicas per region of a table by supplying the `REGION_REPLICATION` property in the table descriptor.\n\nThere is another per-table property `REGION_MEMSTORE_REPLICATION`.All tables have `REGION_MEMSTORE_REPLICATION = true` by default, which means the new data written to the primary region should be replicated. If you set this to `false`, replicas do not receive memstore updates from the primary RegionServer,they will only receive updates for events like flushes and bulkloads, and will not have access to data which the primary has not yet flushed. Please note that if you set `REGION_MEMSTORE_REPLICATION` to false,`hbase.region.replica.wait.for.primary.flush` will be ignored.\n\n### Shell\n\n```ruby\ncreate 't1', 'f1', {REGION_REPLICATION => 2}\n\ndescribe 't1'\nfor i in 1..100\nput 't1', \"r#{i}\", 'f1:c1', i\nend\nflush 't1'\n```\n\n### Java\n\n```java\nHTableDescriptor htd = new HTableDescriptor(TableName.valueOf(“test_table”));\nhtd.setRegionReplication(2);\n...\nadmin.createTable(htd);\n```\n\nYou can also use `setRegionReplication()` and alter table to increase, decrease the region replication for a table.\n\n## Read API and Usage\n\n### Shell\n\nYou can do reads in shell using a the Consistency.TIMELINE semantics as follows\n\n```java\nhbase(main):001:0> get 't1','r6', {CONSISTENCY => \"TIMELINE\"}\n```\n\nYou can simulate a region server pausing or becoming unavailable and do a read from the secondary replica:\n\n```bash\n$ kill -STOP <pid or primary region server>\n\nhbase(main):001:0> get 't1','r6', {CONSISTENCY => \"TIMELINE\"}\n```\n\nUsing scans is also similar\n\n```java\nhbase> scan 't1', {CONSISTENCY => 'TIMELINE'}\n```\n\n### Java\n\nYou can set the consistency for Gets and Scans and do requests as follows.\n\n```java\nGet get = new Get(row);\nget.setConsistency(Consistency.TIMELINE);\n...\nResult result = table.get(get);\n```\n\nYou can also pass multiple gets:\n\n```java\nGet get1 = new Get(row);\nget1.setConsistency(Consistency.TIMELINE);\n...\nArrayList<Get> gets = new ArrayList<Get>();\ngets.add(get1);\n...\nResult[] results = table.get(gets);\n```\n\nAnd Scans:\n\n```java\nScan scan = new Scan();\nscan.setConsistency(Consistency.TIMELINE);\n...\nResultScanner scanner = table.getScanner(scan);\n```\n\nYou can inspect whether the results are coming from primary region or not by calling the `Result.isStale()` method:\n\n```java\nResult result = table.get(get);\nif (result.isStale()) {\n  ...\n}\n```\n\n\n# HBase and the Apache Software Foundation (/docs/asf)\n## ASF Development Process\n\nSee the [Apache Development Process page](https://www.apache.org/dev/#committers) for all sorts of information on how the ASF is structured (e.g., PMC, committers, contributors), to tips on contributing and getting involved, and how open-source works at ASF.\n\n## ASF Board Reporting\n\nOnce a quarter, each project in the ASF portfolio submits a report to the ASF board. This is done by the HBase project lead and the committers. See [ASF board reporting](https://www.apache.org/foundation/board/reporting) for more information.\n\n\n# Additional Topics (/docs/backup-restore/additional-topics)\n\n\n## Configuration keys\n\nThe backup and restore feature includes both required and optional configuration keys.\n\n### Required properties\n\n***hbase.backup.enable***: Controls whether or not the feature is enabled (Default: `false`). Set this value to `true`.\n\n***hbase.master.logcleaner.plugins***: A comma-separated list of classes invoked when cleaning logs in the HBase Master. Set\nthis value to `org.apache.hadoop.hbase.backup.master.BackupLogCleaner` or append it to the current value.\n\n***hbase.procedure.master.classes***: A comma-separated list of classes invoked with the Procedure framework in the Master. Set\nthis value to `org.apache.hadoop.hbase.backup.master.LogRollMasterProcedureManager` or append it to the current value.\n\n***hbase.procedure.regionserver.classes***: A comma-separated list of classes invoked with the Procedure framework in the RegionServer.\nSet this value to `org.apache.hadoop.hbase.backup.regionserver.LogRollRegionServerProcedureManager` or append it to the current value.\n\n***hbase.coprocessor.region.classes***: A comma-separated list of RegionObservers deployed on tables. Set this value to\n`org.apache.hadoop.hbase.backup.BackupObserver` or append it to the current value.\n\n***hbase.coprocessor.master.classes***: A comma-separated list of MasterObservers deployed on tables. Set this value to\n`org.apache.hadoop.hbase.backup.BackupMasterObserver` or append it to the current value.\n\n***hbase.master.hfilecleaner.plugins***: A comma-separated list of HFileCleaners deployed on the Master. Set this value\nto `org.apache.hadoop.hbase.backup.BackupHFileCleaner` or append it to the current value.\n\n### Optional properties\n\n***hbase.backup.system.ttl***: The time-to-live in seconds of data in the `hbase:backup` tables (default: forever). This property\nis only relevant prior to the creation of the `hbase:backup` table. Use the `alter` command in the HBase shell to modify the TTL\nwhen this table already exists. See the [below section](/docs/backup-restore/additional-topics#a-warning-on-file-system-growth) for more details on the impact of this\nconfiguration property.\n\n***hbase.backup.attempts.max***: The number of attempts to perform when taking hbase table snapshots (default: 10).\n\n***hbase.backup.attempts.pause.ms***: The amount of time to wait between failed snapshot attempts in milliseconds (default: 10000).\n\n***hbase.backup.logroll.timeout.millis***: The amount of time (in milliseconds) to wait for RegionServers to execute a WAL rolling\nin the Master's procedure framework (default: 30000).\n\n## Best Practices\n\n### Formulate a restore strategy and test it.\n\nBefore you rely on a backup and restore strategy for your production environment, identify how backups must be performed,\nand more importantly, how restores must be performed. Test the plan to ensure that it is workable.\nAt a minimum, store backup data from a production cluster on a different cluster or server. To further safeguard the data,\nuse a backup location that is at a different physical location.\n\nIf you have a unrecoverable loss of data on your primary production cluster as a result of computer system issues, you may\nbe able to restore the data from a different cluster or server at the same site. However, a disaster that destroys the whole\nsite renders locally stored backups useless. Consider storing the backup data and necessary resources (both computing capacity\nand operator expertise) to restore the data at a site sufficiently remote from the production site. In the case of a catastrophe\nat the whole primary site (fire, earthquake, etc.), the remote backup site can be very valuable.\n\n### Secure a full backup image first.\n\nAs a baseline, you must complete a full backup of HBase data at least once before you can rely on incremental backups. The full\nbackup should be stored outside of the source cluster. To ensure complete dataset recovery, you must run the restore utility\nwith the option to restore baseline full backup. The full backup is the foundation of your dataset. Incremental backup data\nis applied on top of the full backup during the restore operation to return you to the point in time when backup was last taken.\n\n### Define and use backup sets for groups of tables that are logical subsets of the entire dataset.\n\nYou can group tables into an object called a backup set. A backup set can save time when you have a particular group of tables\nthat you expect to repeatedly back up or restore.\n\nWhen you create a backup set, you type table names to include in the group. The backup set includes not only groups of related\ntables, but also retains the HBase backup metadata. Afterwards, you can invoke the backup set name to indicate what tables apply\nto the command execution instead of entering all the table names individually.\n\n### Document the backup and restore strategy, and ideally log information about each backup.\n\nDocument the whole process so that the knowledge base can transfer to new administrators after employee turnover. As an extra\nsafety precaution, also log the calendar date, time, and other relevant details about the data of each backup. This metadata\ncan potentially help locate a particular dataset in case of source cluster failure or primary site disaster. Maintain duplicate\ncopies of all documentation: one copy at the production cluster site and another at the backup location or wherever it can be\naccessed by an administrator remotely from the production cluster.\n\n## Scenario: Safeguarding Application Datasets on Amazon S3\n\nThis scenario describes how a hypothetical retail business uses backups to safeguard application data and then restore the dataset\nafter failure.\n\nThe HBase administration team uses backup sets to store data from a group of tables that have interrelated information for an\napplication called green. In this example, one table contains transaction records and the other contains customer details. The\ntwo tables need to be backed up and be recoverable as a group.\n\nThe admin team also wants to ensure daily backups occur automatically.\n\n<img alt=\"Tables Composing The Backup Set\" src={__img0} placeholder=\"blur\" />\n\nThe following is an outline of the steps and examples of commands that are used to backup the data for the *green* application and\nto recover the data later. All commands are run when logged in as HBase superuser.\n\n* A backup set called *green\\_set* is created as an alias for both the transactions table and the customer table. The backup set can\n  be used for all operations to avoid typing each table name. The backup set name is case-sensitive and should be formed with only\n  printable characters and without spaces.\n\n  ```bash\n  $ hbase backup set add green_set transactions\n  $ hbase backup set add green_set customer\n  ```\n\n* The first backup of green\\_set data must be a full backup. The following command example shows how credentials are passed to Amazon\n  S3 and specifies the file system with the s3a: prefix.\n\n  ```bash\n  $ ACCESS_KEY=ABCDEFGHIJKLMNOPQRST\n  $ SECRET_KEY=123456789abcdefghijklmnopqrstuvwxyzABCD\n  $ sudo -u hbase hbase backup create full\\\n    s3a://$ACCESS_KEY:SECRET_KEY@prodhbasebackups/backups -s green_set\n  ```\n\n* Incremental backups should be run according to a schedule that ensures essential data recovery in the event of a catastrophe. At\n  this retail company, the HBase admin team decides that automated daily backups secures the data sufficiently. The team decides that\n  they can implement this by modifying an existing Cron job that is defined in `/etc/crontab`. Consequently, IT modifies the Cron job\n  by adding the following line:\n\n  ```bash\n  @daily hbase hbase backup create incremental s3a://$ACCESS_KEY:$SECRET_KEY@prodhbasebackups/backups -s green_set\n  ```\n\n* A catastrophic IT incident disables the production cluster that the green application uses. An HBase system administrator of the\n  backup cluster must restore the *green\\_set* dataset to the point in time closest to the recovery objective.\n\n  <Callout type=\"info\">\n    If the administrator of the backup HBase cluster has the backup ID with relevant details in accessible records, the following\n    search with the `hdfs dfs -ls` command and manually scanning the backup ID list can be bypassed. Consider continuously maintaining\n    and protecting a detailed log of backup IDs outside the production cluster in your environment.\n  </Callout>\n\n  The HBase administrator runs the following command on the directory where backups are stored to print the list of successful backup\n  IDs on the console:\n\n  ```bash\n  hdfs dfs -ls -t /prodhbasebackups/backups\n  ```\n\n* The admin scans the list to see which backup was created at a date and time closest to the recovery objective. To do this, the\n  admin converts the calendar timestamp of the recovery point in time to Unix time because backup IDs are uniquely identified with\n  Unix time. The backup IDs are listed in reverse chronological order, meaning the most recent successful backup appears first.\n\n  The admin notices that the following line in the command output corresponds with the *green\\_set* backup that needs to be restored:\n\n  ```bash\n  /prodhbasebackups/backups/backup_1467823988425`\n  ```\n\n* The admin restores green\\_set invoking the backup ID and the -overwrite option. The -overwrite option truncates all existing data\n  in the destination and populates the tables with data from the backup dataset. Without this flag, the backup data is appended to the\n  existing data in the destination. In this case, the admin decides to overwrite the data because it is corrupted.\n\n  ```bash\n  $ sudo -u hbase hbase restore -s green_set \\\n    s3a://$ACCESS_KEY:$SECRET_KEY@prodhbasebackups/backups backup_1467823988425 \\ -overwrite\n  ```\n\n## Security of Backup Data\n\nWith this feature which makes copying data to remote locations, it's important to take a moment to clearly state the procedural\nconcerns that exist around data security. Like the HBase replication feature, backup and restore provides the constructs to automatically\ncopy data from within a corporate boundary to some system outside of that boundary. It is imperative when storing sensitive data that with backup and restore, much\nless any feature which extracts data from HBase, the locations to which data is being sent has undergone a security audit to ensure\nthat only authenticated users are allowed to access that data.\n\nFor example, with the above example of backing up data to S3, it is of the utmost importance that the proper permissions are assigned\nto the S3 bucket to ensure that only a minimum set of authorized users are allowed to access this data. Because the data is no longer\nbeing accessed via HBase, and its authentication and authorization controls, we must ensure that the filesystem storing that data is\nproviding a comparable level of security. This is a manual step which users **must** implement on their own.\n\n## Technical Details of Incremental Backup and Restore\n\nHBase incremental backups enable more efficient capture of HBase table images than previous attempts\nat serial backup and restore solutions, such as those that only used HBase Export and Import APIs.\nIncremental backups use Write Ahead Logs (WALs) to capture the data changes since the\nprevious backup was created. A WAL roll (create new WALs) is executed across all RegionServers\nto track the WALs that need to be in the backup.\nIn addition to WALs, incremental backups also track bulk-loaded HFiles for tables under backup.\n\nIncremental backup gathers all WAL files generated since the last backup from the source cluster,\nconverts them to HFiles in a `.tmp` directory under the `BACKUP_ROOT`, and then moves these\nHFiles to their final location under the backup root directory to form the backup image.\nIt also reads bulk load records from the backup system table, forms the paths for the corresponding\nbulk-loaded HFiles, and copies those files to the backup destination.\nBulk-loaded files are preserved (not deleted by cleaner chores) until they've been included in a\nbackup (for each backup root).\nA process similar to the DistCp (distributed copy) tool is used to move the backup files to the\ntarget file system.\n\nWhen a table restore operation starts, a two-step process is initiated.\nFirst, the full backup is restored from the full backup image.\nSecond, all HFiles from incremental backups between the last full backup and the incremental backup\nbeing restored (including bulk-loaded HFiles) are bulk loaded into the table using the\nHBase Bulk Load utility.\n\nYou can only restore on a live HBase cluster because the data must be redistributed to complete the restore operation successfully.\n\n## A Warning on File System Growth\n\nAs a reminder, incremental backups are implemented via retaining the write-ahead logs which HBase primarily uses for data durability.\nThus, to ensure that all data needing to be included in a backup is still available in the system, the HBase backup and restore feature\nretains all write-ahead logs since the last backup until the next incremental backup is executed.\n\nLike HBase Snapshots, this can have an expectedly large impact on the HDFS usage of HBase for high volume tables. Take care in enabling\nand using the backup and restore feature, specifically with a mind to removing backup sessions when they are not actively being used.\n\nThe only automated, upper-bound on retained write-ahead logs for backup and restore is based on the TTL of the `hbase:backup` system table which,\nas of the time this document is written, is infinite (backup table entries are never automatically deleted). This requires that administrators\nperform backups on a schedule whose frequency is relative to the amount of available space on HDFS (e.g. less available HDFS space requires\nmore aggressive backup merges and deletions). As a reminder, the TTL can be altered on the `hbase:backup` table using the `alter` command\nin the HBase shell. Modifying the configuration property `hbase.backup.system.ttl` in hbase-site.xml after the system table exists has no effect.\n\n## Capacity Planning\n\nWhen designing a distributed system deployment, it is critical that some basic mathmatical rigor is executed to ensure sufficient computational\ncapacity is available given the data and software requirements of the system. For this feature, the availability of network capacity is the largest\nbottleneck when estimating the performance of some implementation of backup and restore. The second most costly function is the speed at which\ndata can be read/written.\n\n### Full Backups\n\nTo estimate the duration of a full backup, we have to understand the general actions which are invoked:\n\n* Write-ahead log roll on each RegionServer: ones to tens of seconds per RegionServer in parallel. Relative to the load on each RegionServer.\n* Take an HBase snapshot of the table(s): tens of seconds. Relative to the number of regions and files that comprise the table.\n* Export the snapshot to the destination: see below. Relative to the size of the data and the network bandwidth to the destination.\n\nTo approximate how long the final step will take, we have to make some assumptions on hardware. Be aware that these will *not* be accurate for your\nsystem — these are numbers that your or your administrator know for your system. Let's say the speed of reading data from HDFS on a single node is\ncapped at 80MB/s (across all Mappers that run on that host), a modern network interface controller (NIC) supports 10Gb/s, the top-of-rack switch can\nhandle 40Gb/s, and the WAN between your clusters is 10Gb/s. This means that you can only ship data to your remote at a speed of 1.25GB/s — meaning\nthat 16 nodes (`1.25 * 1024 / 80 = 16`) participating in the ExportSnapshot should be able to fully saturate the link between clusters. With more\nnodes in the cluster, we can still saturate the network but at a lesser impact on any one node which helps ensure local SLAs are made. If the size\nof the snapshot is 10TB, this would full backup would take in the ballpark of 2.5 hours (`10 * 1024 / 1.25 / (60 * 60) = 2.23hrs`)\n\nAs a general statement, it is very likely that the WAN bandwidth between your local cluster and the remote storage is the largest\nbottleneck to the speed of a full backup.\n\nWhen the concern is restricting the computational impact of backups to a \"production system\", the above formulas can be reused with the optional\ncommand-line arguments to `hbase backup create`: `-b`, `-w`, `-q`. The `-b` option defines the bandwidth at which each worker (Mapper) would\nwrite data. The `-w` argument limits the number of workers that would be spawned in the DistCp job. The `-q` allows the user to specify a YARN\nqueue which can limit the specific nodes where the workers will be spawned — this can quarantine the backup workers performing the copy to\na set of non-critical nodes. Relating the `-b` and `-w` options to our earlier equations: `-b` would be used to restrict each node from reading\ndata at the full 80MB/s and `-w` is used to limit the job from spawning 16 worker tasks.\n\n### Incremental Backup\n\nLike we did for full backups, we have to understand the incremental backup process to approximate its runtime and cost.\n\n* Identify new write-ahead logs since the last full or incremental backup: negligible. Apriori knowledge from the backup system table(s).\n* Read, filter, and write \"minimized\" HFiles equivalent to the WALs: dominated by the speed of writing data. Relative to write speed of HDFS.\n* Read bulk load records from the backup system table, form the paths for bulk-loaded HFiles, and copy them to the backup destination.\n* DistCp the HFiles to the destination: [see above](/docs/backup-restore/additional-topics#full-backups).\n\nFor the second step, the dominating cost of this operation would be the re-writing the data (under the assumption that a majority of the\ndata in the WAL is preserved). In this case, we can assume an aggregate write speed of 30MB/s per node. Continuing our 16-node cluster example,\nthis would require approximately 15 minutes to perform this step for 50GB of data (50 \\* 1024 / 60 / 60 = 14.2). The amount of time to start the\nDistCp MapReduce job would likely dominate the actual time taken to copy the data (50 / 1.25 = 40 seconds) and can be ignored.\n\n## Limitations of the Backup and Restore Utility\n\n**Serial backup operations**\\\nBackup operations cannot be run concurrently. An operation includes actions like create, delete, restore, and merge. Only one active backup session is supported. [HBASE-16391](https://issues.apache.org/jira/browse/HBASE-16391)\nwill introduce multiple-backup sessions support.\n\n**No means to cancel backups**\\\nBoth backup and restore operations cannot be canceled. ([HBASE-15997](https://issues.apache.org/jira/browse/HBASE-15997), [HBASE-15998](https://issues.apache.org/jira/browse/HBASE-15998)).\nThe workaround to cancel a backup would be to kill the client-side backup command (`control-C`), ensure all relevant MapReduce jobs have exited, and then\nrun the `hbase backup repair` command to ensure the system backup metadata is consistent.\n\n**Backups can only be saved to a single location**\\\nCopying backup information to multiple locations is an exercise left to the user. [HBASE-15476](https://issues.apache.org/jira/browse/HBASE-15476) will\nintroduce the ability to specify multiple-backup destinations intrinsically.\n\n**HBase superuser access is required**\\\nOnly an HBase superuser (e.g. hbase) is allowed to perform backup/restore, can pose a problem for shared HBase installations. Current mitigations would require\ncoordination with system administrators to build and deploy a backup and restore strategy ([HBASE-14138](https://issues.apache.org/jira/browse/HBASE-14138)).\n\n**Backup restoration is an online operation**\\\nTo perform a restore from a backup, it requires that the HBase cluster is online as a caveat of the current implementation ([HBASE-16573](https://issues.apache.org/jira/browse/HBASE-16573)).\n\n**Some operations may fail and require re-run**\\\nThe HBase backup feature is primarily client driven. While there is the standard HBase retry logic built into the HBase Connection, persistent errors in executing operations\nmay propagate back to the client (e.g. snapshot failure due to region splits). The backup implementation should be moved from client-side into the ProcedureV2 framework\nin the future which would provide additional robustness around transient/retryable failures. The `hbase backup repair` command is meant to correct states which the system\ncannot automatically detect and recover from.\n\n**Avoidance of declaration of public API**\\\nWhile the Java API to interact with this feature exists and its implementation is separated from an interface, insufficient rigor has been applied to determine if\nit is exactly what we intend to ship to users. As such, it is marked as for a `Private` audience with the expectation that, as users begin to try the feature, there\nwill be modifications that would necessitate breaking compatibility ([HBASE-17517](https://issues.apache.org/jira/browse/HBASE-17517)).\n\n**Lack of global metrics for backup and restore**\\\nIndividual backup and restore operations contain metrics about the amount of work the operation included, but there is no centralized location (e.g. the Master UI)\nwhich present information for consumption ([HBASE-16565](https://issues.apache.org/jira/browse/HBASE-16565)).\n\n\n# Administration of Backup Images (/docs/backup-restore/administration)\nThe `hbase backup` command has several subcommands that help with administering backup images as they accumulate. Most production\nenvironments require recurring backups, so it is necessary to have utilities to help manage the data of the backup repository.\nSome subcommands enable you to find information that can help identify backups that are relevant in a search for particular data.\nYou can also delete backup images.\n\nThe following list details each `hbase backup subcommand` that can help administer backups. Run the full command-subcommand line as\nthe HBase superuser.\n\n### Managing Backup Progress\n\nYou can monitor a running backup in another terminal session by running the *hbase backup progress* command and specifying the backup ID as an argument.\n\nFor example, run the following command as hbase superuser to view the progress of a backup\n\n```bash\n$ hbase backup progress <backup_id>\n```\n\n#### Positional Command-Line Arguments\n\n***backup\\_id***\\\nSpecifies the backup that you want to monitor by seeing the progress information. The backupId is case-sensitive.\n\n#### Named Command-Line Arguments\n\nNone.\n\n#### Example usage\n\n```bash\nhbase backup progress backupId_1467823988425\n```\n\n### Managing Backup History\n\nThis command displays a log of backup sessions. The information for each session includes backup ID, type (full or incremental), the tables\nin the backup, status, and start and end time. Specify the number of backup sessions to display with the optional -n argument.\n\n```bash\n$ hbase backup history <backup_id>\n```\n\n#### Positional Command-Line Arguments\n\n***backup\\_id***\\\nSpecifies the backup that you want to monitor by seeing the progress information. The backupId is case-sensitive.\n\n#### Named Command-Line Arguments\n\n***-n \\<num\\_records>***\\\n(Optional) The maximum number of backup records (Default: 10).\n\n***-p \\<backup\\_root\\_path>***\\\nThe full filesystem URI of where backup images are stored.\n\n***-s \\<backup\\_set\\_name>***\\\nThe name of the backup set to obtain history for. Mutually exclusive with the *-t* option.\n\n***-t \\<table\\_name>***\\\nThe name of table to obtain history for. Mutually exclusive with the *-s* option.\n\n#### Example usage\n\n```bash\n$ hbase backup history\n$ hbase backup history -n 20\n$ hbase backup history -t WebIndexRecords\n```\n\n### Describing a Backup Image\n\nThis command can be used to obtain information about a specific backup image.\n\n```bash\n$ hbase backup describe <backup_id>\n```\n\n#### Positional Command-Line Arguments\n\n***backup\\_id***\nThe ID of the backup image to describe.\n\n#### Named Command-Line Arguments\n\nNone.\n\n#### Example usage\n\n```bash\n$ hbase backup describe backupId_1467823988425\n```\n\n### Deleting Backup Images\n\nThe `hbase backup delete` command deletes backup images that are no longer needed.\n\n#### Syntax\n\n```bash\n$ hbase backup delete -l <backup_id1,backup_id2,...>\n$ hbase backup delete -k <days>\n```\n\n#### Named Command-Line Arguments\n\n***-l \\<backup\\_id1,backup\\_id2,...>***\\\nComma-separated list of backup IDs to delete.\n\n***-k \\<days>***\\\nDeletes all backup images completed more than the specified number of days ago.\n\n<Callout type=\"info\">\n  These options are **mutually exclusive**. Only one of `-l` or `-k` may be used at a time.\n</Callout>\n\n#### Example Usage\n\nDelete specific backup images by ID:\n\n```bash\n$ hbase backup delete -l backupId_1467823988425,backupId_1467824989999\n```\n\nDelete all backup images older than 30 days:\n\n```bash\n$ hbase backup delete -k 30\n```\n\n<Callout type=\"warn\">\n  * Deleting a backup may affect all following incremental backups (in the same backup root) up to\n    the next full backup. For example, if you take a full backup every 2 weeks and\n    daily incremental backups, running `hbase backup delete -k 7` when the full backup is older than\n    7 days will effectively remove the data for all subsequent incremental backups.\n    The backup IDs may still be listed, but their data will be gone.\n\n  * If the most recent backup is an incremental backup and you delete it,\n    you should run a **full backup** next.\n    Running another incremental backup immediately after may result in missing data in the\n    backup image. (See [HBASE-28084](https://issues.apache.org/jira/browse/HBASE-28084))\n</Callout>\n\n### Backup Repair Command\n\nThis command attempts to correct any inconsistencies in persisted backup metadata which exists as\nthe result of software errors or unhandled failure scenarios. While the backup implementation tries\nto correct all errors on its own, this tool may be necessary in the cases where the system cannot\nautomatically recover on its own.\n\n```bash\n$ hbase backup repair\n```\n\n#### Positional Command-Line Arguments\n\nNone.\n\n#### Named Command-Line Arguments\n\nNone.\n\n#### Example usage\n\n```bash\n$ hbase backup repair\n```\n\n\n# Backup and Restore commands (/docs/backup-restore/commands)\nThis covers the command-line utilities that administrators would run to create, restore, and merge backups. Tools to\ninspect details on specific backup sessions is covered in the next section, [Administration of Backup Images](/docs/backup-restore/administration).\n\nRun the command `hbase backup help <command>` to access the online help that provides basic information about a command\nand its options. The below information is captured in this help message for each command.\n\n### Creating a Backup Image\n\n<Callout type=\"info\">\n  For HBase clusters also using Apache Phoenix: include the SQL system catalog tables in the backup.\n  In the event that you need to restore the HBase backup, access to the system catalog tables enable\n  you to resume Phoenix interoperability with the restored data.\n</Callout>\n\nThe first step in running the backup and restore utilities is to perform a full backup and to store the data in a separate image\nfrom the source. At a minimum, you must do this to get a baseline before you can rely on incremental backups.\n\nRun the following command as HBase superuser:\n\n```bash\nhbase backup create <type> <backup_path>\n```\n\nAfter the command finishes running, the console prints a SUCCESS or FAILURE status message. The SUCCESS message includes a *backup* ID.\nThe backup ID is the Unix time (also known as Epoch time) that the HBase master received the backup request from the client.\n\n<Callout type=\"info\">\n  Record the backup ID that appears at the end of a successful backup. In case the source cluster\n  fails and you need to recover the dataset with a restore operation, having the backup ID readily\n  available can save time.\n</Callout>\n\n#### Positional Command-Line Arguments\n\n***type***\\\nThe type of backup to execute: *full* or *incremental*. As a reminder, an *incremental* backup requires a *full* backup to\nalready exist.\n\n***backup\\_path***\\\nThe *backup\\_path* argument specifies the full filesystem URI of where to store the backup image. Valid prefixes are\n*hdfs:*, *webhdfs:*, *s3a:* or other compatible Hadoop File System implementations.\n\n#### Named Command-Line Arguments\n\n***-t \\<table\\_name\\[,table\\_name]>***\\\nA comma-separated list of tables to back up. If no tables are specified, all tables are backed up. No regular-expression or\nwildcard support is present; all table names must be explicitly listed. See [Backup Sets](/docs/backup-restore/commands#using-backup-sets) for more\ninformation about peforming operations on collections of tables. Mutually exclusive with the *-s* option; one of these\nnamed options are required.\n\n***-s \\<backup\\_set\\_name>***\\\nIdentify tables to backup based on a backup set. See [Using Backup Sets](/docs/backup-restore/commands#using-backup-sets) for the purpose and usage\nof backup sets. Mutually exclusive with the *-t* option.\n\n***-w \\<number\\_workers>***\\\n(Optional) Specifies the number of parallel workers to copy data to backup destination. Backups are currently executed by MapReduce jobs\nso this value corresponds to the number of Mappers that will be spawned by the job.\n\n***-b \\<bandwidth\\_per\\_worker>***\\\n(Optional) Specifies the bandwidth of each worker in MB per second.\n\n***-d***\\\n(Optional) Enables \"DEBUG\" mode which prints additional logging about the backup creation.\n\n***-i***\\\n(Optional) Ignore checksum verify between source snapshot and exported snapshot. Especially when the source and target file system types\nare different, we should use -i option to skip checksum-checks.\n\n***-q \\<name>***\\\n(Optional) Allows specification of the name of a YARN queue which the MapReduce job to create the backup should be executed in. This option\nis useful to prevent backup tasks from stealing resources away from other MapReduce jobs of high importance.\n\n#### Example usage\n\n```bash\n$ hbase backup create full hdfs://host5:9000/data/backup -t SALES2,SALES3 -w 3\n```\n\nThis command creates a full backup image of two tables, SALES2 and SALES3, in the HDFS instance who NameNode is host5:9000\nin the path */data/backup*. The *-w* option specifies that no more than three parallel works complete the operation.\n\n### Restoring a Backup Image\n\nRun the following command as an HBase superuser. You can only restore a backup on a running HBase cluster because the data must be\nredistributed the RegionServers for the operation to complete successfully.\n\n```bash\nhbase restore <backup_path> <backup_id>\n```\n\n#### Positional Command-Line Arguments\n\n***backup\\_path***\\\nThe *backup\\_path* argument specifies the full filesystem URI of where to store the backup image. Valid prefixes are\n*hdfs:*, *webhdfs:*, *s3a:* or other compatible Hadoop File System implementations.\n\n***backup\\_id***\\\nThe backup ID that uniquely identifies the backup image to be restored.\n\n#### Named Command-Line Arguments\n\n***-t \\<table\\_name\\[,table\\_name]>***\\\nA comma-separated list of tables to restore. See [Backup Sets](/docs/backup-restore/commands#using-backup-sets) for more\ninformation about peforming operations on collections of tables. Mutually exclusive with the *-s* option; one of these\nnamed options are required.\n\n***-s \\<backup\\_set\\_name>***\\\nIdentify tables to backup based on a backup set. See [Using Backup Sets](/docs/backup-restore/commands#using-backup-sets) for the purpose and usage\nof backup sets. Mutually exclusive with the *-t* option.\n\n***-q \\<name>***\\\n(Optional) Allows specification of the name of a YARN queue which the MapReduce job to create the backup should be executed in. This option\nis useful to prevent backup tasks from stealing resources away from other MapReduce jobs of high importance.\n\n***-c***\\\n(Optional) Perform a dry-run of the restore. The actions are checked, but not executed.\n\n***-m \\<target\\_tables>***\\\n(Optional) A comma-separated list of tables to restore into. If this option is not provided, the original table name is used. When\nthis option is provided, there must be an equal number of entries provided in the `-t` option.\n\n***-o***\\\n(Optional) Overwrites the target table for the restore if the table already exists.\n\n#### Example of Usage\n\n```bash\nhbase restore /tmp/backup_incremental backupId_1467823988425 -t mytable1,mytable2\n```\n\nThis command restores two tables of an incremental backup image. In this example:\n• `/tmp/backup_incremental` is the path to the directory containing the backup image.\n• `backupId_1467823988425` is the backup ID.\n• `mytable1` and `mytable2` are the names of tables in the backup image to be restored.\n\n<Callout type=\"info\">\n  If the namespace of a table being restored does not exist in the target environment, it will be\n  automatically created during the restore operation.\n  [HBASE-25707](https://issues.apache.org/jira/browse/HBASE-25707)\n</Callout>\n\n### Merging Incremental Backup Images\n\nThis command can be used to merge two or more incremental backup images into a single incremental\nbackup image. This can be used to consolidate multiple, small incremental backup images into a single\nlarger incremental backup image. This command could be used to merge hourly incremental backups\ninto a daily incremental backup image, or daily incremental backups into a weekly incremental backup.\n\n```bash\n$ hbase backup merge <backup_ids>\n```\n\n#### Positional Command-Line Arguments\n\n***backup\\_ids***\\\nA comma-separated list of incremental backup image IDs that are to be combined into a single image.\n\n#### Named Command-Line Arguments\n\nNone.\n\n#### Example usage\n\n```bash\n$ hbase backup merge backupId_1467823988425,backupId_1467827588425\n```\n\n### Using Backup Sets\n\nBackup sets can ease the administration of HBase data backups and restores by reducing the amount of repetitive input\nof table names. You can group tables into a named backup set with the `hbase backup set add` command. You can then use\nthe `-set` option to invoke the name of a backup set in the `hbase backup create` or `hbase restore` rather than list\nindividually every table in the group. You can have multiple backup sets.\n\n<Callout type=\"info\">\n  Note the differentiation between the `hbase backup set add` command and the *-set* option. The\n  `hbase backup set add` command must be run before using the `-set` option in a different command\n  because backup sets must be named and defined before using backup sets as a shortcut.\n</Callout>\n\nIf you run the `hbase backup set add` command and specify a backup set name that does not yet exist on your system, a new set\nis created. If you run the command with the name of an existing backup set name, then the tables that you specify are added\nto the set.\n\nIn this command, the backup set name is case-sensitive.\n\n<Callout type=\"info\">\n  The metadata of backup sets are stored within HBase. If you do not have access to the original\n  HBase cluster with the backup set metadata, then you must specify individual table names to\n  restore the data.\n</Callout>\n\nTo create a backup set, run the following command as the HBase superuser:\n\n```bash\n$ hbase backup set <subcommand> <backup_set_name> <tables>\n```\n\n#### Backup Set Subcommands\n\nThe following list details subcommands of the hbase backup set command.\n\n<Callout type=\"info\">\n  You must enter one (and no more than one) of the following subcommands after hbase backup set to\n  complete an operation. Also, the backup set name is case-sensitive in the command-line utility.\n</Callout>\n\n***add***\\\nAdds table\\[s] to a backup set. Specify a *backup\\_set\\_name* value after this argument to create a backup set.\n\n***remove***\\\nRemoves tables from the set. Specify the tables to remove in the tables argument.\n\n***list***\\\nLists all backup sets.\n\n***describe***\\\nDisplays a description of a backup set. The information includes whether the set has full\nor incremental backups, start and end times of the backups, and a list of the tables in the set. This subcommand must precede\na valid value for the *backup\\_set\\_name* value.\n\n***delete***\\\nDeletes a backup set. Enter the value for the *backup\\_set\\_name* option directly after the `hbase backup set delete` command.\n\n#### Positional Command-Line Arguments\n\n***backup\\_set\\_name***\\\nUse to assign or invoke a backup set name. The backup set name must contain only printable characters and cannot have any spaces.\n\n***tables***\\\nList of tables (or a single table) to include in the backup set. Enter the table names as a comma-separated list. If no tables\nare specified, all tables are included in the set.\n\n<Callout type=\"info\">\n  Maintain a log or other record of the case-sensitive backup set names and the corresponding tables\n  in each set on a separate or remote cluster, backup strategy. This information can help you in\n  case of failure on the primary cluster.\n</Callout>\n\n#### Example of Usage\n\n```bash\n$ hbase backup set add Q1Data TEAM3,TEAM_4\n```\n\nDepending on the environment, this command results in *one* of the following actions:\n\n* If the `Q1Data` backup set does not exist, a backup set containing tables `TEAM_3` and `TEAM_4` is created.\n* If the `Q1Data` backup set exists already, the tables `TEAM_3` and `TEAM_4` are added to the `Q1Data` backup set.\n\n\n# Backup and Restore (/docs/backup-restore)\n\n\n# Overview (/docs/backup-restore/overview)\n\n\n\n\n\n\nBackup and restore is a standard operation provided by many databases. An effective backup and restore\nstrategy helps ensure that users can recover data in case of unexpected failures. The HBase backup and restore\nfeature helps ensure that enterprises using HBase as a canonical data repository can recover from catastrophic\nfailures. Another important feature is the ability to restore the database to a particular\npoint-in-time, commonly referred to as a snapshot.\n\nThe HBase backup and restore feature provides the ability to create full backups and incremental backups on\ntables in an HBase cluster. The full backup is the foundation on which incremental backups are applied\nto build iterative snapshots. Incremental backups can be run on a schedule to capture changes over time,\nfor example by using a Cron task. Incremental backups are more cost-effective than full backups because they only capture\nthe changes since the last backup and they also enable administrators to restore the database to any prior incremental backup. Furthermore, the\nutilities also enable table-level data backup-and-recovery if you do not want to restore the entire dataset\nof the backup.\n\nThe backup and restore feature supplements the HBase Replication feature. While HBase replication is ideal for\ncreating \"hot\" copies of the data (where the replicated data is immediately available for query), the backup and\nrestore feature is ideal for creating \"cold\" copies of data (where a manual step must be taken to restore the system).\nPreviously, users only had the ability to create full backups via the ExportSnapshot functionality. The incremental\nbackup implementation is the novel improvement over the previous \"art\" provided by ExportSnapshot.\n\nThe backup and restore feature uses DistCp to transfer files between clusters .\n[HADOOP-15850](https://issues.apache.org/jira/browse/HADOOP-15850) fixes a bug where CopyCommitter#concatFileChunks\nunconditionally tried to concatenate the files being DistCp'ed to target cluster (though the files are\nindependent) . Without the fix from\n[HADOOP-15850](https://issues.apache.org/jira/browse/HADOOP-15850) , the transfer would fail.\nSo the backup and restore feature need hadoop version as below\n\n* 2.7.x\n* 2.8.x\n* 2.9.2+\n* 2.10.0+\n* 3.0.4+\n* 3.1.2+\n* 3.2.0+\n* 3.3.0+\n\n## Terminology\n\nThe backup and restore feature introduces new terminology which can be used to understand how control flows through the\nsystem.\n\n* *A backup*: A logical unit of data and metadata which can restore a table to its state at a specific point in time.\n* *Full backup*: a type of backup which wholly encapsulates the contents of the table at a point in time.\n* *Incremental backup*: a type of backup which contains the changes in a table since a full backup.\n* *Backup set*: A user-defined name which references one or more tables over which a backup can be executed.\n* *Backup ID*: A unique names which identifies one backup from the rest, e.g. `backupId_1467823988425`\n\n## Planning\n\nThere are some common strategies which can be used to implement backup and restore in your environment. The following section\nshows how these strategies are implemented and identifies potential tradeoffs with each.\n\n<Callout type=\"warn\">\n  This backup and restore tools has not been tested on Transparent Data Encryption (TDE) enabled\n  HDFS clusters. This is related to the open issue\n  [HBASE-16178](https://issues.apache.org/jira/browse/HBASE-16178).\n</Callout>\n\n### Backup within a cluster\n\nThis strategy stores the backups on the same cluster as where the backup was taken. This approach is only appropriate for testing\nas it does not provide any additional safety on top of what the software itself already provides.\n\n<img alt=\"Intra-Cluster Backup\" src={__img0} placeholder=\"blur\" />\n\n### Backup using a dedicated cluster\n\nThis strategy provides greater fault tolerance and provides a path towards disaster recovery. In this setting, you will\nstore the backup on a separate HDFS cluster by supplying the backup destination cluster's HDFS URL to the backup utility.\nYou should consider backing up to a different physical location, such as a different data center.\n\nTypically, a backup-dedicated HDFS cluster uses a more economical hardware profile to save money.\n\n<img alt=\"Dedicated HDFS Cluster Backup\" src={__img1} placeholder=\"blur\" />\n\n### Backup to the Cloud or a storage vendor appliance\n\nAnother approach to safeguarding HBase incremental backups is to store the data on provisioned, secure servers that belong\nto third-party vendors and that are located off-site. The vendor can be a public cloud provider or a storage vendor who uses\na Hadoop-compatible file system, such as S3 and other HDFS-compatible destinations.\n\n<img alt=\"Backup to Cloud or Vendor Storage Solutions\" src={__img2} placeholder=\"blur\" />\n\n<Callout type=\"info\">\n  The HBase backup utility does not support backup to multiple destinations. A workaround is to\n  manually create copies of the backup files from HDFS or S3.\n</Callout>\n\n## First-time configuration steps\n\nThis section contains the necessary configuration changes that must be made in order to use the backup and restore feature.\nAs this feature makes significant use of YARN's MapReduce framework to parallelize these I/O heavy operations, configuration\nchanges extend outside of just `hbase-site.xml`.\n\n### Allow the \"hbase\" system user in YARN\n\nThe YARN *container-executor.cfg* configuration file must have the following property setting: *allowed.system.users=hbase*. No spaces\nare allowed in entries of this configuration file.\n\n<Callout type=\"warn\">\n  Skipping this step will result in runtime errors when executing the first backup tasks.\n</Callout>\n\n**Example of a valid container-executor.cfg file for backup and restore:**\n\n```text\nyarn.nodemanager.log-dirs=/var/log/hadoop/mapred\nyarn.nodemanager.linux-container-executor.group=yarn\nbanned.users=hdfs,yarn,mapred,bin\nallowed.system.users=hbase\nmin.user.id=500\n```\n\n### HBase specific changes\n\nAdd the following properties to hbase-site.xml and restart HBase if it is already running.\n\n<Callout type=\"info\">\n  The \",...\" is an ellipsis meant to imply that this is a comma-separated list of values, not\n  literal text which should be added to hbase-site.xml.\n</Callout>\n\n```xml\n<property>\n  <name>hbase.backup.enable</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.master.logcleaner.plugins</name>\n  <value>org.apache.hadoop.hbase.backup.master.BackupLogCleaner,...</value>\n</property>\n<property>\n  <name>hbase.procedure.master.classes</name>\n  <value>org.apache.hadoop.hbase.backup.master.LogRollMasterProcedureManager,...</value>\n</property>\n<property>\n  <name>hbase.procedure.regionserver.classes</name>\n  <value>org.apache.hadoop.hbase.backup.regionserver.LogRollRegionServerProcedureManager,...</value>\n</property>\n<property>\n  <name>hbase.coprocessor.region.classes</name>\n  <value>org.apache.hadoop.hbase.backup.BackupObserver,...</value>\n</property>\n<property>\n  <name>hbase.coprocessor.master.classes</name>\n  <value>org.apache.hadoop.hbase.backup.BackupMasterObserver,...</value>\n</property>\n<property>\n  <name>hbase.master.hfilecleaner.plugins</name>\n  <value>org.apache.hadoop.hbase.backup.BackupHFileCleaner,...</value>\n</property>\n```\n\n\n# Announcing Releases (/docs/building-and-developing/announcing)\nOnce an RC has passed successfully and the needed artifacts have been staged for disribution, you'll need to let everyone know about our shiny new release. It's not a requirement, but to make things easier for release managers we have a template you can start with. Be sure you replace \\_version\\_ and other markers with the relevant version numbers. You should manually verify all links before sending.\n\n```text\nThe HBase team is happy to announce the immediate availability of HBase _version_.\n\nApache HBase™ is an open-source, distributed, versioned, non-relational database.\nApache HBase gives you low latency random access to billions of rows with\nmillions of columns atop non-specialized hardware. To learn more about HBase,\nsee https://hbase.apache.org/.\n\nHBase _version_ is the _nth_ minor release in the HBase _major_.x line, which aims to\nimprove the stability and reliability of HBase. This release includes roughly\nXXX resolved issues not covered by previous _major_.x releases.\n\nNotable new features include:\n- List text descriptions of features that fit on one line\n- Including if JDK or Hadoop support versions changes\n- If the \"stable\" pointer changes, call that out\n- For those with obvious JIRA IDs, include them (HBASE-YYYYY)\n\nThe full list of issues can be found in the included CHANGES.md and RELEASENOTES.md,\nor via our issue tracker:\n\n    https://s.apache.org/hbase-_version_-jira\n\nTo download please follow the links and instructions on our website:\n\n    https://hbase.apache.org/downloads.html\n\n\nQuestion, comments, and problems are always welcome at: dev@hbase.apache.org.\n\nThanks to all who contributed and made this release possible.\n\nCheers,\nThe HBase Dev Team\n```\n\nYou should sent this message to the following lists: [dev@hbase.apache.org](mailto:dev@hbase.apache.org), [user@hbase.apache.org](mailto:user@hbase.apache.org), [announce@apache.org](mailto:announce@apache.org). If you'd like a spot check before sending, feel free to ask via jira or the dev list.\n\n\n# Building Apache HBase (/docs/building-and-developing/building)\n## Basic Compile\n\nHBase is compiled using Maven. You must use at least Maven 3.0.4. To check your Maven version, run\nthe command `mvn -version`.\n\n### JDK Version Requirements\n\nHBase has Java version compiler requirements that vary by release branch. At compilation time,\nHBase has the same version requirements as it does for runtime. See [Java](/docs/configuration/basic-prerequisites#configuration-basic-prerequisites-java) for a complete\nsupport matrix of Java version by HBase version.\n\n### Maven Build Commands\n\nAll commands are executed from the local HBase project directory.\n\n#### Package\n\nThe simplest command to compile HBase from its java source code is to use the `package` target, which builds JARs with the compiled files.\n\n```bash\nmvn package -DskipTests\n```\n\nOr, to clean up before compiling:\n\n```bash\nmvn clean package -DskipTests\n```\n\nWith Eclipse set up as explained above in [Eclipse](/docs/building-and-developing#eclipse), you can also use the **Build** command in Eclipse.\nTo create the full installable HBase package takes a little bit more work, so read on.\n\n#### Compile\n\nThe `compile` target does not create the JARs with the compiled files.\n\n```bash\nmvn compile\n```\n\n```bash\nmvn clean compile\n```\n\n#### Install\n\nTo install the JARs in your *\\~/.m2/* directory, use the `install` target.\n\n```bash\nmvn install\n```\n\n```bash\nmvn clean install\n```\n\n```bash\nmvn clean install -DskipTests\n```\n\n#### Building HBase 2.x on Apple Silicon\n\nBuilding a non-master branch requires protoc 2.5.0 binary which is not available for Apple Silicon.\nHBASE-27741 added a workaround to the build to fall back to osx-x86\\_64 version of protoc automatically by `apple-silicon-workaround` Maven profile.\nThe intention is that this change will permit the build to proceed with the x86 version of `protoc`, making use of the Rosetta instruction translation service built into the OS.\nIf you'd like to provide and make use of your own aarch\\_64 `protoc`, you can disable this profile on the command line by adding `-P'!apple-silicon-workaround'`, or through configuration in your `settings.xml`.\n\nYou can use the following commands to build protoc on your Apple Silicon machine.\n\n```bash\ncurl -sSL https://github.com/protocolbuffers/protobuf/releases/download/v2.5.0/protobuf-2.5.0.tar.gz | tar zx -\ncd protobuf-2.5.0\ncurl -L -O https://gist.githubusercontent.com/liusheng/64aee1b27de037f8b9ccf1873b82c413/raw/118c2fce733a9a62a03281753572a45b6efb8639/protobuf-2.5.0-arm64.patch\npatch -p1 < protobuf-2.5.0-arm64.patch\n./configure --disable-shared\nmake\nmvn install:install-file -DgroupId=com.google.protobuf -DartifactId=protoc -Dversion=2.5.0 -Dclassifier=osx-aarch_64 -Dpackaging=exe -Dfile=src/protoc\n```\n\n### Running all or individual Unit Tests\n\nSee the [Running tests](/docs/building-and-developing/tests#running-tests) section in [Unit Tests](/docs/building-and-developing/tests#building-and-developing-unit-tests)\n\n### Building against various Hadoop versions\n\nHBase supports building against Apache Hadoop versions: 2.y and 3.y (early release artifacts).\nExactly which version of Hadoop is used by default varies by release branch. See the section\n[Hadoop](/docs/configuration/basic-prerequisites#hadoop) for the complete breakdown of supported Hadoop version by HBase release.\n\nThe mechanism for selecting a Hadoop version at build time is identical across all releases. Which\nversion of Hadoop is default varies. We manage Hadoop major version selection by way of Maven\nprofiles. Due to the peculiarities of Maven profile mutual exclusion, the profile that builds\nagainst a particular Hadoop version is activated by setting a property, *not* the usual profile\nactivation. Hadoop version profile activation is summarized by the following table.\n\n#### Hadoop Profile Activation by HBase Release\n\n|            | Hadoop2 Activation  | Hadoop3 Activation     |\n| ---------- | ------------------- | ---------------------- |\n| HBase 1.3+ | *active by default* | `-Dhadoop.profile=3.0` |\n| HBase 3.0+ | *not supported*     | *active by default*    |\n\n<Callout type=\"warn\">\n  Please note that where a profile is active by default, `hadoop.profile` must NOT be provided.\n</Callout>\n\nOnce the Hadoop major version profile is activated, the exact Hadoop version can be\nspecified by overriding the appropriate property value. For Hadoop2 versions, the property name\nis `hadoop-two.version`. With Hadoop3 versions, the property name is `hadoop-three.version`.\n\n#### Example 1: Building HBase 1.7 against Hadoop 2.10.0\n\nFor example, to build HBase 1.7 against Hadoop 2.10.0, the profile is set for Hadoop2 by default,\nso only `hadoop-two.version` must be specified:\n\n```bash\ngit checkout branch-1\nmvn -Dhadoop-two.version=2.10.0 ...\n```\n\n#### Example 2: Building HBase 2.3 or 2.4 against Hadoop 3.4.0-SNAPSHOT\n\nThis is how a developer might check the compatibility of HBase 2.3 or 2.4 against an unreleased\nHadoop version (currently 3.4). Both the Hadoop3 profile and version must be specified:\n\n```bash\ngit checkout branch-2.4\nmvn -Dhadoop.profile=3.0 -Dhadoop-three.version=3.4.0-SNAPSHOT ...\n```\n\n#### Example 3: Building HBase 3.0 against Hadoop 3.4.0-SNAPSHOT\n\nThe same developer might want also to check the development version of HBase (currently 3.0)\nagainst the development version of Hadoop (currently 3.4). In this case, the Hadoop3 profile is\nactive by default, so only `hadoop-three.version` must be specified:\n\n```bash\ngit checkout master\nmvn -Dhadoop-three.version=3.4.0-SNAPSHOT ...\n```\n\n### Building with JDK11 and Hadoop3\n\nHBase manages JDK-specific build settings using Maven profiles. The profile appropriate to the JDK\nin use is automatically activated. Building and running on JDK8 supports both Hadoop2 and Hadoop3.\nFor JDK11, only Hadoop3 is supported. Thus, the Hadoop3 profile must be active when building on\nJDK11, and the artifacts used when running HBase on JDK11 must be compiled against Hadoop3.\nFurthermore, the JDK11 profile requires a minimum Hadoop version of 3.2.0. This value is specified\nby the JDK11 profile, but it can be overridden using the `hadoop-three.version` property as normal.\nFor details on Hadoop profile activation by HBase branch, see\n[Building against various Hadoop versions](/docs/building-and-developing/building#building-against-various-hadoop-versions). See [Java](/docs/configuration/basic-prerequisites#configuration-basic-prerequisites-java) for a complete\nsupport matrix of Java version by HBase version.\n\n#### Example 1: Building HBase 2.3 or 2.4 with JDK11\n\nTo build HBase 2.3 or 2.4 with JDK11, the Hadoop3 profile must be activated explicitly.\n\n```bash\ngit checkout branch-2.4\nJAVA_HOME=/usr/lib/jvm/java-11 mvn -Dhadoop.profile=3.0 ...\n```\n\n#### Example 2: Building HBase 3.0 with JDK11\n\nFor HBase 3.0, the Hadoop3 profile is active by default, no additional properties need be\nspecified.\n\n```bash\ngit checkout master\nJAVA_HOME=/usr/lib/jvm/java-11 mvn ...\n```\n\n### Building and testing in an IDE with JDK11 and Hadoop3\n\nContinuing the discussion from the [earlier section](/docs/building-and-developing/building#building-with-jdk11-and-hadoop3), building and\ntesting with JDK11 and Hadoop3 within an IDE may require additional configuration. Specifically,\nmake sure the JVM version used by the IDE is a JDK11, the active JDK Maven profile is for JDK11,\nand the Maven profile for JDK8 is NOT active. Likewise, ensure the Hadoop3 Maven profile is active\nand the Hadoop2 Maven profile is NOT active.\n\n### Build Protobuf\n\nYou may need to change the protobuf definitions that reside in the *hbase-protocol* module or other modules.\n\nPrevious to hbase-2.0.0, protobuf definition files were sprinkled across all hbase modules but now all\nto do with protobuf must reside in the hbase-protocol module; we are trying to contain our protobuf\nuse so we can freely change versions without upsetting any downstream project use of protobuf.\n\nThe protobuf files are located in *hbase-protocol/src/main/protobuf*.\nFor the change to be effective, you will need to regenerate the classes.\n\n```bash\nmvn package -pl hbase-protocol -am\n```\n\nSimilarly, protobuf definitions for internal use are located in the *hbase-protocol-shaded* module.\n\n```bash\nmvn package -pl hbase-protocol-shaded -am\n```\n\nTypically, protobuf code generation is done using the native `protoc` binary. In our build we use a maven plugin for\nconvenience; however, the plugin may not be able to retrieve appropriate binaries for all platforms. If you find yourself\non a platform where protoc fails, you will have to compile protoc from source, and run it independent of our maven build.\nYou can disable the inline code generation by specifying `-Dprotoc.skip` in your maven arguments, allowing your build to proceed further.\n\n<Callout type=\"info\">\n  If you need to manually generate your protobuf files, you should not use `clean` in subsequent\n  maven calls, as that will delete the newly generated files.\n</Callout>\n\nRead the *hbase-protocol/README.txt* for more details\n\n### Build Thrift\n\nYou may need to change the thrift definitions that reside in the *hbase-thrift* module or other modules.\n\nThe thrift files are located in *hbase-thrift/src/main/resources*.\nFor the change to be effective, you will need to regenerate the classes.\nYou can use maven profile `compile-thrift` to do this.\n\n```bash\nmvn compile -Pcompile-thrift\n```\n\nYou may also want to define `thrift.path` for the thrift binary, using the following command:\n\n```bash\nmvn compile -Pcompile-thrift -Dthrift.path=/opt/local/bin/thrift\n```\n\n### Build a Tarball\n\nYou can build a tarball without going through the release process described in [Releasing Apache HBase](/docs/building-and-developing/releasing), by running the following command:\n\n```bash\nmvn -DskipTests clean install && mvn -DskipTests package assembly:single\n```\n\nThe distribution tarball is built in `hbase-assembly/target/hbase-<version>-bin.tar.gz`.\n\nYou can install or deploy the tarball by having the assembly:single goal before install or deploy in the maven command:\n\n```bash\nmvn -DskipTests package assembly:single install\n```\n\n```bash\nmvn -DskipTests package assembly:single deploy\n```\n\n### Build Gotchas\n\n#### Maven Site failure\n\nIf you see `Unable to find resource 'VM_global_library.vm'`, ignore it.\nIt's not an error.\nIt is [officially ugly](https://issues.apache.org/jira/browse/MSITE-286) though.\n\n## Build On Linux Aarch64\n\nHBase runs on both Windows and UNIX-like systems, and it should run on any platform\nthat runs a supported version of Java. This should include JVMs on x86\\_64 and aarch64.\nThe documentation below describes how to build hbase on aarch64 platform.\n\n### Set Environment Variables\n\nManually install Java and Maven on aarch64 servers if they are not installed,\nand set environment variables. For example:\n\n```bash\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-arm64\nexport MAVEN_HOME=/opt/maven\nexport PATH=${MAVEN_HOME}/bin:${JAVA_HOME}/bin:${PATH}\n```\n\n### Use Protobuf Supported On Aarch64\n\nNow HBase uses protobuf of two versions. Version '3.11.4' of protobuf that hbase uses\ninternally and version '2.5.0' as external usage.\nPackage protoc-2.5.0 does not work on aarch64 platform, we should add maven\nprofile '-Paarch64' when building. It downloads protoc-2.5.0 package from maven\nrepository which we made on aarch64 platform locally.\n\n```bash\nmvn clean install -Paarch64 -DskipTests\n```\n\n<Callout type=\"info\">\n  Protobuf is released with aarch64 protoc since version '3.5.0', and we are planning to upgrade\n  protobuf later, then we don't have to add the profile '-Paarch64' anymore.\n</Callout>\n\n\n# Developer Guidelines (/docs/building-and-developing/developer-guidelines)\n## Branches\n\nWe use Git for source code management and latest development happens on `master` branch. There are\nbranches for past major/minor/maintenance releases and important features and bug fixes are often\nback-ported to them.\n\n## Policy for Fix Version in JIRA\n\nTo determine if a given fix is in a given release purely from the release numbers following rules\nare defined:\n\nFix version of X.Y.Z => fixed in all releases X.Y.Z' (where Z' = Z).\\\nFix version of X.Y.0 => fixed in all releases X.Y'.\\* (where Y' = Y).\\\nFix version of X.0.0 => fixed in all releases X'.\\*.\\* (where X' = X).\n\nBy this policy, fix version of 1.3.0 implies 1.4.0, but 1.3.2 does not imply 1.4.0 as we could not\ntell purely from the numbers which release came first.\n\n## Code Standards\n\n### Interface Classifications\n\nInterfaces are classified both by audience and by stability level.\nThese labels appear at the head of a class.\nThe conventions followed by HBase are inherited by its parent project, Hadoop.\n\nThe following interface classifications are commonly used:\n\n#### InterfaceAudience\n\n`@InterfaceAudience.Public`\\\nAPIs for users and HBase applications.\nThese APIs will be deprecated through major versions of HBase.\n\n`@InterfaceAudience.Private`\\\nAPIs for HBase internals developers.\nNo guarantees on compatibility or availability in future versions.\nPrivate interfaces do not need an `@InterfaceStability` classification.\n\n`@InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.COPROC)`\\\nAPIs for HBase coprocessor writers.\n\n**No `@InterfaceAudience` Classification**:\\\nPackages without an `@InterfaceAudience` label are considered private.\nMark your new packages if publicly accessible.\n\n<Callout type=\"info\" title=\"Excluding Non-Public Interfaces from API Documentation\">\n  Only interfaces classified `@InterfaceAudience.Public` should be included in API documentation\n  (Javadoc). Committers must add new package excludes `ExcludePackageNames` section of the *pom.xml*\n  for new packages which do not contain public classes.\n</Callout>\n\n#### @InterfaceStability\n\n`@InterfaceStability` is important for packages marked `@InterfaceAudience.Public`.\n\n`@InterfaceStability.Stable`\\\nPublic packages marked as stable cannot be changed without a deprecation path or a very good reason.\n\n`@InterfaceStability.Unstable`\\\nPublic packages marked as unstable can be changed without a deprecation path.\n\n`@InterfaceStability.Evolving`\\\nPublic packages marked as evolving may be changed, but it is discouraged.\n\n**No `@InterfaceStability` Label**:\nPublic classes with no `@InterfaceStability` label are discouraged, and should be considered implicitly unstable.\n\nIf you are unclear about how to mark packages, ask on the development list.\n\n### Code Formatting Conventions\n\nPlease adhere to the following guidelines so that your patches can be reviewed more quickly.\nThese guidelines have been developed based upon common feedback on patches from new contributors.\n\nSee the [Code Conventions for the Java Programming Language](http://www.oracle.com/technetwork/java/index-135089.html) for more information on coding conventions in Java.\nSee [Eclipse Code Formatting](/docs/building-and-developing#code-formatting) to setup Eclipse to check for some of\nthese guidelines automatically.\n\n#### Space Invaders\n\nDo not use extra spaces around brackets.\nUse the second style, rather than the first.\n\n```java\nif ( foo.equals( bar ) ) {     // don't do this\n```\n\n```java\nif (foo.equals(bar)) {\n```\n\n```java\nfoo = barArray[ i ];     // don't do this\n```\n\n```java\nfoo = barArray[i];\n```\n\n#### Auto Generated Code\n\nAuto-generated code in Eclipse often uses bad variable names such as `arg0`.\nUse more informative variable names.\nUse code like the second example here.\n\n```java\n public void readFields(DataInput arg0) throws IOException {    // don't do this\n   foo = arg0.readUTF();                                       // don't do this\n```\n\n```java\n public void readFields(DataInput di) throws IOException {\n   foo = di.readUTF();\n```\n\n#### Long Lines\n\nKeep lines less than 100 characters.\nYou can configure your IDE to do this automatically.\n\n```java\nBar bar = foo.veryLongMethodWithManyArguments(argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9);  // don't do this\n```\n\n```java\nBar bar = foo.veryLongMethodWithManyArguments(\n argument1, argument2, argument3,argument4, argument5, argument6, argument7, argument8, argument9);\n```\n\n#### Trailing Spaces\n\nBe sure there is a line break after the end of your code, and avoid lines with nothing but whitespace.\nThis makes diffs more meaningful.\nYou can configure your IDE to help with this.\n\n```java\nBar bar = foo.getBar();     <--- imagine there is an extra space(s) after the semicolon.\n```\n\n#### API Documentation (Javadoc)\n\nDon't forget Javadoc!\n\nJavadoc warnings are checked during precommit.\nIf the precommit tool gives you a '-1', please fix the javadoc issue.\nYour patch won't be committed if it adds such warnings.\n\nAlso, no `@author` tags - that's a rule.\n\n#### Findbugs\n\n`Findbugs` is used to detect common bugs pattern.\nIt is checked during the precommit build.\nIf errors are found, please fix them.\nYou can run findbugs locally with `mvn\n                            findbugs:findbugs`, which will generate the `findbugs` files locally.\nSometimes, you may have to write code smarter than `findbugs`.\nYou can annotate your code to tell `findbugs` you know what you're doing, by annotating your class with the following annotation:\n\n```java\n@edu.umd.cs.findbugs.annotations.SuppressWarnings(\nvalue=\"HE_EQUALS_USE_HASHCODE\",\njustification=\"I know what I'm doing\")\n```\n\nIt is important to use the Apache-licensed version of the annotations. That generally means using\nannotations in the `edu.umd.cs.findbugs.annotations` package so that we can rely on the cleanroom\nreimplementation rather than annotations in the `javax.annotations` package.\n\n#### Javadoc - Useless Defaults\n\nDon't just leave javadoc tags the way IDE generates them, or fill redundant information in them.\n\n```java\n  /**\n   * @param table                              <---- don't leave them empty!\n   * @param region An HRegion object.          <---- don't fill redundant information!\n   * @return Foo Object foo just created.      <---- Not useful information\n   * @throws SomeException                     <---- Not useful. Function declarations already tell that!\n   * @throws BarException when something went wrong  <---- really?\n   */\n  public Foo createFoo(Bar bar);\n```\n\nEither add something descriptive to the tags, or just remove them.\nThe preference is to add something descriptive and useful.\n\n#### One Thing At A Time, Folks\n\nIf you submit a patch for one thing, don't do auto-reformatting or unrelated reformatting of code on a completely different area of code.\n\nLikewise, don't add unrelated cleanup or refactorings outside the scope of your Jira.\n\n#### Ambiguous Unit Tests\n\nMake sure that you're clear about what you are testing in your unit tests and why.\n\n### Garbage-Collection Conserving Guidelines\n\nThe following guidelines were borrowed from [http://engineering.linkedin.com/performance/linkedin-feed-faster-less-jvm-garbage](http://engineering.linkedin.com/performance/linkedin-feed-faster-less-jvm-garbage).\nKeep them in mind to keep preventable garbage collection to a minimum. Have a look\nat the blog post for some great examples of how to refactor your code according to\nthese guidelines.\n\n* Be careful with Iterators\n* Estimate the size of a collection when initializing\n* Defer expression evaluation\n* Compile the regex patterns in advance\n* Cache it if you can\n* String Interns are useful but dangerous\n\n## Invariants\n\nWe don't have many but what we have we list below.\nAll are subject to challenge of course but until then, please hold to the rules of the road.\n\n### No permanent state in ZooKeeper\n\nZooKeeper state should transient (treat it like memory). If ZooKeeper state is deleted, hbase should be able to recover and essentially be in the same state.\n\n* .Exceptions: There are currently a few exceptions that we need to fix around whether a table is enabled or disabled.\n* Replication data is currently stored only in ZooKeeper.\n  Deleting ZooKeeper data related to replication may cause replication to be disabled.\n  Do not delete the replication tree, */hbase/replication/*.\n\n<Callout type=\"warning\">\n  Replication may be disrupted and data loss may occur if you delete the replication tree\n  (*/hbase/replication/*) from ZooKeeper. Follow progress on this issue at\n  [HBASE-10295](https://issues.apache.org/jira/browse/HBASE-10295).\n</Callout>\n\n## Running In-Situ\n\nIf you are developing Apache HBase, frequently it is useful to test your changes against a more-real cluster than what you find in unit tests.\nIn this case, HBase can be run directly from the source in local-mode.\nAll you need to do is run:\n\n```bash\n${HBASE_HOME}/bin/start-hbase.sh\n```\n\nThis will spin up a full local-cluster, just as if you had packaged up HBase and installed it on your machine.\n\nKeep in mind that you will need to have installed HBase into your local maven repository for the in-situ cluster to work properly.\nThat is, you will need to run:\n\n```bash\nmvn clean install -DskipTests\n```\n\nto ensure that maven can find the correct classpath and dependencies.\nGenerally, the above command is just a good thing to try running first, if maven is acting oddly.\n\n## Adding Metrics\n\nAfter adding a new feature a developer might want to add metrics.\nHBase exposes metrics using the Hadoop Metrics 2 system, so adding a new metric involves exposing that metric to the hadoop system.\nUnfortunately the API of metrics2 changed from hadoop 1 to hadoop 2.\nIn order to get around this a set of interfaces and implementations have to be loaded at runtime.\nTo get an in-depth look at the reasoning and structure of these classes you can read the blog post located [here](https://blogs.apache.org/hbase/entry/migration_to_the_new_metrics).\nTo add a metric to an existing MBean follow the short guide below:\n\n### Add Metric name and Function to Hadoop Compat Interface.\n\nInside of the source interface the corresponds to where the metrics are generated (eg MetricsMasterSource for things coming from HMaster) create new static strings for metric name and description.\nThen add a new method that will be called to add new reading.\n\n### Add the Implementation to Both Hadoop 1 and Hadoop 2 Compat modules.\n\nInside of the implementation of the source (eg.\nMetricsMasterSourceImpl in the above example) create a new histogram, counter, gauge, or stat in the init method.\nThen in the method that was added to the interface wire up the parameter passed in to the histogram.\n\nNow add tests that make sure the data is correctly exported to the metrics 2 system.\nFor this the MetricsAssertHelper is provided.\n\n## Git Best Practices\n\n**Avoid git merges.**\\\nUse `git pull --rebase` or `git fetch` followed by `git rebase`.\n\n**Do not use `git push --force`.**\\\nIf the push does not work, fix the problem or ask for help.\n\nPlease contribute to this document if you think of other Git best practices.\n\n### `rebase_all_git_branches.sh`\n\nThe *dev-support/rebase\\_all\\_git\\_branches.sh* script is provided to help keep your Git repository clean.\nUse the `-h` parameter to get usage instructions.\nThe script automatically refreshes your tracking branches, attempts an automatic rebase of each local branch against its remote branch, and gives you the option to delete any branch which represents a closed `HBASE-` JIRA.\nThe script has one optional configuration option, the location of your Git directory.\nYou can set a default by editing the script.\nOtherwise, you can pass the git directory manually by using the `-d` parameter, followed by an absolute or relative directory name, or even '.' for the current working directory.\nThe script checks the directory for sub-directory called *.git/*, before proceeding.\n\n## Submitting Patches\n\nIf you are new to submitting patches to open source or new to submitting patches to Apache, start by\nreading the [On Contributing Patches](https://commons.apache.org/patches.html) page from\n[Apache Commons Project](https://commons.apache.org/).\nIt provides a nice overview that applies equally to the Apache HBase Project.\n\nMake sure you review [Code Formatting Conventions](/docs/building-and-developing/developer-guidelines#code-formatting-conventions) for code style. If your patch\nwas generated incorrectly or your code does not adhere to the code formatting guidelines, you may\nbe asked to redo some work.\n\nHBase enforces code style via a maven plugin. After you've written up your changes, apply the\nformatter before committing.\n\n```bash\n$ mvn spotless:apply\n```\n\nWhen your commit is ready, present it to the community as a\n[GitHub Pull Request](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests).\n\n### Few general guidelines\n\n* Always patch against the master branch first, even if you want to patch in another branch.\n  HBase committers always apply patches first to the master branch, and backport as necessary. For\n  complex patches, you may be asked to perform the backport(s) yourself.\n* Submit one single PR for a single fix. If necessary, squash local commits to merge local commits\n  into a single one first. See this\n  [Stack Overflow\n  question](http://stackoverflow.com/questions/5308816/how-to-use-git-merge-squash) for more information about squashing commits.\n* Please understand that not every patch may get committed, and that feedback will likely be\n  provided on the patch.\n\n### Unit Tests\n\nAlways add and/or update relevant unit tests when making the changes.\nMake sure that new/changed unit tests pass locally before submitting the patch because it is faster\nthan waiting for presubmit result which runs full test suite. This will save your own time and\neffort.\nUse [Mockito](https://site.mockito.org/) to make mocks which are very useful for testing failure scenarios by\ninjecting appropriate failures.\n\nIf you are creating a new unit test class, notice how other unit test classes have\nclassification/sizing annotations before class name and a static methods for setup/teardown of\ntesting environment. Be sure to include annotations in any new unit test files.\nSee [Tests](/docs/building-and-developing/tests) for more information on tests.\n\n### Integration Tests\n\nSignificant new features should provide an integration test in addition to unit tests, suitable for exercising the new feature at different points in its configuration space.\n\n### ReviewBoard\n\nPatches larger than one screen, or patches that will be tricky to review, should go through [ReviewBoard](https://reviews.apache.org).\n\n**Procedure: Use ReviewBoard**\n\n<Steps>\n  <Step>\n    Register for an account if you don't already have one.\n    It does not use the credentials from [issues.apache.org](https://issues.apache.org).\n    Log in.\n  </Step>\n\n  <Step>\n    Click **New Review Request**.\n  </Step>\n\n  <Step>\n    Choose the `hbase-git` repository.\n    Click Choose File to select the diff and optionally a parent diff.\n    Click **Create Review Request**.\n  </Step>\n\n  <Step>\n    Fill in the fields as required.\n    At the minimum, fill in the **Summary** and choose `hbase` as the **Review Group**.\n    If you fill in the **Bugs** field, the review board links back to the relevant JIRA.\n    The more fields you fill in, the better.\n    Click **Publish** to make your review request public.\n    An email will be sent to everyone in the `hbase` group, to review the patch.\n  </Step>\n\n  <Step>\n    Back in your JIRA, click , and paste in the URL of your ReviewBoard request.\n    This attaches the ReviewBoard to the JIRA, for easy access.\n  </Step>\n\n  <Step>\n    To cancel the request, click .\n  </Step>\n</Steps>\n\nFor more information on how to use ReviewBoard, see [the ReviewBoard\ndocumentation](http://www.reviewboard.org/docs/manual/1.5/).\n\n### GitHub\n\nSubmitting [GitHub](https://github.com/apache/hbase) pull requests is another accepted form of\ncontributing patches. Refer to GitHub [documentation](https://help.github.com/) for details on\nhow to create pull requests.\n\n<Callout type=\"info\">\n  This section is incomplete and needs to be updated. Refer to\n  [HBASE-23557](https://issues.apache.org/jira/browse/HBASE-23557)\n</Callout>\n\n#### GitHub Tooling\n\n**Browser bookmarks**\n\nFollowing is a useful javascript based browser bookmark that redirects from GitHub pull\nrequests to the corresponding jira work item. This redirects based on the HBase jira ID mentioned\nin the issue title for the PR. Add the following javascript snippet as a browser bookmark to the\ntool bar. Clicking on it while you are on an HBase GitHub PR page redirects you to the corresponding\njira item.\n\n```js\nlocation.href =\n  \"https://issues.apache.org/jira/browse/\" +\n  document.getElementsByClassName(\"js-issue-title\")[0].innerHTML.match(/HBASE-\\d+/)[0];\n```\n\n### Guide for HBase Committers\n\n#### Becoming a committer\n\nCommitters are responsible for reviewing and integrating code changes, testing\nand voting on release candidates, weighing in on design discussions, as well as\nother types of project contributions. The PMC votes to make a contributor a\ncommitter based on an assessment of their contributions to the project. It is\nexpected that committers demonstrate a sustained history of high-quality\ncontributions to the project and community involvement.\n\nContributions can be made in many ways. There is no single path to becoming a\ncommitter, nor any expected timeline. Submitting features, improvements, and bug\nfixes is the most common avenue, but other methods are both recognized and\nencouraged (and may be even more important to the health of HBase as a project and a\ncommunity). A non-exhaustive list of potential contributions (in no particular\norder):\n\n* [Update the documentation](/docs/contributing-to-documentation) for new\n  changes, best practices, recipes, and other improvements.\n* Keep the website up to date.\n* Perform testing and report the results. For instance, scale testing and\n  testing non-standard configurations is always appreciated.\n* Maintain the shared Jenkins testing environment and other testing\n  infrastructure.\n* [Vote on release candidates](/docs/building-and-developing/voting) after performing validation, even if non-binding.\n  A non-binding vote is a vote by a non-committer.\n* Provide input for discussion threads on the link:/mail-lists.html\\[mailing lists] (which usually have\n  `[DISCUSS]` in the subject line).\n* Answer questions questions on the user or developer mailing lists and on\n  Slack.\n* Make sure the HBase community is a welcoming one and that we adhere to our\n  link:/coc.html\\[Code of conduct]. Alert the PMC if you\n  have concerns.\n* Review other people's work (both code and non-code) and provide public\n  feedback.\n* Report bugs that are found, or file new feature requests.\n* Triage issues and keep JIRA organized. This includes closing stale issues,\n  labeling new issues, updating metadata, and other tasks as needed.\n* Mentor new contributors of all sorts.\n* Give talks and write blogs about HBase. Add these to the link:/\\[News] section\n  of the website.\n* Provide UX feedback about HBase, the web UI, the CLI, APIs, and the website.\n* Write demo applications and scripts.\n* Help attract and retain a diverse community.\n* Interact with other projects in ways that benefit HBase and those other\n  projects.\n\nNot every individual is able to do all (or even any) of the items on this list.\nIf you think of other ways to contribute, go for it (and add them to the list).\nA pleasant demeanor and willingness to contribute are all you need to make a\npositive impact on the HBase project. Invitations to become a committer are the\nresult of steady interaction with the community over the long term, which builds\ntrust and recognition.\n\n#### New committers\n\nNew committers are encouraged to first read Apache's generic committer\ndocumentation:\n\n* [Apache New Committer Guide](https://www.apache.org/dev/new-committers-guide.html)\n* [Apache Committer FAQ](https://www.apache.org/dev/committers.html)\n\n#### Review\n\nHBase committers should, as often as possible, attempt to review patches\nsubmitted by others. Ideally every submitted patch will get reviewed by a\ncommitter *within a few days*. If a committer reviews a patch they have not\nauthored, and believe it to be of sufficient quality, then they can commit the\npatch. Otherwise the patch should be cancelled with a clear explanation for why\nit was rejected.\n\nThe list of submitted patches is in the\n[HBase Review Queue](https://issues.apache.org/jira/secure/IssueNavigator.jspa?mode=hide\\&requestId=12312392),\nwhich is ordered by time of last modification. Committers should scan the list\nfrom top to bottom, looking for patches that they feel qualified to review and\npossibly commit. If you see a patch you think someone else is better qualified\nto review, you can mention them by username in the JIRA.\n\nFor non-trivial changes, it is required that another committer review your\npatches before commit. **Self-commits of non-trivial patches are not allowed.**\nUse the **Submit Patch** button in JIRA, just like other contributors, and\nthen wait for a `+1` response from another committer before committing.\n\n#### Reject\n\nPatches which do not adhere to the guidelines in\n[HowToContribute](/docs/building-and-developing) and to the\n[code review checklist](https://cwiki.apache.org/confluence/display/HADOOP2/CodeReviewChecklist)\nshould be rejected. Committers should always be polite to contributors and try\nto instruct and encourage them to contribute better patches. If a committer\nwishes to improve an unacceptable patch, then it should first be rejected, and a\nnew patch should be attached by the committer for further review.\n\n#### Commit\n\nCommitters commit patches to the Apache HBase GIT repository.\n\n<Callout type=\"warn\" title=\"Before you commit!!!!\">\n  Make sure your local configuration is correct, especially your identity and email. Examine the\n  output of the `$ git config --list` command and be sure it is correct. See [Set Up\n  Git](https://help.github.com/articles/set-up-git) if you need pointers.\n</Callout>\n\nWhen you commit a patch:\n\n1. Include the Jira issue ID in the commit message along with a short description\n   of the change. Try to add something more than just the Jira title so that\n   someone looking at `git log` output doesn't have to go to Jira to discern what\n   the change is about. Be sure to get the issue ID right, because this causes\n   Jira to link to the change in Git (use the issue's \"All\" tab to see these\n   automatic links).\n\n2. Commit the patch to a new branch based off `master` or the other intended\n   branch. It's a good idea to include the JIRA ID in the name of this branch.\n   Check out the relevant target branch where you want to commit, and make sure\n   your local branch has all remote changes, by doing a `git pull --rebase` or\n   another similar command. Next, cherry-pick the change into each relevant\n   branch (such as master), and push the changes to the remote branch using\n   a command such as `git push <remote-server> <remote-branch>`.\n\n   <Callout type=\"warning\">\n     If you do not have all remote changes, the push will fail. If the push fails for any reason,\n     fix the problem or ask for help. Do not do a `git push --force`.\n   </Callout>\n\n   Before you can commit a patch, you need to determine how the patch was created.\n   The instructions and preferences around the way to create patches have changed,\n   and there will be a transition period.\n\n   **Determine How a Patch Was Created**\n\n   * If the first few lines of the patch look like the headers of an email, with a From, Date, and\n     Subject, it was created using `git format-patch`. This is the preferred way, because you can\n     reuse the submitter's commit message. If the commit message is not appropriate, you can still use\n     the commit, then run `git commit --amend` and reword as appropriate.\n\n   * If the first line of the patch looks similar to the following, it was created using +git diff+ without `--no-prefix`.\n     This is acceptable too.\n     Notice the `a` and `b` in front of the file names.\n     This is the indication that the patch was not created with `--no-prefix`.\n\n     ```diff\n     diff --git a/src/main/asciidoc/_chapters/developer.adoc b/src/main/asciidoc/_chapters/developer.adoc\n     ```\n\n   * If the first line of the patch looks similar to the following (without the `a` and `b`), the\n     patch was created with `git diff --no-prefix` and you need to add `-p0` to the `git apply` command\n     below.\n\n     ```diff\n     diff --git src/main/asciidoc/_chapters/developer.adoc src/main/asciidoc/_chapters/developer.adoc\n     ```\n\n   **Example of committing a Patch**\n\n   One thing you will notice with these examples is that there are a lot of\n   `git pull` commands. The only command that actually writes anything to the\n   remote repository is `git push`, and you need to make absolutely sure you have\n   the correct versions of everything and don't have any conflicts before pushing.\n   The extra `git pull` commands are usually redundant, but better safe than sorry.\n\n   The first example shows how to apply a patch that was generated with +git\n   format-patch+ and apply it to the `master` and `branch-1` branches.\n\n   The directive to use `git format-patch` rather than `git diff`, and not to use\n   `--no-prefix`, is a new one. See the second example for how to apply a patch\n   created with `git diff`, and educate the person who created the patch.\n\n   ```bash\n   $ git checkout -b HBASE-XXXX\n   $ git am ~/Downloads/HBASE-XXXX-v2.patch --signoff  # If you are committing someone else's patch.\n   $ git checkout master\n   $ git pull --rebase\n   $ git cherry-pick <sha-from-commit>\n   # Resolve conflicts if necessary or ask the submitter to do it\n   $ git pull --rebase          # Better safe than sorry\n   $ git push origin master\n\n   # Backport to branch-1\n   $ git checkout branch-1\n   $ git pull --rebase\n   $ git cherry-pick <sha-from-commit>\n   # Resolve conflicts if necessary\n   $ git pull --rebase          # Better safe than sorry\n   $ git push origin branch-1\n   $ git branch -D HBASE-XXXX\n   ```\n\n   This example shows how to commit a patch that was created using `git diff`\n   without `--no-prefix`. If the patch was created with `--no-prefix`, add `-p0` to\n   the `git apply` command.\n\n   ```bash\n   $ git apply ~/Downloads/HBASE-XXXX-v2.patch\n   $ git commit -m \"HBASE-XXXX Really Good Code Fix (Joe Schmo)\" --author=<contributor> -a  # This and next command is needed for patches created with 'git diff'\n   $ git commit --amend --signoff\n   $ git checkout master\n   $ git pull --rebase\n   $ git cherry-pick <sha-from-commit>\n   # Resolve conflicts if necessary or ask the submitter to do it\n   $ git pull --rebase          # Better safe than sorry\n   $ git push origin master\n\n   # Backport to branch-1\n   $ git checkout branch-1\n   $ git pull --rebase\n   $ git cherry-pick <sha-from-commit>\n   # Resolve conflicts if necessary or ask the submitter to do it\n   $ git pull --rebase           # Better safe than sorry\n   $ git push origin branch-1\n   $ git branch -D HBASE-XXXX\n   ```\n\n3. Resolve the issue as fixed, thanking the contributor.\n   Always set the \"Fix Version\" at this point, but only set a single fix version\n   for each branch where the change was committed, the earliest release in that\n   branch in which the change will appear.\n\n**Commit Message Format**\n\nThe commit message should contain the JIRA ID and a description of what the patch does.\nThe preferred commit message format is:\n\n```text\n<jira-id> <jira-title> (<contributor-name-if-not-commit-author>)\n```\n\n```text\nHBASE-12345 Fix All The Things (jane@example.com)\n```\n\nIf the contributor used `git format-patch` to generate the patch, their commit\nmessage is in their patch and you can use that, but be sure the JIRA ID is at\nthe front of the commit message, even if the contributor left it out.\n\n**Use GitHub's \"Co-authored-by\" when there are multiple authors**\n\nWe've established the practice of committing to master and then cherry picking back to branches whenever possible, unless\n\n* it's breaking compat: In which case, if it can go in minor releases, backport to branch-1 and branch-2.\n* it's a new feature: No for maintenance releases, For minor releases, discuss and arrive at consensus.\n\nThere are occasions when there are multiple author for a patch.\nFor example when there is a minor conflict we can fix it up and just proceed with the commit.\nThe amending author will be different from the original committer, so you should also attribute to the original author by\nadding one or more `Co-authored-by` trailers to the commit's message.\nSee [the GitHub documentation for \"Creating a commit with multiple authors\"](https://help.github.com/en/articles/creating-a-commit-with-multiple-authors/).\n\nIn short, these are the steps to add Co-authors that will be tracked by GitHub:\n\n1. Collect the name and email address for each co-author.\n2. Commit the change, but after your commit description, instead of a closing quotation, add two empty lines. (Do not close the commit message with a quotation mark)\n3. On the next line of the commit message, type `Co-authored-by: name <name@example.com>`. After the co-author information, add a closing quotation mark.\n\nHere is the example from the GitHub page, using 2 Co-authors:\n\n```bash\n$ git commit -m \"Refactor usability tests.\n>\n>\nCo-authored-by: name <name@example.com>\nCo-authored-by: another-name <another-name@example.com>\"\n```\n\nNote: `Amending-Author: Author <committer@apache>` was used prior to this\n[DISCUSSION](https://lists.apache.org/thread.html/f00b5f9b65570e777dbb31c37d7b0ffc55c5fc567aefdb456608a042@%3Cdev.hbase.apache.org%3E).\n\n**Close related GitHub PRs**\n\nAs a project we work to ensure there's a JIRA associated with each change, but we don't mandate any particular tool be used for reviews. Due to implementation details of the ASF's integration between hosted git repositories and GitHub, the PMC has no ability to directly close PRs on our GitHub repo. In the event that a contributor makes a Pull Request on GitHub, either because the contributor finds that easier than attaching a patch to JIRA or because a reviewer prefers that UI for examining changes, it's important to make note of the PR in the commit that goes to the master branch so that PRs are kept up to date.\n\nTo read more about the details of what kinds of commit messages will work with the GitHub \"close via keyword in commit\" mechanism see [the GitHub documentation for \"Closing issues using keywords\"](https://help.github.com/articles/closing-issues-using-keywords/). In summary, you should include a line with the phrase \"closes #XXX\", where the XXX is the pull request id. The pull request id is usually given in the GitHub UI in grey at the end of the subject heading.\n\n**Committers are responsible for making sure commits do not break the build or tests**\n\nIf a committer commits a patch, it is their responsibility to make sure it passes the test suite.\nIt is helpful if contributors keep an eye out that their patch does not break the hbase build and/or tests, but ultimately, a contributor cannot be expected to be aware of all the particular vagaries and interconnections that occur in a project like HBase.\nA committer should.\n\n**Patching Etiquette**\n\nIn the thread [HBase, mail # dev - ANNOUNCEMENT: Git Migration In Progress (WAS =>\nRe: Git Migration)](https://lists.apache.org/thread.html/186fcd5eb71973a7b282ecdba41606d3d221efd505d533bb729e1fad%401400648690%40%3Cdev.hbase.apache.org%3E), it was agreed on the following patch flow\n\n1. Develop and commit the patch against master first.\n2. Try to cherry-pick the patch when backporting if possible.\n3. If this does not work, manually commit the patch to the branch.\n\n**Merge Commits**\n\nAvoid merge commits, as they create problems in the git history.\n\n**Committing Documentation**\n\nSee [appendix contributing to documentation](/docs/contributing-to-documentation).\n\n**How to re-trigger github Pull Request checks/re-build**\n\nA Pull Request (PR) submission triggers the hbase yetus checks. The checks make\nsure the patch doesn't break the build or introduce test failures. The checks take\naround four hours to run (They are the same set run when you submit a patch via\nHBASE JIRA). When finished, they add a report to the PR as a comment. If a problem\nw/ the patch — failed compile, checkstyle violation, or an added findbugs --\nthe original author makes fixes and pushes a new patch. This re-runs the checks\nto produce a new report.\n\nSometimes though, the patch is good but a flakey, unrelated test has the report vote -1\non the patch. In this case, **committers** can retrigger the check run by doing a force push of the\nexact same patch. Or, click on the `Console output` link which shows toward the end\nof the report (For example `https://builds.apache.org/job/HBase-PreCommit-GitHub-PR/job/PR-289/1/console`).\nThis will take you to `builds.apache.org`, to the build run that failed. See the\n\"breadcrumbs\" along the top (where breadcrumbs is the listing of the directories that\ngets us to this particular build page). It'll look something like\n`Jenkins > HBase-PreCommit-GitHub-PR > PR-289 > #1`. Click on the\nPR number — i.e. PR-289 in our example — and then, when you've arrived at the PR page,\nfind the 'Build with Parameters' menu-item (along top left-hand menu). Click here and\nthen `Build` leaving the JIRA\\_ISSUE\\_KEY empty. This will re-run your checks.\n\n### Dialog\n\nCommitters should hang out in the #hbase room on irc.freenode.net for real-time discussions.\nHowever any substantive discussion (as with any off-list project-related discussion) should be re-iterated in Jira or on the developer list.\n\n### Do not edit JIRA comments\n\nMisspellings and/or bad grammar is preferable to the disruption a JIRA comment edit.\n\n## The hbase-thirdparty dependency and shading/relocation\n\nA new project was created for the release of hbase-2.0.0. It was called\n`hbase-thirdparty`. This project exists only to provide the main hbase\nproject with relocated — or shaded — versions of popular thirdparty\nlibraries such as guava, netty, and protobuf. The mainline HBase project\nrelies on the relocated versions of these libraries gotten from hbase-thirdparty\nrather than on finding these classes in their usual locations. We do this so\nwe can specify whatever the version we wish. If we don't relocate, we must\nharmonize our version to match that which hadoop, spark, and other projects use.\n\nFor developers, this means you need to be careful referring to classes from\nnetty, guava, protobuf, gson, etc. (see the hbase-thirdparty pom.xml for what\nit provides). Devs must refer to the hbase-thirdparty provided classes. In\npractice, this is usually not an issue (though it can be a bit of a pain). You\nwill have to hunt for the relocated version of your particular class. You'll\nfind it by prepending the general relocation prefix of `org.apache.hbase.thirdparty.`.\nFor example if you are looking for `com.google.protobuf.Message`, the relocated\nversion used by HBase internals can be found at\n`org.apache.hbase.thirdparty.com.google.protobuf.Message`.\n\nFor a few thirdparty libs, like protobuf (see the protobuf chapter in this book\nfor the why), your IDE may give you both options — the `com.google.protobuf.*`\nand the `org.apache.hbase.thirdparty.com.google.protobuf.*` — because both\nclasses are on your CLASSPATH. Unless you are doing the particular juggling\nrequired in Coprocessor Endpoint development (again see above cited protobuf\nchapter), you'll want to use the shaded version, always.\n\nThe `hbase-thirdparty` project has groupid of `org.apache.hbase.thirdparty`.\nAs of this writing, it provides three jars; one for netty with an artifactid of\n`hbase-thirdparty-netty`, one for protobuf at `hbase-thirdparty-protobuf` and then\na jar for all else — gson, guava — at `hbase-thirdpaty-miscellaneous`.\n\nThe hbase-thirdparty artifacts are a product produced by the Apache HBase\nproject under the aegis of the HBase Project Management Committee. Releases\nare done via the usual voting project on the hbase dev mailing list. If issue\nin the hbase-thirdparty, use the hbase JIRA and mailing lists to post notice.\n\n## Development of HBase-related Maven archetypes\n\nThe development of HBase-related Maven archetypes was begun with\n[HBASE-14876](https://issues.apache.org/jira/browse/HBASE-14876).\nFor an overview of the hbase-archetypes infrastructure and instructions\nfor developing new HBase-related Maven archetypes, please see\n`hbase/hbase-archetypes/README.md`.\n\n\n# Generating the HBase Reference Guide (/docs/building-and-developing/generating-documentation)\nThe manual is marked up using [MDX](https://mdxjs.com/) (just extended markdown).\nThen we render markdown into HTML content by using [Fumadocs](https://fumadocs.dev/).\nTo build run `mvn site` from the root or `hbase-website` directory.\nSee [appendix contributing to documentation](/docs/contributing-to-documentation) for more information on building the documentation.\n\n\n# Getting Involved (/docs/building-and-developing/getting-involved)\nApache HBase gets better only when people contribute! If you are looking to contribute to Apache HBase, look for [issues in JIRA tagged with the label 'beginner'](https://issues.apache.org/jira/issues/?jql=project%20%3D%20HBASE%20AND%20labels%20in%20\\(beginner\\)%20AND%20status%20in%20\\(Open%2C%20%22In%20Progress%22%2C%20Reopened\\)).\nThese are issues HBase contributors have deemed worthy but not of immediate priority and a good way to ramp on HBase internals.\nSee [What label\nis used for issues that are good on ramps for new contributors?](https://lists.apache.org/thread.html/b122265f4e4054cf08f8cd38609fb06af72f398c44f9086b05ef4e21%401407246237%40%3Cdev.hbase.apache.org%3E) from the dev mailing list for background.\n\nBefore you get started submitting code to HBase, please refer to [Developer Guidelines](/docs/building-and-developing/developer-guidelines).\n\nAs Apache HBase is an Apache Software Foundation project, see [The Apache Software Foundation](/docs/asf) for more information about how the ASF functions.\n\n## Mailing Lists\n\nSign up for the dev-list and the user-list.\nSee the [mailing lists](/mailing-lists) page.\nPosing questions - and helping to answer other people's questions - is encouraged! There are varying levels of experience on both lists so patience and politeness are encouraged (and please stay on topic.)\n\n## Slack\n\nThe Apache HBase project uses the #hbase channel on the official\n[https://the-asf.slack.com/\\[ASF](https://the-asf.slack.com/\\[ASF) Slack Workspace] for real-time questions and discussion.\nAll committers of any Apache projects can join the channel directly, for others, please mail\n[dev@hbase.apache.org](mailto:dev@hbase.apache.org) to request an invite.\n\n## Internet Relay Chat (IRC)\n\n(NOTE: Our IRC channel seems to have been deprecated in favor of the above Slack channel)\n\nFor real-time questions and discussions, use the `#hbase` IRC channel on the [FreeNode](https://freenode.net/) IRC network.\nFreeNode offers a web-based client, but most people prefer a native client, and several clients are available for each operating system.\n\n## Jira\n\nCheck for existing issues in [Jira](https://issues.apache.org/jira/projects/HBASE/issues).\nIf it's either a new feature request, enhancement, or a bug, file a ticket.\n\nWe track multiple types of work in JIRA:\n\n* Bug: Something is broken in HBase itself.\n* Test: A test is needed, or a test is broken.\n* New feature: You have an idea for new functionality. It's often best to bring\n  these up on the mailing lists first, and then write up a design specification\n  that you add to the feature request JIRA.\n* Improvement: A feature exists, but could be tweaked or augmented. It's often\n  best to bring these up on the mailing lists first and have a discussion, then\n  summarize or link to the discussion if others seem interested in the\n  improvement.\n* Wish: This is like a new feature, but for something you may not have the\n  background to flesh out yourself.\n\nBugs and tests have the highest priority and should be actionable.\n\n### Guidelines for reporting effective issues\n\n* *Search for duplicates*: Your issue may have already been reported. Have a\n  look, realizing that someone else might have worded the summary differently.\n\n  Also search the mailing lists, which may have information about your problem\n  and how to work around it. Don't file an issue for something that has already\n  been discussed and resolved on a mailing list, unless you strongly disagree\n  with the resolution *and* are willing to help take the issue forward.\n\n  * *Discuss in public*: Use the mailing lists to discuss what you've discovered\n    and see if there is something you've missed. Avoid using back channels, so\n    that you benefit from the experience and expertise of the project as a whole.\n  * *Don't file on behalf of others*: You might not have all the context, and you\n    don't have as much motivation to see it through as the person who is actually\n    experiencing the bug. It's more helpful in the long term to encourage others\n    to file their own issues. Point them to this material and offer to help out\n    the first time or two.\n  * *Write a good summary*: A good summary includes information about the problem,\n    the impact on the user or developer, and the area of the code.\n    * Good: `Address new license dependencies from hadoop3-alpha4`\n    * Room for improvement: `Canary is broken`\n      If you write a bad title, someone else will rewrite it for you. This is time\n      they could have spent working on the issue instead.\n  * *Give context in the description*: It can be good to think of this in multiple\n    parts:\n    * What happens or doesn't happen?\n    * How does it impact you?\n    * How can someone else reproduce it?\n    * What would \"fixed\" look like?\\\n      You don't need to know the answers for all of these, but give as much\n      information as you can. If you can provide technical information, such as a\n      Git commit SHA that you think might have caused the issue or a build failure\n      on builds.apache.org where you think the issue first showed up, share that\n      info.\n  * **Fill in all relevant fields**: These fields help us filter, categorize, and\n    find things.\n  * **One bug, one issue, one patch**: To help with back-porting, don't split issues\n    or fixes among multiple bugs.\n  * **Add value if you can**: Filing issues is great, even if you don't know how to\n    fix them. But providing as much information as possible, being willing to\n    triage and answer questions, and being willing to test potential fixes is even\n    better! We want to fix your issue as quickly as you want it to be fixed.\n  * **Don't be upset if we don't fix it**: Time and resources are finite. In some\n    cases, we may not be able to (or might choose not to) fix an issue, especially\n    if it is an edge case or there is a workaround. Even if it doesn't get fixed,\n    the JIRA is a public record of it, and will help others out if they run into\n    a similar issue in the future.\n\n### Working on an issue\n\nTo check for existing issues which you can tackle as a beginner, search for [issues in JIRA tagged with the label 'beginner'](https://issues.apache.org/jira/issues/?jql=project%20%3D%20HBASE%20AND%20labels%20in%20\\(beginner\\)%20AND%20status%20in%20\\(Open%2C%20%22In%20Progress%22%2C%20Reopened\\)).\n\nJIRA Priorites:\n\n* **Blocker**: Should only be used if the issue WILL cause data loss or cluster instability reliably.\n* **Critical**: The issue described can cause data loss or cluster instability in some cases.\n* **Major**: Important but not tragic issues, like updates to the client API that will add a lot of much-needed functionality or significant bugs that need to be fixed but that don't cause data loss.\n* **Minor**: Useful enhancements and annoying but not damaging bugs.\n* **Trivial**: Useful enhancements but generally cosmetic.\n\nCode Blocks in Jira Comments:\n\nA commonly used macro in Jira is `{code}`. Everything inside the tags is preformatted, as in this example.\n\n```text\n{code}\ncode snippet\n{code}\n```\n\n\n# IDEs (/docs/building-and-developing/ides)\n## Eclipse\n\n### Code Formatting\n\nUnder the *dev-support/* folder, you will find *hbase\\_eclipse\\_formatter.xml*.\nWe encourage you to have this formatter in place in eclipse when editing HBase code.\n\nGo to `Preferences->Java->Code Style->Formatter->Import` to load the xml file.\nGo to `Preferences->Java->Editor->Save Actions`, and make sure 'Format source code' and 'Format\nedited lines' is selected.\n\nIn addition to the automatic formatting, make sure you follow the style guidelines explained in\n[Code Formatting Conventions](/docs/building-and-developing/developer-guidelines#code-formatting-conventions).\n\n### Eclipse Git Plugin\n\nIf you cloned the project via git, download and install the Git plugin (EGit). Attach to your local git repo (via the Git Repositories window) and you'll be able to see file revision history, generate patches, etc.\n\n### HBase Project Setup in Eclipse using `m2eclipse`\n\nThe easiest way is to use the `m2eclipse` plugin for Eclipse.\nEclipse Indigo or newer includes +m2eclipse+, or you can download it from [http://www.eclipse.org/m2e/](http://www.eclipse.org/m2e/). It provides Maven integration for Eclipse, and even lets you use the direct Maven commands from within Eclipse to compile and test your project.\n\nTo import the project, click and select the HBase root directory. `m2eclipse` locates all the hbase modules for you.\n\nIf you install `m2eclipse` and import HBase in your workspace, do the following to fix your eclipse Build Path.\n\n* Remove *target* folder\n* Add *target/generated-sources/java* folder.\n* Remove from your Build Path the exclusions on the *src/main/resources* and *src/test/resources* to avoid error message in the console, such as the following:\n  ```text\n  Failed to execute goal\n  org.apache.maven.plugins:maven-antrun-plugin:1.6:run (default) on project hbase:\n  'An Ant BuildException has occurred: Replace: source file .../target/classes/hbase-default.xml\n  doesn't exist\n  ```\n  This will also reduce the eclipse build cycles and make your life easier when developing.\n\n### HBase Project Setup in Eclipse Using the Command Line\n\nInstead of using `m2eclipse`, you can generate the Eclipse files from the command line.\n\n* First, run the following command, which builds HBase.\n  You only need to do this once.\n\n  ```bash\n  mvn clean install -DskipTests\n  ```\n\n* Close Eclipse, and execute the following command from the terminal, in your local HBase project directory, to generate new *.project* and *.classpath* files.\n\n  ```bash\n  mvn eclipse:eclipse\n  ```\n\n* Reopen Eclipse and import the *.project* file in the HBase directory to a workspace.\n\n### Maven Classpath Variable\n\nThe `$M2_REPO` classpath variable needs to be set up for the project.\nThis needs to be set to your local Maven repository, which is usually *\\~/.m2/repository*\n\nIf this classpath variable is not configured, you will see compile errors in Eclipse like this:\n\n```text\nDescription        Resource        Path        Location        Type\nThe project cannot be built until build path errors are resolved        hbase                Unknown        Java Problem\nUnbound classpath variable: 'M2_REPO/asm/asm/3.1/asm-3.1.jar' in project 'hbase'        hbase                Build path        Build Path Problem\nUnbound classpath variable: 'M2_REPO/com/google/guava/guava/r09/guava-r09.jar' in project 'hbase'        hbase                Build path        Build Path Problem\nUnbound classpath variable: 'M2_REPO/com/google/protobuf/protobuf-java/2.3.0/protobuf-java-2.3.0.jar' in project 'hbase'        hbase                Build path        Build Path Problem Unbound classpath variable:\n```\n\n### Eclipse Known Issues\n\nEclipse will currently complain about *Bytes.java*.\nIt is not possible to turn these errors off.\n\n```text\nDescription        Resource        Path        Location        Type\nAccess restriction: The method arrayBaseOffset(Class) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar        Bytes.java        /hbase/src/main/java/org/apache/hadoop/hbase/util        line 1061        Java Problem\nAccess restriction: The method arrayIndexScale(Class) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar        Bytes.java        /hbase/src/main/java/org/apache/hadoop/hbase/util        line 1064        Java Problem\nAccess restriction: The method getLong(Object, long) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar        Bytes.java        /hbase/src/main/java/org/apache/hadoop/hbase/util        line 1111        Java Problem\n```\n\n### Eclipse - More Information\n\nFor additional information on setting up Eclipse for HBase development on Windows, see [Michael Morello's blog](http://michaelmorello.blogspot.com/2011/09/hbase-subversion-eclipse-windows.html) on the topic.\n\n## IntelliJ IDEA\n\nA functional development environment can be setup around an IntelliJ IDEA installation that has the\nplugins necessary for building Java projects with Maven.\n\n* Use either File > New > \"Project from Existing Sources...\" or \"Project From Version Control..\"\n* Depending on your version of IntelliJ, you may need to choose Maven as the \"project\" or \"model\"\n  type.\n\nThe following plugins are recommended:\n\n* Maven, bundled. This allows IntelliJ to resolve dependencies and recognize the project structure.\n* EditorConfig, bundled. This will apply project whitespace settings found in the\n  `.editorconfig` file available on branches with\n  [HBASE-23234](https://issues.apache.org/jira/browse/HBASE-23234) or later.\n* [Checkstyle-IDEA](https://plugins.jetbrains.com/plugin/1065-checkstyle-idea/). Configure this\n  against the configuration file found under `hbase-checkstyle/src/main/resources/hbase/checkstyle.xml`\n  (If the Intellij checkstyle plugin complains parsing the volunteered hbase `checkstyle.xml`, make\n  sure the plugin's `version` popup menu matches the hbase checkstyle version. Find the current\n  checkstyle version as a property in `pom.xml`.\n  This plugin will highlight style errors in the IDE, so you can fix them before they get flagged during the\n  pre-commit process.\n* [Protobuf Support](https://plugins.jetbrains.com/plugin/8277-protobuf-support/). HBase uses\n  [Protocol Buffers](https://developers.google.com/protocol-buffers/) in a number of places where\n  serialization is required. This plugin is helpful when editing these object definitions.\n* [MDX](https://plugins.jetbrains.com/plugin/14944-mdx). HBase uses\n  [MDX](https://mdxjs.com) (just extended markdown) for building it's project documentation. This plugin is helpful\n  when editing this book.\n\n## Other IDEs\n\nIf you'd have another environment with which you'd like to develop on HBase, please consider\ndocumenting your setup process here.\n\n\n# Building and Developing Apache HBase (/docs/building-and-developing)\nThis chapter contains information and guidelines for building and releasing HBase code and documentation.\nBeing familiar with these guidelines will help the HBase committers to use your contributions more easily.\n\n\n# Releasing Apache HBase (/docs/building-and-developing/releasing)\n<Callout type=\"info\" title=\"Building against HBase 1.x\">\n  See old refguides for how to build HBase 1.x. The below is for building hbase2.\n</Callout>\n\n## Making a Release Candidate\n\nOnly committers can make releases of hbase artifacts.\n\n**Before You Begin**\n\nCheck to be sure recent builds have been passing for the branch from where you\nare going to take your release. You should also have tried recent branch tips\nout on a cluster under load, perhaps by running the `hbase-it` integration test\nsuite for a few hours to 'burn in' the near-candidate bits.\n\nYou will need a published signing key added to the hbase\n[KEYS](https://dist.apache.org/repos/dist/release/hbase/KEYS) file.\n(For how to add a KEY, see *Step 1.* in [How To Release](https://cwiki.apache.org/confluence/display/HADOOP2/HowToRelease),\nthe Hadoop version of this document).\n\nNext make sure JIRA is properly primed, that all issues targeted against\nthe prospective release have been resolved and are present in git on the\nparticular branch. If any outstanding issues, move them out of the release by\nadjusting the fix version to remove this pending release as a target.\nAny JIRA with a fix version that matches the release candidate\ntarget release will be included in the generated *CHANGES.md/RELEASENOTES.md*\nfiles that ship with the release so make sure JIRA is correct before you begin.\n\nAfter doing the above, you can move to the manufacture of an RC.\n\nBuilding an RC is involved so we've scripted it. The script builds in a Docker\ncontainer to ensure we have a consistent environment building. It will ask you\nfor passwords for apache and for your gpg signing key so it can sign and commit\non your behalf. The passwords are passed to gpg-agent in the container and\npurged along with the container when the build is done.\n\nThe script will:\n\n* Set version to the release version\n* Updates RELEASENOTES.md and CHANGES.md\n* Tag the RC\n* Set version to next SNAPSHOT version.\n* Builds, signs, and hashes all artifacts.\n* Generates the api compatibility report\n* Pushes release tgzs to the dev dir in a apache dist.\n* Pushes to repository.apache.org staging.\n* Creates vote email template.\n\nThe *dev-support/create-release/do-release-docker.sh* Release Candidate (RC)\nGenerating script is maintained in the master branch but can generate RCs\nfor any 2.x+ branch (The script does not work against branch-1). Check out\nand update the master branch when making RCs. See\n*dev-support/create-release/README.txt* for how to configure your\nenvironment and run the script.\n\n<Callout type=\"info\">\n  *dev-support/create-release/do-release-docker.sh* supercedes the previous *dev-support/make\\_rc.sh*\n  script. It is more comprehensive automating all steps, rather than a portion, building a RC.\n</Callout>\n\n### Release Candidate Procedure\n\nHere we outline the steps involved generating a Release Candidate, the steps\nautomated by the *dev-support/create-release/do-release-docker.sh* script\ndescribed in the previous section. Running these steps manually tends to\nbe error-prone so is not recommended. The below is informational only.\n\nThe process below makes use of various tools, mainly *git* and *maven*.\n\n<Callout type=\"info\" title=\"Specifying the Heap Space for Maven\">\n  You may run into OutOfMemoryErrors building, particularly building the site and\n  documentation. Up the heap for Maven by setting the `MAVEN_OPTS` variable.\n  You can prefix the variable to the Maven command, as in the following example:\n\n  ```bash\n  MAVEN_OPTS=\"-Xmx4g -XX:MaxPermSize=256m\" mvn package\n  ```\n\n  You could also set this in an environment variable or alias in your shell.\n</Callout>\n\n<Steps>\n  <Step>\n    #### Example *\\~/.m2/settings.xml* File\n\n    Publishing to maven requires you sign the artifacts you want to upload.\n    For the build to sign them for you, you a properly configured *settings.xml*\n    in your local repository under *.m2*, such as the following.\n\n    ```xml\n    <settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0\n                          http://maven.apache.org/xsd/settings-1.0.0.xsd\">\n      <servers>\n        <!- To publish a snapshot of some part of Maven -->\n        <server>\n          <id>apache.snapshots.https</id>\n          <username>YOUR_APACHE_ID\n          </username>\n          <password>YOUR_APACHE_PASSWORD\n          </password>\n        </server>\n        <!-- To publish a website using Maven -->\n        <!-- To stage a release of some part of Maven -->\n        <server>\n          <id>apache.releases.https</id>\n          <username>YOUR_APACHE_ID\n          </username>\n          <password>YOUR_APACHE_PASSWORD\n          </password>\n        </server>\n      </servers>\n      <profiles>\n        <profile>\n          <id>apache-release</id>\n          <properties>\n        <gpg.keyname>YOUR_KEYNAME</gpg.keyname>\n        <!--Keyname is something like this ... 00A5F21E... do `gpg ——list-keys` to find it-->\n        <gpg.passphrase>YOUR_KEY_PASSWORD\n        </gpg.passphrase>\n          </properties>\n        </profile>\n      </profiles>\n    </settings>\n    ```\n  </Step>\n\n  <Step>\n    #### Update the *CHANGES.md* and *RELEASENOTES.md* files and the POM files.\n\n    Update *CHANGES.md* with the changes since the last release. Be careful with where you put\n    headings and license. Respect the instructions and warning you find in current\n    *CHANGES.md* and *RELEASENOTES.md* since these two files are processed by tooling that is\n    looking for particular string sequences. See [HBASE-21399](https://issues.apache.org/jira/browse/HBASE-21399)\n    for description on how to make use of yetus generating additions to\n    *CHANGES.md* and *RELEASENOTES.md* (RECOMMENDED!). Adding JIRA fixes, make sure the\n    URL to the JIRA points to the proper location which lists fixes for this release.\n\n    Next, adjust the version in all the POM files appropriately.\n    If you are making a release candidate, you must remove the `-SNAPSHOT` label from all versions\n    in all pom.xml files.\n    If you are running this receipe to publish a snapshot, you must keep the `-SNAPSHOT` suffix on the hbase version.\n    The [Versions Maven Plugin](http://www.mojohaus.org/versions-maven-plugin/) can be of use here.\n    To set a version in all the many poms of the hbase multi-module project, use a command like the following:\n\n    ```bash\n    $ mvn clean org.codehaus.mojo:versions-maven-plugin:2.5:set -DnewVersion=2.1.0-SNAPSHOT\u001a\n    ```\n\n    Make sure all versions in poms are changed! Checkin the *CHANGES.md*, *RELEASENOTES.md*, and\n    any maven version changes.\n  </Step>\n\n  <Step>\n    #### Update the documentation.\n\n    Update the documentation under *hbase-website/app/page/\\_docs/docs/\\_mdx/(multi-page)*.\n    This usually involves copying the latest from master branch and making version-particular\n    adjustments to suit this release candidate version. Commit your changes.\n  </Step>\n\n  <Step>\n    #### Clean the checkout dir\n\n    ```bash\n    $ mvn clean\n    $ git clean -f -x -d\n    ```\n  </Step>\n\n  <Step>\n    #### Run Apache-Rat\n\n    Check licenses are good\n\n    ```bash\n    $ mvn apache-rat:check\n    ```\n\n    If the above fails, check the rat log.\n\n    ```bash\n    $ grep 'Rat check' patchprocess/mvn_apache_rat.log\n    ```\n  </Step>\n\n  <Step>\n    #### Create a release tag.\n\n    Presuming you have run basic tests, the rat check, passes and all is\n    looking good, now is the time to tag the release candidate (You\n    always remove the tag if you need to redo). To tag, do\n    what follows substituting in the version appropriate to your build.\n    All tags should be signed tags; i.e. pass the *-s* option (See\n    [Signing Your Work](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work)\n    for how to set up your git environment for signing).\n\n    ```bash\n    $ git tag -s 2.0.0-alpha4-RC0 -m \"Tagging the 2.0.0-alpha4 first Releae Candidate (Candidates start at zero)\"\n    ```\n\n    Or, if you are making a release, tags should have a *rel/* prefix to ensure\n    they are preserved in the Apache repo as in:\n\n    ```bash\n    +$ git tag -s rel/2.0.0-alpha4 -m \"Tagging the 2.0.0-alpha4 Release\"\n    ```\n\n    Push the (specific) tag (only) so others have access.\n\n    ```bash\n    $ git push origin 2.0.0-alpha4-RC0\n    ```\n\n    For how to delete tags, see\n    [How to Delete a Tag](http://www.manikrathee.com/how-to-delete-a-tag-in-git.html). Covers\n    deleting tags that have not yet been pushed to the remote Apache\n    repo as well as delete of tags pushed to Apache.\n  </Step>\n\n  <Step>\n    #### Build the source tarball.\n\n    Now, build the source tarball. Lets presume we are building the source\n    tarball for the tag *2.0.0-alpha4-RC0* into */tmp/hbase-2.0.0-alpha4-RC0/*\n    (This step requires that the mvn and git clean steps described above have just been done).\n\n    ```bash\n    $ git archive --format=tar.gz --output=\"/tmp/hbase-2.0.0-alpha4-RC0/hbase-2.0.0-alpha4-src.tar.gz\" --prefix=\"hbase-2.0.0-alpha4/\" $git_tag\n    ```\n\n    Above we generate the hbase-2.0.0-alpha4-src.tar.gz tarball into the\n    */tmp/hbase-2.0.0-alpha4-RC0* build output directory (We don't want the *RC0* in the name or prefix.\n    These bits are currently a release candidate but if the VOTE passes, they will become the release so we do not taint\n    the artifact names with *RCX*).\n  </Step>\n\n  <Step>\n    #### Build the binary tarball.\n\n    Next, build the binary tarball. Add the `-Prelease` profile when building.\n    It runs the license apache-rat check among other rules that help ensure\n    all is wholesome. Do it in two steps.\n\n    First install into the local repository\n\n    ```bash\n    $ mvn clean install -DskipTests -Prelease\n    ```\n\n    Next, generate documentation and assemble the tarball. Be warned,\n    this next step can take a good while, a couple of hours generating site\n    documentation.\n\n    ```bash\n    $ mvn install -DskipTests site assembly:single -Prelease\n    ```\n\n    Otherwise, the build complains that hbase modules are not in the maven repository\n    when you try to do it all in one step, especially on a fresh repository.\n    It seems that you need the install goal in both steps.\n\n    Extract the generated tarball — you'll find it under\n    *hbase-assembly/target* and check it out.\n    Look at the documentation, see if it runs, etc.\n    If good, copy the tarball beside the source tarball in the\n    build output directory.\n  </Step>\n\n  <Step>\n    #### Deploy to the Maven Repository.\n\n    Next, deploy HBase to the Apache Maven repository. Add the\n    apache-release`profile when running the`mvn deploy\\` command.\n    This profile comes from the Apache parent pom referenced by our pom files.\n    It does signing of your artifacts published to Maven, as long as the\n    *settings.xml* is configured correctly, as described in [Example \\~/.m2/settings.xml File](/docs/building-and-developing/releasing#example-m2settingsxml-file).\n    This step depends on the local repository having been populate\n    by the just-previous bin tarball build.\n\n    ```bash\n    $ mvn deploy -DskipTests -Papache-release -Prelease\n    ```\n\n    This command copies all artifacts up to a temporary staging Apache mvn repository in an 'open' state.\n    More work needs to be done on these maven artifacts to make them generally available.\n\n    We do not release HBase tarball to the Apache Maven repository. To avoid deploying the tarball, do not\n    include the `assembly:single` goal in your `mvn deploy` command. Check the deployed artifacts as described in the next section.\n\n    <Callout type=\"info\" title=\"make_rc.sh\">\n      If you ran the old *dev-support/make\\_rc.sh* script, this is as far as it takes you. To finish the\n      release, take up the script from here on out.\n    </Callout>\n  </Step>\n\n  <Step>\n    #### Make the Release Candidate available.\n\n    The artifacts are in the maven repository in the staging area in the 'open' state.\n    While in this 'open' state you can check out what you've published to make sure all is good.\n    To do this, log in to Apache's Nexus at [repository.apache.org](https://repository.apache.org) using your Apache ID.\n    Find your artifacts in the staging repository. Click on 'Staging Repositories' and look for a new one ending in \"hbase\" with a status of 'Open', select it.\n    Use the tree view to expand the list of repository contents and inspect if the artifacts you expect are present. Check the POMs.\n    As long as the staging repo is open you can re-upload if something is missing or built incorrectly.\n\n    If something is seriously wrong and you would like to back out the upload, you can use the 'Drop' button to drop and delete the staging repository.\n    Sometimes the upload fails in the middle. This is another reason you might have to 'Drop' the upload from the staging repository.\n\n    If it checks out, close the repo using the 'Close' button. The repository must be closed before a public URL to it becomes available. It may take a few minutes for the repository to close. Once complete you'll see a public URL to the repository in the Nexus UI. You may also receive an email with the URL. Provide the URL to the temporary staging repository in the email that announces the release candidate.\n    (Folks will need to add this repo URL to their local poms or to their local *settings.xml* file to pull the published release candidate artifacts.)\n\n    When the release vote concludes successfully, return here and click the 'Release' button to release the artifacts to central. The release process will automatically drop and delete the staging repository.\n\n    <Callout type=\"info\" title=\"hbase-downstreamer\">\n      See the [hbase-downstreamer](https://github.com/saintstack/hbase-downstreamer) test for a simple\n      example of a project that is downstream of HBase an depends on it. Check it out and run its simple\n      test to make sure maven artifacts are properly deployed to the maven repository. Be sure to edit\n      the pom to point to the proper staging repository. Make sure you are pulling from the repository\n      when tests run and that you are not getting from your local repository, by either passing the `-U`\n      flag or deleting your local repo content and check maven is pulling from remote out of the staging\n      repository.\n    </Callout>\n\n    See [Publishing Maven Artifacts](https://www.apache.org/dev/publishing-maven-artifacts.html) for some pointers on this maven staging process.\n\n    If the HBase version ends in `-SNAPSHOT`, the artifacts go elsewhere.\n    They are put into the Apache snapshots repository directly and are immediately available.\n    Making a SNAPSHOT release, this is what you want to happen.\n\n    At this stage, you have two tarballs in your 'build output directory' and a set of artifacts\n    in a staging area of the maven repository, in the 'closed' state.\n    Next sign, fingerprint and then 'stage' your release candiate build output directory via svnpubsub by committing\n    your directory to [The dev distribution directory](https://dist.apache.org/repos/dist/dev/hbase/)\n    (See comments on [HBASE-10554 Please delete old releases from mirroring system](https://issues.apache.org/jira/browse/HBASE-10554)\n    but in essence it is an svn checkout of [dev/hbase](https://dist.apache.org/repos/dist/dev/hbase) — releases are at\n    [release/hbase](https://dist.apache.org/repos/dist/release/hbase)). In the *version directory* run the following commands:\n\n    ```bash\n    $ for i in *.tar.gz; do echo $i; gpg --print-md MD5 $i > $i.md5 ; done\n    $ for i in *.tar.gz; do echo $i; gpg --print-md SHA512 $i > $i.sha ; done\n    $ for i in *.tar.gz; do echo $i; gpg --armor --output $i.asc --detach-sig $i  ; done\n    $ cd ..\n    # Presuming our 'build output directory' is named 0.96.0RC0, copy it to the svn checkout of the dist dev dir\n    # in this case named hbase.dist.dev.svn\n    $ cd /Users/stack/checkouts/hbase.dist.dev.svn\n    $ svn info\n    Path: .\n    Working Copy Root Path: /Users/stack/checkouts/hbase.dist.dev.svn\n    URL: https://dist.apache.org/repos/dist/dev/hbase\n    Repository Root: https://dist.apache.org/repos/dist\n    Repository UUID: 0d268c88-bc11-4956-87df-91683dc98e59\n    Revision: 15087\n    Node Kind: directory\n    Schedule: normal\n    Last Changed Author: ndimiduk\n    Last Changed Rev: 15045\n    Last Changed Date: 2016-08-28 11:13:36 -0700 (Sun, 28 Aug 2016)\n    $ mv 0.96.0RC0 /Users/stack/checkouts/hbase.dist.dev.svn\n    $ svn add 0.96.0RC0\n    $ svn commit ...\n    ```\n\n    Ensure it actually gets published by checking [https://dist.apache.org/repos/dist/dev/hbase/](https://dist.apache.org/repos/dist/dev/hbase/).\n\n    Announce the release candidate on the mailing list and call a vote.\n  </Step>\n</Steps>\n\n### Publishing a SNAPSHOT to maven\n\nMake sure your *settings.xml* is set up properly (see [Example \\~/.m2/settings.xml File](/docs/building-and-developing/releasing#example-m2settingsxml-file)).\nMake sure the hbase version includes `-SNAPSHOT` as a suffix.\nFollowing is an example of publishing SNAPSHOTS of a release that had an hbase version of 0.96.0 in its poms.\n\n```bash\n$ mvn clean install -DskipTests  javadoc:aggregate site assembly:single -Prelease\n$ mvn -DskipTests  deploy -Papache-release\n```\n\nThe *make\\_rc.sh* script mentioned above (see [Making a Release Candidate](/docs/building-and-developing/releasing#making-a-release-candidate)) can help you publish `SNAPSHOTS`.\nMake sure your `hbase.version` has a `-SNAPSHOT` suffix before running the script.\nIt will put a snapshot up into the apache snapshot repository for you.\n\n\n# Apache HBase Repositories (/docs/building-and-developing/repositories)\nApache HBase consists of multiple repositories which are hosted on [Apache GitBox](https://gitbox.apache.org/).\nThese are the following:\n\n* [hbase](https://gitbox.apache.org/repos/asf?p=hbase.git) - main Apache HBase repository\n* [hbase-connectors](https://gitbox.apache.org/repos/asf?p=hbase-connectors.git) - connectors to Apache Kafka and Apache Spark\n* [hbase-operator-tools](https://gitbox.apache.org/repos/asf?p=hbase-operator-tools.git) - operability and supportability tools, such as [HBase HBCK2](/docs/operational-management/tools#hbase-hbck2)\n* [hbase-site](https://gitbox.apache.org/repos/asf?p=hbase-site.git) - hbase.apache.org website\n* [hbase-thirdparty](https://gitbox.apache.org/repos/asf?p=hbase-thirdparty.git) - relocated versions of popular third-party libraries\n\n\n# Tests (/docs/building-and-developing/tests)\nDevelopers, at a minimum, should familiarize themselves with the unit test detail; unit tests in HBase have a character not usually seen in other projects.\n\nThis information is about unit tests for HBase itself.\nFor developing unit tests for your HBase applications, see [Unit Testing HBase Applications](/docs/unit-testing).\n\n## Apache HBase Modules\n\nAs of 0.96, Apache HBase is split into multiple modules.\nThis creates \"interesting\" rules for how and where tests are written.\nIf you are writing code for `hbase-server`, see [Unit Tests](/docs/building-and-developing/tests#building-and-developing-unit-tests) for how to write your tests.\nThese tests can spin up a minicluster and will need to be categorized.\nFor any other module, for example `hbase-common`, the tests must be strict unit tests and just test the class under test - no use of the HBaseTestingUtility or minicluster is allowed (or even possible given the dependency tree).\n\nStarting from 3.0.0, HBaseTestingUtility is renamed to HBaseTestingUtil and marked as IA.Private. Of course the API is still the same.\n\n### Testing the HBase Shell\n\nThe HBase shell and its tests are predominantly written in jruby.\n\nIn order to make these tests run as a part of the standard build, there are a few JUnit test classes that take care of loading the jruby implemented tests and running them.\nThe tests were split into separate classes to accomodate class level timeouts (see [Unit Tests](/docs/building-and-developing/tests#building-and-developing-unit-tests) for specifics).\nYou can run all of these tests from the top level with:\n\n```bash\nmvn clean test -Dtest=Test*Shell\n```\n\nIf you have previously done a `mvn install`, then you can instruct maven to run only the tests in the hbase-shell module with:\n\n```bash\nmvn clean test -pl hbase-shell\n```\n\nAlternatively, you may limit the shell tests that run using the system variable `shell.test`.\nThis value should specify the ruby literal equivalent of a particular test case by name.\nFor example, the tests that cover the shell commands for altering tables are contained in the test case `AdminAlterTableTest` and you can run them with:\n\n```bash\nmvn clean test -pl hbase-shell -Dshell.test=/AdminAlterTableTest/\n```\n\nYou may also use a [Ruby Regular Expression\nliteral](https://docs.ruby-lang.org/en/master/syntax/literals_rdoc.html#label-Regexp+Literals) (in the `/pattern/` style) to select a set of test cases.\nYou can run all of the HBase admin related tests, including both the normal administration and the security administration, with the command:\n\n```bash\nmvn clean test -pl hbase-shell -Dshell.test=/.*Admin.*Test/\n```\n\nIn the event of a test failure, you can see details by examining the XML version of the surefire report results\n\n```bash\nvim hbase-shell/target/surefire-reports/TEST-org.apache.hadoop.hbase.client.TestShell.xml\n```\n\n### Running Tests in other Modules\n\nIf the module you are developing in has no other dependencies on other HBase modules, then you can cd into that module and just run:\n\n```bash\nmvn test\n```\n\nwhich will just run the tests IN THAT MODULE.\nIf there are other dependencies on other modules, then you will have run the command from the ROOT HBASE DIRECTORY.\nThis will run the tests in the other modules, unless you specify to skip the tests in that module.\nFor instance, to skip the tests in the hbase-server module, you would run:\n\n```bash\nmvn clean test -PskipServerTests\n```\n\nfrom the top level directory to run all the tests in modules other than hbase-server.\nNote that you can specify to skip tests in multiple modules as well as just for a single module.\nFor example, to skip the tests in `hbase-server` and `hbase-common`, you would run:\n\n```bash\nmvn clean test -PskipServerTests -PskipCommonTests\n```\n\nAlso, keep in mind that if you are running tests in the `hbase-server` module you will need to apply the maven profiles discussed in [Running tests](/docs/building-and-developing/tests#running-tests) to get the tests to run properly.\n\n## Unit Tests\n\nApache HBase unit tests must carry a Category annotation and\nas of `hbase-2.0.0`, must be stamped with the HBase `ClassRule`.\nHere is an example of what a Test Class looks like with a\nCategory and ClassRule included:\n\n```java\n...\n@Category(SmallTests.class)\npublic class TestHRegionInfo {\n  @ClassRule\n  public static final HBaseClassTestRule CLASS_RULE =\n      HBaseClassTestRule.forClass(TestHRegionInfo.class);\n\n  @Test\n  public void testCreateHRegionInfoName() throws Exception {\n    // ...\n  }\n}\n```\n\nHere the Test Class is `TestHRegionInfo`. The `CLASS_RULE` has\nthe same form in every test class only the `.class` you pass\nis that of the local test; i.e. in the TestTimeout Test Class, you'd\npass `TestTimeout.class` to the `CLASS_RULE` instead of the\n`TestHRegionInfo.class` we have above. The `CLASS_RULE`\nis where we'll enforce timeouts (currently set at a hard-limit of\nthirteen! minutes for all tests — 780 seconds) and other cross-unit test facility.\nThe test is in the `SmallTest` Category.\n\nCategories can be arbitrary and provided as a list but each test MUST\ncarry one from the following list of sizings: `small`, `medium`, `large`, and\n`integration`. The test sizing is designated using the JUnit\n[categories](https://github.com/junit-team/junit4/wiki/Categories): `SmallTests`, `MediumTests`, `LargeTests`, `IntegrationTests`.\nJUnit Categories are denoted using java annotations (a special unit test looks\nfor the presence of the @Category annotation in all unit tess and will fail if it\nfinds a test suite missing a sizing marking).\n\nThe first three categories, `small`, `medium`, and `large`, are for test cases which run when you\ntype `$ mvn test`.\nIn other words, these three categorizations are for HBase unit tests.\nThe `integration` category is not for unit tests, but for integration tests.\nThese are normally run when you invoke `$ mvn verify`.\nIntegration tests are described in [Integration Tests](/docs/building-and-developing/tests#building-and-developing-integration-tests).\n\nKeep reading to figure which annotation of the set `small`, `medium`, and `large`\nto put on your new HBase test case.\n\n### Categorizing Tests\n\n#### Small Tests:\n\n*Small* test cases are executed in separate JVM and each test suite/test class should\nrun in 15 seconds or less; i.e. a [junit test fixture](https://en.wikipedia.org/wiki/JUnit), a java object made\nup of test methods, should finish in under 15 seconds, no matter how many or how few test methods\nit has. These test cases should not use a minicluster as a minicluster starts many services,\nmost unrelated to what is being tested.\n\n#### Medium Tests:\n\n*Medium* test cases are executed in separate JVM and individual test suites or test classes or in\njunit parlance, [test fixture](https://en.wikipedia.org/wiki/JUnit), should run in 50 seconds\nor less. These test cases can use a mini cluster. Since we start up a JVM per test fixture (and\noften a cluster too), be sure to make the startup pay by writing test fixtures that do a lot of\ntesting running tens of seconds perhaps combining test rather than spin up a jvm (and cluster)\nper test method; this practice will help w/ overall test times.\n\n#### Large Tests:\n\n*Large* test cases are everything else. They are typically large-scale tests, regression tests\nfor specific bugs, timeout tests, or performance tests. No large test suite can take longer than\nthirteen minutes. It will be killed as timed out. Cast your test as an Integration Test if it needs\nto run longer.\n\n#### Integration Tests:\n\n*Integration* tests are system level tests.\nSee [Integration Tests](/docs/building-and-developing/tests#building-and-developing-integration-tests) for more info.\nIf you invoke `$ mvn test` on integration tests, there is no timeout for the test.\n\n## Running tests\n\nThe state of tests on the hbase branches varies. Some branches keep good test hygiene and all tests pass\nreliably with perhaps an unlucky sporadic flakey test failure. On other branches, the case may be less so with\nfrequent flakies and even broken tests in need of attention that fail 100% of the time. Try and figure\nthe state of tests on the branch you are currently interested in; the current state of nightly\n[apache jenkins builds](https://builds.apache.org/view/H-L/view/HBase/job/HBase%20Nightly/) is a good\nplace to start. Tests on master branch are generally not in the best of condition as releases\nare less frequent off master. This can make it hard landing patches especially given our dictum that\npatches land on master branch first.\n\nThe full test suite can take from 5-6 hours on an anemic VM with 4 CPUs and minimal\nparallelism to 50 minutes or less on a linux machine with dozens of CPUs and plenty of\nRAM.\n\nWhen you go to run the full test suite, make sure you up the test runner user nproc\n(`ulimit -u` — make sure it > 6000 or more if more parallelism) and the number of\nopen files (`ulimit -n` — make sure it > 10240 or more) limits on your system.\nErrors because the test run hits\nlimits are often only opaquely related to the constraint. You can see the current\nuser settings by running `ulimit -a`.\n\n### Default: small and medium category tests\n\nRunning `mvn test` will execute all small tests in a single JVM (no fork) and then medium tests in a\nforked, separate JVM for each test instance (For definition of 'small' test and so on, see\n[Unit Tests](/docs/building-and-developing/tests#building-and-developing-unit-tests)). Medium tests are NOT executed if there is an error in a\nsmall test. Large tests are NOT executed.\n\n### Running all tests\n\nRunning `mvn test -P runAllTests` will execute small tests in a single JVM, then medium and large tests\nin a forked, separate JVM for each test. Medium and large tests are NOT executed if there is an error in\na small test.\n\n### Running a single test or all tests in a package\n\nTo run an individual test, e.g. `MyTest`, rum `mvn test -Dtest=MyTest` You can also pass multiple,\nindividual tests as a comma-delimited list:\n\n```bash\nmvn test  -Dtest=MyTest1,MyTest2,MyTest3\n```\n\nYou can also pass a package, which will run all tests under the package:\n\n```bash\nmvn test '-Dtest=org.apache.hadoop.hbase.client.*'\n```\n\nWhen `-Dtest` is specified, the `localTests` profile will be used.\nEach junit test is executed in a separate JVM (A fork per test class).\nThere is no parallelization when tests are running in this mode.\nYou will see a new message at the end of the -report: `\"[INFO] Tests are skipped\"`.\nIt's harmless. However, you need to make sure the sum of\n`Tests run:` in the `Results:` section of test reports matching the number of tests\nyou specified because no error will be reported when a non-existent test case is specified.\n\n### Other test invocation permutations\n\nRunning `mvn test -P runSmallTests` will execute \"small\" tests only, using a single JVM.\n\nRunning `mvn test -P runMediumTests` will execute \"medium\" tests only, launching a new JVM for each test-class.\n\nRunning `mvn test -P runLargeTests` will execute \"large\" tests only, launching a new JVM for each test-class.\n\nFor convenience, you can run `mvn test -P runDevTests` to execute both small and medium tests, using a single JVM.\n\n### Running tests faster\n\nBy default, `$ mvn test -P runAllTests` runs all tests using a quarter of the CPUs available on machine\nhosting the test run (see `surefire.firstPartForkCount` and `surefire.secondPartForkCount` in the top-level\nhbase `pom.xml` which default to 0.25C, or 1/4 of CPU count). Up these counts to get the build to run faster.\nYou can also have hbase modules\nrun their tests in parrallel when the dependency graph allows by passing `--threads=N` when you invoke\nmaven, where `N` is the amount of parallelism wanted.\nmaven, where `N` is the amount of *module* parallelism wanted.\n\nFor example, allowing that you want to use all cores on a machine to run tests,\nyou could start up the maven test run with:\n\n```bash\n$ x=\"1.0C\";  mvn -Dsurefire.firstPartForkCount=$x -Dsurefire.secondPartForkCount=$x test -PrunAllTests\n```\n\nIf a 32 core machine, you should see periods during which 32 forked jvms appear in your process listing each running unit tests.\nYour milage may vary. Dependent on hardware, overcommittment of CPU and/or memory can bring the test suite crashing down,\nusually complaining with a spew of test system exits and incomplete test report xml files. Start gently, with the default fork\nand move up gradually.\n\nAdding the `--threads=N`, maven will run N maven modules in parallel (when module inter-dependencies allow). Be aware, if you have\nset the forkcount to `1.0C`, and the `--threads` count to '2', the number of concurrent test runners can approach\n2 \\* CPU, a count likely to overcommit the host machine (with attendant test exits failures).\n\nYou will need \\~2.2GB of memory per forked JVM plus the memory used by maven itself (3-4G).\n\n#### RAM Disk\n\nTo increase the speed, you can as well use a ramdisk. 2-3G should be sufficient. Be sure to\ndelete the files between each test run. The typical way to configure a ramdisk on Linux is:\n\n```bash\n$ sudo mkdir /ram2G\nsudo mount -t tmpfs -o size=2048M tmpfs /ram2G\n```\n\nYou can then use it to run all HBase tests on 2.0 with the command:\n\n```bash\nmvn test -PrunAllTests -Dtest.build.data.basedirectory=/ram2G\n```\n\n### hbasetests.sh\n\nIt's also possible to use the script `hbasetests.sh`.\nThis script runs the medium and large tests in parallel with two maven instances, and provides a single report.\nThis script does not use the hbase version of surefire so no parallelization is being done other than the two maven instances the script sets up.\nIt must be executed from the directory which contains the *pom.xml*.\n\nFor example running `./dev-support/hbasetests.sh` will execute small and medium tests.\nRunning `./dev-support/hbasetests.sh runAllTests` will execute all tests.\nRunning `./dev-support/hbasetests.sh replayFailed` will rerun the failed tests a second time, in a separate jvm and without parallelisation.\n\n### Test Timeouts\n\nThe HBase unit test sizing Categorization timeouts are not strictly enforced.\n\nAny test that runs longer than ten minutes will be timedout/killed.\n\nAs of hbase-2.0.0, we have purged all per-test-method timeouts: i.e.\n\n```java\n...\n  @Test(timeout=30000)\n  public void testCreateHRegionInfoName() throws Exception {\n    // ...\n  }\n```\n\nThey are discouraged and don't make much sense given we are timing\nbase of how long the whole Test Fixture/Class/Suite takes and\nthat the variance in how long a test method takes varies wildly\ndependent upon context (loaded Apache Infrastructure versus\ndeveloper machine with nothing else running on it).\n\n### Test Resource Checker\n\nA custom Maven SureFire plugin listener checks a number of resources before and after each HBase unit test runs and logs its findings at the end of the test output files which can be found in *target/surefire-reports* per Maven module (Tests write test reports named for the test class into this directory.\nCheck the *\\*-out.txt* files). The resources counted are the number of threads, the number of file descriptors, etc.\nIf the number has increased, it adds a *LEAK?* comment in the logs.\nAs you can have an HBase instance running in the background, some threads can be deleted/created without any specific action in the test.\nHowever, if the test does not work as expected, or if the test should not impact these resources, it's worth checking these log lines `...hbase.ResourceChecker(157): before...` and `...hbase.ResourceChecker(157): after...`.\nFor example:\n\n```text\n2012-09-26 09:22:15,315 INFO [pool-1-thread-1]\nhbase.ResourceChecker(157): after:\nregionserver.TestColumnSeeking#testReseeking Thread=65 (was 65),\nOpenFileDescriptor=107 (was 107), MaxFileDescriptor=10240 (was 10240),\nConnectionCount=1 (was 1)\n```\n\n## Writing Tests\n\n### General rules\n\n* As much as possible, tests should be written as category small tests.\n* All tests must be written to support parallel execution on the same machine, hence they should not use shared resources as fixed ports or fixed file names.\n* Tests should not overlog.\n  More than 100 lines/second makes the logs complex to read and use i/o that are hence not available for the other tests.\n* Tests can be written with `HBaseTestingUtility`.\n  This class offers helper functions to create a temp directory and do the cleanup, or to start a cluster.\n\n### Categories and execution time\n\n* All tests must be categorized, if not they could be skipped.\n* All tests should be written to be as fast as possible.\n* See [Unit Tests](/docs/building-and-developing/tests#building-and-developing-unit-tests) for test case categories and corresponding timeouts.\n  This should ensure a good parallelization for people using it, and ease the analysis when the test fails.\n\n### Sleeps in tests\n\nWhenever possible, tests should not use `Thread.sleep`, but rather waiting for the real event they need.\nThis is faster and clearer for the reader.\nTests should not do a `Thread.sleep` without testing an ending condition.\nThis allows understanding what the test is waiting for.\nMoreover, the test will work whatever the machine performance is.\nSleep should be minimal to be as fast as possible.\nWaiting for a variable should be done in a 40ms sleep loop.\nWaiting for a socket operation should be done in a 200 ms sleep loop.\n\n### Tests using a cluster\n\nTests using a HRegion do not have to start a cluster: A region can use the local file system.\nStart/stopping a cluster cost around 10 seconds.\nThey should not be started per test method but per test class.\nStarted cluster must be shutdown using `HBaseTestingUtility#shutdownMiniCluster`, which cleans the directories.\nAs most as possible, tests should use the default settings for the cluster.\nWhen they don't, they should document it.\nThis will allow to share the cluster later.\n\n### Tests Skeleton Code\n\nHere is a test skeleton code with Categorization and a Category-based timeout rule to copy and paste and use as basis for test contribution.\n\n```java\n/**\n * Describe what this testcase tests. Talk about resources initialized in @BeforeClass (before\n * any test is run) and before each test is run, etc.\n */\n// Specify the category as explained in Unit Tests section.\n@Category(SmallTests.class)\npublic class TestExample {\n  // Replace the TestExample.class in the below with the name of your test fixture class.\n  private static final Log LOG = LogFactory.getLog(TestExample.class);\n\n  // Handy test rule that allows you subsequently get the name of the current method. See\n  // down in 'testExampleFoo()' where we use it to log current test's name.\n  @Rule public TestName testName = new TestName();\n\n  // The below rule does two things. It decides the timeout based on the category\n  // (small/medium/large) of the testcase. This @Rule requires that the full testcase runs\n  // within this timeout irrespective of individual test methods' times. The second\n  // feature is we'll dump in the log when the test is done a count of threads still\n  // running.\n  @Rule public static TestRule timeout = CategoryBasedTimeout.builder().\n    withTimeout(this.getClass()).withLookingForStuckThread(true).build();\n\n  @Before\n  public void setUp() throws Exception {\n  }\n\n  @After\n  public void tearDown() throws Exception {\n  }\n\n  @Test\n  public void testExampleFoo() {\n    LOG.info(\"Running test \" + testName.getMethodName());\n  }\n}\n```\n\n## Integration Tests\n\nHBase integration/system tests are tests that are beyond HBase unit tests.\nThey are generally long-lasting, sizeable (the test can be asked to 1M rows or 1B rows), targetable (they can take configuration that will point them at the ready-made cluster they are to run against; integration tests do not include cluster start/stop code), and verifying success, integration tests rely on public APIs only; they do not attempt to examine server internals asserting success/fail.\nIntegration tests are what you would run when you need to more elaborate proofing of a release candidate beyond what unit tests can do.\nThey are not generally run on the Apache Continuous Integration build server, however, some sites opt to run integration tests as a part of their continuous testing on an actual cluster.\n\nIntegration tests currently live under the *src/test* directory in the hbase-it submodule and will match the regex: **IntegrationTest*.java*.\nAll integration tests are also annotated with `@Category(IntegrationTests.class)`.\n\nIntegration tests can be run in two modes: using a mini cluster, or against an actual distributed cluster.\nMaven failsafe is used to run the tests using the mini cluster.\nIntegrationTestsDriver class is used for executing the tests against a distributed cluster.\nIntegration tests SHOULD NOT assume that they are running against a mini cluster, and SHOULD NOT use private API's to access cluster state.\nTo interact with the distributed or mini cluster uniformly, `IntegrationTestingUtility`, and `HBaseCluster` classes, and public client API's can be used.\n\nOn a distributed cluster, integration tests that use ChaosMonkey or otherwise manipulate services thru cluster manager (e.g.\nrestart regionservers) use SSH to do it.\nTo run these, test process should be able to run commands on remote end, so ssh should be configured accordingly (for example, if HBase runs under hbase user in your cluster, you can set up passwordless ssh for that user and run the test also under it). To facilitate that, `hbase.it.clustermanager.ssh.user`, `hbase.it.clustermanager.ssh.opts` and `hbase.it.clustermanager.ssh.cmd` configuration settings can be used.\n\"User\" is the remote user that cluster manager should use to perform ssh commands.\n\"Opts\" contains additional options that are passed to SSH (for example, \"-i /tmp/my-key\"). Finally, if you have some custom environment setup, \"cmd\" is the override format for the entire tunnel (ssh) command.\nThe default string is \\{`/usr/bin/ssh %1$s %2$s%3$s%4$s \"%5$s\"`} and is a good starting point.\nThis is a standard Java format string with 5 arguments that is used to execute the remote command.\nThe argument 1 (%1\\$s) is SSH options set the via opts setting or via environment variable, 2 is SSH user name, 3 is \"@\" if username is set or \"\" otherwise, 4 is the target host name, and 5 is the logical command to execute (that may include single quotes, so don't use them). For example, if you run the tests under non-hbase user and want to ssh as that user and change to hbase on remote machine, you can use:\n\n```bash\n/usr/bin/ssh %1$s %2$s%3$s%4$s \"su hbase - -c \\\"%5$s\\\"\"\n```\n\nThat way, to kill RS (for example) integration tests may run:\n\n```bash\n{/usr/bin/ssh some-hostname \"su hbase - -c \\\"ps aux | ... | kill ...\\\"\"}\n```\n\nThe command is logged in the test logs, so you can verify it is correct for your environment.\n\nTo disable the running of Integration Tests, pass the following profile on the command line `-PskipIntegrationTests`.\nFor example,\n\n```bash\n$ mvn clean install test -Dtest=TestZooKeeper  -PskipIntegrationTests\n```\n\n### Running integration tests against mini cluster\n\nHBase 0.92 added a `verify` maven target.\nInvoking it, for example by doing `mvn verify`, will run all the phases up to and including the verify phase via the maven [failsafe\nplugin](https://maven.apache.org/plugins/maven-failsafe-plugin/), running all the above mentioned HBase unit tests as well as tests that are in the HBase integration test group.\nAfter you have completed `mvn install -DskipTests` You can run just the integration tests by invoking:\n\n```bash\ncd hbase-it\nmvn verify\n```\n\nIf you just want to run the integration tests in top-level, you need to run two commands.\nFirst:\n\n```bash\nmvn failsafe:integration-test\n```\n\nThis actually runs ALL the integration tests.\n\n<Callout type=\"info\">\n  This command will always output `BUILD SUCCESS` even if there are test failures.\n</Callout>\n\nAt this point, you could grep the output by hand looking for failed tests.\nHowever, maven will do this for us; just use:\n\n```bash\nmvn failsafe:verify\n```\n\nThe above command basically looks at all the test results (so don't remove the 'target' directory) for test failures and reports the results.\n\n#### Running a subset of Integration tests\n\nThis is very similar to how you specify running a subset of unit tests (see above), but use the property `it.test` instead of `test`.\nTo just run `IntegrationTestClassXYZ.java`, use:\n\n```bash\nmvn failsafe:integration-test -Dit.test=IntegrationTestClassXYZ -DfailIfNoTests=false\n```\n\nThe next thing you might want to do is run groups of integration tests, say all integration tests that are named IntegrationTestClassX\\*.java:\n\n```bash\nmvn failsafe:integration-test -Dit.test=*ClassX* -DfailIfNoTests=false\n```\n\nThis runs everything that is an integration test that matches **ClassX**. This means anything matching: \"**\\*/IntegrationTest\\*ClassX**\". You can also run multiple groups of integration tests using comma-delimited lists (similar to unit tests). Using a list of matches still supports full regex matching for each of the groups. This would look something like:\n\n```bash\nmvn failsafe:integration-test -Dit.test=*ClassX*,*ClassY -DfailIfNoTests=false\n```\n\n### Running integration tests against distributed cluster\n\nIf you have an already-setup HBase cluster, you can launch the integration tests by invoking the class `IntegrationTestsDriver`.\nYou may have to run test-compile first.\nThe configuration will be picked by the bin/hbase script.\n\n```bash\nmvn test-compile\n```\n\nThen launch the tests with:\n\n```bash\nbin/hbase [--config config_dir] org.apache.hadoop.hbase.IntegrationTestsDriver\n```\n\nPass `-h` to get usage on this sweet tool.\nRunning the IntegrationTestsDriver without any argument will launch tests found under `hbase-it/src/test`, having `@Category(IntegrationTests.class)` annotation, and a name starting with `IntegrationTests`.\nSee the usage, by passing -h, to see how to filter test classes.\nYou can pass a regex which is checked against the full class name; so, part of class name can be used.\nIntegrationTestsDriver uses Junit to run the tests.\nCurrently there is no support for running integration tests against a distributed cluster using maven (see [HBASE-6201](https://issues.apache.org/jira/browse/HBASE-6201)).\n\nThe tests interact with the distributed cluster by using the methods in the `DistributedHBaseCluster` (implementing `HBaseCluster`) class, which in turn uses a pluggable `ClusterManager`.\nConcrete implementations provide actual functionality for carrying out deployment-specific and environment-dependent tasks (SSH, etc). The default `ClusterManager` is `HBaseClusterManager`, which uses SSH to remotely execute start/stop/kill/signal commands, and assumes some posix commands (ps, etc). Also assumes the user running the test has enough \"power\" to start/stop servers on the remote machines.\nBy default, it picks up `HBASE_SSH_OPTS`, `HBASE_HOME`, `HBASE_CONF_DIR` from the env, and uses `bin/hbase-daemon.sh` to carry out the actions.\nCurrently tarball deployments, deployments which uses *hbase-daemons.sh*, and [Apache Ambari](https://incubator.apache.org/ambari/) deployments are supported.\n*/etc/init.d/* scripts are not supported for now, but it can be easily added.\nFor other deployment options, a ClusterManager can be implemented and plugged in.\n\nSome integration tests define a *main* method as entry point, and can be run on its' own, rather than using the test driver. For example, the *itbll* test can be run as follows:\n\n```bash\nbin/hbase org.apache.hadoop.hbase.test.IntegrationTestBigLinkedList loop 2 1 100000 /temp 1 1000 50 1 0\n```\n\n<Callout type=\"info\">\n  The *hbase* script assumes all integration tests with exposed *main* methods to be run against a\n  distributed cluster will follow the **IntegrationTest** regex naming pattern mentioned above, in\n  order to proper set test dependencies into the classpath.\n</Callout>\n\n### Destructive integration / system tests (ChaosMonkey)\n\nHBase 0.96 introduced a tool named `ChaosMonkey`, modeled after\n[same-named tool by Netflix's Chaos Monkey tool](https://netflix.github.io/chaosmonkey/).\nChaosMonkey simulates real-world\nfaults in a running cluster by killing or disconnecting random servers, or injecting\nother failures into the environment. You can use ChaosMonkey as a stand-alone tool\nto run a policy while other tests are running. In some environments, ChaosMonkey is\nalways running, in order to constantly check that high availability and fault tolerance\nare working as expected.\n\nChaosMonkey defines **Actions** and **Policies**.\n\n#### Actions:\n\nActions are predefined sequences of events, such as the following:\n\n* Restart active master (sleep 5 sec)\n* Restart random regionserver (sleep 5 sec)\n* Restart random regionserver (sleep 60 sec)\n* Restart META regionserver (sleep 5 sec)\n* Restart ROOT regionserver (sleep 5 sec)\n* Batch restart of 50% of regionservers (sleep 5 sec)\n* Rolling restart of 100% of regionservers (sleep 5 sec)\n\n#### Policies:\n\nA policy is a strategy for executing one or more actions. The default policy\nexecutes a random action every minute based on predefined action weights.\nA given policy will be executed until ChaosMonkey is interrupted.\n\nMost ChaosMonkey actions are configured to have reasonable defaults, so you can run\nChaosMonkey against an existing cluster without any additional configuration. The\nfollowing example runs ChaosMonkey with the default configuration:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.chaos.util.ChaosMonkeyRunner\n\n12/11/19 23:21:57 INFO util.ChaosMonkey: Using ChaosMonkey Policy: class org.apache.hadoop.hbase.util.ChaosMonkey$PeriodicRandomActionPolicy, period:60000\n12/11/19 23:21:57 INFO util.ChaosMonkey: Sleeping for 26953 to add jitter\n12/11/19 23:22:24 INFO util.ChaosMonkey: Performing action: Restart active master\n12/11/19 23:22:24 INFO util.ChaosMonkey: Killing master:master.example.com,60000,1353367210440\n12/11/19 23:22:24 INFO hbase.HBaseCluster: Aborting Master: master.example.com,60000,1353367210440\n12/11/19 23:22:24 INFO hbase.ClusterManager: Executing remote command: ps aux | grep master | grep -v grep | tr -s ' ' | cut -d ' ' -f2 | xargs kill -s SIGKILL , hostname:master.example.com\n12/11/19 23:22:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:\n12/11/19 23:22:25 INFO hbase.HBaseCluster: Waiting service:master to stop: master.example.com,60000,1353367210440\n12/11/19 23:22:25 INFO hbase.ClusterManager: Executing remote command: ps aux | grep master | grep -v grep | tr -s ' ' | cut -d ' ' -f2 , hostname:master.example.com\n12/11/19 23:22:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:\n12/11/19 23:22:25 INFO util.ChaosMonkey: Killed master server:master.example.com,60000,1353367210440\n12/11/19 23:22:25 INFO util.ChaosMonkey: Sleeping for:5000\n12/11/19 23:22:30 INFO util.ChaosMonkey: Starting master:master.example.com\n12/11/19 23:22:30 INFO hbase.HBaseCluster: Starting Master on: master.example.com\n12/11/19 23:22:30 INFO hbase.ClusterManager: Executing remote command: /homes/enis/code/hbase-0.94/bin/../bin/hbase-daemon.sh --config /homes/enis/code/hbase-0.94/bin/../conf start master , hostname:master.example.com\n12/11/19 23:22:31 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:starting master, logging to /homes/enis/code/hbase-0.94/bin/../logs/hbase-enis-master-master.example.com.out\n....\n12/11/19 23:22:33 INFO util.ChaosMonkey: Started master: master.example.com,60000,1353367210440\n12/11/19 23:22:33 INFO util.ChaosMonkey: Sleeping for:51321\n12/11/19 23:23:24 INFO util.ChaosMonkey: Performing action: Restart random region server\n12/11/19 23:23:24 INFO util.ChaosMonkey: Killing region server:rs3.example.com,60020,1353367027826\n12/11/19 23:23:24 INFO hbase.HBaseCluster: Aborting RS: rs3.example.com,60020,1353367027826\n12/11/19 23:23:24 INFO hbase.ClusterManager: Executing remote command: ps aux | grep regionserver | grep -v grep | tr -s ' ' | cut -d ' ' -f2 | xargs kill -s SIGKILL , hostname:rs3.example.com\n12/11/19 23:23:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:\n12/11/19 23:23:25 INFO hbase.HBaseCluster: Waiting service:regionserver to stop: rs3.example.com,60020,1353367027826\n12/11/19 23:23:25 INFO hbase.ClusterManager: Executing remote command: ps aux | grep regionserver | grep -v grep | tr -s ' ' | cut -d ' ' -f2 , hostname:rs3.example.com\n12/11/19 23:23:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:\n12/11/19 23:23:25 INFO util.ChaosMonkey: Killed region server:rs3.example.com,60020,1353367027826. Reported num of rs:6\n12/11/19 23:23:25 INFO util.ChaosMonkey: Sleeping for:60000\n12/11/19 23:24:25 INFO util.ChaosMonkey: Starting region server:rs3.example.com\n12/11/19 23:24:25 INFO hbase.HBaseCluster: Starting RS on: rs3.example.com\n12/11/19 23:24:25 INFO hbase.ClusterManager: Executing remote command: /homes/enis/code/hbase-0.94/bin/../bin/hbase-daemon.sh --config /homes/enis/code/hbase-0.94/bin/../conf start regionserver , hostname:rs3.example.com\n12/11/19 23:24:26 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:starting regionserver, logging to /homes/enis/code/hbase-0.94/bin/../logs/hbase-enis-regionserver-rs3.example.com.out\n\n12/11/19 23:24:27 INFO util.ChaosMonkey: Started region server:rs3.example.com,60020,1353367027826. Reported num of rs:6\n```\n\nThe output indicates that ChaosMonkey started the default `PeriodicRandomActionPolicy`\npolicy, which is configured with all the available actions. It chose to run `RestartActiveMaster` and `RestartRandomRs` actions.\n\n### ChaosMonkey without SSH\n\nChaos monkey can be run without SSH using the Chaos service and ZNode cluster manager. HBase ships\nwith many cluster managers, available in the `hbase-it/src/test/java/org/apache/hadoop/hbase/` directory.\n\nSet the following property in hbase configuration to switch to `ZNodeClusterManager`:\n\n```xml\n<property>\n  <name>hbase.it.clustermanager.class</name>\n  <value>org.apache.hadoop.hbase.ZNodeClusterManager</value>\n</property>\n```\n\nStart chaos agent on all hosts where you want to test chaos scenarios.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.chaos.ChaosService -c start\n```\n\nStart chaos monkey runner from any one host, preferrably an edgenode.\nAn example log while running chaos monkey with default policy `PeriodicRandomActionPolicy` is as shown below:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.chaos.util.ChaosMonkeyRunner\n\nINFO  [main] hbase.HBaseCommonTestingUtility: Instantiating org.apache.hadoop.hbase.ZNodeClusterManager\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe] zookeeper.ZooKeeper: Initiating client connection, connectString=host1.example.com:2181,host2.example.com:2181,host3.example.com:2181 sessionTimeout=90000 watcher=org.apache.hadoop.hbase.zookeeper.ReadOnlyZKClient$$Lambda$19/2106254492@1a39cf8\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe] zookeeper.ClientCnxnSocket: jute.maxbuffer value is 4194304 Bytes\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe] zookeeper.ClientCnxn: zookeeper.request.timeout value is 0. feature enabled=\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe-SendThread(host2.example.com:2181)] zookeeper.ClientCnxn: Opening socket connection to server host2.example.com/10.20.30.40:2181. Will not attempt to authenticate using SASL (unknown error)\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe-SendThread(host2.example.com:2181)] zookeeper.ClientCnxn: Socket connection established, initiating session, client: /10.20.30.40:35164, server: host2.example.com/10.20.30.40:2181\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe-SendThread(host2.example.com:2181)] zookeeper.ClientCnxn: Session establishment complete on server host2.example.com/10.20.30.40:2181, sessionid = 0x101de9204670877, negotiated timeout = 60000\nINFO  [main] policies.Policy: Using ChaosMonkey Policy class org.apache.hadoop.hbase.chaos.policies.PeriodicRandomActionPolicy, period=60000 ms\n [ChaosMonkey-2] policies.Policy: Sleeping for 93741 ms to add jitter\nINFO  [ChaosMonkey-0] policies.Policy: Sleeping for 9752 ms to add jitter\nINFO  [ChaosMonkey-1] policies.Policy: Sleeping for 65562 ms to add jitter\nINFO  [ChaosMonkey-3] policies.Policy: Sleeping for 38777 ms to add jitter\nINFO  [ChaosMonkey-0] actions.CompactRandomRegionOfTableAction: Performing action: Compact random region of table usertable, major=false\nINFO  [ChaosMonkey-0] policies.Policy: Sleeping for 59532 ms\nINFO  [ChaosMonkey-3] client.ConnectionImplementation: Getting master connection state from TTL Cache\nINFO  [ChaosMonkey-3] client.ConnectionImplementation: Getting master state using rpc call\nINFO  [ChaosMonkey-3] actions.DumpClusterStatusAction: Cluster status\nMaster: host1.example.com,16000,1678339058222\nNumber of backup masters: 0\nNumber of live region servers: 3\n  host1.example.com,16020,1678794551244\n  host2.example.com,16020,1678341258970\n  host3.example.com,16020,1678347834336\nNumber of dead region servers: 0\nNumber of unknown region servers: 0\nAverage load: 123.6666666666666\nNumber of requests: 118645157\nNumber of regions: 2654\nNumber of regions in transition: 0\nINFO  [ChaosMonkey-3] policies.Policy: Sleeping for 89614 ms\n```\n\nFor info on more customisations we can see help for the `ChaosMonkeyRunner`. For example we can pass the table name on which the chaos operations to be performed etc.\nBelow is the output of the help command, listing all the supported options.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.chaos.util.ChaosMonkeyRunner --help\n\nusage: hbase org.apache.hadoop.hbase.chaos.util.ChaosMonkeyRunner <options>\nOptions:\n -c <arg>             Name of extra configurations file to find on CLASSPATH\n -m,--monkey <arg>    Which chaos monkey to run\n -monkeyProps <arg>   The properties file for specifying chaos monkey properties.\n -tableName <arg>     Table name in the test to run chaos monkey against\n -familyName <arg>    Family name in the test to run chaos monkey against\n```\n\nFor example, running the following will start `ServerKillingMonkeyFactory` that chooses among actions to rolling batch restart RS, graceful rolling restart RS one at a time, restart active master, force balancer run etc.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.chaos.util.ChaosMonkeyRunner -m org.apache.hadoop.hbase.chaos.factories.ServerKillingMonkeyFactory\n```\n\n### Available Policies\n\nHBase ships with several ChaosMonkey policies, available in the\n`hbase/hbase-it/src/test/java/org/apache/hadoop/hbase/chaos/policies/` directory.\n\n### Configuring Individual ChaosMonkey Actions\n\nChaosMonkey integration tests can be configured per test run.\nCreate a Java properties file in the HBase CLASSPATH and pass it to ChaosMonkey using\nthe `-monkeyProps` configuration flag. Configurable properties, along with their default\nvalues if applicable, are listed in the `org.apache.hadoop.hbase.chaos.factories.MonkeyConstants`\nclass. For properties that have defaults, you can override them by including them\nin your properties file.\n\nThe following example uses a properties file called `monkey.properties`.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.IntegrationTestIngest -m slowDeterministic -monkeyProps monkey.properties\n```\n\nThe above command will start the integration tests and chaos monkey. It will look for the\nproperties file *monkey.properties* on the HBase CLASSPATH; e.g. inside the HBASE *conf* dir.\n\nHere is an example chaos monkey file:\n\n#### Example ChaosMonkey Properties File\n\n```properties\nsdm.action1.period=120000\nsdm.action2.period=40000\nmove.regions.sleep.time=80000\nmove.regions.max.time=1000000\nmove.regions.sleep.time=80000\nbatch.restart.rs.ratio=0.4f\n```\n\nPeriods/time are expressed in milliseconds.\n\nHBase 1.0.2 and newer adds the ability to restart HBase's underlying ZooKeeper quorum or\nHDFS nodes. To use these actions, you need to configure some new properties, which\nhave no reasonable defaults because they are deployment-specific, in your ChaosMonkey\nproperties file, which may be `hbase-site.xml` or a different properties file.\n\n```xml\n<property>\n  <name>hbase.it.clustermanager.hadoop.home</name>\n  <value>$HADOOP_HOME</value>\n</property>\n<property>\n  <name>hbase.it.clustermanager.zookeeper.home</name>\n  <value>$ZOOKEEPER_HOME</value>\n</property>\n<property>\n  <name>hbase.it.clustermanager.hbase.user</name>\n  <value>hbase</value>\n</property>\n<property>\n  <name>hbase.it.clustermanager.hadoop.hdfs.user</name>\n  <value>hdfs</value>\n</property>\n<property>\n  <name>hbase.it.clustermanager.zookeeper.user</name>\n  <value>zookeeper</value>\n</property>\n```\n\n### Customizing Destructive ChaosMonkey Actions\n\nThe session above shows how to setup custom configurations for the *slowDeterministic* monkey\npolicy. This is a policy that pre-defines a set of destructive actions of varying gravity for a\nrunning cluster. These actions are grouped into three categories: *light weight*, *mid weight* and\n*heavy weight*. Although it's possible to define some properties for the different actions\n(such as timeouts, frequency, etc), the actions themselves are not configurable.\n\nFor certain deployments, it may be interesting to define its own test strategy, either less or more\naggressive than the pre-defined set of actions provided by *slowDeterministic*. For such cases,\nthe *configurableSlowDeterministic* policy can be used. It allows for a customizable set of\n*heavy weight* actions to be defined in the *monkey.properties* properties file:\n\n```properties\nbatch.restart.rs.ratio=0.3f\nheavy.actions=RestartRandomRsAction(500000);MoveRandomRegionOfTableAction(360000,$table_name);SplitAllRegionOfTableAction($table_name)\n```\n\nThe above properties file definition instructs chaos monkey to perform a RegionServer crash every 8 minutes,\na random region move every 6 minutes, and at least one split of all table regions.\n\nTo run this policy, just specify *configurableSlowDeterministic* as the monkey policy to run, together\nwith a property file containing the *heavy.actions* property definition:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.IntegrationTestIngest -m configurableSlowDeterministic -monkeyProps monkey.properties\n```\n\nWhen specifying monkey actions, make sure to define all required constructor parameters. For actions\nthat require a table name parameter, the *\\$table\\_name* placeholder can be specified, and it will\nautomatically resort to the table created by the integration test run.\n\nIf *heavy.actions* property is omitted in the properties file, *configurableSlowDeterministic* will\njust run as the *slowDeterministic* policy\n(it will execute all the heavy weight actions defined by *slowDeterministic* policy).\n\n\n# Updating hbase.apache.org (/docs/building-and-developing/updating-landing)\n## Contributing to hbase.apache.org\n\nSee [appendix contributing to documentation](/docs/contributing-to-documentation) for more information on contributing to the documentation or website.\n\n## Publishing hbase.apache.org\n\nSee [Publishing the HBase Website and Documentation](/docs/contributing-to-documentation#publishing-the-hbase-website-and-documentation) for instructions on publishing the website and documentation.\n\n\n# Voting on Release Candidates (/docs/building-and-developing/voting)\nEveryone is encouraged to try and vote on HBase release candidates.\nOnly the votes of PMC members are binding.\nPMC members, please read this WIP doc on policy voting for a release candidate, [Release Policy](https://github.com/rectang/asfrelease/blob/master/release.md).\n\n> Before casting +1 binding votes, individuals are required to\n> download the signed source code package onto their own hardware, compile it as\n> provided, and test the resulting executable on their own platform, along with also\n> validating cryptographic signatures and verifying that the package meets the\n> requirements of the ASF policy on releases.\n\nRegards the latter, run `mvn apache-rat:check` to verify all files are suitably licensed.\nSee [HBase, mail # dev - On recent discussion clarifying ASF release policy](https://mail-archives.apache.org/mod_mbox/hbase-dev/201406.mbox/%3CCA%2BRK%3D_B8EP0JMFV%2Bdt-k1g%3DBmedzyq2z1GSqrnMMiH6%3DcdoiAA%40mail.gmail.com%3E)\nfor how we arrived at this process.\n\nTo help with the release verification, please follow the guideline below and vote based on the your verification.\n\n## Baseline Verifications for Voting Release Candidates\n\nAlthough contributors have their own checklist for verifications, the following items are usually used for voting on release candidates.\n\n* CHANGES.md if any\n\n* RELEASENOTES.md (release notes) if any\n\n* Generated API compatibility report\n  * For what should be compatible please refer the [versioning guideline](/docs/upgrading/version-number), especially for items with marked as high severity\n\n* Use `hbase-vote.sh` to perform sanity checks for checksum, signatures, files are licensed, built from source, and unit tests.\n\n  * `hbase-vote.sh` shell script is available under `dev-support` directory of HBase source. Following are the usage details.\n\n  ```bash\n  ./dev-support/hbase-vote.sh -h\n  hbase-vote. A script for standard vote which verifies the following items\n  1. Checksum of sources and binaries\n  2. Signature of sources and binaries\n  3. Rat check\n  4. Built from source\n  5. Unit tests\n\n  Usage: hbase-vote.sh -s | --source <url> [-k | --key <signature>] [-f | --keys-file-url <url>] [-o | --output-dir </path/to/use>] [-P runSmallTests] [-D property[=value]]\n        hbase-vote.sh -h | --help\n\n    -h | --help                   Show this screen.\n    -s | --source '<url>'         A URL pointing to the release candidate sources and binaries\n                                  e.g. https://dist.apache.org/repos/dist/dev/hbase/hbase-<version>RC0/\n    -k | --key '<signature>'      A signature of the public key, e.g. 9AD2AE49\n    -f | --keys-file-url '<url>'   the URL of the key file, default is\n                                  https://downloads.apache.org/hbase/KEYS\n    -o | --output-dir '</path>'   directory which has the stdout and stderr of each verification target\n    -P |                          list of maven profiles to activate for test UT/IT, i.e. <-P runSmallTests> Defaults to runAllTests\n    -D |                          list of maven properties to set for the mvn invocations, i.e. <-D hadoop.profile=3.0> Defaults to unset\n  ```\n\n* If you see any unit test failures, please call out the solo test result and whether it's part of flaky (nightly) tests dashboard, e.g. [dashboard of master branch](https://builds.apache.org/view/H-L/view/HBase/job/HBase-Find-Flaky-Tests/job/master/lastSuccessfulBuild/artifact/dashboard.html) (please change the test branch accordingly).\n\n## Additional Verifications for Voting Release Candidates\n\nOther than the common verifications, contributors may call out additional concerns, e.g. for a specific feature by running end to end tests on a distributed environment. This is optional and always encouraged.\n\n* Start a distributed HBase cluster and call out the test result of specific workload on cluster. e.g.\n  * Run basic table operations, e.g. `create/put/get/scan/flush/list/disable/drop`\n  * Run built-in tests, e.g. `LoadTestTool` (LTT) and `IntegrationTestBigLinkedList` (ITBLL)\n\n\n# Bulk Data Generator Tool (/docs/bulk-data-generator-tool)\n## Usage\n\n```bash\nusage: hbase org.apache.hadoop.hbase.util.bulkdatagenerator.BulkDataGeneratorTool <OPTIONS> [-D<property=value>]*\n -d,--delete-if-exist         If it's set, the table will be deleted if already exist.\n -h,--help                    Show help message for the tool\n -mc,--mapper-count <arg>     The number of mapper containers to be launched.\n -o,--table-options <arg>     Table options to be set while creating the table.\n -r,--rows-per-mapper <arg>   The number of rows to be generated PER mapper.\n -sc,--split-count <arg>      The number of regions/pre-splits to be created for the table.\n -t,--table <arg>             The table name for which data need to be generated.\n```\n\nExamples:\n\n```bash\nhbase org.apache.hadoop.hbase.util.bulkdatagenerator.BulkDataGeneratorTool -t TEST_TABLE -mc 10 -r 100 -sc 10\n\nhbase org.apache.hadoop.hbase.util.bulkdatagenerator.BulkDataGeneratorTool -t TEST_TABLE -mc 10 -r 100 -sc 10 -d -o \"BACKUP=false,NORMALIZATION_ENABLED=false\"\n\nhbase org.apache.hadoop.hbase.util.bulkdatagenerator.BulkDataGeneratorTool -t TEST_TABLE -mc 10 -r 100 -sc 10 -Dmapreduce.map.memory.mb=8192\n```\n\n## Overview\n\n### Table Schema\n\nTool generates a HBase table with single column family, i.e. **cf** and 9 columns i.e.\n\n```\nORG_ID, TOOL_EVENT_ID, EVENT_ID, VEHICLE_ID, SPEED, LATITUDE, LONGITUDE, LOCATION, TIMESTAMP\n```\n\nwith row key as\n\n```\n<TOOL_EVENT_ID>:<ORGANIZATION_ID>\n```\n\n### Table Creation\n\nTool creates a pre-splited HBase Table having \"**split-count**\" splits (i.e. **split-count** + 1 regions) with sequential 6 digit region boundary prefix.\nExample: If a table is generated with \"**split-count**\" as 10, it will have (10+1) regions with following start-end keys.\n\n```\n(-000001, 000001-000002, 000002-000003, ...., 000009-000010, 0000010-)\n```\n\n### Data Generation\n\nTool creates and run a MR job to generate the HFiles, which are bulk loaded to table regions via `org.apache.hadoop.hbase.tool.BulkLoadHFilesTool`.\nThe number of mappers is defined in input as \"**mapper-count**\". Each mapper generates \"**records-per-mapper**\" rows.\n\n`org.apache.hadoop.hbase.util.bulkdatageneratorBulkDataGeneratorRecordReader` ensures that each record generated by mapper is associated with index (added to the key) ranging from 1 to \"**records-per-mapper**\".\n\nThe TOOL\\_EVENT\\_ID column for each row has a 6 digit prefix as\n\n```\n(index) mod (\"split-count\" + 1)\n```\n\nExample, if 10 records are to be generated by each mapper and \"**split-count**\" is 4, the TOOL\\_EVENT\\_IDs for each record will have a prefix as\n\n| Record Index | TOOL\\_EVENT\\_ID's first six characters |\n| ------------ | -------------------------------------- |\n| 1            | 000001                                 |\n| 2            | 000002                                 |\n| 3            | 000003                                 |\n| 4            | 000004                                 |\n| 5            | 000000                                 |\n| 6            | 000001                                 |\n| 7            | 000002                                 |\n| 8            | 000003                                 |\n| 9            | 000004                                 |\n| 10           | 000005                                 |\n\nSince TOOL\\_EVENT\\_ID is first attribute of row key and table region boundaries are also having start-end keys as 6 digit sequential prefixes, this ensures that each mapper generates (nearly) same number of rows for each region, making the data uniformly distributed.\nTOOL\\_EVENT\\_ID suffix and other columns of the row are populated with random data.\n\nNumber of rows generated is\n\n```\nrows-per-mapper * mapper-count\n```\n\nSize of each rows is (approximately)\n\n```\n850 B\n```\n\n### Experiments\n\nThese results are from a 11 node cluster having HBase and Hadoop service running within self-managed test environment\n\n| Data Size | Time to Generate Data (mins) |\n| --------- | ---------------------------- |\n| 100 GB    | 6 minutes                    |\n| 340 GB    | 13 minutes                   |\n| 3.5 TB    | 3 hours 10 minutes           |\n\n\n# Apache HBase Case Studies (/docs/case-studies)\n## Overview\n\nThis chapter will describe a variety of performance and troubleshooting case studies that can provide a useful blueprint on diagnosing Apache HBase cluster issues.\n\nFor more information on Performance and Troubleshooting, see [Apache HBase Performance Tuning](/docs/performance) and [Troubleshooting and Debugging Apache HBase](/docs/troubleshooting).\n\n## Schema Design\n\nSee the schema design case studies here: [Schema Design Case Studies](/docs/regionserver-sizing#schema-design-case-studies)\n\n## Performance/Troubleshooting\n\n### Case Study #1 (Performance Issue On A Single Node)\n\n#### Scenario\n\nFollowing a scheduled reboot, one data node began exhibiting unusual behavior.\nRoutine MapReduce jobs run against HBase tables which regularly completed in five or six minutes began taking 30 or 40 minutes to finish.\nThese jobs were consistently found to be waiting on map and reduce tasks assigned to the troubled data node (e.g., the slow map tasks all had the same Input Split). The situation came to a head during a distributed copy, when the copy was severely prolonged by the lagging node.\n\n#### Hardware\n\nDatanodes:\n\n* Two 12-core processors\n* Six Enterprise SATA disks\n* 24GB of RAM\n* Two bonded gigabit NICs\n\nNetwork:\n\n* 10 Gigabit top-of-rack switches\n* 20 Gigabit bonded interconnects between racks.\n\n#### Hypotheses\n\n**HBase \"Hot Spot\" Region**\\\nWe hypothesized that we were experiencing a familiar point of pain: a \"hot spot\" region in an HBase table, where uneven key-space distribution can funnel a huge number of requests to a single HBase region, bombarding the RegionServer process and cause slow response time.\nExamination of the HBase Master status page showed that the number of HBase requests to the troubled node was almost zero.\nFurther, examination of the HBase logs showed that there were no region splits, compactions, or other region transitions in progress.\nThis effectively ruled out a \"hot spot\" as the root cause of the observed slowness.\n\n**HBase Region With Non-Local Data**\\\nOur next hypothesis was that one of the MapReduce tasks was requesting data from HBase that was not local to the DataNode, thus forcing HDFS to request data blocks from other servers over the network.\nExamination of the DataNode logs showed that there were very few blocks being requested over the network, indicating that the HBase region was correctly assigned, and that the majority of the necessary data was located on the node.\nThis ruled out the possibility of non-local data causing a slowdown.\n\n**Excessive I/O Wait Due To Swapping Or An Over-Worked Or Failing Hard Disk**\\\nAfter concluding that the Hadoop and HBase were not likely to be the culprits, we moved on to troubleshooting the DataNode's hardware.\nJava, by design, will periodically scan its entire memory space to do garbage collection.\nIf system memory is heavily overcommitted, the Linux kernel may enter a vicious cycle, using up all of its resources swapping Java heap back and forth from disk to RAM as Java tries to run garbage collection.\nFurther, a failing hard disk will often retry reads and/or writes many times before giving up and returning an error.\nThis can manifest as high iowait, as running processes wait for reads and writes to complete.\nFinally, a disk nearing the upper edge of its performance envelope will begin to cause iowait as it informs the kernel that it cannot accept any more data, and the kernel queues incoming data into the dirty write pool in memory.\nHowever, using `vmstat(1)` and `free(1)`, we could see that no swap was being used, and the amount of disk IO was only a few kilobytes per second.\n\n**Slowness Due To High Processor Usage**\\\nNext, we checked to see whether the system was performing slowly simply due to very high computational load. `top(1)` showed that the system load was higher than normal, but `vmstat(1)` and `mpstat(1)` showed that the amount of processor being used for actual computation was low.\n\n**Network Saturation (The Winner)**\\\nSince neither the disks nor the processors were being utilized heavily, we moved on to the performance of the network interfaces.\nThe DataNode had two gigabit ethernet adapters, bonded to form an active-standby interface. `ifconfig(8)` showed some unusual anomalies, namely interface errors, overruns, framing errors.\nWhile not unheard of, these kinds of errors are exceedingly rare on modern hardware which is operating as it should:\n\n```bash\n$ /sbin/ifconfig bond0\nbond0  Link encap:Ethernet  HWaddr 00:00:00:00:00:00\ninet addr:10.x.x.x  Bcast:10.x.x.255  Mask:255.255.255.0\nUP BROADCAST RUNNING MASTER MULTICAST  MTU:1500  Metric:1\nRX packets:2990700159 errors:12 dropped:0 overruns:1 frame:6          <--- Look Here! Errors!\nTX packets:3443518196 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:0\nRX bytes:2416328868676 (2.4 TB)  TX bytes:3464991094001 (3.4 TB)\n```\n\nThese errors immediately lead us to suspect that one or more of the ethernet interfaces might have negotiated the wrong line speed.\nThis was confirmed both by running an ICMP ping from an external host and observing round-trip-time in excess of 700ms, and by running `ethtool(8)` on the members of the bond interface and discovering that the active interface was operating at 100Mbs/, full duplex.\n\n```bash\n$ sudo ethtool eth0\nSettings for eth0:\nSupported ports: [ TP ]\nSupported link modes:   10baseT/Half 10baseT/Full\n                       100baseT/Half 100baseT/Full\n                       1000baseT/Full\nSupports auto-negotiation: Yes\nAdvertised link modes:  10baseT/Half 10baseT/Full\n                       100baseT/Half 100baseT/Full\n                       1000baseT/Full\nAdvertised pause frame use: No\nAdvertised auto-negotiation: Yes\nLink partner advertised link modes:  Not reported\nLink partner advertised pause frame use: No\nLink partner advertised auto-negotiation: No\nSpeed: 100Mb/s                                     <--- Look Here!  Should say 1000Mb/s!\nDuplex: Full\nPort: Twisted Pair\nPHYAD: 1\nTransceiver: internal\nAuto-negotiation: on\nMDI-X: Unknown\nSupports Wake-on: umbg\nWake-on: g\nCurrent message level: 0x00000003 (3)\nLink detected: yes\n```\n\nIn normal operation, the ICMP ping round trip time should be around 20ms, and the interface speed and duplex should read, \"1000MB/s\", and, \"Full\", respectively.\n\n#### Resolution\n\nAfter determining that the active ethernet adapter was at the incorrect speed, we used the `ifenslave(8)` command to make the standby interface the active interface, which yielded an immediate improvement in MapReduce performance, and a 10 times improvement in network throughput:\n\nOn the next trip to the datacenter, we determined that the line speed issue was ultimately caused by a bad network cable, which was replaced.\n\n### Case Study #2 (Performance Research 2012)\n\nInvestigation results of a self-described \"we're not sure what's wrong, but it seems slow\" problem. [http://gbif.blogspot.com/2012/03/hbase-performance-evaluation-continued.html](http://gbif.blogspot.com/2012/03/hbase-performance-evaluation-continued.html)\n\n### Case Study #3 (Performance Research 2010)\n\nInvestigation results of general cluster performance from 2010.\nAlthough this research is on an older version of the codebase, this writeup is still very useful in terms of approach. [https://web.archive.org/web/20180503124332/http://hstack.org/hbase-performance-testing/](https://web.archive.org/web/20180503124332/http://hstack.org/hbase-performance-testing/)\n\n### Case Study #4 (max.transfer.threads Config)\n\nCase study of configuring `max.transfer.threads` (previously known as `xcievers`) and diagnosing errors from misconfigurations. [http://www.larsgeorge.com/2012/03/hadoop-hbase-and-xceivers.html](http://www.larsgeorge.com/2012/03/hadoop-hbase-and-xceivers.html)\n\nSee also [`dfs.datanode.max.transfer.threads`](/docs/configuration/basic-prerequisites#dfsdatanodemaxtransferthreads).\n\n\n# Community (/docs/community)\n## Decisions\n\n### Feature Branches\n\nFeature Branches are easy to make. You do not have to be a committer to make one. Just request the name of your branch be added to JIRA up on the developer's mailing list and a committer will add it for you. Thereafter you can file issues against your feature branch in Apache HBase JIRA. Your code you keep elsewhere — it should be public so it can be observed — and you can update dev mailing list on progress. When the feature is ready for commit, 3 +1s from committers will get your feature merged. See [HBase, mail # dev - Thoughts about large feature dev branches](https://lists.apache.org/thread.html/200513c7e7e4df23c8b9134eeee009d61205c79314e77f222d396006%401346870308%40%3Cdev.hbase.apache.org%3E)\n\n### How to set fix version in JIRA on issue resolve\n\nHere is how we agreed to set versions in JIRA when we resolve an issue. If master is going to be 3.0.0, branch-2 will be 2.4.0, and branch-1 will be 1.7.0 then:\n\n* Commit only to master (i.e., backward-incompatible new feature): Mark with 3.0.0\n* Commit only to master and branch-2 (i.e., backward-compatible new feature, applicable only to 2.x+): Mark with 3.0.0 and 2.4.0\n* Commit to master, branch-2, and branch-1 (i.e., backward-compatible new feature, applicable everywhere): Mark with 3.0.0, 2.4.0, and 1.7.0\n* Commit to master, branch-2, and branch-2.3, branch-1, branch-1.4 (i.e., bug fix applicable to all active release lines): Mark with 3.0.0, 2.4.0, 2.3.x, 1.7.0, and 1.4.x\n* Commit a fix to the website: no version\n\n### Policy on when to set a RESOLVED JIRA as CLOSED\n\nWe agreed that for issues that list multiple releases in their *Fix Version/s* field, CLOSE the issue on the release of any of the versions listed; subsequent change to the issue must happen in a new JIRA.\n\n### Only transient state in ZooKeeper!\n\nYou should be able to kill the data in zookeeper and hbase should ride over it recreating the zk content as it goes. This is an old adage around these parts. We just made note of it now. We also are currently in violation of this basic tenet — replication at least keeps permanent state in zk — but we are working to undo this breaking of a golden rule.\n\n## Community Roles\n\n### Release Managers\n\nEach maintained release branch has a release manager, who volunteers to coordinate new features and bug fixes are backported to that release. The release managers are [committers](/team). If you would like your feature or bug fix to be included in a given release, communicate with that release manager. If this list goes out of date or you can't reach the listed person, reach out to someone else on the list.\n\n**Release Managers:**\n\n| Release | Release Manager   | Latest Release                        | EOL            |\n| ------- | ----------------- | ------------------------------------- | -------------- |\n| 0.94    | Lars Hofhansl     | 0.94.27                               | April 2017     |\n| 0.96    | Michael Stack     | 0.96.2                                | September 2014 |\n| 0.98    | Andrew Purtell    | 0.98.24                               | April 2017     |\n| 1.0     | Enis Soztutar     | 1.0.3                                 | January 2016   |\n| 1.1     | Nick Dimiduk      | 1.1.13                                | December 2017  |\n| 1.2     | Sean Busbey       | 1.2.12                                | June 2019      |\n| 1.3     | Mikhail Antonov   | 1.3.6                                 | August 2020    |\n| 1.4     | Andrew Purtell    | 1.4.14                                | October 2021   |\n| 1.5     | Andrew Purtell    | 1.5.0                                 | October 2019   |\n| 1.6     | Andrew Purtell    | 1.6.0                                 | February 2020  |\n| 1.7     | Reid Chan         | 1.7.2                                 | August 2022    |\n| 2.0     | Michael Stack     | 2.0.6                                 | September 2019 |\n| 2.1     | Duo Zhang         | 2.1.10                                | May 2020       |\n| 2.2     | Guanghao Zhang    | 2.2.7                                 | April 2021     |\n| 2.3     | Nick Dimiduk      | 2.3.7                                 | October 2021   |\n| 2.4     | Andrew Purtell    | 2.4.18                                | June 2024      |\n| 2.5     | Andrew Purtell    | Check the [download](/downloads) page | **NOT YET**    |\n| 2.6     | Bryan Beaudreault | Check the [download](/downloads) page | **NOT YET**    |\n\n## Commit Message format\n\nWe agreed to the following Git commit message format:\n\n```text\nHBASE-xxxxx <title>. (<contributor>)\n```\n\nIf the person making the commit is the contributor, leave off the '(\\<contributor>)' element.\n\n\n# Compression and Data Block Encoding In HBase (/docs/compression)\n\n\n\n\n\n\n<Callout type=\"info\">\n  Codecs mentioned in this section are for encoding and decoding data blocks or row keys. For\n  information about replication codecs, see\n  [cluster.replication.preserving.tags](/docs/operational-management/cluster-replication#life-of-a-wal-edit).\n</Callout>\n\nHBase supports several different compression algorithms which can be enabled on a ColumnFamily.\nData block encoding attempts to limit duplication of information in keys, taking advantage of some of the fundamental designs and patterns of HBase, such as sorted row keys and the schema of a given table.\nCompressors reduce the size of large, opaque byte arrays in cells, and can significantly reduce the storage space needed to store uncompressed data.\n\nCompressors and data block encoding can be used together on the same ColumnFamily.\n\n## Changes Take Effect Upon Compaction\n\nIf you change compression or encoding for a ColumnFamily, the changes take effect during compaction.\n\nSome codecs take advantage of capabilities built into Java, such as GZip compression.\nOthers rely on native libraries. Native libraries may be available via codec dependencies installed into\nHBase's library directory, or, if you are utilizing Hadoop codecs, as part of Hadoop. Hadoop codecs\ntypically have a native code component so follow instructions for installing Hadoop native binary\nsupport at [Making use of Hadoop Native Libraries in HBase](/docs/compression#making-use-of-hadoop-native-libraries-in-hbase).\n\nThis section discusses common codecs that are used and tested with HBase.\n\nNo matter what codec you use, be sure to test that it is installed correctly and is available on all nodes in your cluster.\nExtra operational steps may be necessary to be sure that codecs are available on newly-deployed nodes.\nYou can use the [compression.test](/docs/compression#compressiontest) utility to check that a given codec is correctly installed.\n\nTo configure HBase to use a compressor, see [compressor.install](/docs/compression#compressor-configuration-installation-and-use).\nTo enable a compressor for a ColumnFamily, see [changing.compression](/docs/compression#enable-compression-on-a-columnfamily).\nTo enable data block encoding for a ColumnFamily, see [data.block.encoding.enable](/docs/compression#enable-data-block-encoding).\n\n## Block Compressors\n\n* **NONE**\\\n  This compression type constant selects no compression, and is the default.\n* **BROTLI**\\\n  [Brotli](https://en.wikipedia.org/wiki/Brotli) is a generic-purpose lossless compression algorithm\n  that compresses data using a combination of a modern variant of the LZ77 algorithm, Huffman\n  coding, and 2nd order context modeling, with a compression ratio comparable to the best currently\n  available general-purpose compression methods. It is similar in speed with GZ but offers more\n  dense compression.\n* **BZIP2**\\\n  [Bzip2](https://en.wikipedia.org/wiki/Bzip2) compresses files using the Burrows-Wheeler block\n  sorting text compression algorithm and Huffman coding. Compression is generally considerably\n  better than that achieved by the dictionary- (LZ-) based compressors, but both compression and\n  decompression can be slow in comparison to other options.\n* **GZ**\\\n  gzip is based on the [DEFLATE](https://en.wikipedia.org/wiki/Deflate) algorithm, which is a\n  combination of LZ77 and Huffman coding. It is universally available in the Java Runtime\n  Environment so is a good lowest common denominator option. However in comparison to more modern\n  algorithms like Zstandard it is quite slow.\n* **LZ4**\\\n  [LZ4](https://en.wikipedia.org/wiki/LZ4_\\(compression_algorithm\\)) is a lossless data compression\n  algorithm that is focused on compression and decompression speed. It belongs to the LZ77 family\n  of compression algorithms, like Brotli, DEFLATE, Zstandard, and others. In our microbenchmarks\n  LZ4 is the fastest option for both compression and decompression in that family, and is our\n  universally recommended option.\n* **LZMA**\\\n  [LZMA](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm) is a\n  dictionary compression scheme somewhat similar to the LZ77 algorithm that achieves very high\n  compression ratios with a computationally expensive predictive model and variable size\n  compression dictionary, while still maintaining decompression speed similar to other commonly used\n  compression algorithms. LZMA is superior to all other options in general compression ratio but as\n  a compressor it can be extremely slow, especially when configured to operate at higher levels of\n  compression.\n* **LZO**\\\n  [LZO](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Oberhumer) is another LZ-variant\n  data compression algorithm, with an implementation focused on decompression speed. It is almost\n  but not quite as fast as LZ4.\n* **SNAPPY**\\\n  [Snappy](https://en.wikipedia.org/wiki/Snappy_\\(compression\\)) is based on ideas from LZ77 but is\n  optimized for very high compression speed, achieving only a \"reasonable\" compression in trade.\n  It is as fast as LZ4 but does not compress quite as well. We offer a pure Java Snappy codec\n  that can be used instead of GZ as the universally available option for any Java runtime on any\n  hardware architecture.\n* **ZSTD**\\\n  [Zstandard](https://en.wikipedia.org/wiki/Zstd) combines a dictionary-matching stage (LZ77) with\n  a large search window and a fast entropy coding stage, using both Finite State Entropy and\n  Huffman coding. Compression speed can vary by a factor of 20 or more between the fastest and\n  slowest levels, while decompression is uniformly fast, varying by less than 20% between the\n  fastest and slowest levels.\\\n  ZStandard is the most flexible of the available compression codec options, offering a compression\n  ratio similar to LZ4 at level 1 (but with slightly less performance), compression ratios\n  comparable to DEFLATE at mid levels (but with better performance), and LZMA-alike dense\n  compression (and LZMA-alike compression speeds) at high levels; while providing universally fast\n  decompression.\n\n## Data Block Encoding Types\n\n### Prefix\n\nOften, keys are very similar. Specifically, keys often share a common prefix and only differ near the end. For instance, one key might be `RowKey:Family:Qualifier0` and the next key might be `RowKey:Family:Qualifier1`.\nIn Prefix encoding, an extra column is added which holds the length of the prefix shared between the current key and the previous key. Assuming the first key here is totally different from the key before, its prefix length is 0.\n\nThe second key's prefix length is `23`, since they have the first 23 characters in common.\n\nObviously if the keys tend to have nothing in common, Prefix will not provide much benefit.\n\nThe following image shows a hypothetical ColumnFamily with no data block encoding.\n\n<img alt=\"ColumnFamily with No Encoding\" src={__img0} placeholder=\"blur\" />\n\nHere is the same data with prefix data encoding.\n\n<img alt=\"ColumnFamily with Prefix Encoding\" src={__img1} placeholder=\"blur\" />\n\n### Diff\n\nDiff encoding expands upon Prefix encoding.\nInstead of considering the key sequentially as a monolithic series of bytes, each key field is split so that each part of the key can be compressed more efficiently.\n\nTwo new fields are added: timestamp and type.\n\nIf the ColumnFamily is the same as the previous row, it is omitted from the current row.\n\nIf the key length, value length or type are the same as the previous row, the field is omitted.\n\nIn addition, for increased compression, the timestamp is stored as a Diff from the previous row's timestamp, rather than being stored in full.\nGiven the two row keys in the Prefix example, and given an exact match on timestamp and the same type, neither the value length, or type needs to be stored for the second row, and the timestamp value for the second row is just 0, rather than a full timestamp.\n\nDiff encoding is disabled by default because writing and scanning are slower but more data is cached.\n\nThis image shows the same ColumnFamily from the previous images, with Diff encoding.\n\n<img alt=\"ColumnFamily with Diff Encoding\" src={__img2} placeholder=\"blur\" />\n\n### Fast Diff\n\nFast Diff works similar to Diff, but uses a faster implementation. It also adds another field which stores a single bit to track whether the data itself is the same as the previous row. If it is, the data is not stored again.\n\nFast Diff is the recommended codec to use if you have long keys or many columns.\n\nThe data format is nearly identical to Diff encoding, so there is not an image to illustrate it.\n\n### Prefix Tree\n\nPrefix tree encoding was introduced as an experimental feature in HBase 0.96.\nIt provides similar memory savings to the Prefix, Diff, and Fast Diff encoder, but provides faster random access at a cost of slower encoding speed.\nIt was removed in hbase-2.0.0. It was a good idea but little uptake. If interested in reviving this effort, write the hbase dev list.\n\n## Which Compressor or Data Block Encoder To Use\n\nThe compression or codec type to use depends on the characteristics of your data. Choosing the wrong type could cause your data to take more space rather than less, and can have performance implications.\n\nIn general, you need to weigh your options between smaller size and faster compression/decompression. Following are some general guidelines, expanded from a discussion at [Documenting Guidance on compression and codecs](https://lists.apache.org/thread.html/481e67a61163efaaf4345510447a9244871a8d428244868345a155ff%401378926618%40%3Cdev.hbase.apache.org%3E).\n\n* In most cases, enabling LZ4 or Snappy by default is a good choice, because they have a low\n  performance overhead and provide reasonable space savings. A fast compression algorithm almost\n  always improves overall system performance by trading some increased CPU usage for better I/O\n  efficiency.\n* If the values are large (and not pre-compressed, such as images), use a data block compressor.\n* For *cold data*, which is accessed infrequently, depending on your use case, it might\n  make sense to opt for Zstandard at its higher compression levels, or LZMA, especially for high\n  entropy binary data, or Brotli for data similar in characteristics to web data. Bzip2 might also\n  be a reasonable option but Zstandard is very likely to offer superior decompression speed.\n* For *hot data*, which is accessed frequently, you almost certainly want only LZ4,\n  Snappy, LZO, or Zstandard at a low compression level. These options will not provide as high of\n  a compression ratio but will in trade not unduly impact system performance.\n* If you have long keys (compared to the values) or many columns, use a prefix encoder.\n  FAST\\_DIFF is recommended.\n* If enabling WAL value compression, consider LZ4 or SNAPPY compression, or Zstandard at\n  level 1. Reading and writing the WAL is performance critical. That said, the I/O\n  savings of these compression options can improve overall system performance.\n\n## Making use of Hadoop Native Libraries in HBase\n\nThe Hadoop shared library has a bunch of facility including compression libraries and fast crc'ing — hardware crc'ing if your chipset supports it.\nTo make this facility available to HBase, do the following. HBase/Hadoop will fall back to use alternatives if it cannot find the native library\nversions — or fail outright if you asking for an explicit compressor and there is no alternative available.\n\nFirst make sure of your Hadoop. Fix this message if you are seeing it starting Hadoop processes:\n\n```\n16/02/09 22:40:24 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable\n```\n\nIt means is not properly pointing at its native libraries or the native libs were compiled for another platform.\nFix this first.\n\nThen if you see the following in your HBase logs, you know that HBase was unable to locate the Hadoop native libraries:\n\n```\n2014-08-07 09:26:20,139 WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable\n```\n\nIf the libraries loaded successfully, the WARN message does not show. Usually this means you are good to go but read on.\n\nLet's presume your Hadoop shipped with a native library that suits the platform you are running HBase on.\nTo check if the Hadoop native library is available to HBase, run the following tool (available in Hadoop 2.1 and greater):\n\n```bash\n$ ./bin/hbase --config ~/conf_hbase org.apache.hadoop.util.NativeLibraryChecker\n2014-08-26 13:15:38,717 WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable\nNative library checking:\nhadoop: false\nzlib:   false\nsnappy: false\nlz4:    false\nbzip2:  false\n2014-08-26 13:15:38,863 INFO  [main] util.ExitUtil: Exiting with status 1\n```\n\nAbove shows that the native hadoop library is not available in HBase context.\n\nThe above NativeLibraryChecker tool may come back saying all is hunky-dory\n— i.e. all libs show 'true', that they are available — but follow the below\npresecription anyways to ensure the native libs are available in HBase context,\nwhen it goes to use them.\n\nTo fix the above, either copy the Hadoop native libraries local or symlink to them if the Hadoop and HBase stalls are adjacent in the filesystem.\nYou could also point at their location by setting the `LD_LIBRARY_PATH` environment variable in your hbase-env.sh.\n\nWhere the JVM looks to find native libraries is \"system dependent\" (See `java.lang.System#loadLibrary(name)`). On linux, by default, is going to look in *lib/native/PLATFORM* where `PLATFORM` is the label for the platform your HBase is installed on.\nOn a local linux machine, it seems to be the concatenation of the java properties `os.name` and `os.arch` followed by whether 32 or 64 bit.\nHBase on startup prints out all of the java system properties so find the os.name and os.arch in the log.\nFor example:\n\n```\n...\n2014-08-06 15:27:22,853 INFO  [main] zookeeper.ZooKeeper: Client environment:os.name=Linux\n2014-08-06 15:27:22,853 INFO  [main] zookeeper.ZooKeeper: Client environment:os.arch=amd64\n...\n```\n\nSo in this case, the PLATFORM string is `Linux-amd64-64`.\nCopying the Hadoop native libraries or symlinking at *lib/native/Linux-amd64-64* will ensure they are found.\nRolling restart after you have made this change.\n\nHere is an example of how you would set up the symlinks.\nLet the hadoop and hbase installs be in your home directory. Assume your hadoop native libs\nare at \\~/hadoop/lib/native. Assume you are on a Linux-amd64-64 platform. In this case,\nyou would do the following to link the hadoop native lib so hbase could find them.\n\n```bash\n...\n$ mkdir -p ~/hbaseLinux-amd64-64 -> /home/stack/hadoop/lib/native/lib/native/\n$ cd ~/hbase/lib/native/\n$ ln -s ~/hadoop/lib/native Linux-amd64-64\n$ ls -la\n# Linux-amd64-64 -> /home/USER/hadoop/lib/native\n...\n```\n\nIf you see PureJavaCrc32C in a stack track or if you see something like the below in a perf trace, then native is not working; you are using the java CRC functions rather than native:\n\n```\n  5.02%  perf-53601.map      [.] Lorg/apache/hadoop/util/PureJavaCrc32C;.update\n```\n\nSee [HBASE-11927 Use Native Hadoop Library for HFile checksum (And flip default from CRC32 to CRC32C)](https://issues.apache.org/jira/browse/HBASE-11927),\nfor more on native checksumming support. See in particular the release note for how to check if your hardware to see if your processor has support for hardware CRCs.\nOr checkout the Apache [Checksums in HBase](https://blogs.apache.org/hbase/entry/saving_cpu_using_native_hadoop) blog post.\n\nHere is example of how to point at the Hadoop libs with `LD_LIBRARY_PATH` environment variable:\n\n```bash\n$ LD_LIBRARY_PATH=~/hadoop-2.5.0-SNAPSHOT/lib/native ./bin/hbase --config ~/conf_hbase org.apache.hadoop.util.NativeLibraryChecker\n2014-08-26 13:42:49,332 INFO  [main] bzip2.Bzip2Factory: Successfully loaded & initialized native-bzip2 library system-native\n2014-08-26 13:42:49,337 INFO  [main] zlib.ZlibFactory: Successfully loaded & initialized native-zlib library\nNative library checking:\nhadoop: true /home/stack/hadoop-2.5.0-SNAPSHOT/lib/native/libhadoop.so.1.0.0\nzlib:   true /lib64/libz.so.1\nsnappy: true /usr/lib64/libsnappy.so.1\nlz4:    true revision:99\nbzip2:  true /lib64/libbz2.so.1\n```\n\nSet in *hbase-env.sh* the LD\\_LIBRARY\\_PATH environment variable when starting your HBase.\n\n## Compressor Configuration, Installation, and Use\n\n### Configure HBase For Compressors\n\nCompression codecs are provided either by HBase compressor modules or by Hadoop's native compression\nsupport. As described above you choose a compression type in table or column family schema or in\nsite configuration using its short label, e.g. *snappy* for Snappy, or *zstd* for ZStandard. Which\ncodec implementation is dynamically loaded to support what label is configurable by way of site\nconfiguration.\n\n| Algorithm label | Codec implementation configuration key | Default value                                               |\n| --------------- | -------------------------------------- | ----------------------------------------------------------- |\n| BROTLI          | hbase.io.compress.brotli.codec         | org.apache.hadoop.hbase.io.compress.brotli.BrotliCodec      |\n| BZIP2           | hbase.io.compress.bzip2.codec          | org.apache.hadoop.io.compress.BZip2Codec                    |\n| GZ              | hbase.io.compress.gz.codec             | org.apache.hadoop.hbase.io.compress.ReusableStreamGzipCodec |\n| LZ4             | hbase.io.compress.lz4.codec            | org.apache.hadoop.io.compress.Lz4Codec                      |\n| LZMA            | hbase.io.compress.lzma.codec           | org.apache.hadoop.hbase.io.compress.xz.LzmaCodec            |\n| LZO             | hbase.io.compress.lzo.codec            | com.hadoop.compression.lzo.LzoCodec                         |\n| SNAPPY          | hbase.io.compress.snappy.codec         | org.apache.hadoop.io.compress.SnappyCodec                   |\n| ZSTD            | hbase.io.compress.zstd.codec           | org.apache.hadoop.io.compress.ZStandardCodec                |\n\nThe available codec implementation options are:\n\n| Label  | Codec implementation class                                    | Notes                                                                                                                         |\n| ------ | ------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |\n| BROTLI | org.apache.hadoop.hbase.io.compress.brotli.BrotliCodec        | Implemented with [Brotli4j](https://github.com/hyperxpro/Brotli4j)                                                            |\n| BZIP2  | org.apache.hadoop.io.compress.BZip2Codec                      | Hadoop native codec                                                                                                           |\n| GZ     | org.apache.hadoop.hbase.io.compress.ReusableStreamGzipCodec   | Requires the Hadoop native GZ codec                                                                                           |\n| LZ4    | org.apache.hadoop.io.compress.Lz4Codec                        | Hadoop native codec                                                                                                           |\n| LZ4    | org.apache.hadoop.hbase.io.compress.aircompressor.Lz4Codec    | Pure Java implementation                                                                                                      |\n| LZ4    | org.apache.hadoop.hbase.io.compress.lz4.Lz4Codec              | Implemented with [lz4-java](https://github.com/lz4/lz4-java)                                                                  |\n| LZMA   | org.apache.hadoop.hbase.io.compress.xz.LzmaCodec              | Implemented with [XZ For Java](https://tukaani.org/xz/java.html)                                                              |\n| LZO    | com.hadoop.compression.lzo.LzoCodec                           | Hadoop native codec, requires GPL licensed native dependencies                                                                |\n| LZO    | org.apache.hadoop.io.compress.LzoCodec                        | Hadoop native codec, requires GPL licensed native dependencies                                                                |\n| LZO    | org.apache.hadoop.hbase.io.compress.aircompressor.LzoCodec    | Pure Java implementation                                                                                                      |\n| SNAPPY | org.apache.hadoop.io.compress.SnappyCodec                     | Hadoop native codec                                                                                                           |\n| SNAPPY | org.apache.hadoop.hbase.io.compress.aircompressor.SnappyCodec | Pure Java implementation                                                                                                      |\n| SNAPPY | org.apache.hadoop.hbase.io.compress.xerial.SnappyCodec        | Implemented with [snappy-java](https://github.com/xerial/snappy-java)                                                         |\n| ZSTD   | org.apache.hadoop.io.compress.ZStandardCodec                  | Hadoop native codec                                                                                                           |\n| ZSTD   | org.apache.hadoop.hbase.io.compress.aircompressor.ZstdCodec   | Pure Java implementation, limited to a fixed compression level, not data compatible with the Hadoop zstd codec                |\n| ZSTD   | org.apache.hadoop.hbase.io.compress.zstd.ZstdCodec            | Implemented with [zstd-jni](https://github.com/luben/zstd-jni), supports all compression levels, supports custom dictionaries |\n\nSpecify which codec implementation option you prefer for a given compression algorithm\nin site configuration, like so:\n\n```xml\n...\n<property>\n  <name>hbase.io.compress.lz4.codec</name>\n  <value>org.apache.hadoop.hbase.io.compress.lz4.Lz4Codec</value>\n</property>\n...\n```\n\n#### Compressor Microbenchmarks\n\nSee [https://github.com/apurtell/jmh-compression-tests](https://github.com/apurtell/jmh-compression-tests)\n\n256MB (258,126,022 bytes exactly) of block data was extracted from two HFiles containing Common\nCrawl data ingested using IntegrationLoadTestCommonCrawl, 2,680 blocks in total. This data was\nprocessed by each new codec implementation as if the block data were being compressed again for\nwrite into an HFile, but without writing any data, comparing only the CPU time and resource demand\nof the codec itself. Absolute performance numbers will vary depending on hardware and software\nparticulars of your deployment. The relative differences are what are interesting. Measured time\nis the average time in milliseconds required to compress all blocks of the 256MB file. This is\nhow long it would take to write the HFile containing these contents, minus the I/O overhead of\nblock encoding and actual persistence.\n\nThese are the results:\n\n| Codec                   | Level         | Time (milliseconds)  | Result (bytes) | Improvement |\n| ----------------------- | ------------- | -------------------- | -------------- | ----------- |\n| AirCompressor LZ4       | -             | 349.989 ± 2.835      | 76,999,408     | 70.17%      |\n| AirCompressor LZO       | -             | 334.554 ± 3.243      | 79,369,805     | 69.25%      |\n| AirCompressor Snappy    | -             | 364.153 ± 19.718     | 80,201,763     | 68.93%      |\n| AirCompressor Zstandard | 3 (effective) | 1108.267 ± 8.969     | 55,129,189     | 78.64%      |\n| Brotli                  | 1             | 593.107 ± 2.376      | 58,672,319     | 77.27%      |\n| Brotli                  | 3             | 1345.195 ± 27.327    | 53,917,438     | 79.11%      |\n| Brotli                  | 6             | 2812.411 ± 25.372    | 48,696,441     | 81.13%      |\n| Brotli                  | 10            | 74615.936 ± 224.854  | 44,970,710     | 82.58%      |\n| LZ4 (lz4-java)          | -             | 303.045 ± 0.783      | 76,974,364     | 70.18%      |\n| LZMA                    | 1             | 6410.428 ± 115.065   | 49,948,535     | 80.65%      |\n| LZMA                    | 3             | 8144.620 ± 152.119   | 49,109,363     | 80.97%      |\n| LZMA                    | 6             | 43802.576 ± 382.025  | 46,951,810     | 81.81%      |\n| LZMA                    | 9             | 49821.979 ± 580.110  | 46,951,810     | 81.81%      |\n| Snappy (xerial)         | -             | 360.225 ± 2.324      | 80,749,937     | 68.72%      |\n| Zstd (zstd-jni)         | 1             | 654.699 ± 16.839     | 56,719,994     | 78.03%      |\n| Zstd (zstd-jni)         | 3             | 839.160 ± 24.906     | 54,573,095     | 78.86%      |\n| Zstd (zstd-jni)         | 5             | 1594.373 ± 22.384    | 52,025,485     | 79.84%      |\n| Zstd (zstd-jni)         | 7             | 2308.705 ± 24.744    | 50,651,554     | 80.38%      |\n| Zstd (zstd-jni)         | 9             | 3659.677 ± 58.018    | 50,208,425     | 80.55%      |\n| Zstd (zstd-jni)         | 12            | 8705.294 ± 58.080    | 49,841,446     | 80.69%      |\n| Zstd (zstd-jni)         | 15            | 19785.646 ± 278.080  | 48,499,508     | 81.21%      |\n| Zstd (zstd-jni)         | 18            | 47702.097 ± 442.670  | 48,319,879     | 81.28%      |\n| Zstd (zstd-jni)         | 22            | 97799.695 ± 1106.571 | 48,212,220     | 81.32%      |\n\n#### Compressor Support On the Master\n\nA new configuration setting was introduced in HBase 0.95, to check the Master to determine which data block encoders are installed and configured on it, and assume that the entire cluster is configured the same.\nThis option, `hbase.master.check.compression`, defaults to `true`.\nThis prevents the situation described in [HBASE-6370](https://issues.apache.org/jira/browse/HBASE-6370), where a table is created or modified to support a codec that a region server does not support, leading to failures that take a long time to occur and are difficult to debug.\n\nIf `hbase.master.check.compression` is enabled, libraries for all desired compressors need to be installed and configured on the Master, even if the Master does not run a region server.\n\n#### Install GZ Support Via Native Libraries\n\nHBase uses Java's built-in GZip support unless the native Hadoop libraries are available on the CLASSPATH.\nThe recommended way to add libraries to the CLASSPATH is to set the environment variable `HBASE_LIBRARY_PATH` for the user running HBase.\nIf native libraries are not available and Java's GZIP is used, `Got brand-new compressor` reports will be present in the logs.\nSee [brand.new.compressor](/docs/troubleshooting#logs-flooded-with-2011-01-10-124048407-info-orgapachehadoopiocompresscodecpool-gotbrand-new-compressor-messages)).\n\n#### Install Hadoop Native LZO Support\n\nHBase cannot ship with the Hadoop native LZO codc because of incompatibility between HBase, which uses an Apache Software License (ASL) and LZO, which uses a GPL license.\nSee the [Hadoop-LZO at Twitter](https://github.com/twitter/hadoop-lzo/blob/master/README.md) for information on configuring LZO support for HBase.\n\nIf you depend upon LZO compression, consider using the pure Java and ASL licensed\nAirCompressor LZO codec option instead of the Hadoop native default, or configure your\nRegionServers to fail to start if native LZO support is not available.\nSee [hbase.regionserver.codecs](/docs/compression#enforce-compression-settings-on-a-regionserver).\n\n#### Configure Hadoop Native LZ4 Support\n\nLZ4 support is bundled with Hadoop and is the default LZ4 codec implementation.\nIt is not required that you make use of the Hadoop LZ4 codec. Our LZ4 codec implemented\nwith lz4-java offers superior performance, and the AirCompressor LZ4 codec offers a\npure Java option for use where native support is not available.\n\nThat said, if you prefer the Hadoop option, make sure the hadoop shared library\n(libhadoop.so) is accessible when you start HBase.\nAfter configuring your platform (see [hadoop.native.lib](/docs/compression#making-use-of-hadoop-native-libraries-in-hbase)), you can\nmake a symbolic link from HBase to the native Hadoop libraries. This assumes the two\nsoftware installs are colocated. For example, if my 'platform' is Linux-amd64-64:\n\n```bash\n$ cd $HBASE_HOME\n$ mkdir lib/native\n$ ln -s $HADOOP_HOME/lib/native lib/native/Linux-amd64-64\n```\n\nUse the compression tool to check that LZ4 is installed on all nodes.\nStart up (or restart) HBase.\nAfterward, you can create and alter tables to enable LZ4 as a compression codec.:\n\n```ruby\nhbase(main):003:0> alter 'TestTable', {NAME => 'info', COMPRESSION => 'LZ4'}\n```\n\n#### Install Hadoop native Snappy Support\n\nSnappy support is bundled with Hadoop and is the default Snappy codec implementation.\nIt is not required that you make use of the Hadoop Snappy codec. Our Snappy codec\nimplemented with Xerial Snappy offers superior performance, and the AirCompressor\nSnappy codec offers a pure Java option for use where native support is not available.\n\nThat said, if you prefer the Hadoop codec option, you can install Snappy binaries (for\ninstance, by using +yum install snappy+ on CentOS) or build Snappy from source.\nAfter installing Snappy, search for the shared library, which will be called *libsnappy.so.X* where X is a number.\nIf you built from source, copy the shared library to a known location on your system, such as */opt/snappy/lib/*.\n\nIn addition to the Snappy library, HBase also needs access to the Hadoop shared library, which will be called something like *libhadoop.so.X.Y*, where X and Y are both numbers.\nMake note of the location of the Hadoop library, or copy it to the same location as the Snappy library.\n\n<Callout type=\"info\">\n  The Snappy and Hadoop libraries need to be available on each node of your cluster.\n  See [compression.test](/docs/compression#compressiontest) to find out how to test that this is the case.\n\n  See [hbase.regionserver.codecs](/docs/compression#enforce-compression-settings-on-a-regionserver) to configure your RegionServers to fail to start if a given compressor is not available.\n</Callout>\n\nEach of these library locations need to be added to the environment variable `HBASE_LIBRARY_PATH` for the operating system user that runs HBase.\nYou need to restart the RegionServer for the changes to take effect.\n\n#### CompressionTest\n\nYou can use the CompressionTest tool to verify that your compressor is available to HBase:\n\n```bash\n $ hbase org.apache.hadoop.hbase.util.CompressionTest hdfs://host/path/to/hbase snappy\n```\n\n#### Enforce Compression Settings On a RegionServer\n\nYou can configure a RegionServer so that it will fail to restart if compression is configured incorrectly, by adding the option hbase.regionserver.codecs to the *hbase-site.xml*, and setting its value to a comma-separated list of codecs that need to be available.\nFor example, if you set this property to `lzo,gz`, the RegionServer would fail to start if both compressors were not available.\nThis would prevent a new server from being added to the cluster without having codecs configured properly.\n\n### Enable Compression On a ColumnFamily\n\nTo enable compression for a ColumnFamily, use an `alter` command.\nYou do not need to re-create the table or copy data.\nIf you are changing codecs, be sure the old codec is still available until all the old StoreFiles have been compacted.\n\n#### Enabling Compression on a ColumnFamily of an Existing Table using HBaseShell\n\n```ruby\nhbase> alter 'test', {NAME => 'cf', COMPRESSION => 'GZ'}\n```\n\n#### Creating a New Table with Compression On a ColumnFamily\n\n```ruby\nhbase> create 'test2', { NAME => 'cf2', COMPRESSION => 'SNAPPY' }\n```\n\n#### Verifying a ColumnFamily's Compression Settings\n\n```ruby\nhbase> describe 'test'\nDESCRIPTION                                          ENABLED\n 'test', {NAME => 'cf', DATA_BLOCK_ENCODING => 'NONE false\n ', BLOOMFILTER => 'ROW', REPLICATION_SCOPE => '0',\n VERSIONS => '1', COMPRESSION => 'GZ', MIN_VERSIONS\n => '0', TTL => 'FOREVER', KEEP_DELETED_CELLS => 'fa\n lse', BLOCKSIZE => '65536', IN_MEMORY => 'false', B\n LOCKCACHE => 'true'}\n1 row(s) in 0.1070 seconds\n```\n\n### Testing Compression Performance\n\nHBase includes a tool called LoadTestTool which provides mechanisms to test your compression performance.\nYou must specify either `-write` or `-update-read` as your first parameter, and if you do not specify another parameter, usage advice is printed for each option.\n\n**`LoadTestTool` Usage**\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.util.LoadTestTool -h\nusage: bin/hbase org.apache.hadoop.hbase.util.LoadTestTool <options>\nOptions:\n -batchupdate                 Whether to use batch as opposed to separate\n                              updates for every column in a row\n -bloom <arg>                 Bloom filter type, one of [NONE, ROW, ROWCOL]\n -compression <arg>           Compression type, one of [LZO, GZ, NONE, SNAPPY,\n                              LZ4]\n -data_block_encoding <arg>   Encoding algorithm (e.g. prefix compression) to\n                              use for data blocks in the test column family, one\n                              of [NONE, PREFIX, DIFF, FAST_DIFF, ROW_INDEX_V1].\n -encryption <arg>            Enables transparent encryption on the test table,\n                              one of [AES]\n -generator <arg>             The class which generates load for the tool. Any\n                              args for this class can be passed as colon\n                              separated after class name\n -h,--help                    Show usage\n -in_memory                   Tries to keep the HFiles of the CF inmemory as far\n                              as possible.  Not guaranteed that reads are always\n                              served from inmemory\n -init_only                   Initialize the test table only, don't do any\n                              loading\n -key_window <arg>            The 'key window' to maintain between reads and\n                              writes for concurrent write/read workload. The\n                              default is 0.\n -max_read_errors <arg>       The maximum number of read errors to tolerate\n                              before terminating all reader threads. The default\n                              is 10.\n -multiput                    Whether to use multi-puts as opposed to separate\n                              puts for every column in a row\n -num_keys <arg>              The number of keys to read/write\n -num_tables <arg>            A positive integer number. When a number n is\n                              speicfied, load test tool  will load n table\n                              parallely. -tn parameter value becomes table name\n                              prefix. Each table name is in format\n                              <tn>_1...<tn>_n\n -read <arg>                  <verify_percent>[:#threads=20]\n -regions_per_server <arg>    A positive integer number. When a number n is\n                              specified, load test tool will create the test\n                              table with n regions per server\n -skip_init                   Skip the initialization; assume test table already\n                              exists\n -start_key <arg>             The first key to read/write (a 0-based index). The\n                              default value is 0.\n -tn <arg>                    The name of the table to read or write\n -update <arg>                <update_percent>[:#threads=20][:#whether to\n                              ignore nonce collisions=0]\n -write <arg>                 <avg_cols_per_key>:<avg_data_size>[:#threads=20]\n -zk <arg>                    ZK quorum as comma-separated host names without\n                              port numbers\n -zk_root <arg>               name of parent znode in zookeeper\n```\n\n#### Example Usage of LoadTestTool\n\n```bash\n$ hbase org.apache.hadoop.hbase.util.LoadTestTool -write 1:10:100 -num_keys 1000000 \\\n      -read 100:30 -num_tables 1 -data_block_encoding NONE -tn load_test_tool_NONE\n```\n\n## Enable Data Block Encoding\n\nCodecs are built into HBase so no extra configuration is needed.\nCodecs are enabled on a table by setting the `DATA_BLOCK_ENCODING` property.\nDisable the table before altering its DATA\\_BLOCK\\_ENCODING setting.\nFollowing is an example using HBase Shell:\n\n#### Enable Data Block Encoding On a Table\n\n```ruby\nhbase> alter 'test', { NAME => 'cf', DATA_BLOCK_ENCODING => 'FAST_DIFF' }\nUpdating all regions with the new schema...\n0/1 regions updated.\n1/1 regions updated.\nDone.\n0 row(s) in 2.2820 seconds\n```\n\n#### Verifying a ColumnFamily's Data Block Encoding\n\n```ruby\nhbase> describe 'test'\nDESCRIPTION                                          ENABLED\n 'test', {NAME => 'cf', DATA_BLOCK_ENCODING => 'FAST true\n _DIFF', BLOOMFILTER => 'ROW', REPLICATION_SCOPE =>\n '0', VERSIONS => '1', COMPRESSION => 'GZ', MIN_VERS\n IONS => '0', TTL => 'FOREVER', KEEP_DELETED_CELLS =\n > 'false', BLOCKSIZE => '65536', IN_MEMORY => 'fals\n e', BLOCKCACHE => 'true'}\n1 row(s) in 0.0650 seconds\n```\n\n\n# Basic Prerequisites (/docs/configuration/basic-prerequisites)\n## Java\n\nHBase runs on the Java Virtual Machine, thus all HBase deployments require a JVM runtime.\n\nThe following table summarizes the recommendations of the HBase community with respect to running on various Java versions. The ✅ symbol indicates a base level of testing and willingness to help diagnose and address issues you might run into; these are the expected deployment combinations. An entry of ⚠️ means that there may be challenges with this combination, and you should look for more information before deciding to pursue this as your deployment strategy. The ❌ means this combination does not work; either an older Java version is considered deprecated by the HBase community, or this combination is known to not work. For combinations of newer JDK with older HBase releases, it's likely there are known compatibility issues that cannot be addressed under our compatibility guarantees, making the combination impossible. In some cases, specific guidance on limitations (e.g. whether compiling / unit tests work, specific operational issues, etc) are also noted. Assume any combination not listed here is considered ❌.\n\n<Callout type=\"warn\">\n  HBase recommends downstream users rely only on JDK releases that are marked as Long-Term Supported\n  (LTS), either from the OpenJDK project or vendors. At the time of this writing, the following JDK\n  releases are NOT LTS releases and are NOT tested or advocated for use by the Apache HBase\n  community: JDK9, JDK10, JDK12, JDK13, and JDK14. Community discussion around this decision is\n  recorded on [HBASE-20264](https://issues.apache.org/jira/browse/HBASE-20264).\n</Callout>\n\n<Callout type=\"tip\">\n  At this time, all testing performed by the Apache HBase project runs on the HotSpot variant of the\n  JVM. When selecting your JDK distribution, please take this into consideration.\n</Callout>\n\n**Java support by release line**\n\n| HBase Version | JDK 6 | JDK 7 | JDK 8 | JDK 11 | JDK 17 |\n| :-----------: | :---: | :---: | :---: | :----: | :----: |\n|   HBase 2.6   |   ❌   |   ❌   |   ✅   |    ✅   |    ✅   |\n|   HBase 2.5   |   ❌   |   ❌   |   ✅   |    ✅   |  ⚠️\\*  |\n|   HBase 2.4   |   ❌   |   ❌   |   ✅   |    ✅   |    ❌   |\n|   HBase 2.3   |   ❌   |   ❌   |   ✅   |  ⚠️\\*  |    ❌   |\n| HBase 2.0-2.2 |   ❌   |   ❌   |   ✅   |    ❌   |    ❌   |\n|   HBase 1.2+  |   ❌   |   ✅   |   ✅   |    ❌   |    ❌   |\n| HBase 1.0-1.1 |   ❌   |   ✅   |   ⚠️  |    ❌   |    ❌   |\n|   HBase 0.98  |   ✅   |   ✅   |   ⚠️  |    ❌   |    ❌   |\n|   HBase 0.94  |   ✅   |   ✅   |   ❌   |    ❌   |    ❌   |\n\n<Callout type=\"warn\">\n  Preliminary support for JDK11 is introduced with HBase 2.3.0, and for JDK17 is introduced with HBase 2.5.x. We will compile and run test suites with JDK11/17 in pre commit checks and nightly checks. We will mark the support as ✅ as long as we have run some ITs with the JDK version and also there are users in the community use the JDK version in real production clusters.\n\n  For JDK11/JDK17 support in HBase, please refer to [HBASE-22972](https://issues.apache.org/jira/browse/HBASE-22972) and [HBASE-26038](https://issues.apache.org/jira/browse/HBASE-26038)\n\n  For JDK11/JDK17 support in Hadoop, which may also affect HBase, please refer to [HADOOP-15338](https://issues.apache.org/jira/browse/HADOOP-15338) and [HADOOP-17177](https://issues.apache.org/jira/browse/HADOOP-17177)\n</Callout>\n\n<Callout type=\"info\">\n  You must set `JAVA_HOME` on each node of your cluster. *hbase-env.sh* provides a handy mechanism\n  to do this.\n</Callout>\n\n### Operating System Utilities\n\n#### ssh\n\nHBase uses the Secure Shell (ssh) command and utilities extensively to communicate between cluster nodes. Each server in the cluster must be running `ssh` so that the Hadoop and HBase daemons can be managed. You must be able to connect to all nodes via SSH, including the local node, from the Master as well as any backup Master, using a shared key rather than a password. You can see the basic methodology for such a set-up in Linux or Unix systems at \"[Procedure: Configure Passwordless SSH Access](/docs/getting-started#procedure-configure-passwordless-ssh-access)\" chapter. If your cluster nodes use OS X, see the section, [SSH: Setting up Remote Desktop and Enabling Self-Login](https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=120730246#RunningHadoopOnOSX10.564-bit\\(Single-NodeCluster\\)-SSH:SettingupRemoteDesktopandEnablingSelf-Login) on the Hadoop wiki.\n\n#### DNS\n\nHBase uses the local hostname to self-report its IP address.\n\n#### NTP\n\nThe clocks on cluster nodes should be synchronized. A small amount of variation is acceptable, but larger amounts of skew can cause erratic and unexpected behavior. Time synchronization is one of the first things to check if you see unexplained problems in your cluster. It is recommended that you run a Network Time Protocol (NTP) service, or another time-synchronization mechanism on your cluster and that all nodes look to the same service for time synchronization. See the [Basic NTP Configuration](http://www.tldp.org/LDP/sag/html/basic-ntp-config.html) at *The Linux Documentation Project (TLDP)* to set up NTP.\n\n#### Limits on Number of Files and Processes (ulimit)\n\nApache HBase is a database. It requires the ability to open a large number of files at once. Many Linux distributions limit the number of files a single user is allowed to open to `1024` (or `256` on older versions of OS X). You can check this limit on your servers by running the command `ulimit -n` when logged in as the user which runs HBase. See [the Troubleshooting section](/docs/troubleshooting#javaioioexceptiontoo-many-open-files) for some of the problems you may experience if the limit is too low. You may also notice errors such as the following:\n\n```text\n2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Exception increateBlockOutputStream java.io.EOFException\n2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Abandoning block blk_-6935524980745310745_1391901\n```\n\nIt is recommended to raise the ulimit to at least 10,000, but more likely 10,240, because the value is usually expressed in multiples of 1024. Each ColumnFamily has at least one StoreFile, and possibly more than six StoreFiles if the region is under load. The number of open files required depends upon the number of ColumnFamilies and the number of regions. The following is a rough formula for calculating the potential number of open files on a RegionServer.\n\n**Calculate the Potential Number of Open Files:**\n\n```text\n(StoreFiles per ColumnFamily) x (regions per RegionServer)\n```\n\nFor example, assuming that a schema had 3 ColumnFamilies per region with an average of 3 StoreFiles per ColumnFamily, and there are 100 regions per RegionServer, the JVM will open `3 * 3 * 100 = 900` file descriptors, not counting open JAR files, configuration files, and others. Opening a file does not take many resources, and the risk of allowing a user to open too many files is minimal.\n\nAnother related setting is the number of processes a user is allowed to run at once. In Linux and Unix, the number of processes is set using the `ulimit -u` command. This should not be confused with the `nproc` command, which controls the number of CPUs available to a given user. Under load, a `ulimit -u` that is too low can cause OutOfMemoryError exceptions.\n\nConfiguring the maximum number of file descriptors and processes for the user who is running the HBase process is an operating system configuration, rather than an HBase configuration. It is also important to be sure that the settings are changed for the user that actually runs HBase. To see which user started HBase, and that user's ulimit configuration, look at the first line of the HBase log for that instance.\n\n#### Example: `ulimit` Settings on Ubuntu \\[!toc]\n\nTo configure ulimit settings on Ubuntu, edit */etc/security/limits.conf*, which is a space-delimited file with four columns. Refer to the man page for *limits.conf* for details about the format of this file. In the following example, the first line sets both soft and hard limits for the number of open files (nofile) to 32768 for the operating system user with the username hadoop. The second line sets the number of processes to 32000 for the same user.\n\n```text\nhadoop  -       nofile  32768\nhadoop  -       nproc   32000\n```\n\nThe settings are only applied if the Pluggable Authentication Module (PAM) environment is directed to use them. To configure PAM to use these limits, be sure that the */etc/pam.d/common-session* file contains the following line:\n\n```text\nsession required  pam_limits.so\n```\n\n#### Linux Shell\n\nAll of the shell scripts that come with HBase rely on the [GNU Bash](http://www.gnu.org/software/bash) shell.\n\n#### Windows\n\nRunning production systems on Windows machines is not recommended.\n\n## Hadoop\n\nThe following table summarizes the versions of [Hadoop](https://hadoop.apache.org) supported with each version of HBase. Older versions not appearing in this table are considered unsupported and likely missing necessary features, while newer versions are untested but may be suitable.\n\nBased on the version of HBase, you should select the most appropriate version of Hadoop. You can use Apache Hadoop, or a vendor's distribution of Hadoop. No distinction is made here. See [the Hadoop wiki](https://cwiki.apache.org/confluence/display/HADOOP2/Distributions+and+Commercial+Support) for information about vendors of Hadoop.\n\n<Callout type=\"tip\">\n  Comparing to Hadoop 1.x, Hadoop 2.x is faster and includes features, such as short-circuit reads (see [Leveraging local data](/docs/performance#leveraging-local-data)), which will help improve your HBase random read profile. Hadoop 2.x also includes important bug fixes that will improve your overall HBase experience. HBase does not support running with earlier versions of Hadoop. See the table below for requirements specific to different HBase versions.\n\n  Today, Hadoop 3.x is recommended as the last Hadoop 2.x release 2.10.2 was released years ago, and there is no release for Hadoop 2.x for a very long time, although the Hadoop community does not officially EOL Hadoop 2.x yet.\n</Callout>\n\nUse the following legend to interpret these tables:\n\n* ✅ = Tested to be fully-functional\n* ❌ = Known to not be fully-functional, or there are [CVEs](https://hadoop.apache.org/cve_list.html) so we drop the support in newer minor releases\n* ⚠️ = Not tested, may/may-not function\n\n|                    | HBase-2.5.x | HBase-2.6.x |\n| ------------------ | ----------- | ----------- |\n| Hadoop-2.10.\\[0-1] | ❌           | ❌           |\n| Hadoop-2.10.2+     | ✅           | ✅           |\n| Hadoop-3.1.0       | ❌           | ❌           |\n| Hadoop-3.1.1+      | ❌           | ❌           |\n| Hadoop-3.2.\\[0-2]  | ❌           | ❌           |\n| Hadoop-3.2.3+      | ✅           | ❌           |\n| Hadoop-3.3.\\[0-1]  | ❌           | ❌           |\n| Hadoop-3.3.\\[2-4]  | ✅           | ❌           |\n| Hadoop-3.3.5+      | ✅           | ✅           |\n| Hadoop-3.4.0+      | ✅ (2.5.11+) | ✅ (2.6.2+)  |\n\n### Hadoop version support matrix for active release lines\n\n|               | HBase-2.3.x | HBase-2.4.x |\n| ------------- | ----------- | ----------- |\n| Hadoop-2.10.x | ✅           | ✅           |\n| Hadoop-3.1.0  | ❌           | ❌           |\n| Hadoop-3.1.1+ | ✅           | ✅           |\n| Hadoop-3.2.x  | ✅           | ✅           |\n| Hadoop-3.3.x  | ✅           | ✅           |\n\n### Hadoop version support matrix for EOM 2.3+ release lines\n\n|                   | HBase-2.0.x | HBase-2.1.x | HBase-2.2.x |\n| ----------------- | ----------- | ----------- | ----------- |\n| Hadoop-2.6.1+     | ✅           | ❌           | ❌           |\n| Hadoop-2.7.\\[0-6] | ❌           | ❌           | ❌           |\n| Hadoop-2.7.7+     | ✅           | ✅           | ❌           |\n| Hadoop-2.8.\\[0-2] | ❌           | ❌           | ❌           |\n| Hadoop-2.8.\\[3-4] | ✅           | ✅           | ❌           |\n| Hadoop-2.8.5+     | ✅           | ✅           | ✅           |\n| Hadoop-2.9.\\[0-1] | ⚠️          | ❌           | ❌           |\n| Hadoop-2.9.2+     | ⚠️          | ⚠️          | ✅           |\n| Hadoop-3.0.\\[0-2] | ❌           | ❌           | ❌           |\n| Hadoop-3.0.3+     | ❌           | ✅           | ❌           |\n| Hadoop-3.1.0      | ❌           | ❌           | ❌           |\n| Hadoop-3.1.1+     | ❌           | ✅           | ✅           |\n\n### Hadoop version support matrix for EOM 2.x release lines\n\n|                   | HBase-1.5.x | HBase-1.6.x | HBase-1.7.x |\n| ----------------- | ----------- | ----------- | ----------- |\n| Hadoop-2.7.7+     | ✅           | ❌           | ❌           |\n| Hadoop-2.8.\\[0-4] | ❌           | ❌           | ❌           |\n| Hadoop-2.8.5+     | ✅           | ✅           | ✅           |\n| Hadoop-2.9.\\[0-1] | ❌           | ❌           | ❌           |\n| Hadoop-2.9.2+     | ✅           | ✅           | ✅           |\n| Hadoop-2.10.x     | ⚠️          | ✅           | ✅           |\n\n### Hadoop version support matrix for EOM 1.5+ release lines\n\n|               | HBase-1.0.x (Hadoop 1.x is NOT supported) | HBase-1.1.x | HBase-1.2.x | HBase-1.3.x | HBase-1.4.x |\n| ------------- | ----------------------------------------- | ----------- | ----------- | ----------- | ----------- |\n| Hadoop-2.4.x  | ✅                                         | ✅           | ✅           | ✅           | ❌           |\n| Hadoop-2.5.x  | ✅                                         | ✅           | ✅           | ✅           | ❌           |\n| Hadoop-2.6.0  | ❌                                         | ❌           | ❌           | ❌           | ❌           |\n| Hadoop-2.6.1+ | ⚠️                                        | ⚠️          | ✅           | ✅           | ❌           |\n| Hadoop-2.7.0  | ❌                                         | ❌           | ❌           | ❌           | ❌           |\n| Hadoop-2.7.1+ | ⚠️                                        | ⚠️          | ✅           | ✅           | ✅           |\n\n### Hadoop version support matrix for EOM 1.x release lines\n\n|                    | HBase-0.92.x | HBase-0.94.x | HBase-0.96.x | HBase-0.98.x (Support for Hadoop 1.1+ is deprecated.) |\n| ------------------ | ------------ | ------------ | ------------ | ----------------------------------------------------- |\n| Hadoop-0.20.205    | ✅            | ❌            | ❌            | ❌                                                     |\n| Hadoop-0.22.x      | ✅            | ❌            | ❌            | ❌                                                     |\n| Hadoop-1.0.x       | ❌            | ❌            | ❌            | ❌                                                     |\n| Hadoop-1.1.x       | ⚠️           | ✅            | ✅            | ⚠️                                                    |\n| Hadoop-0.23.x      | ❌            | ✅            | ⚠️           | ❌                                                     |\n| Hadoop-2.0.x-alpha | ❌            | ⚠️           | ❌            | ❌                                                     |\n| Hadoop-2.1.0-beta  | ❌            | ⚠️           | ✅            | ❌                                                     |\n| Hadoop-2.2.0       | ❌            | ⚠️           | ✅            | ✅                                                     |\n| Hadoop-2.3.x       | ❌            | ⚠️           | ✅            | ✅                                                     |\n| Hadoop-2.4.x       | ❌            | ⚠️           | ✅            | ✅                                                     |\n| Hadoop-2.5.x       | ❌            | ⚠️           | ✅            | ✅                                                     |\n\n### Hadoop version support matrix for EOM pre-1.0 release lines\n\n<Callout type=\"idea\">\n  Starting around the time of Hadoop version 2.7.0, the Hadoop PMC got into the habit of calling out\n  new minor releases on their major version 2 release line as not stable / production ready. As\n  such, HBase expressly advises downstream users to avoid running on top of these releases. Note\n  that additionally the 2.8.1 release was given the same caveat by the Hadoop PMC. For reference,\n  see the release announcements for [Apache Hadoop\n  2.7.0](https://s.apache.org/hadoop-2.7.0-announcement), [Apache Hadoop\n  2.8.0](https://s.apache.org/hadoop-2.8.0-announcement), [Apache Hadoop\n  2.8.1](https://s.apache.org/hadoop-2.8.1-announcement), and [Apache Hadoop\n  2.9.0](https://s.apache.org/hadoop-2.9.0-announcement).\n</Callout>\n\n<Callout type=\"idea\">\n  The Hadoop PMC called out the 3.1.0 release as not stable / production ready. As such, HBase\n  expressly advises downstream users to avoid running on top of this release. For reference, see the\n  [release announcement for Hadoop 3.1.0](https://s.apache.org/hadoop-3.1.0-announcement).\n</Callout>\n\n<Callout type=\"info\">\n  Because HBase depends on Hadoop, it bundles Hadoop jars under its *lib* directory. The bundled\n  jars are ONLY for use in stand-alone mode. In distributed mode, it is *critical* that the version\n  of Hadoop that is out on your cluster match what is under HBase. Replace the hadoop jars found in\n  the HBase lib directory with the equivalent hadoop jars from the version you are running on your\n  cluster to avoid version mismatch issues. Make sure you replace the jars under HBase across your\n  whole cluster. Hadoop version mismatch issues have various manifestations. Check for mismatch if\n  HBase appears hung.\n</Callout>\n\n### Hadoop 3 Support for the HBase Binary Releases and Maven Artifacts\n\nFor HBase 2.5.1 and earlier, the official HBase binary releases and Maven artifacts were built with Hadoop 2.x.\n\nStarting with HBase 2.5.2, HBase provides binary releases and Maven artifacts built with both Hadoop 2.x and Hadoop 3.x. The Hadoop 2 artifacts do not have any version suffix, the Hadoop 3 artifacts add the `-hadoop-3` suffix to the version. i.e. `hbase-2.5.2-bin.tar.gz.asc` is the Binary release built with Hadoop2, and `hbase-2.5.2-hadoop3-bin.tar.gz` is the release built with Hadoop 3.\n\n### Hadoop 3 version policy\n\nEach HBase release has a default Hadoop 3 version. This is used when the Hadoop 3 version is not specified during build, and for building the official binary releases and artifacts. Generally when a new minor version is released (i.e. 2.5.0) the default version is set to the latest supported Hadoop 3 version at the start of the release process.\n\nUp to HBase 2.5.10 and 2.6.1 even if HBase added support for newer Hadoop 3 releases in a patch release, the default Hadoop 3 version (and the one used in the official binary releases) was not updated. This simplified upgrading, but meant that HBase releases often included old unfixed CVEs both from Hadoop and Hadoop's dependencies, even when newer Hadoop releases with fixes were available.\n\nStarting with HBase 2.5.11 and 2.6.2, the default Hadoop 3 version is always set to the latest supported Hadoop 3 version, and is also used for the `-hadoop3` binary releases and artifacts. This will drastically reduce the number of known CVEs shipped in the HBase binary releases, and make sure that all fixes and improvements in Hadoop are included.\n\n### `dfs.datanode.max.transfer.threads`\n\nAn HDFS DataNode has an upper bound on the number of files that it will serve at any one time. Before doing any loading, make sure you have configured Hadoop's *conf/hdfs-site.xml*, setting the `dfs.datanode.max.transfer.threads` value to at least the following:\n\n```xml\n<property>\n  <name>dfs.datanode.max.transfer.threads</name>\n  <value>4096</value>\n</property>\n```\n\nBe sure to restart your HDFS after making the above configuration.\n\nNot having this configuration in place makes for strange-looking failures. One manifestation is a complaint about missing blocks. For example:\n\n```text\n10/12/08 20:10:31 INFO hdfs.DFSClient: Could not obtain block\n          blk_XXXXXXXXXXXXXXXXXXXXXX_YYYYYYYY from any node: java.io.IOException: No live nodes\n          contain current block. Will get new block locations from namenode and retry...\n```\n\nSee also [Case Studies](/docs/case-studies#case-study-4-maxtransferthreads-config) and note that this property was previously known as `dfs.datanode.max.xcievers` (e.g. [Hadoop HDFS: Deceived by Xciever](http://ccgtech.blogspot.com/2010/02/hadoop-hdfs-deceived-by-xciever.html)).\n\n## ZooKeeper Requirements\n\nAn Apache ZooKeeper quorum is required. The exact version depends on your version of HBase, though the minimum ZooKeeper version is 3.4.x due to the `useMulti` feature made default in 1.0.0 (see [HBASE-16598](https://issues.apache.org/jira/browse/HBASE-16598)).\n\n\n# Running and Confirming Your Installation (/docs/configuration/confirm)\nMake sure HDFS is running first. Start and stop the Hadoop HDFS daemons by running *bin/start-hdfs.sh* over in the `HADOOP_HOME` directory. You can ensure it started properly by testing the `put` and `get` of files into the Hadoop filesystem. HBase does not normally use the MapReduce or YARN daemons. These do not need to be started.\n\n*If* you are managing your own ZooKeeper, start it and confirm it's running, else HBase will start up ZooKeeper for you as part of its start process.\n\nStart HBase with the following command:\n\n```bash\nbin/start-hbase.sh\n```\n\nRun the above from the `HBASE_HOME` directory.\n\nYou should now have a running HBase instance. HBase logs can be found in the *logs* subdirectory. Check them out especially if HBase had trouble starting.\n\nHBase also puts up a UI listing vital attributes. By default it's deployed on the Master host at port 16010 (HBase RegionServers listen on port 16020 by default and put up an informational HTTP server at port 16030). If the Master is running on a host named `master.example.org` on the default port, point your browser at [http://master.example.org:16010](http://master.example.org:16010) to see the web interface.\n\nOnce HBase has started, see the [shell exercises](/docs/getting-started#procedure-use-hbase-for-the-first-time) documentation for how to create tables, add data, scan your insertions, and finally disable and drop your tables.\n\nTo stop HBase after exiting the HBase shell enter\n\n```bash\n$ ./bin/stop-hbase.sh\nstopping hbase...............\n```\n\nShutdown can take a moment to complete. It can take longer if your cluster is comprised of many machines. If you are running a distributed operation, be sure to wait until HBase has shut down completely before stopping the Hadoop daemons.\n\n\n# Default Configuration (/docs/configuration/default)\n## *hbase-site.xml* and *hbase-default.xml*\n\nJust as in Hadoop where you add site-specific HDFS configuration to the *hdfs-site.xml* file, for HBase, site specific customizations go into the file *conf/hbase-site.xml*. For the list of configurable properties, see [hbase default configurations](/docs/configuration/default#configuration-default-hbase-default-configuration) below or view the raw *hbase-default.xml* source file in the HBase source code at *src/main/resources*.\n\nNot all configuration options make it out to *hbase-default.xml*. Some configurations would only appear in source code; the only way to identify these changes are through code review.\n\nCurrently, changes here will require a cluster restart for HBase to notice the change.\n\n## HBase Default configuration\n\nThe documentation below is generated using the default hbase configuration file, *hbase-default.xml*, as source.\n\n#### `hbase.tmp.dir` \\[!toc]\n\n**Description:** Temporary directory on the local filesystem. Change this setting to point to a location more permanent than '/tmp', the usual resolve for java.io.tmpdir, as the '/tmp' directory is cleared on machine restart.\\\n**Default:** `${java.io.tmpdir}/hbase-${user.name}`\n\n#### `hbase.rootdir` \\[!toc]\n\n**Description:** The directory shared by region servers and into which HBase persists. The URL should be 'fully-qualified' to include the filesystem scheme. For example, to specify the HDFS directory '/hbase' where the HDFS instance's namenode is running at namenode.example.org on port 9000, set this value to: hdfs\\://namenode.example.org:9000/hbase. By default, we write to whatever $\\{hbase.tmp.dir} is set too -- usually /tmp -- so change this configuration or else all data will be lost on machine restart.\\\n**Default:** `${hbase.tmp.dir}/hbase`\n\n#### `hbase.cluster.distributed` \\[!toc]\n\n**Description:** The mode the cluster will be in. Possible values are false for standalone mode and true for distributed mode. If false, startup will run all HBase and ZooKeeper daemons together in the one JVM.\\\n**Default:** `false`\n\n#### `hbase.zookeeper.quorum` \\[!toc]\n\n**Description:** Comma separated list of servers in the ZooKeeper ensemble (This config. should have been named hbase.zookeeper.ensemble). For example, \"host1.mydomain.com,host2.mydomain.com,host3.mydomain.com\". By default this is set to localhost for local and pseudo-distributed modes of operation. For a fully-distributed setup, this should be set to a full list of ZooKeeper ensemble servers. If HBASE\\_MANAGES\\_ZK is set in hbase-env.sh this is the list of servers which hbase will start/stop ZooKeeper on as part of cluster start/stop. Client-side, we will take this list of ensemble members and put it together with the hbase.zookeeper.property.clientPort config. and pass it into zookeeper constructor as the connectString parameter.\\\n**Default:** `127.0.0.1`\n\n#### `zookeeper.recovery.retry.maxsleeptime` \\[!toc]\n\n**Description:** Max sleep time before retry zookeeper operations in milliseconds, a max time is needed here so that sleep time won't grow unboundedly\\\n**Default:** `60000`\n\n#### `hbase.local.dir` \\[!toc]\n\n**Description:** Directory on the local filesystem to be used as a local storage.\\\n**Default:** `${hbase.tmp.dir}/local/`\n\n#### `hbase.master.port` \\[!toc]\n\n**Description:** The port the HBase Master should bind to.\\\n**Default:** `16000`\n\n#### `hbase.master.info.port` \\[!toc]\n\n**Description:** The port for the HBase Master web UI. Set to -1 if you do not want a UI instance run.\\\n**Default:** `16010`\n\n#### `hbase.master.info.bindAddress` \\[!toc]\n\n**Description:** The bind address for the HBase Master web UI\\\n**Default:** `0.0.0.0`\n\n#### `hbase.master.logcleaner.plugins` \\[!toc]\n\n**Description:** A comma-separated list of BaseLogCleanerDelegate invoked by the LogsCleaner service. These WAL cleaners are called in order, so put the cleaner that prunes the most files in front. To implement your own BaseLogCleanerDelegate, just put it in HBase's classpath and add the fully qualified class name here. Always add the above default log cleaners in the list.\\\n**Default:** `org.apache.hadoop.hbase.master.cleaner.TimeToLiveLogCleaner,org.apache.hadoop.hbase.master.cleaner.TimeToLiveProcedureWALCleaner,org.apache.hadoop.hbase.master.cleaner.TimeToLiveMasterLocalStoreWALCleaner`\n\n#### `hbase.master.logcleaner.ttl` \\[!toc]\n\n**Description:** How long a WAL remain in the archive (\\{hbase.rootdir}/oldWALs) directory, after which it will be cleaned by a Master thread. The value is in milliseconds.\\\n**Default:** `600000`\n\n#### `hbase.master.hfilecleaner.plugins` \\[!toc]\n\n**Description:** A comma-separated list of BaseHFileCleanerDelegate invoked by the HFileCleaner service. These HFiles cleaners are called in order, so put the cleaner that prunes the most files in front. To implement your own BaseHFileCleanerDelegate, just put it in HBase's classpath and add the fully qualified class name here. Always add the above default hfile cleaners in the list as they will be overwritten in hbase-site.xml.\\\n**Default:** `org.apache.hadoop.hbase.master.cleaner.TimeToLiveHFileCleaner,org.apache.hadoop.hbase.master.cleaner.TimeToLiveMasterLocalStoreHFileCleaner`\n\n#### `hbase.master.infoserver.redirect` \\[!toc]\n\n**Description:** Whether or not the Master listens to the Master web UI port (hbase.master.info.port) and redirects requests to the web UI server shared by the Master and RegionServer. Config. makes sense when Master is serving Regions (not the default).\\\n**Default:** `true`\n\n#### `hbase.master.fileSplitTimeout` \\[!toc]\n\n**Description:** Splitting a region, how long to wait on the file-splitting step before aborting the attempt. Default: 600000. This setting used to be known as hbase.regionserver.fileSplitTimeout in hbase-1.x. Split is now run master-side hence the rename (If a 'hbase.master.fileSplitTimeout' setting found, will use it to prime the current 'hbase.master.fileSplitTimeout' Configuration.\\\n**Default:** `600000`\n\n#### `hbase.regionserver.port` \\[!toc]\n\n**Description:** The port the HBase RegionServer binds to.\\\n**Default:** `16020`\n\n#### `hbase.regionserver.info.port` \\[!toc]\n\n**Description:** The port for the HBase RegionServer web UI Set to -1 if you do not want the RegionServer UI to run.\\\n**Default:** `16030`\n\n#### `hbase.regionserver.info.bindAddress` \\[!toc]\n\n**Description:** The address for the HBase RegionServer web UI\\\n**Default:** `0.0.0.0`\n\n#### `hbase.regionserver.info.port.auto` \\[!toc]\n\n**Description:** Whether or not the Master or RegionServer UI should search for a port to bind to. Enables automatic port search if hbase.regionserver.info.port is already in use. Useful for testing, turned off by default.\\\n**Default:** `false`\n\n#### `hbase.regionserver.handler.count` \\[!toc]\n\n**Description:** Count of RPC Listener instances spun up on RegionServers. Same property is used by the Master for count of master handlers. Too many handlers can be counter-productive. Make it a multiple of CPU count. If mostly read-only, handlers count close to cpu count does well. Start with twice the CPU count and tune from there.\\\n**Default:** `30`\n\n#### `hbase.ipc.server.callqueue.handler.factor` \\[!toc]\n\n**Description:** Factor to determine the number of call queues. A value of 0 means a single queue shared between all the handlers. A value of 1 means that each handler has its own queue.\\\n**Default:** `0.1`\n\n#### `hbase.ipc.server.callqueue.read.ratio` \\[!toc]\n\n**Description:** Split the call queues into read and write queues. The specified interval (which should be between 0.0 and 1.0) will be multiplied by the number of call queues. A value of 0 indicate to not split the call queues, meaning that both read and write requests will be pushed to the same set of queues. A value lower than 0.5 means that there will be less read queues than write queues. A value of 0.5 means there will be the same number of read and write queues. A value greater than 0.5 means that there will be more read queues than write queues. A value of 1.0 means that all the queues except one are used to dispatch read requests. Example: Given the total number of call queues being 10 a read.ratio of 0 means that: the 10 queues will contain both read/write requests. a read.ratio of 0.3 means that: 3 queues will contain only read requests and 7 queues will contain only write requests. a read.ratio of 0.5 means that: 5 queues will contain only read requests and 5 queues will contain only write requests. a read.ratio of 0.8 means that: 8 queues will contain only read requests and 2 queues will contain only write requests. a read.ratio of 1 means that: 9 queues will contain only read requests and 1 queues will contain only write requests.\\\n**Default:** `0`\n\n#### `hbase.ipc.server.callqueue.scan.ratio` \\[!toc]\n\n**Description:** Given the number of read call queues, calculated from the total number of call queues multiplied by the callqueue.read.ratio, the scan.ratio property will split the read call queues into small-read and long-read queues. A value lower than 0.5 means that there will be less long-read queues than short-read queues. A value of 0.5 means that there will be the same number of short-read and long-read queues. A value greater than 0.5 means that there will be more long-read queues than short-read queues A value of 0 or 1 indicate to use the same set of queues for gets and scans. Example: Given the total number of read call queues being 8 a scan.ratio of 0 or 1 means that: 8 queues will contain both long and short read requests. a scan.ratio of 0.3 means that: 2 queues will contain only long-read requests and 6 queues will contain only short-read requests. a scan.ratio of 0.5 means that: 4 queues will contain only long-read requests and 4 queues will contain only short-read requests. a scan.ratio of 0.8 means that: 6 queues will contain only long-read requests and 2 queues will contain only short-read requests.\\\n**Default:** `0`\n\n#### `hbase.regionserver.msginterval` \\[!toc]\n\n**Description:** Interval between messages from the RegionServer to Master in milliseconds.\\\n**Default:** `3000`\n\n#### `hbase.regionserver.logroll.period` \\[!toc]\n\n**Description:** Period at which we will roll the commit log regardless of how many edits it has.\\\n**Default:** `3600000`\n\n#### `hbase.regionserver.logroll.errors.tolerated` \\[!toc]\n\n**Description:** The number of consecutive WAL close errors we will allow before triggering a server abort. A setting of 0 will cause the region server to abort if closing the current WAL writer fails during log rolling. Even a small value (2 or 3) will allow a region server to ride over transient HDFS errors.\\\n**Default:** `2`\n\n#### `hbase.regionserver.free.heap.min.memory.size` \\[!toc]\n\n**Description:** Defines the minimum amount of heap memory that must remain free for the RegionServer to start, specified in bytes or human-readable formats like '512m' for megabytes or '4g' for gigabytes. If not set, the default is 20% of the total heap size. To disable the check entirely, set this value to 0. If the combined memory usage of memstore and block cache exceeds (total heap - this value), the RegionServer will fail to start.\\\n**Default:** `(empty)`\n\n#### `hbase.regionserver.global.memstore.size` \\[!toc]\n\n**Description:** Maximum size of all memstores in a region server before new updates are blocked and flushes are forced. Defaults to 40% of heap (0.4). Updates are blocked and flushes are forced until size of all memstores in a region server hits hbase.regionserver.global.memstore.size.lower.limit. The default value in this configuration has been intentionally left empty in order to honor the old hbase.regionserver.global.memstore.upperLimit property if present.\\\n**Default:** `(empty)`\n\n#### `hbase.regionserver.global.memstore.size.lower.limit` \\[!toc]\n\n**Description:** Maximum size of all memstores in a region server before flushes are forced. Defaults to 95% of hbase.regionserver.global.memstore.size (0.95). A 100% value for this value causes the minimum possible flushing to occur when updates are blocked due to memstore limiting. The default value in this configuration has been intentionally left empty in order to honor the old hbase.regionserver.global.memstore.lowerLimit property if present.\\\n**Default:** `(empty)`\n\n#### `hbase.systemtables.compacting.memstore.type` \\[!toc]\n\n**Description:** Determines the type of memstore to be used for system tables like META, namespace tables etc. By default NONE is the type and hence we use the default memstore for all the system tables. If we need to use compacting memstore for system tables then set this property to BASIC/EAGER\\\n**Default:** `NONE`\n\n#### `hbase.regionserver.optionalcacheflushinterval` \\[!toc]\n\n**Description:** Maximum amount of time an edit lives in memory before being automatically flushed. Default 1 hour. Set it to 0 to disable automatic flushing.\\\n**Default:** `3600000`\n\n#### `hbase.regionserver.dns.interface` \\[!toc]\n\n**Description:** The name of the Network Interface from which a region server should report its IP address.\\\n**Default:** `default`\n\n#### `hbase.regionserver.dns.nameserver` \\[!toc]\n\n**Description:** The host name or IP address of the name server (DNS) which a region server should use to determine the host name used by the master for communication and display purposes.\\\n**Default:** `default`\n\n#### `hbase.regionserver.region.split.policy` \\[!toc]\n\n**Description:** A split policy determines when a region should be split. The various other split policies that are available currently are BusyRegionSplitPolicy, ConstantSizeRegionSplitPolicy, DisabledRegionSplitPolicy, DelimitedKeyPrefixRegionSplitPolicy, KeyPrefixRegionSplitPolicy, and SteppingSplitPolicy. DisabledRegionSplitPolicy blocks manual region splitting.\\\n**Default:** `org.apache.hadoop.hbase.regionserver.SteppingSplitPolicy`\n\n#### `hbase.regionserver.regionSplitLimit` \\[!toc]\n\n**Description:** Limit for the number of regions after which no more region splitting should take place. This is not hard limit for the number of regions but acts as a guideline for the regionserver to stop splitting after a certain limit. Default is set to 1000.\\\n**Default:** `1000`\n\n#### `zookeeper.session.timeout` \\[!toc]\n\n**Description:** ZooKeeper session timeout in milliseconds. It is used in two different ways. First, this value is used in the ZK client that HBase uses to connect to the ensemble. It is also used by HBase when it starts a ZK server and it is passed as the 'maxSessionTimeout'. See [https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch\\_zkSessions](https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkSessions). For example, if an HBase region server connects to a ZK ensemble that's also managed by HBase, then the session timeout will be the one specified by this configuration. But, a region server that connects to an ensemble managed with a different configuration will be subjected that ensemble's maxSessionTimeout. So, even though HBase might propose using 90 seconds, the ensemble can have a max timeout lower than this and it will take precedence. The current default maxSessionTimeout that ZK ships with is 40 seconds, which is lower than HBase's.\\\n**Default:** `90000`\n\n#### `zookeeper.znode.parent` \\[!toc]\n\n**Description:** Root ZNode for HBase in ZooKeeper. All of HBase's ZooKeeper files that are configured with a relative path will go under this node. By default, all of HBase's ZooKeeper file paths are configured with a relative path, so they will all go under this directory unless changed.\\\n**Default:** `/hbase`\n\n#### `zookeeper.znode.acl.parent` \\[!toc]\n\n**Description:** Root ZNode for access control lists.\\\n**Default:** `acl`\n\n#### `hbase.zookeeper.dns.interface` \\[!toc]\n\n**Description:** The name of the Network Interface from which a ZooKeeper server should report its IP address.\\\n**Default:** `default`\n\n#### `hbase.zookeeper.dns.nameserver` \\[!toc]\n\n**Description:** The host name or IP address of the name server (DNS) which a ZooKeeper server should use to determine the host name used by the master for communication and display purposes.\\\n**Default:** `default`\n\n#### `hbase.zookeeper.peerport` \\[!toc]\n\n**Description:** Port used by ZooKeeper peers to talk to each other. See [https://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html#sc\\_RunningReplicatedZooKeeper](https://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html#sc_RunningReplicatedZooKeeper) for more information.\\\n**Default:** `2888`\n\n#### `hbase.zookeeper.leaderport` \\[!toc]\n\n**Description:** Port used by ZooKeeper for leader election. See [https://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html#sc\\_RunningReplicatedZooKeeper](https://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html#sc_RunningReplicatedZooKeeper) for more information.\\\n**Default:** `3888`\n\n#### `hbase.zookeeper.property.initLimit` \\[!toc]\n\n**Description:**\\\n**Default:** `10`\n\n#### `hbase.zookeeper.property.initLimit` \\[!toc]\n\n**Description:** Property from ZooKeeper's config zoo.cfg. The number of ticks that the initial synchronization phase can take.\\\n**Default:** `10`\n\n#### `hbase.zookeeper.property.syncLimit` \\[!toc]\n\n**Description:** Property from ZooKeeper's config zoo.cfg. The number of ticks that can pass between sending a request and getting an acknowledgment.\\\n**Default:** `5`\n\n#### `hbase.zookeeper.property.dataDir` \\[!toc]\n\n**Description:** Property from ZooKeeper's config zoo.cfg. The directory where the snapshot is stored.\\\n**Default:** `${hbase.tmp.dir}/zookeeper`\n\n#### `hbase.zookeeper.property.clientPort` \\[!toc]\n\n**Description:** Property from ZooKeeper's config zoo.cfg. The port at which the clients will connect.\\\n**Default:** `2181`\n\n#### `hbase.zookeeper.property.maxClientCnxns` \\[!toc]\n\n**Description:** Property from ZooKeeper's config zoo.cfg. Limit on number of concurrent connections (at the socket level) that a single client, identified by IP address, may make to a single member of the ZooKeeper ensemble. Set high to avoid zk connection issues running standalone and pseudo-distributed.\\\n**Default:** `300`\n\n#### `hbase.client.write.buffer` \\[!toc]\n\n**Description:** Default size of the BufferedMutator write buffer in bytes. A bigger buffer takes more memory -- on both the client and server side since server instantiates the passed write buffer to process it -- but a larger buffer size reduces the number of RPCs made. For an estimate of server-side memory-used, evaluate hbase.client.write.buffer \\* hbase.regionserver.handler.count\\\n**Default:** `2097152`\n\n#### `hbase.client.pause` \\[!toc]\n\n**Description:** General client pause value. Used mostly as value to wait before running a retry of a failed get, region lookup, etc. See hbase.client.retries.number for description of how we backoff from this initial pause amount and how this pause works w/ retries.\\\n**Default:** `100`\n\n#### `hbase.client.pause.server.overloaded` \\[!toc]\n\n**Description:** Pause time when encountering an exception indicating a server is overloaded, CallQueueTooBigException or CallDroppedException. Set this property to a higher value than hbase.client.pause if you observe frequent CallQueueTooBigException or CallDroppedException from the same RegionServer and the call queue there keeps filling up. This config used to be called hbase.client.pause.cqtbe, which has been deprecated as of 2.5.0.\\\n**Default:** `(empty)`\n\n#### `hbase.client.retries.number` \\[!toc]\n\n**Description:** Maximum retries. Used as maximum for all retryable operations such as the getting of a cell's value, starting a row update, etc. Retry interval is a rough function based on hbase.client.pause. At first we retry at this interval but then with backoff, we pretty quickly reach retrying every ten seconds. See HConstants#RETRY\\_BACKOFF for how the backup ramps up. Change this setting and hbase.client.pause to suit your workload.\\\n**Default:** `15`\n\n#### `hbase.client.max.total.tasks` \\[!toc]\n\n**Description:** The maximum number of concurrent mutation tasks a single HTable instance will send to the cluster.\\\n**Default:** `100`\n\n#### `hbase.client.max.perserver.tasks` \\[!toc]\n\n**Description:** The maximum number of concurrent mutation tasks a single HTable instance will send to a single region server.\\\n**Default:** `2`\n\n#### `hbase.client.max.perregion.tasks` \\[!toc]\n\n**Description:** The maximum number of concurrent mutation tasks the client will maintain to a single Region. That is, if there is already hbase.client.max.perregion.tasks writes in progress for this region, new puts won't be sent to this region until some writes finishes.\\\n**Default:** `1`\n\n#### `hbase.client.perserver.requests.threshold` \\[!toc]\n\n**Description:** The max number of concurrent pending requests for one server in all client threads (process level). Exceeding requests will be thrown ServerTooBusyException immediately to prevent user's threads being occupied and blocked by only one slow region server. If you use a fix number of threads to access HBase in a synchronous way, set this to a suitable value which is related to the number of threads will help you. See [https://issues.apache.org/jira/browse/HBASE-16388](https://issues.apache.org/jira/browse/HBASE-16388) for details.\\\n**Default:** `2147483647`\n\n#### `hbase.client.scanner.caching` \\[!toc]\n\n**Description:** Number of rows that we try to fetch when calling next on a scanner if it is not served from (local, client) memory. This configuration works together with hbase.client.scanner.max.result.size to try and use the network efficiently. The default value is Integer.MAX\\_VALUE by default so that the network will fill the chunk size defined by hbase.client.scanner.max.result.size rather than be limited by a particular number of rows since the size of rows varies table to table. If you know ahead of time that you will not require more than a certain number of rows from a scan, this configuration should be set to that row limit via Scan#setCaching. Higher caching values will enable faster scanners but will eat up more memory and some calls of next may take longer and longer times when the cache is empty. Do not set this value such that the time between invocations is greater than the scanner timeout; i.e. hbase.client.scanner.timeout.period\\\n**Default:** `2147483647`\n\n#### `hbase.client.keyvalue.maxsize` \\[!toc]\n\n**Description:** Specifies the combined maximum allowed size of a KeyValue instance. This is to set an upper boundary for a single entry saved in a storage file. Since they cannot be split it helps avoiding that a region cannot be split any further because the data is too large. It seems wise to set this to a fraction of the maximum region size. Setting it to zero or less disables the check.\\\n**Default:** `10485760`\n\n#### `hbase.server.keyvalue.maxsize` \\[!toc]\n\n**Description:** Maximum allowed size of an individual cell, inclusive of value and all key components. A value of 0 or less disables the check. The default value is 10MB. This is a safety setting to protect the server from OOM situations.\\\n**Default:** `10485760`\n\n#### `hbase.client.scanner.timeout.period` \\[!toc]\n\n**Description:** Client scanner lease period in milliseconds.\\\n**Default:** `60000`\n\n#### `hbase.client.localityCheck.threadPoolSize` \\[!toc]\n\n**Description:**\\\n**Default:** `2`\n\n#### `hbase.bulkload.retries.number` \\[!toc]\n\n**Description:** Maximum retries. This is maximum number of iterations to atomic bulk loads are attempted in the face of splitting operations 0 means never give up.\\\n**Default:** `10`\n\n#### `hbase.compaction.after.bulkload.enable` \\[!toc]\n\n**Description:** Request Compaction after bulkload immediately. If bulkload is continuous, the triggered compactions may increase load, bring about performance side effect.\\\n**Default:** `false`\n\n#### `hbase.master.balancer.maxRitPercent` \\[!toc]\n\n**Description:** The max percent of regions in transition when balancing. The default value is 1.0. So there are no balancer throttling. If set this config to 0.01, It means that there are at most 1% regions in transition when balancing. Then the cluster's availability is at least 99% when balancing.\\\n**Default:** `1.0`\n\n#### `hbase.balancer.period` \\[!toc]\n\n**Description:** Period at which the region balancer runs in the Master, in milliseconds.\\\n**Default:** `300000`\n\n#### `hbase.master.oldwals.dir.updater.period` \\[!toc]\n\n**Description:** Period at which the oldWALs directory size calculator/updater will run in the Master, in milliseconds.\\\n**Default:** `300000`\n\n#### `hbase.regions.slop` \\[!toc]\n\n**Description:** The load balancer can trigger for several reasons. This value controls one of those reasons. Run the balancer if any regionserver has a region count outside the range of average +/- (average \\* slop) regions. If the value of slop is negative, disable sloppiness checks. The balancer can still run for other reasons, but sloppiness will not be one of them. If the value of slop is 0, run the balancer if any server has a region count more than 1 from the average. If the value of slop is 100, run the balancer if any server has a region count greater than 101 times the average. The default value of this parameter is 0.2, which runs the balancer if any server has a region count less than 80% of the average, or greater than 120% of the average. Note that for the default StochasticLoadBalancer, this does not guarantee any balancing actions will be taken, but only that the balancer will attempt to run.\\\n**Default:** `0.2`\n\n#### `hbase.normalizer.period` \\[!toc]\n\n**Description:** Period at which the region normalizer runs in the Master, in milliseconds.\\\n**Default:** `300000`\n\n#### `hbase.normalizer.split.enabled` \\[!toc]\n\n**Description:** Whether to split a region as part of normalization.\\\n**Default:** `true`\n\n#### `hbase.normalizer.merge.enabled` \\[!toc]\n\n**Description:** Whether to merge a region as part of normalization.\\\n**Default:** `true`\n\n#### `hbase.normalizer.merge.min.region.count` \\[!toc]\n\n**Description:** The minimum number of regions in a table to consider it for merge normalization.\\\n**Default:** `3`\n\n#### `hbase.normalizer.merge.min_region_age.days` \\[!toc]\n\n**Description:** The minimum age for a region to be considered for a merge, in days.\\\n**Default:** `3`\n\n#### `hbase.normalizer.merge.min_region_size.mb` \\[!toc]\n\n**Description:** The minimum size for a region to be considered for a merge, in whole MBs.\\\n**Default:** `1`\n\n#### `hbase.normalizer.merge.merge_request_max_number_of_regions` \\[!toc]\n\n**Description:** The maximum number of region count in a merge request for merge normalization.\\\n**Default:** `100`\n\n#### `hbase.table.normalization.enabled` \\[!toc]\n\n**Description:** This config is used to set default behaviour of normalizer at table level. To override this at table level one can set NORMALIZATION\\_ENABLED at table descriptor level and that property will be honored\\\n**Default:** `false`\n\n#### `hbase.server.thread.wakefrequency` \\[!toc]\n\n**Description:** In master side, this config is the period used for FS related behaviors: checking if hdfs is out of safe mode, setting or checking hbase.version file, setting or checking hbase.id file. Using default value should be fine. In regionserver side, this config is used in several places: flushing check interval, compaction check interval, wal rolling check interval. Specially, admin can tune flushing and compaction check interval by hbase.regionserver.flush.check.period and hbase.regionserver.compaction.check.period. (in milliseconds)\\\n**Default:** `10000`\n\n#### `hbase.regionserver.flush.check.period` \\[!toc]\n\n**Description:** It determines the flushing check period of PeriodicFlusher in regionserver. If unset, it uses hbase.server.thread.wakefrequency as default value. (in milliseconds)\\\n**Default:** `${hbase.server.thread.wakefrequency}`\n\n#### `hbase.regionserver.compaction.check.period` \\[!toc]\n\n**Description:** It determines the compaction check period of CompactionChecker in regionserver. If unset, it uses hbase.server.thread.wakefrequency as default value. (in milliseconds)\\\n**Default:** `${hbase.server.thread.wakefrequency}`\n\n#### `hbase.server.versionfile.writeattempts` \\[!toc]\n\n**Description:** How many times to retry attempting to write a version file before just aborting. Each attempt is separated by the hbase.server.thread.wakefrequency milliseconds.\\\n**Default:** `3`\n\n#### `hbase.hregion.memstore.flush.size` \\[!toc]\n\n**Description:** Memstore will be flushed to disk if size of the memstore exceeds this number of bytes. Value is checked by a thread that runs every hbase.server.thread.wakefrequency.\\\n**Default:** `134217728`\n\n#### `hbase.hregion.percolumnfamilyflush.size.lower.bound.min` \\[!toc]\n\n**Description:** If FlushLargeStoresPolicy is used and there are multiple column families, then every time that we hit the total memstore limit, we find out all the column families whose memstores exceed a \"lower bound\" and only flush them while retaining the others in memory. The \"lower bound\" will be \"hbase.hregion.memstore.flush.size / column\\_family\\_number\" by default unless value of this property is larger than that. If none of the families have their memstore size more than lower bound, all the memstores will be flushed (just as usual).\\\n**Default:** `16777216`\n\n#### `hbase.hregion.preclose.flush.size` \\[!toc]\n\n**Description:** If the memstores in a region are this size or larger when we go to close, run a \"pre-flush\" to clear out memstores before we put up the region closed flag and take the region offline. On close, a flush is run under the close flag to empty memory. During this time the region is offline and we are not taking on any writes. If the memstore content is large, this flush could take a long time to complete. The preflush is meant to clean out the bulk of the memstore before putting up the close flag and taking the region offline so the flush that runs under the close flag has little to do.\\\n**Default:** `5242880`\n\n#### `hbase.hregion.memstore.block.multiplier` \\[!toc]\n\n**Description:** Block updates if memstore has hbase.hregion.memstore.block.multiplier times hbase.hregion.memstore.flush.size bytes. Useful preventing runaway memstore during spikes in update traffic. Without an upper-bound, memstore fills such that when it flushes the resultant flush files take a long time to compact or split, or worse, we OOME.\\\n**Default:** `4`\n\n#### `hbase.hregion.memstore.mslab.enabled` \\[!toc]\n\n**Description:** Enables the MemStore-Local Allocation Buffer, a feature which works to prevent heap fragmentation under heavy write loads. This can reduce the frequency of stop-the-world GC pauses on large heaps.\\\n**Default:** `true`\n\n#### `hbase.hregion.memstore.mslab.chunksize` \\[!toc]\n\n**Description:** The maximum byte size of a chunk in the MemStoreLAB. Unit: bytes\\\n**Default:** `2097152`\n\n#### `hbase.regionserver.offheap.global.memstore.size` \\[!toc]\n\n**Description:** The amount of off-heap memory all MemStores in a RegionServer may use. A value of 0 means that no off-heap memory will be used and all chunks in MSLAB will be HeapByteBuffer, otherwise the non-zero value means how many megabyte of off-heap memory will be used for chunks in MSLAB and all chunks in MSLAB will be DirectByteBuffer. Unit: megabytes.\\\n**Default:** `0`\n\n#### `hbase.hregion.memstore.mslab.max.allocation` \\[!toc]\n\n**Description:** The maximal size of one allocation in the MemStoreLAB, if the desired byte size exceed this threshold then it will be just allocated from JVM heap rather than MemStoreLAB.\\\n**Default:** `262144`\n\n#### `hbase.hregion.max.filesize` \\[!toc]\n\n**Description:** Maximum file size. If the sum of the sizes of a region's HFiles has grown to exceed this value, the region is split in two. There are two choices of how this option works, the first is when any store's size exceed the threshold then split, and the other is overall region's size exceed the threshold then split, it can be configed by hbase.hregion.split.overallfiles.\\\n**Default:** `10737418240`\n\n#### `hbase.hregion.split.overallfiles` \\[!toc]\n\n**Description:** If we should sum overall region files size when check to split.\\\n**Default:** `true`\n\n#### `hbase.hregion.majorcompaction` \\[!toc]\n\n**Description:** Time between major compactions, expressed in milliseconds. Set to 0 to disable time-based automatic major compactions. User-requested and size-based major compactions will still run. This value is multiplied by hbase.hregion.majorcompaction.jitter to cause compaction to start at a somewhat-random time during a given window of time. The default value is 7 days, expressed in milliseconds. If major compactions are causing disruption in your environment, you can configure them to run at off-peak times for your deployment, or disable time-based major compactions by setting this parameter to 0, and run major compactions in a cron job or by another external mechanism.\\\n**Default:** `604800000`\n\n#### `hbase.hregion.majorcompaction.jitter` \\[!toc]\n\n**Description:** A multiplier applied to hbase.hregion.majorcompaction to cause compaction to occur a given amount of time either side of hbase.hregion.majorcompaction. The smaller the number, the closer the compactions will happen to the hbase.hregion.majorcompaction interval.\\\n**Default:** `0.50`\n\n#### `hbase.hstore.compactionThreshold` \\[!toc]\n\n**Description:** If more than or equal to this number of StoreFiles exist in any one Store (one StoreFile is written per flush of MemStore), a compaction is run to rewrite all StoreFiles into a single StoreFile. Larger values delay compaction, but when compaction does occur, it takes longer to complete.\\\n**Default:** `3`\n\n#### `hbase.regionserver.compaction.enabled` \\[!toc]\n\n**Description:** Enable/disable compactions on by setting true/false. We can further switch compactions dynamically with the compaction\\_switch shell command.\\\n**Default:** `true`\n\n#### `hbase.hstore.flusher.count` \\[!toc]\n\n**Description:** The number of flush threads. With fewer threads, the MemStore flushes will be queued. With more threads, the flushes will be executed in parallel, increasing the load on HDFS, and potentially causing more compactions.\\\n**Default:** `2`\n\n#### `hbase.hstore.blockingStoreFiles` \\[!toc]\n\n**Description:** If more than this number of StoreFiles exist in any one Store (one StoreFile is written per flush of MemStore), updates are blocked for this region until a compaction is completed, or until hbase.hstore.blockingWaitTime has been exceeded.\\\n**Default:** `16`\n\n#### `hbase.hstore.blockingWaitTime` \\[!toc]\n\n**Description:** The time for which a region will block updates after reaching the StoreFile limit defined by hbase.hstore.blockingStoreFiles. After this time has elapsed, the region will stop blocking updates even if a compaction has not been completed.\\\n**Default:** `90000`\n\n#### `hbase.hstore.compaction.min` \\[!toc]\n\n**Description:** The minimum number of StoreFiles which must be eligible for compaction before compaction can run. The goal of tuning hbase.hstore.compaction.min is to avoid ending up with too many tiny StoreFiles to compact. Setting this value to 2 would cause a minor compaction each time you have two StoreFiles in a Store, and this is probably not appropriate. If you set this value too high, all the other values will need to be adjusted accordingly. For most cases, the default value is appropriate (empty value here, results in 3 by code logic). In previous versions of HBase, the parameter hbase.hstore.compaction.min was named hbase.hstore.compactionThreshold.\\\n**Default:** `(empty)`\n\n#### `hbase.hstore.compaction.max` \\[!toc]\n\n**Description:** The maximum number of StoreFiles which will be selected for a single minor compaction, regardless of the number of eligible StoreFiles. Effectively, the value of hbase.hstore.compaction.max controls the length of time it takes a single compaction to complete. Setting it larger means that more StoreFiles are included in a compaction. For most cases, the default value is appropriate.\\\n**Default:** `10`\n\n#### `hbase.hstore.compaction.min.size` \\[!toc]\n\n**Description:** A StoreFile (or a selection of StoreFiles, when using ExploringCompactionPolicy) smaller than this size will always be eligible for minor compaction. HFiles this size or larger are evaluated by hbase.hstore.compaction.ratio to determine if they are eligible. Because this limit represents the \"automatic include\" limit for all StoreFiles smaller than this value, this value may need to be reduced in write-heavy environments where many StoreFiles in the 1-2 MB range are being flushed, because every StoreFile will be targeted for compaction and the resulting StoreFiles may still be under the minimum size and require further compaction. If this parameter is lowered, the ratio check is triggered more quickly. This addressed some issues seen in earlier versions of HBase but changing this parameter is no longer necessary in most situations. Default: 128 MB expressed in bytes.\\\n**Default:** `134217728`\n\n#### `hbase.hstore.compaction.max.size` \\[!toc]\n\n**Description:** A StoreFile (or a selection of StoreFiles, when using ExploringCompactionPolicy) larger than this size will be excluded from compaction. The effect of raising hbase.hstore.compaction.max.size is fewer, larger StoreFiles that do not get compacted often. If you feel that compaction is happening too often without much benefit, you can try raising this value. Default: the value of LONG.MAX\\_VALUE, expressed in bytes.\\\n**Default:** `9223372036854775807`\n\n#### `hbase.hstore.compaction.ratio` \\[!toc]\n\n**Description:** For minor compaction, this ratio is used to determine whether a given StoreFile which is larger than hbase.hstore.compaction.min.size is eligible for compaction. Its effect is to limit compaction of large StoreFiles. The value of hbase.hstore.compaction.ratio is expressed as a floating-point decimal. A large ratio, such as 10, will produce a single giant StoreFile. Conversely, a low value, such as .25, will produce behavior similar to the BigTable compaction algorithm, producing four StoreFiles. A moderate value of between 1.0 and 1.4 is recommended. When tuning this value, you are balancing write costs with read costs. Raising the value (to something like 1.4) will have more write costs, because you will compact larger StoreFiles. However, during reads, HBase will need to seek through fewer StoreFiles to accomplish the read. Consider this approach if you cannot take advantage of Bloom filters. Otherwise, you can lower this value to something like 1.0 to reduce the background cost of writes, and use Bloom filters to control the number of StoreFiles touched during reads. For most cases, the default value is appropriate.\\\n**Default:** `1.2F`\n\n#### `hbase.hstore.compaction.ratio.offpeak` \\[!toc]\n\n**Description:** Allows you to set a different (by default, more aggressive) ratio for determining whether larger StoreFiles are included in compactions during off-peak hours. Works in the same way as hbase.hstore.compaction.ratio. Only applies if hbase.offpeak.start.hour and hbase.offpeak.end.hour are also enabled.\\\n**Default:** `5.0F`\n\n#### `hbase.hstore.time.to.purge.deletes` \\[!toc]\n\n**Description:** The amount of time to delay purging of delete markers with future timestamps. If unset, or set to 0, all delete markers, including those with future timestamps, are purged during the next major compaction. Otherwise, a delete marker is kept until the major compaction which occurs after the marker's timestamp plus the value of this setting, in milliseconds.\\\n**Default:** `0`\n\n#### `hbase.offpeak.start.hour` \\[!toc]\n\n**Description:** The start of off-peak hours, expressed as an integer between 0 and 23, inclusive. Set to -1 to disable off-peak.\\\n**Default:** `-1`\n\n#### `hbase.offpeak.end.hour` \\[!toc]\n\n**Description:** The end of off-peak hours, expressed as an integer between 0 and 23, inclusive. Set to -1 to disable off-peak.\\\n**Default:** `-1`\n\n#### `hbase.regionserver.thread.compaction.throttle` \\[!toc]\n\n**Description:** There are two different thread pools for compactions, one for large compactions and the other for small compactions. This helps to keep compaction of lean tables (such as hbase:meta) fast. If a compaction is larger than this threshold, it goes into the large compaction pool. In most cases, the default value is appropriate. Default: 2 x hbase.hstore.compaction.max x hbase.hregion.memstore.flush.size (which defaults to 128MB). The value field assumes that the value of hbase.hregion.memstore.flush.size is unchanged from the default.\\\n**Default:** `2684354560`\n\n#### `hbase.regionserver.majorcompaction.pagecache.drop` \\[!toc]\n\n**Description:** Specifies whether to drop pages read/written into the system page cache by major compactions. Setting it to true helps prevent major compactions from polluting the page cache, which is almost always required, especially for clusters with low/moderate memory to storage ratio.\\\n**Default:** `true`\n\n#### `hbase.regionserver.minorcompaction.pagecache.drop` \\[!toc]\n\n**Description:** Specifies whether to drop pages read/written into the system page cache by minor compactions. Setting it to true helps prevent minor compactions from polluting the page cache, which is most beneficial on clusters with low memory to storage ratio or very write heavy clusters. You may want to set it to false under moderate to low write workload when bulk of the reads are on the most recently written data.\\\n**Default:** `true`\n\n#### `hbase.hstore.compaction.kv.max` \\[!toc]\n\n**Description:** The maximum number of KeyValues to read and then write in a batch when flushing or compacting. Set this lower if you have big KeyValues and problems with Out Of Memory Exceptions Set this higher if you have wide, small rows.\\\n**Default:** `10`\n\n#### `hbase.storescanner.parallel.seek.enable` \\[!toc]\n\n**Description:** Enables StoreFileScanner parallel-seeking in StoreScanner, a feature which can reduce response latency under special conditions.\\\n**Default:** `false`\n\n#### `hbase.storescanner.parallel.seek.threads` \\[!toc]\n\n**Description:** The default thread pool size if parallel-seeking feature enabled.\\\n**Default:** `10`\n\n#### `hfile.block.cache.policy` \\[!toc]\n\n**Description:** The eviction policy for the L1 block cache (LRU or TinyLFU).\\\n**Default:** `LRU`\n\n#### `hfile.block.cache.size` \\[!toc]\n\n**Description:** Percentage of maximum heap (-Xmx setting) to allocate to block cache used by a StoreFile. Default of 0.4 means allocate 40%. Set to 0 to disable but it's not recommended; you need at least enough cache to hold the storefile indices.\\\n**Default:** `0.4`\n\n#### `hfile.block.cache.memory.size` \\[!toc]\n\n**Description:** Defines the maximum heap memory allocated for the HFile block cache, specified in bytes or human-readable formats like '10m' for megabytes or '10g' for gigabytes. This configuration allows setting an absolute memory size instead of a percentage of the maximum heap. Takes precedence over hfile.block.cache.size if both are specified.\\\n**Default:** `(empty)`\n\n#### `hfile.block.index.cacheonwrite` \\[!toc]\n\n**Description:** This allows to put non-root multi-level index blocks into the block cache at the time the index is being written.\\\n**Default:** `false`\n\n#### `hfile.index.block.max.size` \\[!toc]\n\n**Description:** When the size of a leaf-level, intermediate-level, or root-level index block in a multi-level block index grows to this size, the block is written out and a new block is started.\\\n**Default:** `131072`\n\n#### `hbase.bucketcache.ioengine` \\[!toc]\n\n**Description:** Where to store the contents of the bucketcache. One of: offheap, file, files, mmap or pmem. If a file or files, set it to file(s):PATH\\_TO\\_FILE. mmap means the content will be in an mmaped file. Use mmap:PATH\\_TO\\_FILE. 'pmem' is bucket cache over a file on the persistent memory device. Use pmem:PATH\\_TO\\_FILE. See [http://hbase.apache.org/book.html#offheap.blockcache](http://hbase.apache.org/book.html#offheap.blockcache) for more information.\\\n**Default:** `(empty)`\n\n#### `hbase.hstore.compaction.throughput.lower.bound` \\[!toc]\n\n**Description:** The target lower bound on aggregate compaction throughput, in bytes/sec. Allows you to tune the minimum available compaction throughput when the PressureAwareCompactionThroughputController throughput controller is active. (It is active by default.)\\\n**Default:** `52428800`\n\n#### `hbase.hstore.compaction.throughput.higher.bound` \\[!toc]\n\n**Description:** The target upper bound on aggregate compaction throughput, in bytes/sec. Allows you to control aggregate compaction throughput demand when the PressureAwareCompactionThroughputController throughput controller is active. (It is active by default.) The maximum throughput will be tuned between the lower and upper bounds when compaction pressure is within the range \\[0.0, 1.0]. If compaction pressure is 1.0 or greater the higher bound will be ignored until pressure returns to the normal range.\\\n**Default:** `104857600`\n\n#### `hbase.bucketcache.size` \\[!toc]\n\n**Description:** It is the total capacity in megabytes of BucketCache. Default: 0.0\\\n**Default:** `(empty)`\n\n#### `hbase.bucketcache.bucket.sizes` \\[!toc]\n\n**Description:** A comma-separated list of sizes for buckets for the bucketcache. Can be multiple sizes. List block sizes in order from smallest to largest. The sizes you use will depend on your data access patterns. Must be a multiple of 256 else you will run into 'java.io.IOException: Invalid HFile block magic' when you go to read from cache. If you specify no values here, then you pick up the default bucketsizes set in code (See BucketAllocator#DEFAULT\\_BUCKET\\_SIZES).\\\n**Default:** `(empty)`\n\n#### `hfile.format.version` \\[!toc]\n\n**Description:** The HFile format version to use for new files. Version 3 adds support for tags in hfiles (See [http://hbase.apache.org/book.html#hbase.tags](http://hbase.apache.org/book.html#hbase.tags)). Also see the configuration 'hbase.replication.rpc.codec'.\\\n**Default:** `3`\n\n#### `hfile.block.bloom.cacheonwrite` \\[!toc]\n\n**Description:** Enables cache-on-write for inline blocks of a compound Bloom filter.\\\n**Default:** `false`\n\n#### `io.storefile.bloom.block.size` \\[!toc]\n\n**Description:** The size in bytes of a single block (\"chunk\") of a compound Bloom filter. This size is approximate, because Bloom blocks can only be inserted at data block boundaries, and the number of keys per data block varies.\\\n**Default:** `131072`\n\n#### `hbase.rs.cacheblocksonwrite` \\[!toc]\n\n**Description:** Whether an HFile block should be added to the block cache when the block is finished.\\\n**Default:** `false`\n\n#### `hbase.rpc.timeout` \\[!toc]\n\n**Description:** This is for the RPC layer to define how long (millisecond) HBase client applications take for a remote call to time out. It uses pings to check connections but will eventually throw a TimeoutException.\\\n**Default:** `60000`\n\n#### `hbase.client.operation.timeout` \\[!toc]\n\n**Description:** Operation timeout is a top-level restriction (millisecond) that makes sure a blocking operation in Table will not be blocked more than this. In each operation, if rpc request fails because of timeout or other reason, it will retry until success or throw RetriesExhaustedException. But if the total time being blocking reach the operation timeout before retries exhausted, it will break early and throw SocketTimeoutException.\\\n**Default:** `1200000`\n\n#### `hbase.client.connection.metacache.invalidate-interval.ms` \\[!toc]\n\n**Description:** Interval in milliseconds of checking and invalidating meta cache when table disabled or dropped, when set to zero means disable checking, suggest set it to 24h or a higher value, because disable/delete table usually not very frequently.\\\n**Default:** `0`\n\n#### `hbase.cells.scanned.per.heartbeat.check` \\[!toc]\n\n**Description:** The number of cells scanned in between heartbeat checks. Heartbeat checks occur during the processing of scans to determine whether or not the server should stop scanning in order to send back a heartbeat message to the client. Heartbeat messages are used to keep the client-server connection alive during long running scans. Small values mean that the heartbeat checks will occur more often and thus will provide a tighter bound on the execution time of the scan. Larger values mean that the heartbeat checks occur less frequently\\\n**Default:** `10000`\n\n#### `hbase.rpc.shortoperation.timeout` \\[!toc]\n\n**Description:** This is another version of \"hbase.rpc.timeout\". For those RPC operation within cluster, we rely on this configuration to set a short timeout limitation for short operation. For example, short rpc timeout for region server's trying to report to active master can benefit quicker master failover process.\\\n**Default:** `10000`\n\n#### `hbase.ipc.client.tcpnodelay` \\[!toc]\n\n**Description:** Set no delay on rpc socket connections. See [http://docs.oracle.com/javase/1.5.0/docs/api/java/net/Socket.html#getTcpNoDelay()](http://docs.oracle.com/javase/1.5.0/docs/api/java/net/Socket.html#getTcpNoDelay\\(\\))\\\n**Default:** `true`\n\n#### `hbase.unsafe.regionserver.hostname` \\[!toc]\n\n**Description:** This config is for experts: don't set its value unless you really know what you are doing. When set to a non-empty value, this represents the (external facing) hostname for the underlying server. See [https://issues.apache.org/jira/browse/HBASE-12954](https://issues.apache.org/jira/browse/HBASE-12954) for details.\\\n**Default:** `(empty)`\n\n#### `hbase.unsafe.regionserver.hostname.disable.master.reversedns` \\[!toc]\n\n**Description:** This config is for experts: don't set its value unless you really know what you are doing. When set to true, regionserver will use the current node hostname for the servername and HMaster will skip reverse DNS lookup and use the hostname sent by regionserver instead. Note that this config and hbase.unsafe.regionserver.hostname are mutually exclusive. See [https://issues.apache.org/jira/browse/HBASE-18226](https://issues.apache.org/jira/browse/HBASE-18226) for more details.\\\n**Default:** `false`\n\n#### `hbase.master.keytab.file` \\[!toc]\n\n**Description:** Full path to the kerberos keytab file to use for logging in the configured HMaster server principal.\\\n**Default:** `(empty)`\n\n#### `hbase.master.kerberos.principal` \\[!toc]\n\n**Description:** Ex. \"hbase/\\_[HOST@EXAMPLE.COM](mailto:HOST@EXAMPLE.COM)\". The kerberos principal name that should be used to run the HMaster process. The principal name should be in the form: user/hostname\\@DOMAIN. If \"\\_HOST\" is used as the hostname portion, it will be replaced with the actual hostname of the running instance.\\\n**Default:** `(empty)`\n\n#### `hbase.regionserver.keytab.file` \\[!toc]\n\n**Description:** Full path to the kerberos keytab file to use for logging in the configured HRegionServer server principal.\\\n**Default:** `(empty)`\n\n#### `hbase.regionserver.kerberos.principal` \\[!toc]\n\n**Description:** Ex. \"hbase/\\_[HOST@EXAMPLE.COM](mailto:HOST@EXAMPLE.COM)\". The kerberos principal name that should be used to run the HRegionServer process. The principal name should be in the form: user/hostname\\@DOMAIN. If \"\\_HOST\" is used as the hostname portion, it will be replaced with the actual hostname of the running instance. An entry for this principal must exist in the file specified in hbase.regionserver.keytab.file\\\n**Default:** `(empty)`\n\n#### `hadoop.policy.file` \\[!toc]\n\n**Description:** The policy configuration file used by RPC servers to make authorization decisions on client requests. Only used when HBase security is enabled.\\\n**Default:** `hbase-policy.xml`\n\n#### `hbase.superuser` \\[!toc]\n\n**Description:** List of users or groups (comma-separated), who are allowed full privileges, regardless of stored ACLs, across the cluster. Only used when HBase security is enabled. Group names should be prefixed with \"@\".\\\n**Default:** `(empty)`\n\n#### `hbase.auth.key.update.interval` \\[!toc]\n\n**Description:** The update interval for master key for authentication tokens in servers in milliseconds. Only used when HBase security is enabled.\\\n**Default:** `86400000`\n\n#### `hbase.auth.token.max.lifetime` \\[!toc]\n\n**Description:** The maximum lifetime in milliseconds after which an authentication token expires. Only used when HBase security is enabled.\\\n**Default:** `604800000`\n\n#### `hbase.ipc.client.fallback-to-simple-auth-allowed` \\[!toc]\n\n**Description:** When a client is configured to attempt a secure connection, but attempts to connect to an insecure server, that server may instruct the client to switch to SASL SIMPLE (unsecure) authentication. This setting controls whether or not the client will accept this instruction from the server. When false (the default), the client will not allow the fallback to SIMPLE authentication, and will abort the connection.\\\n**Default:** `false`\n\n#### `hbase.ipc.server.fallback-to-simple-auth-allowed` \\[!toc]\n\n**Description:** When a server is configured to require secure connections, it will reject connection attempts from clients using SASL SIMPLE (unsecure) authentication. This setting allows secure servers to accept SASL SIMPLE connections from clients when the client requests. When false (the default), the server will not allow the fallback to SIMPLE authentication, and will reject the connection. WARNING: This setting should ONLY be used as a temporary measure while converting clients over to secure authentication. It MUST BE DISABLED for secure operation.\\\n**Default:** `false`\n\n#### `hbase.unsafe.client.kerberos.hostname.disable.reversedns` \\[!toc]\n\n**Description:** This config is for experts: don't set its value unless you really know what you are doing. When set to true, HBase client using SASL Kerberos will skip reverse DNS lookup and use provided hostname of the destination for the principal instead. See [https://issues.apache.org/jira/browse/HBASE-25665](https://issues.apache.org/jira/browse/HBASE-25665) for more details.\\\n**Default:** `false`\n\n#### `hbase.display.keys` \\[!toc]\n\n**Description:** When this is set to true the webUI and such will display all start/end keys as part of the table details, region names, etc. When this is set to false, the keys are hidden.\\\n**Default:** `true`\n\n#### `hbase.coprocessor.enabled` \\[!toc]\n\n**Description:** Enables or disables coprocessor loading. If 'false' (disabled), any other coprocessor related configuration will be ignored.\\\n**Default:** `true`\n\n#### `hbase.coprocessor.user.enabled` \\[!toc]\n\n**Description:** Enables or disables user (aka. table) coprocessor loading. If 'false' (disabled), any table coprocessor attributes in table descriptors will be ignored. If \"hbase.coprocessor.enabled\" is 'false' this setting has no effect.\\\n**Default:** `true`\n\n#### `hbase.coprocessor.region.classes` \\[!toc]\n\n**Description:** A comma-separated list of region observer or endpoint coprocessors that are loaded by default on all tables. For any override coprocessor method, these classes will be called in order. After implementing your own Coprocessor, add it to HBase's classpath and add the fully qualified class name here. A coprocessor can also be loaded on demand by setting HTableDescriptor or the HBase shell.\\\n**Default:** `(empty)`\n\n#### `hbase.coprocessor.master.classes` \\[!toc]\n\n**Description:** A comma-separated list of org.apache.hadoop.hbase.coprocessor.MasterObserver coprocessors that are loaded by default on the active HMaster process. For any implemented coprocessor methods, the listed classes will be called in order. After implementing your own MasterObserver, just put it in HBase's classpath and add the fully qualified class name here.\\\n**Default:** `(empty)`\n\n#### `hbase.coprocessor.abortonerror` \\[!toc]\n\n**Description:** Set to true to cause the hosting server (master or regionserver) to abort if a coprocessor fails to load, fails to initialize, or throws an unexpected Throwable object. Setting this to false will allow the server to continue execution but the system wide state of the coprocessor in question will become inconsistent as it will be properly executing in only a subset of servers, so this is most useful for debugging only.\\\n**Default:** `true`\n\n#### `hbase.rest.port` \\[!toc]\n\n**Description:** The port for the HBase REST server.\\\n**Default:** `8080`\n\n#### `hbase.rest.readonly` \\[!toc]\n\n**Description:** Defines the mode the REST server will be started in. Possible values are: false: All HTTP methods are permitted - GET/PUT/POST/DELETE. true: Only the GET method is permitted.\\\n**Default:** `false`\n\n#### `hbase.rest.threads.max` \\[!toc]\n\n**Description:** The maximum number of threads of the REST server thread pool. Threads in the pool are reused to process REST requests. This controls the maximum number of requests processed concurrently. It may help to control the memory used by the REST server to avoid OOM issues. If the thread pool is full, incoming requests will be queued up and wait for some free threads.\\\n**Default:** `100`\n\n#### `hbase.rest.threads.min` \\[!toc]\n\n**Description:** The minimum number of threads of the REST server thread pool. The thread pool always has at least these number of threads so the REST server is ready to serve incoming requests.\\\n**Default:** `2`\n\n#### `hbase.rest.support.proxyuser` \\[!toc]\n\n**Description:** Enables running the REST server to support proxy-user mode.\\\n**Default:** `false`\n\n#### `hbase.defaults.for.version.skip` \\[!toc]\n\n**Description:** Set to true to skip the 'hbase.defaults.for.version' check. Setting this to true can be useful in contexts other than the other side of a maven generation; i.e. running in an IDE. You'll want to set this boolean to true to avoid seeing the RuntimeException complaint: \"hbase-default.xml file seems to be for and old version of HBase ($\\{hbase.version}), this version is X.X.X-SNAPSHOT\"\\\n**Default:** `false`\n\n#### `hbase.table.lock.enable` \\[!toc]\n\n**Description:** Set to true to enable locking the table in zookeeper for schema change operations. Table locking from master prevents concurrent schema modifications to corrupt table state.\\\n**Default:** `true`\n\n#### `hbase.table.max.rowsize` \\[!toc]\n\n**Description:** Maximum size of single row in bytes (default is 1 Gb) for Get'ting or Scan'ning without in-row scan flag set. If row size exceeds this limit RowTooBigException is thrown to client.\\\n**Default:** `1073741824`\n\n#### `hbase.thrift.minWorkerThreads` \\[!toc]\n\n**Description:** The \"core size\" of the thread pool. New threads are created on every connection until this many threads are created.\\\n**Default:** `16`\n\n#### `hbase.thrift.maxWorkerThreads` \\[!toc]\n\n**Description:** The maximum size of the thread pool. When the pending request queue overflows, new threads are created until their number reaches this number. After that, the server starts dropping connections.\\\n**Default:** `1000`\n\n#### `hbase.thrift.maxQueuedRequests` \\[!toc]\n\n**Description:** The maximum number of pending Thrift connections waiting in the queue. If there are no idle threads in the pool, the server queues requests. Only when the queue overflows, new threads are added, up to hbase.thrift.maxQueuedRequests threads.\\\n**Default:** `1000`\n\n#### `hbase.regionserver.thrift.framed` \\[!toc]\n\n**Description:** Use Thrift TFramedTransport on the server side. This is the recommended transport for thrift servers and requires a similar setting on the client side. Changing this to false will select the default transport, vulnerable to DoS when malformed requests are issued due to THRIFT-601.\\\n**Default:** `false`\n\n#### `hbase.regionserver.thrift.framed.max_frame_size_in_mb` \\[!toc]\n\n**Description:** Default frame size when using framed transport, in MB\\\n**Default:** `2`\n\n#### `hbase.regionserver.thrift.compact` \\[!toc]\n\n**Description:** Use Thrift TCompactProtocol binary serialization protocol.\\\n**Default:** `false`\n\n#### `hbase.rootdir.perms` \\[!toc]\n\n**Description:** FS Permissions for the root data subdirectory in a secure (kerberos) setup. When master starts, it creates the rootdir with this permissions or sets the permissions if it does not match.\\\n**Default:** `700`\n\n#### `hbase.wal.dir.perms` \\[!toc]\n\n**Description:** FS Permissions for the root WAL directory in a secure(kerberos) setup. When master starts, it creates the WAL dir with this permissions or sets the permissions if it does not match.\\\n**Default:** `700`\n\n#### `hbase.data.umask.enable` \\[!toc]\n\n**Description:** Enable, if true, that file permissions should be assigned to the files written by the regionserver\\\n**Default:** `false`\n\n#### `hbase.data.umask` \\[!toc]\n\n**Description:** File permissions that should be used to write data files when hbase.data.umask.enable is true\\\n**Default:** `000`\n\n#### `hbase.snapshot.enabled` \\[!toc]\n\n**Description:** Set to true to allow snapshots to be taken / restored / cloned.\\\n**Default:** `true`\n\n#### `hbase.snapshot.restore.take.failsafe.snapshot` \\[!toc]\n\n**Description:** Set to true to take a snapshot before the restore operation. The snapshot taken will be used in case of failure, to restore the previous state. At the end of the restore operation this snapshot will be deleted\\\n**Default:** `true`\n\n#### `hbase.snapshot.restore.failsafe.name` \\[!toc]\n\n**Description:** Name of the failsafe snapshot taken by the restore operation. You can use the \\{snapshot.name}, \\{table.name} and \\{restore.timestamp} variables to create a name based on what you are restoring.\\\n**Default:** `hbase-failsafe-{snapshot.name}-{restore.timestamp}`\n\n#### `hbase.snapshot.working.dir` \\[!toc]\n\n**Description:** Location where the snapshotting process will occur. The location of the completed snapshots will not change, but the temporary directory where the snapshot process occurs will be set to this location. This can be a separate filesystem than the root directory, for performance increase purposes. See HBASE-21098 for more information\\\n**Default:** `(empty)`\n\n#### `hbase.server.compactchecker.interval.multiplier` \\[!toc]\n\n**Description:** The number that determines how often we scan to see if compaction is necessary. Normally, compactions are done after some events (such as memstore flush), but if region didn't receive a lot of writes for some time, or due to different compaction policies, it may be necessary to check it periodically. The interval between checks is hbase.server.compactchecker.interval.multiplier multiplied by hbase.server.thread.wakefrequency.\\\n**Default:** `1000`\n\n#### `hbase.lease.recovery.timeout` \\[!toc]\n\n**Description:** How long we wait on dfs lease recovery in total before giving up.\\\n**Default:** `900000`\n\n#### `hbase.lease.recovery.dfs.timeout` \\[!toc]\n\n**Description:** How long between dfs recover lease invocations. Should be larger than the sum of the time it takes for the namenode to issue a block recovery command as part of datanode; dfs.heartbeat.interval and the time it takes for the primary datanode, performing block recovery to timeout on a dead datanode; usually dfs.client.socket-timeout. See the end of HBASE-8389 for more.\\\n**Default:** `64000`\n\n#### `hbase.column.max.version` \\[!toc]\n\n**Description:** New column family descriptors will use this value as the default number of versions to keep.\\\n**Default:** `1`\n\n#### `dfs.client.read.shortcircuit` \\[!toc]\n\n**Description:** If set to true, this configuration parameter enables short-circuit local reads.\\\n**Default:** `(empty)`\n\n#### `dfs.domain.socket.path` \\[!toc]\n\n**Description:** This is a path to a UNIX domain socket that will be used for communication between the DataNode and local HDFS clients, if dfs.client.read.shortcircuit is set to true. If the string \"\\_PORT\" is present in this path, it will be replaced by the TCP port of the DataNode. Be careful about permissions for the directory that hosts the shared domain socket; dfsclient will complain if open to other users than the HBase user.\\\n**Default:** `(empty)`\n\n#### `hbase.dfs.client.read.shortcircuit.buffer.size` \\[!toc]\n\n**Description:** If the DFSClient configuration dfs.client.read.shortcircuit.buffer.size is unset, we will use what is configured here as the short circuit read default direct byte buffer size. DFSClient native default is 1MB; HBase keeps its HDFS files open so number of file blocks \\* 1MB soon starts to add up and threaten OOME because of a shortage of direct memory. So, we set it down from the default. Make it > the default hbase block size set in the HColumnDescriptor which is usually 64k.\\\n**Default:** `131072`\n\n#### `hbase.regionserver.checksum.verify` \\[!toc]\n\n**Description:** If set to true (the default), HBase verifies the checksums for hfile blocks. HBase writes checksums inline with the data when it writes out hfiles. HDFS (as of this writing) writes checksums to a separate file than the data file necessitating extra seeks. Setting this flag saves some on i/o. Checksum verification by HDFS will be internally disabled on hfile streams when this flag is set. If the hbase-checksum verification fails, we will switch back to using HDFS checksums (so do not disable HDFS checksums! And besides this feature applies to hfiles only, not to WALs). If this parameter is set to false, then hbase will not verify any checksums, instead it will depend on checksum verification being done in the HDFS client.\\\n**Default:** `true`\n\n#### `hbase.hstore.bytes.per.checksum` \\[!toc]\n\n**Description:** Number of bytes in a newly created checksum chunk for HBase-level checksums in hfile blocks.\\\n**Default:** `16384`\n\n#### `hbase.hstore.checksum.algorithm` \\[!toc]\n\n**Description:** Name of an algorithm that is used to compute checksums. Possible values are NULL, CRC32, CRC32C.\\\n**Default:** `CRC32C`\n\n#### `hbase.client.scanner.max.result.size` \\[!toc]\n\n**Description:** Maximum number of bytes returned when calling a scanner's next method. Note that when a single row is larger than this limit the row is still returned completely. The default value is 2MB, which is good for 1ge networks. With faster and/or high latency networks this value should be increased.\\\n**Default:** `2097152`\n\n#### `hbase.server.scanner.max.result.size` \\[!toc]\n\n**Description:** Maximum number of bytes returned when calling a scanner's next method. Note that when a single row is larger than this limit the row is still returned completely. The default value is 100MB. This is a safety setting to protect the server from OOM situations.\\\n**Default:** `104857600`\n\n#### `hbase.status.published` \\[!toc]\n\n**Description:** This setting activates the publication by the master of the status of the region server. When a region server dies and its recovery starts, the master will push this information to the client application, to let them cut the connection immediately instead of waiting for a timeout.\\\n**Default:** `false`\n\n#### `hbase.status.publisher.class` \\[!toc]\n\n**Description:** Implementation of the status publication with a multicast message.\\\n**Default:** `org.apache.hadoop.hbase.master.ClusterStatusPublisher$MulticastPublisher`\n\n#### `hbase.status.listener.class` \\[!toc]\n\n**Description:** Implementation of the status listener with a multicast message.\\\n**Default:** `org.apache.hadoop.hbase.client.ClusterStatusListener$MulticastListener`\n\n#### `hbase.status.multicast.address.ip` \\[!toc]\n\n**Description:** Multicast address to use for the status publication by multicast.\\\n**Default:** `226.1.1.3`\n\n#### `hbase.status.multicast.address.port` \\[!toc]\n\n**Description:** Multicast port to use for the status publication by multicast.\\\n**Default:** `16100`\n\n#### `hbase.dynamic.jars.dir` \\[!toc]\n\n**Description:** The directory from which the custom filter JARs can be loaded dynamically by the region server without the need to restart. However, an already loaded filter/co-processor class would not be un-loaded. See HBASE-1936 for more details. Does not apply to coprocessors.\\\n**Default:** `${hbase.rootdir}/lib`\n\n#### `hbase.security.authentication` \\[!toc]\n\n**Description:** Controls whether or not secure authentication is enabled for HBase. Possible values are 'simple' (no authentication), and 'kerberos'.\\\n**Default:** `simple`\n\n#### `hbase.rest.filter.classes` \\[!toc]\n\n**Description:** Servlet filters for REST service.\\\n**Default:** `org.apache.hadoop.hbase.rest.filter.GzipFilter`\n\n#### `hbase.master.loadbalancer.class` \\[!toc]\n\n**Description:** Class used to execute the regions balancing when the period occurs. See the class comment for more on how it works [http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/balancer/StochasticLoadBalancer.html](http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/balancer/StochasticLoadBalancer.html) It replaces the DefaultLoadBalancer as the default (since renamed as the SimpleLoadBalancer).\\\n**Default:** `org.apache.hadoop.hbase.master.balancer.StochasticLoadBalancer`\n\n#### `hbase.master.loadbalance.bytable` \\[!toc]\n\n**Description:** Factor Table name when the balancer runs. Default: false.\\\n**Default:** `false`\n\n#### `hbase.master.normalizer.class` \\[!toc]\n\n**Description:** Class used to execute the region normalization when the period occurs. See the class comment for more on how it works [http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.html](http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.html)\\\n**Default:** `org.apache.hadoop.hbase.master.normalizer.SimpleRegionNormalizer`\n\n#### `hbase.rest.csrf.enabled` \\[!toc]\n\n**Description:** Set to true to enable protection against cross-site request forgery (CSRF)\\\n**Default:** `false`\n\n#### `hbase.rest-csrf.browser-useragents-regex` \\[!toc]\n\n**Description:** A comma-separated list of regular expressions used to match against an HTTP request's User-Agent header when protection against cross-site request forgery (CSRF) is enabled for REST server by setting hbase.rest.csrf.enabled to true. If the incoming User-Agent matches any of these regular expressions, then the request is considered to be sent by a browser, and therefore CSRF prevention is enforced. If the request's User-Agent does not match any of these regular expressions, then the request is considered to be sent by something other than a browser, such as scripted automation. In this case, CSRF is not a potential attack vector, so the prevention is not enforced. This helps achieve backwards-compatibility with existing automation that has not been updated to send the CSRF prevention header.\\\n**Default:** `^Mozilla.*,^Opera.*`\n\n#### `hbase.security.exec.permission.checks` \\[!toc]\n\n**Description:** If this setting is enabled and ACL based access control is active (the AccessController coprocessor is installed either as a system coprocessor or on a table as a table coprocessor) then you must grant all relevant users EXEC privilege if they require the ability to execute coprocessor endpoint calls. EXEC privilege, like any other permission, can be granted globally to a user, or to a user on a per table or per namespace basis. For more information on coprocessor endpoints, see the coprocessor section of the HBase online manual. For more information on granting or revoking permissions using the AccessController, see the security section of the HBase online manual.\\\n**Default:** `false`\n\n#### `hbase.procedure.regionserver.classes` \\[!toc]\n\n**Description:** A comma-separated list of org.apache.hadoop.hbase.procedure.RegionServerProcedureManager procedure managers that are loaded by default on the active HRegionServer process. The lifecycle methods (init/start/stop) will be called by the active HRegionServer process to perform the specific globally barriered procedure. After implementing your own RegionServerProcedureManager, just put it in HBase's classpath and add the fully qualified class name here.\\\n**Default:** `(empty)`\n\n#### `hbase.procedure.master.classes` \\[!toc]\n\n**Description:** A comma-separated list of org.apache.hadoop.hbase.procedure.MasterProcedureManager procedure managers that are loaded by default on the active HMaster process. A procedure is identified by its signature and users can use the signature and an instant name to trigger an execution of a globally barriered procedure. After implementing your own MasterProcedureManager, just put it in HBase's classpath and add the fully qualified class name here.\\\n**Default:** `(empty)`\n\n#### `hbase.coordinated.state.manager.class` \\[!toc]\n\n**Description:** Fully qualified name of class implementing coordinated state manager.\\\n**Default:** `org.apache.hadoop.hbase.coordination.ZkCoordinatedStateManager`\n\n#### `hbase.regionserver.storefile.refresh.period` \\[!toc]\n\n**Description:** The period (in milliseconds) for refreshing the store files for the secondary regions. 0 means this feature is disabled. Secondary regions sees new files (from flushes and compactions) from primary once the secondary region refreshes the list of files in the region (there is no notification mechanism). But too frequent refreshes might cause extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger value is also recommended with this setting.\\\n**Default:** `0`\n\n#### `hbase.region.replica.replication.enabled` \\[!toc]\n\n**Description:** Whether asynchronous WAL replication to the secondary region replicas is enabled or not. We have a separated implementation for replicating the WAL without using the general inter-cluster replication framework, so now we will not add any replication peers.\\\n**Default:** `false`\n\n#### `hbase.http.filter.initializers` \\[!toc]\n\n**Description:** A comma separated list of class names. Each class in the list must extend org.apache.hadoop.hbase.http.FilterInitializer. The corresponding Filter will be initialized. Then, the Filter will be applied to all user facing jsp and servlet web pages. The ordering of the list defines the ordering of the filters. The default StaticUserWebFilter add a user principal as defined by the hbase.http.staticuser.user property.\\\n**Default:** `org.apache.hadoop.hbase.http.lib.StaticUserWebFilter`\n\n#### `hbase.security.visibility.mutations.checkauths` \\[!toc]\n\n**Description:** This property if enabled, will check whether the labels in the visibility expression are associated with the user issuing the mutation\\\n**Default:** `false`\n\n#### `hbase.http.max.threads` \\[!toc]\n\n**Description:** The maximum number of threads that the HTTP Server will create in its ThreadPool.\\\n**Default:** `16`\n\n#### `hbase.http.metrics.servlets` \\[!toc]\n\n**Description:** Comma separated list of servlet names to enable for metrics collection. Supported servlets are jmx, metrics, prometheus\\\n**Default:** `jmx,metrics,prometheus`\n\n#### `hbase.replication.rpc.codec` \\[!toc]\n\n**Description:** The codec that is to be used when replication is enabled so that the tags are also replicated. This is used along with HFileV3 which supports tags in them. If tags are not used or if the hfile version used is HFileV2 then KeyValueCodec can be used as the replication codec. Note that using KeyValueCodecWithTags for replication when there are no tags causes no harm.\\\n**Default:** `org.apache.hadoop.hbase.codec.KeyValueCodecWithTags`\n\n#### `hbase.replication.source.maxthreads` \\[!toc]\n\n**Description:** The maximum number of threads any replication source will use for shipping edits to the sinks in parallel. This also limits the number of chunks each replication batch is broken into. Larger values can improve the replication throughput between the master and slave clusters. The default of 10 will rarely need to be changed.\\\n**Default:** `10`\n\n#### `hbase.http.staticuser.user` \\[!toc]\n\n**Description:** The user name to filter as, on static web filters while rendering content. An example use is the HDFS web UI (user to be used for browsing files).\\\n**Default:** `dr.stack`\n\n#### `hbase.regionserver.handler.abort.on.error.percent` \\[!toc]\n\n**Description:** The percent of region server RPC threads failed to abort RS. -1 Disable aborting; 0 Abort if even a single handler has died; 0.x Abort only when this percent of handlers have died; 1 Abort only all of the handers have died.\\\n**Default:** `0.5`\n\n#### `hbase.mob.file.cache.size` \\[!toc]\n\n**Description:** Number of opened file handlers to cache. A larger value will benefit reads by providing more file handlers per mob file cache and would reduce frequent file opening and closing. However, if this is set too high, this could lead to a \"too many opened file handlers\" The default value is 1000.\\\n**Default:** `1000`\n\n#### `hbase.mob.cache.evict.period` \\[!toc]\n\n**Description:** The amount of time in seconds before the mob cache evicts cached mob files. The default value is 3600 seconds.\\\n**Default:** `3600`\n\n#### `hbase.mob.cache.evict.remain.ratio` \\[!toc]\n\n**Description:** The ratio (between 0.0 and 1.0) of files that remains cached after an eviction is triggered when the number of cached mob files exceeds the hbase.mob.file.cache.size. The default value is 0.5f.\\\n**Default:** `0.5f`\n\n#### `hbase.master.mob.cleaner.period` \\[!toc]\n\n**Description:** The period that MobFileCleanerChore runs. The unit is second. The default value is one day. The MOB file name uses only the date part of the file creation time in it. We use this time for deciding TTL expiry of the files. So the removal of TTL expired files might be delayed. The max delay might be 24 hrs.\\\n**Default:** `86400`\n\n#### `hbase.mob.major.compaction.region.batch.size` \\[!toc]\n\n**Description:** The max number of a MOB table regions that is allowed in a batch of the mob compaction. By setting this number to a custom value, users can control the overall effect of a major compaction of a large MOB-enabled table. Default is 0 - means no limit - all regions of a MOB table will be compacted at once\\\n**Default:** `0`\n\n#### `hbase.mob.compaction.chore.period` \\[!toc]\n\n**Description:** The period that MobCompactionChore runs. The unit is second. The default value is one week.\\\n**Default:** `604800`\n\n#### `hbase.snapshot.master.timeout.millis` \\[!toc]\n\n**Description:** Timeout for master for the snapshot procedure execution.\\\n**Default:** `300000`\n\n#### `hbase.snapshot.region.timeout` \\[!toc]\n\n**Description:** Timeout for regionservers to keep threads in snapshot request pool waiting.\\\n**Default:** `300000`\n\n#### `hbase.rpc.rows.warning.threshold` \\[!toc]\n\n**Description:** Number of rows in a batch operation above which a warning will be logged. If hbase.client.write.buffer.maxmutations is not set, this will be used as fallback for that setting.\\\n**Default:** `5000`\n\n#### `hbase.master.wait.on.service.seconds` \\[!toc]\n\n**Description:** Default is 5 minutes. Make it 30 seconds for tests. See HBASE-19794 for some context.\\\n**Default:** `30`\n\n#### `hbase.master.cleaner.snapshot.interval` \\[!toc]\n\n**Description:** Snapshot Cleanup chore interval in milliseconds. The cleanup thread keeps running at this interval to find all snapshots that are expired based on TTL and delete them.\\\n**Default:** `1800000`\n\n#### `hbase.master.snapshot.ttl` \\[!toc]\n\n**Description:** Default Snapshot TTL to be considered when the user does not specify TTL while creating snapshot. Default value 0 indicates FOREVERE - snapshot should not be automatically deleted until it is manually deleted\\\n**Default:** `0`\n\n#### `hbase.master.regions.recovery.check.interval` \\[!toc]\n\n**Description:** Regions Recovery Chore interval in milliseconds. This chore keeps running at this interval to find all regions with configurable max store file ref count and reopens them.\\\n**Default:** `1200000`\n\n#### `hbase.regions.recovery.store.file.ref.count` \\[!toc]\n\n**Description:** Very large number of ref count on a compacted store file indicates that it is a ref leak on that object(compacted store file). Such files can not be removed after it is invalidated via compaction. Only way to recover in such scenario is to reopen the region which can release all resources, like the refcount, leases, etc. This config represents Store files Ref Count threshold value considered for reopening regions. Any region with compacted store files ref count > this value would be eligible for reopening by master. Here, we get the max refCount among all refCounts on all compacted away store files that belong to a particular region. Default value -1 indicates this feature is turned off. Only positive integer value should be provided to enable this feature.\\\n**Default:** `-1`\n\n#### `hbase.regionserver.slowlog.ringbuffer.size` \\[!toc]\n\n**Description:** Default size of ringbuffer to be maintained by each RegionServer in order to store online slowlog responses. This is an in-memory ring buffer of requests that were judged to be too slow in addition to the responseTooSlow logging. The in-memory representation would be complete. For more details, please look into Doc Section: Get Slow Response Log from shell\\\n**Default:** `256`\n\n#### `hbase.regionserver.slowlog.buffer.enabled` \\[!toc]\n\n**Description:** Indicates whether RegionServers have ring buffer running for storing Online Slow logs in FIFO manner with limited entries. The size of the ring buffer is indicated by config: hbase.regionserver.slowlog.ringbuffer.size The default value is false, turn this on and get latest slowlog responses with complete data.\\\n**Default:** `false`\n\n#### `hbase.regionserver.slowlog.systable.enabled` \\[!toc]\n\n**Description:** Should be enabled only if hbase.regionserver.slowlog.buffer.enabled is enabled. If enabled (true), all slow/large RPC logs would be persisted to system table hbase:slowlog (in addition to in-memory ring buffer at each RegionServer). The records are stored in increasing order of time. Operators can scan the table with various combination of ColumnValueFilter. More details are provided in the doc section: \"Get Slow/Large Response Logs from System table hbase:slowlog\"\\\n**Default:** `false`\n\n#### `hbase.master.metafixer.max.merge.count` \\[!toc]\n\n**Description:** Maximum regions to merge at a time when we fix overlaps noted in CJ consistency report, but avoid merging 100 regions in one go!\\\n**Default:** `64`\n\n#### `hbase.rpc.rows.size.threshold.reject` \\[!toc]\n\n**Description:** If value is true, RegionServer will abort batch requests of Put/Delete with number of rows in a batch operation exceeding threshold defined by value of config: hbase.rpc.rows.warning.threshold. The default value is false and hence, by default, only warning will be logged. This config should be turned on to prevent RegionServer from serving very large batch size of rows and this way we can improve CPU usages by discarding too large batch request.\\\n**Default:** `false`\n\n#### `hbase.namedqueue.provider.classes` \\[!toc]\n\n**Description:** Default values for NamedQueueService implementors. This comma separated full class names represent all implementors of NamedQueueService that we would like to be invoked by LogEvent handler service. One example of NamedQueue service is SlowLogQueueService which is used to store slow/large RPC logs in ringbuffer at each RegionServer. All implementors of NamedQueueService should be found under package: \"org.apache.hadoop.hbase.namequeues.impl\"\\\n**Default:** `org.apache.hadoop.hbase.namequeues.impl.SlowLogQueueService,org.apache.hadoop.hbase.namequeues.impl.BalancerDecisionQueueService,org.apache.hadoop.hbase.namequeues.impl.BalancerRejectionQueueService,org.apache.hadoop.hbase.namequeues.WALEventTrackerQueueService`\n\n#### `hbase.master.balancer.decision.buffer.enabled` \\[!toc]\n\n**Description:** Indicates whether active HMaster has ring buffer running for storing balancer decisions in FIFO manner with limited entries. The size of the ring buffer is indicated by config: hbase.master.balancer.decision.queue.size\\\n**Default:** `false`\n\n#### `hbase.master.balancer.rejection.buffer.enabled` \\[!toc]\n\n**Description:** Indicates whether active HMaster has ring buffer running for storing balancer rejection in FIFO manner with limited entries. The size of the ring buffer is indicated by config: hbase.master.balancer.rejection.queue.size\\\n**Default:** `false`\n\n#### `hbase.locality.inputstream.derive.enabled` \\[!toc]\n\n**Description:** If true, derive StoreFile locality metrics from the underlying DFSInputStream backing reads for that StoreFile. This value will update as the DFSInputStream's block locations are updated over time. Otherwise, locality is computed on StoreFile open, and cached until the StoreFile is closed.\\\n**Default:** `false`\n\n#### `hbase.locality.inputstream.derive.cache.period` \\[!toc]\n\n**Description:** If deriving StoreFile locality metrics from the underlying DFSInputStream, how long should the derived values be cached for. The derivation process may involve hitting the namenode, if the DFSInputStream's block list is incomplete.\\\n**Default:** `60000`\n\n## hbase-env.sh\n\nSet HBase environment variables in this file. Examples include options to pass the JVM on start of an HBase daemon such as heap size and garbage collector configs. You can also set configurations for HBase configuration, log directories, niceness, ssh options, where to locate process pid files, etc. Open the file at *conf/hbase-env.sh* and peruse its content. Each option is fairly well documented. Add your own environment variables here if you want them read by HBase daemons on startup.\n\nChanges here will require a cluster restart for HBase to notice the change.\n\n## *log4j2.properties*\n\nSince version 2.5.0, HBase has upgraded to Log4j2, so the configuration file name and format has changed. Read more in [Apache Log4j2](https://logging.apache.org/log4j/2.x/index.html).\n\nEdit this file to change rate at which HBase files are rolled and to change the level at which HBase logs messages.\n\nChanges here will require a cluster restart for HBase to notice the change though log levels can be changed for particular daemons via the HBase UI.\n\n## Client configuration and dependencies connecting to an HBase cluster\n\nIf you are running HBase in standalone mode, you don't need to configure anything for your client to work provided that they are all on the same machine.\n\nStarting release 3.0.0, the default connection registry has been switched to a rpc based implementation. Refer to [Rpc Connection Registry (new as of 2.5.0)](/docs/architecture/client#rpc-connection-registry-new-as-of-250). Depending on your HBase version, following is the expected minimal client configuration.\n\n### Up until 2.x.y releases\n\nIn 2.x.y releases, the default connection registry was based on ZooKeeper as the source of truth. This means that the clients always looked up ZooKeeper znodes to fetch the required metadata. For example, if an active master crashed and the a new master is elected, clients looked up the master znode to fetch the active master address (similarly for meta locations). This meant that the clients needed to have access to ZooKeeper and need to know the ZooKeeper ensemble information before they can do anything. This can be configured in the client configuration xml as follows:\n\n```xml\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<configuration>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>example1,example2,example3</value>\n    <description>Zookeeper ensemble information</description>\n  </property>\n</configuration>\n```\n\n### Starting from 3.0.0 release\n\nThe default implementation was switched to a rpc based connection registry. With this implementation, by default clients contact the active or stand-by master RPC end points to fetch the connection registry information. This means that the clients should have access to the list of active and master end points before they can do anything. This can be configured in the client configuration xml as follows:\n\n```xml\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<configuration>\n  <property>\n    <name>hbase.masters</name>\n    <value>example1,example2,example3</value>\n    <description>List of master rpc end points for the hbase cluster.</description>\n  </property>\n</configuration>\n```\n\nThe configuration value for *hbase.masters* is a comma separated list of *host:port* values. If no port value is specified, the default of *16000* is assumed.\n\nOf course you are free to specify bootstrap nodes other than masters, like:\n\n```xml\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<property>\n  <name>hbase.client.bootstrap.servers</name>\n  <value>server1:16020,server2:16020,server3:16020</value>\n</property>\n```\n\nThe configuration value for *hbase.client.bootstrap.servers* is a comma separated list of *host:port* values. Notice that port must be specified here.\n\nUsually these configurations are kept out in the *hbase-site.xml* and is picked up by the client from the `CLASSPATH`.\n\nIf you are configuring an IDE to run an HBase client, you should include the *conf/* directory on your classpath so *hbase-site.xml* settings can be found (or add *src/test/resources* to pick up the hbase-site.xml used by tests).\n\nFor Java applications using Maven, including the hbase-shaded-client module is the recommended dependency when connecting to a cluster:\n\n```xml\n<dependency>\n  <groupId>org.apache.hbase</groupId>\n  <artifactId>hbase-shaded-client</artifactId>\n  <version>2.0.0</version>\n</dependency>\n```\n\n### Java client configuration\n\nThe configuration used by a Java client is kept in an [HBaseConfiguration](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/HBaseConfiguration) instance.\n\nThe factory method on HBaseConfiguration, `HBaseConfiguration.create();`, on invocation, will read in the content of the first *hbase-site.xml* found on the client's `CLASSPATH`, if one is present (Invocation will also factor in any *hbase-default.xml* found; an *hbase-default.xml* ships inside the *hbase.X.X.X.jar*). It is also possible to specify configuration directly without having to read from a *hbase-site.xml*.\n\nFor example, to set the ZooKeeper ensemble or bootstrap nodes for the cluster programmatically do as follows:\n\n```java\nConfiguration config = HBaseConfiguration.create();\nconfig.set(\"hbase.zookeeper.quorum\", \"localhost\");  // Until 2.x.y versions\n// ---- or ----\nconfig.set(\"hbase.client.bootstrap.servers\", \"localhost:1234\"); // Starting 3.0.0 version\n```\n\n## Timeout settings\n\nHBase provides a wide variety of timeout settings to limit the execution time of various remote operations.\n\n* hbase.rpc.timeout\n* hbase.rpc.read.timeout\n* hbase.rpc.write.timeout\n* hbase.client.operation.timeout\n* hbase.client.meta.operation.timeout\n* hbase.client.scanner.timeout.period\n\nThe `hbase.rpc.timeout` property limits how long a single RPC call can run before timing out. To fine tune read or write related RPC timeouts set `hbase.rpc.read.timeout` and `hbase.rpc.write.timeout` configuration properties. In the absence of these properties `hbase.rpc.timeout` will be used.\n\nA higher-level timeout is `hbase.client.operation.timeout` which is valid for each client call. When an RPC call fails for instance for a timeout due to `hbase.rpc.timeout` it will be retried until `hbase.client.operation.timeout` is reached. Client operation timeout for system tables can be fine tuned by setting `hbase.client.meta.operation.timeout` configuration value. When this is not set its value will use `hbase.client.operation.timeout`.\n\nTimeout for scan operations is controlled differently. Use `hbase.client.scanner.timeout.period` property to set this timeout.\n\n\n# Dynamic Configuration (/docs/configuration/dynamic)\nIt is possible to change a subset of the configuration without requiring a server restart. In the HBase shell, the operations `update_config`, `update_all_config` and `update_rsgroup_config` will prompt a server, all servers or all servers in the RSGroup to reload configuration.\n\nOnly a subset of all configurations can currently be changed in the running server. Here are those configurations:\n\nConfigurations that support dynamically change\n\n| Key                                                                    |\n| ---------------------------------------------------------------------- |\n| hbase.ipc.server.fallback-to-simple-auth-allowed                       |\n| hbase.cleaner.scan.dir.concurrent.size                                 |\n| hbase.coprocessor.master.classes                                       |\n| hbase.coprocessor.region.classes                                       |\n| hbase.coprocessor.regionserver.classes                                 |\n| hbase.coprocessor.user.region.classes                                  |\n| hbase.regionserver.thread.compaction.large                             |\n| hbase.regionserver.thread.compaction.small                             |\n| hbase.regionserver.thread.split                                        |\n| hbase.regionserver.throughput.controller                               |\n| hbase.regionserver.thread.hfilecleaner.throttle                        |\n| hbase.regionserver.hfilecleaner.large.queue.size                       |\n| hbase.regionserver.hfilecleaner.small.queue.size                       |\n| hbase.regionserver.hfilecleaner.large.thread.count                     |\n| hbase.regionserver.hfilecleaner.small.thread.count                     |\n| hbase.regionserver.hfilecleaner.thread.timeout.msec                    |\n| hbase.regionserver.hfilecleaner.thread.check.interval.msec             |\n| hbase.regionserver.flush.throughput.controller                         |\n| hbase.hstore.compaction.max.size                                       |\n| hbase.hstore.compaction.max.size.offpeak                               |\n| hbase.hstore.compaction.min.size                                       |\n| hbase.hstore.compaction.min                                            |\n| hbase.hstore.compaction.max                                            |\n| hbase.hstore.compaction.ratio                                          |\n| hbase.hstore.compaction.ratio.offpeak                                  |\n| hbase.regionserver.thread.compaction.throttle                          |\n| hbase.hregion.majorcompaction                                          |\n| hbase.hregion.majorcompaction.jitter                                   |\n| hbase.hstore.min.locality.to.skip.major.compact                        |\n| hbase.hstore.compaction.date.tiered.max.storefile.age.millis           |\n| hbase.hstore.compaction.date.tiered.incoming.window\\.min               |\n| hbase.hstore.compaction.date.tiered.window\\.policy.class               |\n| hbase.hstore.compaction.date.tiered.single.output.for.minor.compaction |\n| hbase.hstore.compaction.date.tiered.window\\.factory.class              |\n| hbase.offpeak.start.hour                                               |\n| hbase.offpeak.end.hour                                                 |\n| hbase.oldwals.cleaner.thread.size                                      |\n| hbase.oldwals.cleaner.thread.timeout.msec                              |\n| hbase.oldwals.cleaner.thread.check.interval.msec                       |\n| hbase.procedure.worker.keep.alive.time.msec                            |\n| hbase.procedure.worker.add.stuck.percentage                            |\n| hbase.procedure.worker.monitor.interval.msec                           |\n| hbase.procedure.worker.stuck.threshold.msec                            |\n| hbase.regions.slop                                                     |\n| hbase.regions.overallSlop                                              |\n| hbase.balancer.tablesOnMaster                                          |\n| hbase.balancer.tablesOnMaster.systemTablesOnly                         |\n| hbase.util.ip.to.rack.determiner                                       |\n| hbase.ipc.server.max.callqueue.length                                  |\n| hbase.ipc.server.priority.max.callqueue.length                         |\n| hbase.ipc.server.callqueue.type                                        |\n| hbase.ipc.server.callqueue.codel.target.delay                          |\n| hbase.ipc.server.callqueue.codel.interval                              |\n| hbase.ipc.server.callqueue.codel.lifo.threshold                        |\n| hbase.master.balancer.stochastic.maxSteps                              |\n| hbase.master.balancer.stochastic.stepsPerRegion                        |\n| hbase.master.balancer.stochastic.maxRunningTime                        |\n| hbase.master.balancer.stochastic.runMaxSteps                           |\n| hbase.master.balancer.stochastic.numRegionLoadsToRemember              |\n| hbase.master.loadbalance.bytable                                       |\n| hbase.master.balancer.stochastic.minCostNeedBalance                    |\n| hbase.master.balancer.stochastic.localityCost                          |\n| hbase.master.balancer.stochastic.rackLocalityCost                      |\n| hbase.master.balancer.stochastic.readRequestCost                       |\n| hbase.master.balancer.stochastic.writeRequestCost                      |\n| hbase.master.balancer.stochastic.memstoreSizeCost                      |\n| hbase.master.balancer.stochastic.storefileSizeCost                     |\n| hbase.master.balancer.stochastic.regionReplicaHostCostKey              |\n| hbase.master.balancer.stochastic.regionReplicaRackCostKey              |\n| hbase.master.balancer.stochastic.regionCountCost                       |\n| hbase.master.balancer.stochastic.primaryRegionCountCost                |\n| hbase.master.balancer.stochastic.moveCost                              |\n| hbase.master.balancer.stochastic.moveCost.offpeak                      |\n| hbase.master.balancer.stochastic.maxMovePercent                        |\n| hbase.master.balancer.stochastic.tableSkewCost                         |\n| hbase.master.regions.recovery.check.interval                           |\n| hbase.regions.recovery.store.file.ref.count                            |\n| hbase.rsgroup.fallback.enable                                          |\n\n\n# Example Configurations (/docs/configuration/example)\n## Basic Distributed HBase Install\n\nHere is a basic configuration example for a distributed ten node cluster: \\* The nodes are named `example0`, `example1`, etc., through node `example9` in this example. \\* The HBase Master and the HDFS NameNode are running on the node `example0`. \\* RegionServers run on nodes `example1`-`example9`. \\* A 3-node ZooKeeper ensemble runs on `example1`, `example2`, and `example3` on the default ports. \\* ZooKeeper data is persisted to the directory */export/zookeeper*.\n\nBelow we show what the main configuration files — *hbase-site.xml*, *regionservers*, and *hbase-env.sh* — found in the HBase *conf* directory might look like.\n\n### hbase-site.xml\n\n```xml\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<configuration>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>example1,example2,example3</value>\n    <description>The directory shared by RegionServers.</description>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.dataDir</name>\n    <value>/export/zookeeper</value>\n    <description>Property from ZooKeeper config zoo.cfg.\n      The directory where the snapshot is stored.\n    </description>\n  </property>\n  <property>\n    <name>hbase.rootdir</name>\n    <value>hdfs://example0:9000/hbase</value>\n    <description>The directory shared by RegionServers.</description>\n  </property>\n  <property>\n    <name>hbase.cluster.distributed</name>\n    <value>true</value>\n    <description>The mode the cluster will be in. Possible values are\n      false: standalone and pseudo-distributed setups with managed ZooKeeper\n      true: fully-distributed with unmanaged ZooKeeper Quorum (see hbase-env.sh)\n    </description>\n  </property>\n</configuration>\n```\n\n### *regionservers*\n\nIn this file you list the nodes that will run RegionServers. In our case, these nodes are `example1`-`example9`.\n\n```text\nexample1\nexample2\nexample3\nexample4\nexample5\nexample6\nexample7\nexample8\nexample9\n```\n\n### hbase-env.sh\n\nThe following lines in the *hbase-env.sh* file show how to set the `JAVA_HOME` environment variable (required for HBase) and set the heap to 4 GB (rather than the default value of 1 GB). If you copy and paste this example, be sure to adjust the `JAVA_HOME` to suit your environment.\n\n```bash\n# The java implementation to use.\nexport JAVA_HOME=/usr/java/jdk1.8.0/\n\n# The maximum amount of heap to use. Default is left to JVM default.\nexport HBASE_HEAPSIZE=4G\n```\n\nUse rsync to copy the content of the *conf* directory to all nodes of the cluster.\n\n\n# HBase run modes: Standalone and Distributed (/docs/configuration/hbase-run-models)\nHBase has two run modes: [standalone](/docs/configuration/hbase-run-models#standalone-hbase) and [distributed](/docs/configuration/hbase-run-models#distributed). Out of the box, HBase runs in standalone mode. Whatever your mode, you will need to configure HBase by editing files in the HBase *conf* directory. At a minimum, you must edit `conf/hbase-env.sh` to tell HBase which java to use. In this file you set HBase environment variables such as the heapsize and other options for the `JVM`, the preferred location for log files, etc. Set `JAVA_HOME` to point at the root of your java install.\n\n## Standalone HBase\n\nThis is the default mode. Standalone mode is what is described in the [quickstart](/docs/getting-started#quick-start---standalone-hbase) section. In standalone mode, HBase does not use HDFS — it uses the local filesystem instead — and it runs all HBase daemons and a local ZooKeeper all up in the same JVM. ZooKeeper binds to a well-known port so clients may talk to HBase.\n\n### Standalone HBase over HDFS\n\nA sometimes useful variation on standalone hbase has all daemons running inside the one JVM but rather than persist to the local filesystem, instead they persist to an HDFS instance.\n\nYou might consider this profile when you are intent on a simple deploy profile, the loading is light, but the data must persist across node comings and goings. Writing to HDFS where data is replicated ensures the latter.\n\nTo configure this standalone variant, edit your *hbase-site.xml* setting *hbase.rootdir* to point at a directory in your HDFS instance but then set *hbase.cluster.distributed* to *false*. For example:\n\n```xml\n<configuration>\n  <property>\n    <name>hbase.rootdir</name>\n    <value>hdfs://namenode.example.org:9000/hbase</value>\n  </property>\n  <property>\n    <name>hbase.cluster.distributed</name>\n    <value>false</value>\n  </property>\n</configuration>\n```\n\n## Distributed\n\nDistributed mode can be subdivided into distributed but all daemons run on a single node — a.k.a. *pseudo-distributed* — and *fully-distributed* where the daemons are spread across all nodes in the cluster. The *pseudo-distributed* vs. *fully-distributed* nomenclature comes from Hadoop.\n\nPseudo-distributed mode can run against the local filesystem or it can run against an instance of the *Hadoop Distributed File System* (HDFS). Fully-distributed mode can ONLY run on HDFS. See the Hadoop [documentation](https://hadoop.apache.org/docs/current/) for how to set up HDFS. A good walk-through for setting up HDFS on Hadoop 2 can be found at [https://web.archive.org/web/20221007121526/https://www.alexjf.net/blog/distributed-systems/hadoop-yarn-installation-definitive-guide/](https://web.archive.org/web/20221007121526/https://www.alexjf.net/blog/distributed-systems/hadoop-yarn-installation-definitive-guide/).\n\n### Pseudo-distributed\n\n<Callout type=\"info\">\n  A quickstart has been added to the\n  [quickstart](/docs/getting-started#quick-start---standalone-hbase) chapter. See\n  [quickstart-pseudo](/docs/getting-started#pseudo-distributed-for-local-testing). Some of the\n  information that was originally in this section has been moved there.\n</Callout>\n\nA pseudo-distributed mode is simply a fully-distributed mode run on a single host. Use this HBase configuration for testing and prototyping purposes only. Do not use this configuration for production or for performance evaluation.\n\n## Fully-distributed\n\nBy default, HBase runs in stand-alone mode. Both stand-alone mode and pseudo-distributed mode are provided for the purposes of small-scale testing. For a production environment, distributed mode is advised. In distributed mode, multiple instances of HBase daemons run on multiple servers in the cluster.\n\nJust as in pseudo-distributed mode, a fully distributed configuration requires that you set the `hbase.cluster.distributed` property to `true`. Typically, the `hbase.rootdir` is configured to point to a highly-available HDFS filesystem.\n\nIn addition, the cluster is configured so that multiple cluster nodes enlist as RegionServers, ZooKeeper QuorumPeers, and backup HMaster servers. These configuration basics are all demonstrated in [quickstart-fully-distributed](/docs/getting-started#fully-distributed-for-production).\n\n### Distributed RegionServers\n\nTypically, your cluster will contain multiple RegionServers all running on different servers, as well as primary and backup Master and ZooKeeper daemons. The *conf/regionservers* file on the master server contains a list of hosts whose RegionServers are associated with this cluster. Each host is on a separate line. All hosts listed in this file will have their RegionServer processes started and stopped when the master server starts or stops.\n\n### ZooKeeper and HBase\n\nSee the [ZooKeeper](/docs/zookeeper) section for ZooKeeper setup instructions for HBase.\n\n### Example: Distributed HBase Cluster\n\nThis is a bare-bones *conf/hbase-site.xml* for a distributed HBase cluster. A cluster that is used for real-world work would contain more custom configuration parameters. Most HBase configuration directives have default values, which are used unless the value is overridden in the *hbase-site.xml*. See \"[Configuration Files](/docs/configuration/default)\" for more information.\n\n```xml\n<configuration>\n  <property>\n    <name>hbase.rootdir</name>\n    <value>hdfs://namenode.example.org:9000/hbase</value>\n  </property>\n  <property>\n    <name>hbase.cluster.distributed</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>node-a.example.com,node-b.example.com,node-c.example.com</value>\n  </property>\n</configuration>\n```\n\nThis is an example *conf/regionservers* file, which contains a list of nodes that should run a RegionServer in the cluster. These nodes need HBase installed and they need to use the same contents of the *conf/* directory as the Master server.\n\n```text\nnode-a.example.com\nnode-b.example.com\nnode-c.example.com\n```\n\nThis is an example *conf/backup-masters* file, which contains a list of each node that should run a backup Master instance. The backup Master instances will sit idle unless the main Master becomes unavailable.\n\n```text\nnode-b.example.com\nnode-c.example.com\n```\n\n### Distributed HBase Quickstart\n\nSee [quickstart-fully-distributed](/docs/getting-started#fully-distributed-for-production) for a walk-through of a simple three-node cluster configuration with multiple ZooKeeper, backup HMaster, and RegionServer instances.\n\n### Procedure: HDFS Client Configuration\n\n1. Of note, if you have made HDFS client configuration changes on your Hadoop cluster, such as configuration directives for HDFS clients, as opposed to server-side configurations, you must use one of the following methods to enable HBase to see and use these configuration changes:\n   * Add a pointer to your `HADOOP_CONF_DIR` to the `HBASE_CLASSPATH` environment variable in *hbase-env.sh*.\n   * Add a copy of *hdfs-site.xml* (or *hadoop-site.xml*) or, better, symlinks, under `$HBASE_HOME/conf`, or\n   * if only a small set of HDFS client configurations, add them to *hbase-site.xml*.\n\nAn example of such an HDFS client configuration is `dfs.replication`. If for example, you want to run with a replication factor of 5, HBase will create files with the default of 3 unless you do the above to make the configuration available to HBase.\n\n## Choosing between the Classic Package and the BYO Hadoop Package\n\nStarting with HBase 3.0, HBase includes two binary packages. The classic package includes both the HBase and Hadoop components, while the Hadoop-less \"Bring Your Own Hadoop\" package omits the Hadoop components, and uses the files from an existing Hadoop installation. The classic binary package filename is named `hbase-VERSION-bin.tar.gz` (e.g. *hbase-3.0.0-bin.tar.gz*), while the Hadoop-less package is `hbase-byo-hadoop-VERSION-bin.tar.gz` (e.g. *hbase-byo-hadoop-3.0.0-bin.tar.gz*).\n\nIf the cluster nodes already have Hadoop installed, you can use the Hadoop-less package. In this case you need to make sure that the `HADOOP_HOME` environment variable is set and points to the Hadoop installation. The easiest way to ensure this is to set it in *hbase-env.sh*. You still need to make sure that the Hadoop configuration files are present on the HBase classpath, as described above.\n\n## Advantages of the BYO Hadoop package:\n\n* There is no need to replace the Hadoop libraries.\n* It is easier to upgrade Hadoop and HBase independently (as long as compatible versions are used).\n* Both the package and installed size are about 100 MB smaller.\n\n\n# The Important Configurations (/docs/configuration/important)\n## Required Configurations\n\nReview the [os](/docs/configuration/basic-prerequisites#operating-system-utilities) and [hadoop](/docs/configuration/basic-prerequisites#hadoop) sections.\n\n### Big Cluster Configurations\n\nIf you have a cluster with a lot of regions, it is possible that a Regionserver checks in briefly after the Master starts while all the remaining RegionServers lag behind. This first server to check in will be assigned all regions which is not optimal. To prevent the above scenario from happening, up the `hbase.master.wait.on.regionservers.mintostart` property from its default value of 1. See [HBASE-6389 Modify the conditions to ensure that Master waits for sufficient number of Region Servers before starting region assignments](https://issues.apache.org/jira/browse/HBASE-6389) for more detail.\n\n## Recommended Configurations\n\n### ZooKeeper Configuration\n\n#### `zookeeper.session.timeout`\n\nThe default timeout is 90 seconds (specified in milliseconds). This means that if a server crashes, it will be 90 seconds before the Master notices the crash and starts recovery. You might need to tune the timeout down to a minute or even less so the Master notices failures sooner. Before changing this value, be sure you have your JVM garbage collection configuration under control, otherwise, a long garbage collection that lasts beyond the ZooKeeper session timeout will take out your RegionServer. (You might be fine with this — you probably want recovery to start on the server if a RegionServer has been in GC for a long period of time).\n\nTo change this configuration, edit *hbase-site.xml*, copy the changed file across the cluster and restart.\n\nWe set this value high to save our having to field questions up on the mailing lists asking why a RegionServer went down during a massive import. The usual cause is that their JVM is untuned and they are running into long GC pauses. Our thinking is that while users are getting familiar with HBase, we'd save them having to know all of its intricacies. Later when they've built some confidence, then they can play with configuration such as this.\n\n#### Number of ZooKeeper Instances\n\nSee [zookeeper](/docs/zookeeper).\n\n### HDFS Configurations\n\n#### `dfs.datanode.failed.volumes.tolerated`\n\nThis is the \"...number of volumes that are allowed to fail before a DataNode stops offering service. By default, any volume failure will cause a datanode to shutdown\" from the *hdfs-default.xml* description. You might want to set this to about half the amount of your available disks.\n\n#### `hbase.regionserver.handler.count`\n\nThis setting defines the number of threads that are kept open to answer incoming requests to user tables. The rule of thumb is to keep this number low when the payload per request approaches the MB (big puts, scans using a large cache) and high when the payload is small (gets, small puts, ICVs, deletes). The total size of the queries in progress is limited by the setting `hbase.ipc.server.max.callqueue.size`.\n\nIt is safe to set that number to the maximum number of incoming clients if their payload is small, the typical example being a cluster that serves a website since puts aren't typically buffered and most of the operations are gets.\n\nThe reason why it is dangerous to keep this setting high is that the aggregate size of all the puts that are currently happening in a region server may impose too much pressure on its memory, or even trigger an OutOfMemoryError. A RegionServer running on low memory will trigger its JVM's garbage collector to run more frequently up to a point where GC pauses become noticeable (the reason being that all the memory used to keep all the requests' payloads cannot be trashed, no matter how hard the garbage collector tries). After some time, the overall cluster throughput is affected since every request that hits that RegionServer will take longer, which exacerbates the problem even more.\n\nYou can get a sense of whether you have too little or too many handlers by [rpc.logging](/docs/troubleshooting#enabling-rpc-level-logging) on an individual RegionServer then tailing its logs (Queued requests consume memory).\n\n### Configuration for large memory machines\n\nHBase ships with a reasonable, conservative configuration that will work on nearly all machine types that people might want to test with. If you have larger machines — HBase has 8G and larger heap — you might find the following configuration options helpful. TODO.\n\n### Compression\n\nYou should consider enabling ColumnFamily compression. There are several options that are near-frictionless and in most all cases boost performance by reducing the size of StoreFiles and thus reducing I/O.\n\nSee [compression](/docs/compression) for more information.\n\n### Configuring the size and number of WAL files\n\nHBase uses \\[wal]/docs/architecture/regionserver#write-ahead-log-wal to recover the memstore data that has not been flushed to disk in case of an RS failure. These WAL files should be configured to be slightly smaller than HDFS block (by default a HDFS block is 64Mb and a WAL file is \\~60Mb).\n\nHBase also has a limit on the number of WAL files, designed to ensure there's never too much data that needs to be replayed during recovery. This limit needs to be set according to memstore configuration, so that all the necessary data would fit. It is recommended to allocate enough WAL files to store at least that much data (when all memstores are close to full). For example, with 16Gb RS heap, default memstore settings (0.4), and default WAL file size (\\~60Mb), 16Gb\\*0.4/60, the starting point for WAL file count is \\~109. However, as all memstores are not expected to be full all the time, less WAL files can be allocated.\n\n### Managed Splitting\n\nHBase generally handles splitting of your regions based upon the settings in your *hbase-default.xml* and *hbase-site.xml* configuration files. Important settings include `hbase.regionserver.region.split.policy`, `hbase.hregion.max.filesize`, `hbase.regionserver.regionSplitLimit`. A simplistic view of splitting is that when a region grows to `hbase.hregion.max.filesize`, it is split. For most usage patterns, you should use automatic splitting. See [manual region splitting decisions](/docs/architecture/regions#manual-region-splitting) for more information about manual region splitting.\n\nInstead of allowing HBase to split your regions automatically, you can choose to manage the splitting yourself. Manually managing splits works if you know your keyspace well, otherwise let HBase figure where to split for you. Manual splitting can mitigate region creation and movement under load. It also makes it so region boundaries are known and invariant (if you disable region splitting). If you use manual splits, it is easier doing staggered, time-based major compactions to spread out your network IO load.\n\n#### Disable Automatic Splitting\n\nTo disable automatic splitting, you can set region split policy in either cluster configuration or table configuration to be `org.apache.hadoop.hbase.regionserver.DisabledRegionSplitPolicy`\n\n<Callout type=\"info\">\n  If you disable automatic splits to diagnose a problem or during a period of fast data growth, it\n  is recommended to re-enable them when your situation becomes more stable. The potential benefits\n  of managing region splits yourself are not undisputed.\n</Callout>\n\n#### Determine the Optimal Number of Pre-Split Regions\n\nThe optimal number of pre-split regions depends on your application and environment. A good rule of thumb is to start with 10 pre-split regions per server and watch as data grows over time. It is better to err on the side of too few regions and perform rolling splits later. The optimal number of regions depends upon the largest StoreFile in your region. The size of the largest StoreFile will increase with time if the amount of data grows. The goal is for the largest region to be just large enough that the compaction selection algorithm only compacts it during a timed major compaction. Otherwise, the cluster can be prone to compaction storms with a large number of regions under compaction at the same time. It is important to understand that the data growth causes compaction storms and not the manual split decision.\n\nIf the regions are split into too many large regions, you can increase the major compaction interval by configuring `HConstants.MAJOR_COMPACTION_PERIOD`. The `org.apache.hadoop.hbase.util.RegionSplitter` utility also provides a network-IO-safe rolling split of all regions.\n\n### Managed Compactions\n\nBy default, major compactions are scheduled to run once in a 7-day period.\n\nIf you need to control exactly when and how often major compaction runs, you can disable managed major compactions. See the entry for `hbase.hregion.majorcompaction` in the [compaction.parameters](/docs/architecture/regions#parameters-used-by-compaction-algorithm) table for details.\n\n<Callout type=\"warn\">\n  Major compactions are absolutely necessary for StoreFile clean-up. Do not disable them altogether.\n  You can run major compactions manually via the HBase shell or via the [Admin\n  API](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Admin.html#majorCompact\\(org.apache.hadoop.hbase.TableName\\)).\n</Callout>\n\nFor more information about compactions and the compaction file selection process, see [compaction](/docs/architecture/regions#compaction)\n\n### Speculative Execution\n\nSpeculative Execution of MapReduce tasks is on by default, and for HBase clusters it is generally advised to turn off Speculative Execution at a system-level unless you need it for a specific case, where it can be configured per-job. Set the properties `mapreduce.map.speculative` and `mapreduce.reduce.speculative` to false.\n\n## Other Configurations\n\n### Balancer\n\nThe balancer is a periodic operation which is run on the master to redistribute regions on the cluster. It is configured via `hbase.balancer.period` and defaults to 300000 (5 minutes).\n\nSee [master.processes.loadbalancer](/docs/architecture/master#loadbalancer) for more information on the LoadBalancer.\n\n### Disabling Blockcache\n\nDo not turn off block cache (You'd do it by setting `hfile.block.cache.size` to zero). Currently, we do not do well if you do this because the RegionServer will spend all its time loading HFile indices over and over again. If your working set is such that block cache does you no good, at least size the block cache such that HFile indices will stay up in the cache (you can get a rough idea on the size you need by surveying RegionServer UIs; you'll see index block size accounted near the top of the webpage).\n\n### Nagle's or the small package problem\n\nIf a big 40ms or so occasional delay is seen in operations against HBase, try the [Nagle's](https://en.wikipedia.org/wiki/Nagle%27s_algorithm) setting. For example, see the user mailing list thread, [Inconsistent scan performance with caching set to 1](https://lists.apache.org/thread.html/3d7ceb41c04a955b1b1c80480cdba95208ca3e97bf6895a40e0c1bbb%401346186127%40%3Cuser.hbase.apache.org%3E) and the issue cited therein where setting `notcpdelay` improved scan speeds. You might also see the graphs on the tail of [HBASE-7008 Set scanner caching to a better default](https://issues.apache.org/jira/browse/HBASE-7008) where our Lars Hofhansl tries various data sizes w/ Nagle's on and off measuring the effect.\n\n### Better Mean Time to Recover (MTTR)\n\nThis section is about configurations that will make servers come back faster after a fail. See the Deveraj Das and Nicolas Liochon blog post [Introduction to HBase Mean Time to Recover (MTTR)](http://hortonworks.com/blog/introduction-to-hbase-mean-time-to-recover-mttr/) for a brief introduction.\n\nThe issue [HBASE-8354 forces Namenode into loop with lease recovery requests](https://issues.apache.org/jira/browse/HBASE-8389) is messy but has a bunch of good discussion toward the end on low timeouts and how to cause faster recovery including citation of fixes added to HDFS. Read the Varun Sharma comments. The below suggested configurations are Varun's suggestions distilled and tested. Make sure you are running on a late-version HDFS so you have the fixes he refers to and himself adds to HDFS that help HBase MTTR (e.g. HDFS-3703, HDFS-3712, and HDFS-4791 — Hadoop 2 for sure has them and late Hadoop 1 has some). Set the following in the RegionServer.\n\n```xml\n<property>\n  <name>hbase.lease.recovery.dfs.timeout</name>\n  <value>23000</value>\n  <description>How much time we allow elapse between calls to recover lease.\n  Should be larger than the dfs timeout.</description>\n</property>\n<property>\n  <name>dfs.client.socket-timeout</name>\n  <value>10000</value>\n  <description>Down the DFS timeout from 60 to 10 seconds.</description>\n</property>\n```\n\nAnd on the NameNode/DataNode side, set the following to enable 'staleness' introduced in HDFS-3703, HDFS-3912.\n\n```xml\n<property>\n  <name>dfs.client.socket-timeout</name>\n  <value>10000</value>\n  <description>Down the DFS timeout from 60 to 10 seconds.</description>\n</property>\n<property>\n  <name>dfs.datanode.socket.write.timeout</name>\n  <value>10000</value>\n  <description>Down the DFS timeout from 8 * 60 to 10 seconds.</description>\n</property>\n<property>\n  <name>ipc.client.connect.timeout</name>\n  <value>3000</value>\n  <description>Down from 60 seconds to 3.</description>\n</property>\n<property>\n  <name>ipc.client.connect.max.retries.on.timeouts</name>\n  <value>2</value>\n  <description>Down from 45 seconds to 3 (2 == 3 retries).</description>\n</property>\n<property>\n  <name>dfs.namenode.avoid.read.stale.datanode</name>\n  <value>true</value>\n  <description>Enable stale state in hdfs</description>\n</property>\n<property>\n  <name>dfs.namenode.stale.datanode.interval</name>\n  <value>20000</value>\n  <description>Down from default 30 seconds</description>\n</property>\n<property>\n  <name>dfs.namenode.avoid.write.stale.datanode</name>\n  <value>true</value>\n  <description>Enable stale state in hdfs</description>\n</property>\n```\n\n### JMX\n\nJMX (Java Management Extensions) provides built-in instrumentation that enables you to monitor and manage the Java VM. To enable monitoring and management from remote systems, you need to set system property `com.sun.management.jmxremote.port` (the port number through which you want to enable JMX RMI connections) when you start the Java VM. See the [official documentation](http://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html) for more information. Historically, besides above port mentioned, JMX opens two additional random TCP listening ports, which could lead to port conflict problem. (See [HBASE-10289](https://issues.apache.org/jira/browse/HBASE-10289) for details)\n\nAs an alternative, you can use the coprocessor-based JMX implementation provided by HBase. To enable it, add below property in *hbase-site.xml*:\n\n```xml\n<property>\n  <name>hbase.coprocessor.regionserver.classes</name>\n  <value>org.apache.hadoop.hbase.JMXListener</value>\n</property>\n```\n\n<Callout type=\"info\">\n  DO NOT set `com.sun.management.jmxremote.port` for Java VM at the same time.\n</Callout>\n\nCurrently it supports Master and RegionServer Java VM. By default, the JMX listens on TCP port 10102, you can further configure the port using below properties:\n\n```xml\n<property>\n  <name>regionserver.rmi.registry.port</name>\n  <value>61130</value>\n</property>\n<property>\n  <name>regionserver.rmi.connector.port</name>\n  <value>61140</value>\n</property>\n```\n\nThe registry port can be shared with connector port in most cases, so you only need to configure `regionserver.rmi.registry.port`. However, if you want to use SSL communication, the 2 ports must be configured to different values.\n\nBy default the password authentication and SSL communication is disabled. To enable password authentication, you need to update *hbase-env.sh* like below:\n\n```bash\nexport HBASE_JMX_BASE=\"-Dcom.sun.management.jmxremote.authenticate=true                  \\\n                       -Dcom.sun.management.jmxremote.password.file=your_password_file   \\\n                       -Dcom.sun.management.jmxremote.access.file=your_access_file\"\n\nexport HBASE_MASTER_OPTS=\"$HBASE_MASTER_OPTS $HBASE_JMX_BASE \"\nexport HBASE_REGIONSERVER_OPTS=\"$HBASE_REGIONSERVER_OPTS $HBASE_JMX_BASE \"\n```\n\nSee example password/access file under `$JRE_HOME/lib/management`.\n\nTo enable SSL communication with password authentication, follow below steps:\n\n```bash\n#1. generate a key pair, stored in myKeyStore\nkeytool -genkey -alias jconsole -keystore myKeyStore\n\n#2. export it to file jconsole.cert\nkeytool -export -alias jconsole -keystore myKeyStore -file jconsole.cert\n\n#3. copy jconsole.cert to jconsole client machine, import it to jconsoleKeyStore\nkeytool -import -alias jconsole -keystore jconsoleKeyStore -file jconsole.cert\n```\n\nAnd then update *hbase-env.sh* like below:\n\n```bash\nexport HBASE_JMX_BASE=\"-Dcom.sun.management.jmxremote.ssl=true                         \\\n                       -Djavax.net.ssl.keyStore=/home/tianq/myKeyStore                 \\\n                       -Djavax.net.ssl.keyStorePassword=your_password_in_step_1        \\\n                       -Dcom.sun.management.jmxremote.authenticate=true                \\\n                       -Dcom.sun.management.jmxremote.password.file=your_password file \\\n                       -Dcom.sun.management.jmxremote.access.file=your_access_file\"\n\nexport HBASE_MASTER_OPTS=\"$HBASE_MASTER_OPTS $HBASE_JMX_BASE \"\nexport HBASE_REGIONSERVER_OPTS=\"$HBASE_REGIONSERVER_OPTS $HBASE_JMX_BASE \"\n```\n\nFinally start `jconsole` on the client using the key store:\n\n```bash\njconsole -J-Djavax.net.ssl.trustStore=/home/tianq/jconsoleKeyStore\n```\n\n<Callout type=\"info\">\n  To enable the HBase JMX implementation on Master, you also need to add below property in\n  *hbase-site.xml*:\n</Callout>\n\n```xml\n<property>\n  <name>hbase.coprocessor.master.classes</name>\n  <value>org.apache.hadoop.hbase.JMXListener</value>\n</property>\n```\n\nThe corresponding properties for port configuration are `master.rmi.registry.port` (by default 10101) and `master.rmi.connector.port` (by default the same as registry.port)\n\n\n# Configuration (/docs/configuration)\nThis chapter expands upon the [Getting Started](/docs/getting-started) chapter to further explain configuration of Apache HBase. Please read this chapter carefully, especially the [Basic Prerequisites](basic-prerequisites) to ensure that your HBase testing and deployment goes smoothly. Familiarize yourself with [Support and Testing Expectations](/docs#support-and-testing-expectations) as well.\n\n## Configuration Files\n\nApache HBase uses the same configuration system as Apache Hadoop. All configuration files are located in the *conf/* directory, which needs to be kept in sync for each node on your cluster.\n\n***backup-masters***\\\nNot present by default. A plain-text file which lists hosts on which the Master should start a backup Master process, one host per line.\n\n***hadoop-metrics2-hbase.properties***\\\nUsed to connect HBase Hadoop's Metrics2 framework. See the [Hadoop Wiki entry](https://cwiki.apache.org/confluence/display/HADOOP2/HADOOP-6728-MetricsV2) for more information on Metrics2. Contains only commented-out examples by default.\n\n***hbase-env.cmd* and *hbase-env.sh***\\\nScript for Windows and Linux / Unix environments to set up the working environment for HBase, including the location of Java, Java options, and other environment variables. The file contains many commented-out examples to provide guidance.\n\n***hbase-policy.xml***\\\nThe default policy configuration file used by RPC servers to make authorization decisions on client requests. Only used if HBase [security](/docs/security) is enabled.\n\n***hbase-site.xml***\\\nThe main HBase configuration file. This file specifies configuration options which override HBase's default configuration. You can view (but do not edit) the default configuration file at *hbase-common/src/main/resources/hbase-default.xml*. You can also view the entire effective configuration for your cluster (defaults and overrides) in the **HBase Configuration** tab of the HBase Web UI.\n\n***log4j2.properties***\\\nConfiguration file for HBase logging via `log4j2`.\n\n***regionservers***\\\nA plain-text file containing a list of hosts which should run a RegionServer in your HBase cluster. By default, this file contains the single entry `localhost`. It should contain a list of hostnames or IP addresses, one per line, and should only contain `localhost` if each node in your cluster will run a RegionServer on its `localhost` interface.\n\n<Callout type=\"tip\">\n  When you edit XML, it is a good idea to use an XML-aware editor to be sure that your syntax is\n  correct and your XML is well-formed. You can also use the `xmllint` utility to check that your XML\n  is well-formed. By default, `xmllint` re-flows and prints the XML to standard output. To check for\n  well-formedness and only print output if errors exist, use the command `xmllint -noout\n    filename.xml`.\n</Callout>\n\n<Callout type=\"warn\">\n  When running in distributed mode, after you make an edit to an HBase configuration, make sure you\n  copy the contents of the *conf/* directory to all nodes of the cluster. HBase will not do this for\n  you. Use a configuration management tool for managing and copying the configuration files to your\n  nodes. For most configurations, a restart is needed for servers to pick up changes. Dynamic\n  configuration is an exception to this, to be described later below.\n</Callout>\n\n\n# Appendix: Contributing to Documentation (/docs/contributing-to-documentation)\n## Contributing to Documentation\n\nThe Apache HBase project welcomes contributions to all aspects of the project, including the documentation.\n\nIn HBase, documentation includes the following areas, and probably some others:\n\n* The [HBase Reference Guide](/docs) (this book)\n* The [HBase website](/)\n* API documentation\n* Command-line utility output and help text\n* Web UI strings, explicit help text, context-sensitive strings, and others\n* Log messages\n* Comments in source files, configuration files, and others\n* Localization of any of the above into target languages other than English\n\nNo matter which area you want to help out with, the first step is almost always to download (typically by cloning the Git repository) and familiarize yourself with the HBase source code. For information on downloading and building the source, see [developer](/docs/building-and-developing).\n\n## Contributing to Documentation or Other Strings\n\nIf you spot an error in a string in a UI, utility, script, log message, or elsewhere, or you think something could be made more clear, or you think text needs to be added where it doesn't currently exist, the first step is to file a JIRA. Be sure to set the component to `Documentation` in addition to any other involved components. Most components have one or more default owners, who monitor new issues which come into those queues. Regardless of whether you feel able to fix the bug, you should still file bugs where you see them.\n\nIf you want to try your hand at fixing your newly-filed bug, assign it to yourself. You will need to clone the HBase Git repository to your local system and work on the issue there. When you have developed a potential fix, submit it for review. If it addresses the issue and is seen as an improvement, one of the HBase committers will commit it to one or more branches, as appropriate.\n\n### Procedure: Suggested Work flow for Submitting Patches\n\nThis procedure goes into more detail than Git pros will need, but is included in this appendix so that people unfamiliar with Git can feel confident contributing to HBase while they learn.\n\n<Steps>\n  <Step>\n    If you have not already done so, clone the Git repository locally. You only need to do this once.\n  </Step>\n\n  <Step>\n    Fairly often, pull remote changes into your local repository by using the `git pull` command,\n    while your tracking branch is checked out.\n  </Step>\n\n  <Step>\n    For each issue you work on, create a new branch. One convention that works well for naming the branches is to name a given branch the same as the JIRA it relates to:\n\n    ```bash\n    $ git checkout -b HBASE-123456\n    ```\n  </Step>\n\n  <Step>\n    Make your suggested changes on your branch, committing your changes to your local repository\n    often. If you need to switch to working on a different issue, remember to check out the\n    appropriate branch.\n  </Step>\n\n  <Step>\n    When you are ready to submit your patch, first be sure that HBase builds cleanly and behaves as\n    expected in your modified branch.\n  </Step>\n\n  <Step>\n    If you have made documentation or website changes, verify that the site builds correctly by\n    running the development server from the `hbase-website/` directory.\n  </Step>\n\n  <Step>\n    If it takes you several days or weeks to implement your fix, or you know that the area of the code you are working in has had a lot of changes lately, make sure you rebase your branch against the remote master and take care of any conflicts before submitting your patch.\n\n    ```bash\n    $ git checkout HBASE-123456\n    $ git rebase origin/master\n    ```\n  </Step>\n\n  <Step>\n    Generate your patch against the remote master. Run the following command from the top level of your git repository (usually called `hbase`):\n\n    ```bash\n    $ git format-patch --stdout origin/master > HBASE-123456.patch\n    ```\n\n    The name of the patch should contain the JIRA ID.\n  </Step>\n\n  <Step>\n    Look over the patch file to be sure that you did not change any additional files by accident and\n    that there are no other surprises.\n  </Step>\n\n  <Step>\n    When you are satisfied, attach the patch to the JIRA and click the **Patch Available** button. A\n    reviewer will review your patch.\n  </Step>\n\n  <Step>\n    If you need to submit a new version of the patch, leave the old one on the JIRA and add a version\n    number to the name of the new patch.\n  </Step>\n\n  <Step>\n    After a change has been committed, there is no need to keep your local branch around.\n  </Step>\n</Steps>\n\n## Editing the HBase Website and Documentation\n\nThe HBase website and documentation are now part of a single application built with Remix and Fumadocs. The source files are located in the `hbase-website/` directory:\n\n* **Documentation pages**: `hbase-website/app/pages/_docs/docs/_mdx/(multi-page)/` - individual MDX files for each documentation section\n* **Single-page view**: `hbase-website/app/pages/_docs/docs/_mdx/single-page/index.mdx` - combines all documentation into one page\n* **Website components**: `hbase-website/app/components/` - React components used throughout the site\n* **Images**: `hbase-website/public/` - static assets including images\n\nYou can edit MDX files in any text editor or IDE. To preview your changes locally, run the development server from the `hbase-website/` directory and navigate to the documentation pages in your browser. When you are satisfied with your changes, follow the procedure in [submit doc patch procedure](/docs/contributing-to-documentation#procedure-suggested-work-flow-for-submitting-patches) to submit your patch.\n\n## Publishing the HBase Website and Documentation\n\nThe HBase website and documentation are built and deployed as a single Remix application. The deployment process is managed through the project's CI/CD pipeline, which builds the site from the `hbase-website/` directory and deploys it automatically when changes are merged to the main branch.\n\n## MDX and Fumadocs Components\n\nThe HBase documentation is written in MDX (Markdown with JSX), which allows you to use standard Markdown syntax along with React components. For comprehensive documentation on Markdown formatting and MDX features, refer to:\n\n* [Fumadocs Markdown Documentation](https://www.fumadocs.dev/docs/markdown) - Complete guide to MDX syntax and Fumadocs features\n* [CommonMark specification](https://commonmark.org/) - Standard Markdown syntax reference\n* [GFM (GitHub Flavored Markdown)](https://github.github.com/gfm) - GitHub-style Markdown extensions\n\n### Fumadocs Components\n\nFumadocs provides several components that enhance the documentation:\n\n#### Steps Component\n\nUse `<Steps>` to create numbered step-by-step instructions:\n\n```mdx\n<Steps>\n\n<Step>First, do this thing.</Step>\n\n<Step>Then, do this other thing.</Step>\n\n</Steps>\n```\n\n**Example output:**\n\n<Steps>\n  <Step>\n    First, do this thing.\n  </Step>\n\n  <Step>\n    Then, do this other thing.\n  </Step>\n</Steps>\n\n#### Callout Component\n\nUse `<Callout>` for notes, warnings, and important information:\n\n```mdx\n<Callout type=\"info\">This is an informational callout.</Callout>\n\n<Callout type=\"warning\">This is a warning callout.</Callout>\n```\n\n**Example output:**\n\n<Callout type=\"info\">\n  This is an informational callout.\n</Callout>\n\n<Callout type=\"warning\">\n  This is a warning callout.\n</Callout>\n\n#### Include Directive\n\nThe single-page documentation view uses `<include>` tags to combine multiple MDX files:\n\n```mdx\n<include>../(multi-page)/getting-started.mdx</include>\n```\n\nSee `hbase-website/app/pages/_docs/docs/_mdx/single-page/index.mdx` for examples of how all documentation sections are included in the single-page view.\n\n## Auto-Generated Content\n\nSome parts of the HBase documentation, such as the [default configuration](/docs/configuration/default), are generated automatically to stay in sync with the code. The configuration documentation is generated from the `hbase-common/src/main/resources/hbase-default.xml` file.\n\nTo add or modify configuration parameters, update the source XML file. To regenerate the documentation from the updated configuration, run:\n\n```bash\nnpm run extract-hbase-config\n```\n\nThis command is also executed automatically when you run `npm ci`.\n\n## Images in the Documentation\n\nYou can include images in the HBase documentation using standard Markdown syntax. Always include descriptive alt text for accessibility:\n\n```markdown\n![Alt text describing the image](/path/to/image.png)\n```\n\nSave images to the `hbase-website/public/` directory or an appropriate subdirectory. Reference them in your MDX files using absolute paths from the public directory:\n\n```markdown\n![Architecture diagram](/images/architecture-diagram.png)\n```\n\nWhen submitting a patch that includes images, attach the images to the JIRA issue.\n\n## Adding a New Section to the Documentation\n\nTo add a new section to the HBase documentation:\n\n1. Create a new MDX file in `hbase-website/app/pages/_docs/docs/_mdx/(multi-page)/` with a descriptive name (e.g., `my-new-section.mdx`)\n2. Add frontmatter at the top of the file with a title and description:\n\n```mdx\n---\ntitle: \"My New Section\"\ndescription: \"Brief description of what this section covers\"\n---\n\n## My New Section\n\nYour content here...\n```\n\n3. Add your new file to `hbase-website/app/pages/_docs/docs/_mdx/(multi-page)/meta.json` in the appropriate location within the `pages` array (without the `.mdx` extension):\n\n```json\n{\n  \"pages\": [\n    \"---My Category---\",\n    \"my-new-section\",\n    ...\n  ]\n}\n```\n\n4. Add an `<include>` directive to `hbase-website/app/pages/_docs/docs/_mdx/single-page/index.mdx` in the appropriate location:\n\n```mdx\n<include>../(multi-page)/my-new-section.mdx</include>\n```\n\n5. Add your new file to Git before creating your patch.\n\n## Unique Headings Requirement\n\nSince all documentation files are merged into a single-page view, **all heading IDs must be unique across the entire documentation**. A test will fail during the build if duplicate heading IDs are detected, marking the problematic headings.\n\nHeadings don't have to be visually unique, but their link IDs must be unique. You can customize the heading ID using Fumadocs syntax:\n\n```markdown\n## Configuration [#server-configuration]\n```\n\nThis creates a heading that displays as \"Configuration\" but has the unique ID `#server-configuration` for linking purposes.\n\n### Hiding Headings from Table of Contents\n\nYou can hide specific headings from the right-side table of contents:\n\n```markdown\n## Internal Implementation Details [!toc]\n```\n\nThis heading will still appear in the document but won't show up in the table of contents navigation.\n\n<Callout type=\"warning\">\n  Note: `[!toc]` becomes part of the heading ID. For example, `## Usage [!toc]` will have the ID\n  `#usage-toc`.\n</Callout>\n\n### Combining Custom IDs and TOC Hiding\n\nYou can combine both attributes:\n\n```markdown\n## Configuration Details [#server-config] [!toc]\n```\n\n## Common Documentation Issues\n\nThe following documentation issues come up often:\n\n1. **Isolate Changes for Easy Diff Review**\n\n   Avoid reformatting entire files when making content changes. If you need to reformat a file, do that in a separate JIRA where you do not change any content.\n\n2. **Syntax Highlighting**\n\n   MDX supports syntax highlighting for code blocks. Specify the language after the opening triple backticks:\n\n   ````markdown\n   ```java\n   public class Example {\n       // your code here\n   }\n   ```\n   ````\n\n3. **Component Syntax**\n\n   Remember to properly close Fumadocs components. Components like `<Steps>` and `<Callout>` must be properly closed:\n\n   ```mdx\n   <Callout>Your content here</Callout>\n   ```\n\n4. **Unique Heading IDs**\n\n   Ensure all heading IDs are unique across the entire documentation. If you get a test failure about duplicate headings, customize the heading ID using `[#custom-id]` syntax as described in the [Unique Headings Requirement](#unique-headings-requirement) section.\n\n\n# Apache HBase Coprocessors (/docs/cp)\nHBase Coprocessors are modeled after Google BigTable's coprocessor implementation\n([http://research.google.com/people/jeff/SOCC2010-keynote-slides.pdf](http://research.google.com/people/jeff/SOCC2010-keynote-slides.pdf) pages 41-42.).\nEfforts are ongoing to bridge gaps between HBase's\nimplementation and BigTable's architecture. For more information see\n[HBASE-4047](https://issues.apache.org/jira/browse/HBASE-4047).\n\nThe information in this chapter is primarily sourced and heavily reused from the following\nresources:\n\n1. Mingjie Lai's blog post\n   [Coprocessor Introduction](https://blogs.apache.org/hbase/entry/coprocessor_introduction).\n2. Gaurav Bhardwaj's blog post\n   [The How To Of HBase Coprocessors](http://www.3pillarglobal.com/insights/hbase-coprocessors).\n\n<Callout type=\"warn\" title=\"Use Coprocessors At Your Own Risk\">\n  Coprocessors are an advanced feature of HBase and are intended to be used by system\n  developers only. Because coprocessor code runs directly on the RegionServer and has\n  direct access to your data, they introduce the risk of data corruption, man-in-the-middle\n  attacks, or other malicious data access. Currently, there is no mechanism to prevent\n  data corruption by coprocessors, though work is underway on\n  [HBASE-4047](https://issues.apache.org/jira/browse/HBASE-4047).\n\n  In addition, there is no resource isolation, so a well-intentioned but misbehaving\n  coprocessor can severely degrade cluster performance and stability.\n</Callout>\n\n## Coprocessor Overview\n\nIn HBase, you fetch data using a `Get` or `Scan`, whereas in an RDBMS you use a SQL\nquery. In order to fetch only the relevant data, you filter it using a HBase\n[Filter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/Filter.html)\n, whereas in an RDBMS you use a `WHERE` predicate.\n\nAfter fetching the data, you perform computations on it. This paradigm works well\nfor \"small data\" with a few thousand rows and several columns. However, when you scale\nto billions of rows and millions of columns, moving large amounts of data across your\nnetwork will create bottlenecks at the network layer, and the client needs to be powerful\nenough and have enough memory to handle the large amounts of data and the computations.\nIn addition, the client code can grow large and complex.\n\nIn this scenario, coprocessors might make sense. You can put the business computation\ncode into a coprocessor which runs on the RegionServer, in the same location as the\ndata, and returns the result to the client.\n\nThis is only one scenario where using coprocessors can provide benefit. Following\nare some analogies which may help to explain some of the benefits of coprocessors.\n\n### Coprocessor Analogies\n\n**Triggers and Stored Procedure**\\\nAn Observer coprocessor is similar to a trigger in a RDBMS in that it executes\nyour code either before or after a specific event (such as a `Get` or `Put`)\noccurs. An endpoint coprocessor is similar to a stored procedure in a RDBMS\nbecause it allows you to perform custom computations on the data on the\nRegionServer itself, rather than on the client.\n\n**MapReduce**\\\nMapReduce operates on the principle of moving the computation to the location of\nthe data. Coprocessors operate on the same principal.\n\n**AOP**\\\nIf you are familiar with Aspect Oriented Programming (AOP), you can think of a coprocessor\nas applying advice by intercepting a request and then running some custom code,\nbefore passing the request on to its final destination (or even changing the destination).\n\n### Coprocessor Implementation Overview\n\n1. Your class should implement one of the Coprocessor interfaces -\n   [Coprocessor](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/Coprocessor.html),\n   [RegionObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html),\n   [CoprocessorService](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/CoprocessorService.html) - to name a few.\n2. Load the coprocessor, either statically (from the configuration) or dynamically,\n   using HBase Shell. For more details see [Loading Coprocessors](/docs/cp#loading-coprocessors).\n3. Call the coprocessor from your client-side code. HBase handles the coprocessor\n   transparently.\n\nThe framework API is provided in the\n[coprocessor](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/package-summary.html)\npackage.\n\n## Types of Coprocessors\n\n### Observer Coprocessors\n\nObserver coprocessors are triggered either before or after a specific event occurs.\nObservers that happen before an event use methods that start with a `pre` prefix,\nsuch as [`prePut`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html#prePut\\(org.apache.hadoop.hbase.coprocessor.ObserverContext,org.apache.hadoop.hbase.client.Put,org.apache.hadoop.hbase.wal.WALEdit\\)). Observers that happen just after an event override methods that start\nwith a `post` prefix, such as [`postPut`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html#postPut\\(org.apache.hadoop.hbase.coprocessor.ObserverContext,org.apache.hadoop.hbase.client.Put,org.apache.hadoop.hbase.wal.WALEdit\\)).\n\n#### Use Cases for Observer Coprocessors\n\n**Security**\\\nBefore performing a `Get` or `Put` operation, you can check for permission using\n`preGet` or `prePut` methods.\n\n**Referential Integrity**\\\nHBase does not directly support the RDBMS concept of refential integrity, also known\nas foreign keys. You can use a coprocessor to enforce such integrity. For instance,\nif you have a business rule that every insert to the `users` table must be followed\nby a corresponding entry in the `user_daily_attendance` table, you could implement\na coprocessor to use the `prePut` method on `user` to insert a record into `user_daily_attendance`.\n\n**Secondary Indexes**\\\nYou can use a coprocessor to maintain secondary indexes. For more information, see\n[SecondaryIndexing](https://cwiki.apache.org/confluence/display/HADOOP2/Hbase+SecondaryIndexing).\n\n#### Types of Observer Coprocessor\n\n**RegionObserver**\\\nA RegionObserver coprocessor allows you to observe events on a region, such as `Get`\nand `Put` operations. See\n[RegionObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html).\n\n**RegionServerObserver**\\\nA RegionServerObserver allows you to observe events related to the RegionServer's\noperation, such as starting, stopping, or performing merges, commits, or rollbacks.\nSee\n[RegionServerObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionServerObserver.html).\n\n**MasterObserver**\\\nA MasterObserver allows you to observe events related to the HBase Master, such\nas table creation, deletion, or schema modification. See\n[MasterObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/MasterObserver.html).\n\n**WalObserver**\\\nA WalObserver allows you to observe events related to writes to the Write-Ahead\nLog (WAL). See\n[WALObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/WALObserver.html).\n\n[Examples](/docs/cp#cp-examples) provides working examples of observer coprocessors.\n\n### Endpoint Coprocessor\n\nEndpoint processors allow you to perform computation at the location of the data.\nSee [Coprocessor Analogy](/docs/cp#coprocessor-analogies). An example is the need to calculate a running\naverage or summation for an entire table which spans hundreds of regions.\n\nIn contrast to observer coprocessors, where your code is run transparently, endpoint\ncoprocessors must be explicitly invoked using the\n[CoprocessorService()](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/AsyncTable.html#coprocessorService\\(java.util.function.Function,org.apache.hadoop.hbase.client.ServiceCaller,byte%5B%5D\\))\nmethod available in\n[AsyncTable](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/AsyncTable.html).\n\n<Callout type=\"warn\" title=\"On using coprocessorService method with sync client\">\n  The coprocessorService method in [Table](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html)\n  has been deprecated.\n\n  In [HBASE-21512](https://issues.apache.org/jira/browse/HBASE-21512)\n  we reimplement the sync client based on the async client. The coprocessorService\n  method defined in `Table` interface directly references a method from protobuf's\n  `BlockingInterface`, which means we need to use a separate thread pool to execute\n  the method so we avoid blocking the async client(We want to avoid blocking calls in\n  our async implementation).\n\n  Since coprocessor is an advanced feature, we believe it is OK for coprocessor users to\n  instead switch over to use `AsyncTable`. There is a lightweight\n  [toAsyncConnection](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Connection.html#toAsyncConnection\\(\\))\n  method to get an `AsyncConnection` from `Connection` if needed.\n</Callout>\n\nStarting with HBase 0.96, endpoint coprocessors are implemented using Google Protocol\nBuffers (protobuf). For more details on protobuf, see Google's\n[Protocol Buffer Guide](https://developers.google.com/protocol-buffers/docs/proto).\nEndpoints Coprocessor written in version 0.94 are not compatible with version 0.96 or later.\nSee\n[HBASE-5448](https://issues.apache.org/jira/browse/HBASE-5448)). To upgrade your\nHBase cluster from 0.94 or earlier to 0.96 or later, you need to reimplement your\ncoprocessor.\n\nIn HBase 2.x, we made use of a shaded version of protobuf 3.x, but kept the\nprotobuf for coprocessors on 2.5.0. In HBase 3.0.0, we removed all dependencies on\nnon-shaded protobuf so you need to reimplement your coprocessor to make use of the\nshaded protobuf version provided in hbase-thirdparty. Please see\nthe [protobuf](/docs/protobuf) section for more details.\n\nCoprocessor Endpoints should make no use of HBase internals and\nonly avail of public APIs; ideally a CPEP should depend on Interfaces\nand data structures only. This is not always possible but beware\nthat doing so makes the Endpoint brittle, liable to breakage as HBase\ninternals evolve. HBase internal APIs annotated as private or evolving\ndo not have to respect semantic versioning rules or general java rules on\ndeprecation before removal. While generated protobuf files are\nabsent the hbase audience annotations — they are created by the\nprotobuf protoc tool which knows nothing of how HBase works —\nthey should be consided `@InterfaceAudience.Private` so are liable to\nchange.\n\n[Examples](/docs/cp#cp-examples) provides working examples of endpoint coprocessors.\n\n## Loading Coprocessors\n\nTo make your coprocessor available to HBase, it must be *loaded*, either statically\n(through the HBase configuration) or dynamically (using HBase Shell or the Java API).\n\n### Static Loading\n\nFollow these steps to statically load your coprocessor. Keep in mind that you must\nrestart HBase to unload a coprocessor that has been loaded statically.\n\n1. Define the Coprocessor in *hbase-site.xml*, with a `<property>` element with a `<name>`\n   and a `<value>` sub-element. The `<name>` should be one of the following:\n\n   * `hbase.coprocessor.region.classes` for RegionObservers and Endpoints.\n   * `hbase.coprocessor.wal.classes` for WALObservers.\n   * `hbase.coprocessor.master.classes` for MasterObservers.\n\n     `<value>` must contain the fully-qualified class name of your coprocessor's implementation\n     class.\n\n     For example to load a Coprocessor (implemented in class SumEndPoint.java) you have to create\n     following entry in RegionServer's 'hbase-site.xml' file (generally located under 'conf' directory):\n\n     ```xml\n     <property>\n         <name>hbase.coprocessor.region.classes</name>\n         <value>org.myname.hbase.coprocessor.endpoint.SumEndPoint</value>\n     </property>\n     ```\n\n     If multiple classes are specified for loading, the class names must be comma-separated.\n     The framework attempts to load all the configured classes using the default class loader.\n     Therefore, the jar file must reside on the server-side HBase classpath.\n\n     Coprocessors which are loaded in this way will be active on all regions of all tables.\n     These are also called system Coprocessor.\n     The first listed Coprocessors will be assigned the priority `Coprocessor.Priority.SYSTEM`.\n     Each subsequent coprocessor in the list will have its priority value incremented by one (which\n     reduces its priority, because priorities have the natural sort order of Integers).\n\n     These priority values can be manually overriden in hbase-site.xml. This can be useful if you\n     want to guarantee that a coprocessor will execute after another. For example, in the following\n     configuration `SumEndPoint` would be guaranteed to go last, except in the case of a tie with\n     another coprocessor:\n\n     ```xml\n     <property>\n         <name>hbase.coprocessor.region.classes</name>\n         <value>org.myname.hbase.coprocessor.endpoint.SumEndPoint|2147483647</value>\n     </property>\n     ```\n\n   When calling out to registered observers, the framework executes their callbacks methods in the\n   sorted order of their priority.\n   Ties are broken arbitrarily.\n\n2. Put your code on HBase's classpath. One easy way to do this is to drop the jar\n   (containing you code and all the dependencies) into the `lib/` directory in the\n   HBase installation.\n\n3. Restart HBase.\n\n### Static Unloading\n\n1. Delete the coprocessor's `<property>` element, including sub-elements, from `hbase-site.xml`.\n2. Restart HBase.\n3. Optionally, remove the coprocessor's JAR file from the classpath or HBase's `lib/`\n   directory.\n\n### Dynamic Loading\n\nYou can also load a coprocessor dynamically, without restarting HBase. This may seem\npreferable to static loading, but dynamically loaded coprocessors are loaded on a\nper-table basis, and are only available to the table for which they were loaded. For\nthis reason, dynamically loaded tables are sometimes called **Table Coprocessor**.\n\nIn addition, dynamically loading a coprocessor acts as a schema change on the table,\nand the table must be taken offline to load the coprocessor.\n\nThere are three ways to dynamically load Coprocessor.\n\n<Callout type=\"info\" title=\"Assumptions\">\n  The below mentioned instructions makes the following assumptions:\n\n  * A JAR called `coprocessor.jar` contains the Coprocessor implementation along with all of its\n    dependencies.\n  * The JAR is available in HDFS in some location like\n    `hdfs://NAMENODE:PORT/user/HADOOP_USER/coprocessor.jar`.\n</Callout>\n\n#### Using HBase Shell\n\n1. Load the Coprocessor, using a command like the following:\n\n   ```ruby\n   hbase alter 'users', METHOD => 'table_att', 'Coprocessor'=>'hdfs://NAMENODE:PORT/user/HADOOP_USER/coprocessor.jar|org.myname.hbase.Coprocessor.RegionObserverExample|1073741823|arg1=1,arg2=2'\n   ```\n\n   The Coprocessor framework will try to read the class information from the coprocessor table\n   attribute value.\n   The value contains four pieces of information which are separated by the pipe (`|`) character.\n\n   * File path: The jar file containing the Coprocessor implementation must be in a location where\n     all region servers can read it.\n     You could copy the file onto the local disk on each region server, but it is recommended to store\n     it in HDFS.\n     [HBASE-14548](https://issues.apache.org/jira/browse/HBASE-14548) allows a directory containing the jars\n     or some wildcards to be specified, such as: `hdfs://NAMENODE:PORT/user/HADOOP_USER/` or\n     `hdfs://NAMENODE:PORT/user/HADOOP_USER/*.jar`. Please note that if a directory is specified,\n     all jar files(.jar) in the directory are added. It does not search for files in sub-directories.\n     Do not use a wildcard if you would like to specify a directory. This enhancement applies to the\n     usage via the JAVA API as well.\n   * Class name: The full class name of the Coprocessor.\n   * Priority: An integer. The framework will determine the execution sequence of all configured\n     observers registered at the same hook using priorities. This field can be left blank. In that\n     case the framework will assign a default priority value.\n   * Arguments (Optional): This field is passed to the Coprocessor implementation. This is optional.\n\n2. Verify that the coprocessor loaded:\n\n   ```ruby\n   hbase(main):04:0> describe 'users'\n   ```\n\n   The coprocessor should be listed in the `TABLE_ATTRIBUTES`.\n\n#### Using the Java API (all HBase versions)\n\nThe following Java code shows how to use the `setValue()` method of `HTableDescriptor`\nto load a coprocessor on the `users` table.\n\n```java\nTableName tableName = TableName.valueOf(\"users\");\nString path = \"hdfs://<namenode>:<port>/user/<hadoop-user>/coprocessor.jar\";\nConfiguration conf = HBaseConfiguration.create();\nConnection connection = ConnectionFactory.createConnection(conf);\nAdmin admin = connection.getAdmin();\nHTableDescriptor hTableDescriptor = new HTableDescriptor(tableName);\nHColumnDescriptor columnFamily1 = new HColumnDescriptor(\"personalDet\");\ncolumnFamily1.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily1);\nHColumnDescriptor columnFamily2 = new HColumnDescriptor(\"salaryDet\");\ncolumnFamily2.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily2);\nhTableDescriptor.setValue(\"COPROCESSOR$1\", path + \"|\"\n+ RegionObserverExample.class.getCanonicalName() + \"|\"\n+ Coprocessor.PRIORITY_USER);\nadmin.modifyTable(tableName, hTableDescriptor);\n```\n\n#### Using the Java API (HBase 0.96+ only)\n\nIn HBase 0.96 and newer, the `addCoprocessor()` method of `HTableDescriptor` provides\nan easier way to load a coprocessor dynamically.\n\n```java\nTableName tableName = TableName.valueOf(\"users\");\nPath path = new Path(\"hdfs://<namenode>:<port>/user/<hadoop-user>/coprocessor.jar\");\nConfiguration conf = HBaseConfiguration.create();\nConnection connection = ConnectionFactory.createConnection(conf);\nAdmin admin = connection.getAdmin();\nHTableDescriptor hTableDescriptor = new HTableDescriptor(tableName);\nHColumnDescriptor columnFamily1 = new HColumnDescriptor(\"personalDet\");\ncolumnFamily1.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily1);\nHColumnDescriptor columnFamily2 = new HColumnDescriptor(\"salaryDet\");\ncolumnFamily2.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily2);\nhTableDescriptor.addCoprocessor(RegionObserverExample.class.getCanonicalName(), path,\nCoprocessor.PRIORITY_USER, null);\nadmin.modifyTable(tableName, hTableDescriptor);\n```\n\n<Callout type=\"warn\">\n  There is no guarantee that the framework will load a given Coprocessor successfully. For example,\n  the shell command neither guarantees a jar file exists at a particular location nor verifies\n  whether the given class is actually contained in the jar file.\n</Callout>\n\n### Dynamic Unloading\n\n#### Using HBase Shell\n\n1. Alter the table to remove the coprocessor with `table_att_unset`.\n\n   ```ruby\n   hbase> alter 'users', METHOD => 'table_att_unset', NAME => 'coprocessor$1'\n   ```\n\n2. Alter the table to remove the coprocessor with `table_remove_coprocessor` introduced in\n   [HBASE-26524](https://issues.apache.org/jira/browse/HBASE-26524) by specifying an explicit\n   classname\n\n   ```ruby\n   hbase> alter 'users', METHOD => 'table_remove_coprocessor', CLASSNAME => \\\n       'org.myname.hbase.Coprocessor.RegionObserverExample'\n   ```\n\n#### Using the Java API\n\nReload the table definition without setting the value of the coprocessor either by\nusing `setValue()` or `addCoprocessor()` methods. This will remove any coprocessor\nattached to the table.\n\n```java\nTableName tableName = TableName.valueOf(\"users\");\nString path = \"hdfs://<namenode>:<port>/user/<hadoop-user>/coprocessor.jar\";\nConfiguration conf = HBaseConfiguration.create();\nConnection connection = ConnectionFactory.createConnection(conf);\nAdmin admin = connection.getAdmin();\nHTableDescriptor hTableDescriptor = new HTableDescriptor(tableName);\nHColumnDescriptor columnFamily1 = new HColumnDescriptor(\"personalDet\");\ncolumnFamily1.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily1);\nHColumnDescriptor columnFamily2 = new HColumnDescriptor(\"salaryDet\");\ncolumnFamily2.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily2);\nadmin.modifyTable(tableName, hTableDescriptor);\n```\n\nIn HBase 0.96 and newer, you can instead use the `removeCoprocessor()` method of the\n`HTableDescriptor` class.\n\n## Examples\n\nHBase ships examples for Observer Coprocessor.\n\nA more detailed example is given below.\n\nThese examples assume a table called `users`, which has two column families `personalDet`\nand `salaryDet`, containing personal and salary details. Below is the graphical representation\nof the `users` table.\n\n**Users Table**\n\n|            | **personalDet** |              |            | **salaryDet** |         |                |\n| ---------- | --------------- | ------------ | ---------- | ------------- | ------- | -------------- |\n| **rowkey** | **name**        | **lastname** | **dob**    | **gross**     | **net** | **allowances** |\n| admin      | Admin           | Admin        |            |               |         |                |\n| cdickens   | Charles         | Dickens      | 02/07/1812 | 10000         | 8000    | 2000           |\n| jverne     | Jules           | Verne        | 02/08/1828 | 12000         | 9000    | 3000           |\n\n### Observer Example\n\nThe following Observer coprocessor prevents the details of the user `admin` from being\nreturned in a `Get` or `Scan` of the `users` table.\n\n1. Write a class that implements the\n   [RegionCoprocessor](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionCoprocessor.html),\n   [RegionObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html)\n   class.\n2. Override the `preGetOp()` method (the `preGet()` method is deprecated) to check\n   whether the client has queried for the rowkey with value `admin`. If so, return an\n   empty result. Otherwise, process the request as normal.\n3. Put your code and dependencies in a JAR file.\n4. Place the JAR in HDFS where HBase can locate it.\n5. Load the Coprocessor.\n6. Write a simple program to test it.\n\nFollowing are the implementation of the above steps:\n\n```java\npublic class RegionObserverExample implements RegionCoprocessor, RegionObserver {\n\n    private static final byte[] ADMIN = Bytes.toBytes(\"admin\");\n    private static final byte[] COLUMN_FAMILY = Bytes.toBytes(\"details\");\n    private static final byte[] COLUMN = Bytes.toBytes(\"Admin_det\");\n    private static final byte[] VALUE = Bytes.toBytes(\"You can't see Admin details\");\n\n    @Override\n    public Optional<RegionObserver> getRegionObserver() {\n      return Optional.of(this);\n    }\n\n    @Override\n    public void preGetOp(final ObserverContext<RegionCoprocessorEnvironment> e, final Get get, final List<Cell> results)\n    throws IOException {\n\n        if (Bytes.equals(get.getRow(),ADMIN)) {\n            Cell c = CellUtil.createCell(get.getRow(),COLUMN_FAMILY, COLUMN,\n            System.currentTimeMillis(), (byte)4, VALUE);\n            results.add(c);\n            e.bypass();\n        }\n    }\n}\n```\n\nOverriding the `preGetOp()` will only work for `Get` operations. You also need to override\nthe `preScannerOpen()` method to filter the `admin` row from scan results.\n\n```java\n@Override\npublic RegionScanner preScannerOpen(final ObserverContext<RegionCoprocessorEnvironment> e, final Scan scan,\nfinal RegionScanner s) throws IOException {\n\n    Filter filter = new RowFilter(CompareOp.NOT_EQUAL, new BinaryComparator(ADMIN));\n    scan.setFilter(filter);\n    return s;\n}\n```\n\nThis method works but there is a *side effect*. If the client has used a filter in\nits scan, that filter will be replaced by this filter. Instead, you can explicitly\nremove any `admin` results from the scan:\n\n```java\n@Override\npublic boolean postScannerNext(final ObserverContext<RegionCoprocessorEnvironment> e, final InternalScanner s,\nfinal List<Result> results, final int limit, final boolean hasMore) throws IOException {\n        Result result = null;\n    Iterator<Result> iterator = results.iterator();\n    while (iterator.hasNext()) {\n    result = iterator.next();\n        if (Bytes.equals(result.getRow(), ROWKEY)) {\n            iterator.remove();\n            break;\n        }\n    }\n    return hasMore;\n}\n```\n\n### Endpoint Example\n\nStill using the `users` table, this example implements a coprocessor to calculate\nthe sum of all employee salaries, using an endpoint coprocessor.\n\n1. Create a '.proto' file defining your service.\n\n   ```protobuf\n   option java_package = \"org.myname.hbase.coprocessor.autogenerated\";\n   option java_outer_classname = \"Sum\";\n   option java_generic_services = true;\n   option java_generate_equals_and_hash = true;\n   option optimize_for = SPEED;\n   message SumRequest {\n       required string family = 1;\n       required string column = 2;\n   }\n\n   message SumResponse {\n   required int64 sum = 1 [default = 0];\n   }\n\n   service SumService {\n   rpc getSum(SumRequest)\n       returns (SumResponse);\n   }\n   ```\n\n2. Execute the `protoc` command to generate the Java code from the above .proto' file.\n\n   ```bash\n   $ mkdir src\n   $ protoc --java_out=src ./sum.proto\n   ```\n\n   This will generate a class call `Sum.java`.\n\n3. Write a class that extends the generated service class, implement the `Coprocessor`\n   and `CoprocessorService` classes, and override the service method.\n\n   <Callout type=\"warn\">\n     If you load a coprocessor from `hbase-site.xml` and then load the same coprocessor\n     again using HBase Shell, it will be loaded a second time. The same class will\n     exist twice, and the second instance will have a higher ID (and thus a lower priority).\n     The effect is that the duplicate coprocessor is effectively ignored.\n   </Callout>\n\n   ```java\n   public class SumEndPoint extends Sum.SumService implements Coprocessor, CoprocessorService {\n\n       private RegionCoprocessorEnvironment env;\n\n       @Override\n       public Service getService() {\n           return this;\n       }\n\n       @Override\n       public void start(CoprocessorEnvironment env) throws IOException {\n           if (env instanceof RegionCoprocessorEnvironment) {\n               this.env = (RegionCoprocessorEnvironment)env;\n           } else {\n               throw new CoprocessorException(\"Must be loaded on a table region!\");\n           }\n       }\n\n       @Override\n       public void stop(CoprocessorEnvironment env) throws IOException {\n           // do nothing\n       }\n\n       @Override\n       public void getSum(RpcController controller, Sum.SumRequest request, RpcCallback<Sum.SumResponse> done) {\n           Scan scan = new Scan();\n           scan.addFamily(Bytes.toBytes(request.getFamily()));\n           scan.addColumn(Bytes.toBytes(request.getFamily()), Bytes.toBytes(request.getColumn()));\n\n           Sum.SumResponse response = null;\n           InternalScanner scanner = null;\n\n           try {\n               scanner = env.getRegion().getScanner(scan);\n               List<Cell> results = new ArrayList<>();\n               boolean hasMore = false;\n               long sum = 0L;\n\n               do {\n                   hasMore = scanner.next(results);\n                   for (Cell cell : results) {\n                       sum = sum + Bytes.toLong(CellUtil.cloneValue(cell));\n                   }\n                   results.clear();\n               } while (hasMore);\n\n               response = Sum.SumResponse.newBuilder().setSum(sum).build();\n           } catch (IOException ioe) {\n               ResponseConverter.setControllerException(controller, ioe);\n           } finally {\n               if (scanner != null) {\n                   try {\n                       scanner.close();\n                   } catch (IOException ignored) {}\n               }\n           }\n\n           done.run(response);\n       }\n   }\n   ```\n\n   ```java\n   Configuration conf = HBaseConfiguration.create();\n   Connection connection = ConnectionFactory.createConnection(conf);\n   TableName tableName = TableName.valueOf(\"users\");\n   Table table = connection.getTable(tableName);\n\n   final Sum.SumRequest request = Sum.SumRequest.newBuilder().setFamily(\"salaryDet\").setColumn(\"gross\").build();\n   try {\n       Map<byte[], Long> results = table.coprocessorService(\n           Sum.SumService.class,\n           null,  /* start key */\n           null,  /* end   key */\n           new Batch.Call<Sum.SumService, Long>() {\n               @Override\n               public Long call(Sum.SumService aggregate) throws IOException {\n                   BlockingRpcCallback<Sum.SumResponse> rpcCallback = new BlockingRpcCallback<>();\n                   aggregate.getSum(null, request, rpcCallback);\n                   Sum.SumResponse response = rpcCallback.get();\n\n                   return response.hasSum() ? response.getSum() : 0L;\n               }\n           }\n       );\n\n       for (Long sum : results.values()) {\n           System.out.println(\"Sum = \" + sum);\n       }\n   } catch (ServiceException e) {\n       e.printStackTrace();\n   } catch (Throwable e) {\n       e.printStackTrace();\n   }\n   ```\n\n4. Load the Coprocessor.\n\n5. Write a client code to call the Coprocessor.\n\n## Guidelines For Deploying A Coprocessor\n\n**Bundling Coprocessors**\\\nYou can bundle all classes for a coprocessor into a\nsingle JAR on the RegionServer's classpath, for easy deployment. Otherwise,\nplace all dependencies on the RegionServer's classpath so that they can be\nloaded during RegionServer start-up. The classpath for a RegionServer is set\nin the RegionServer's `hbase-env.sh` file.\n\n**Automating Deployment**\\\nYou can use a tool such as Puppet, Chef, or\nAnsible to ship the JAR for the coprocessor to the required location on your\nRegionServers' filesystems and restart each RegionServer, to automate\ncoprocessor deployment. Details for such set-ups are out of scope of this\ndocument.\n\n**Updating a Coprocessor**\\\nDeploying a new version of a given coprocessor is not as simple as disabling it,\nreplacing the JAR, and re-enabling the coprocessor. This is because you cannot\nreload a class in a JVM unless you delete all the current references to it.\nSince the current JVM has reference to the existing coprocessor, you must restart\nthe JVM, by restarting the RegionServer, in order to replace it. This behavior\nis not expected to change.\n\n**Coprocessor Logging**\\\nThe Coprocessor framework does not provide an API for logging beyond standard Java\nlogging.\n\n**Coprocessor Configuration**\\\nIf you do not want to load coprocessors from the HBase Shell, you can add their configuration\nproperties to `hbase-site.xml`. In [Using HBase Shell](/docs/cp#using-hbase-shell), two arguments are\nset: `arg1=1,arg2=2`. These could have been added to `hbase-site.xml` as follows:\n\n```xml\n<property>\n  <name>arg1</name>\n  <value>1</value>\n</property>\n<property>\n  <name>arg2</name>\n  <value>2</value>\n</property>\n```\n\nThen you can read the configuration using code like the following:\n\n```java\nConfiguration conf = HBaseConfiguration.create();\nConnection connection = ConnectionFactory.createConnection(conf);\nTableName tableName = TableName.valueOf(\"users\");\nTable table = connection.getTable(tableName);\n\nGet get = new Get(Bytes.toBytes(\"admin\"));\nResult result = table.get(get);\nfor (Cell c : result.rawCells()) {\n    System.out.println(Bytes.toString(CellUtil.cloneRow(c))\n        + \"==> \" + Bytes.toString(CellUtil.cloneFamily(c))\n        + \"{\" + Bytes.toString(CellUtil.cloneQualifier(c))\n        + \":\" + Bytes.toLong(CellUtil.cloneValue(c)) + \"}\");\n}\nScan scan = new Scan();\nResultScanner scanner = table.getScanner(scan);\nfor (Result res : scanner) {\n    for (Cell c : res.rawCells()) {\n        System.out.println(Bytes.toString(CellUtil.cloneRow(c))\n        + \" ==> \" + Bytes.toString(CellUtil.cloneFamily(c))\n        + \" {\" + Bytes.toString(CellUtil.cloneQualifier(c))\n        + \":\" + Bytes.toLong(CellUtil.cloneValue(c))\n        + \"}\");\n    }\n}\n```\n\n## Restricting Coprocessor Usage\n\nRestricting arbitrary user coprocessors can be a big concern in multitenant environments. HBase provides a continuum of options for ensuring only expected coprocessors are running:\n\n* `hbase.coprocessor.enabled`: Enables or disables all coprocessors. This will limit the functionality of HBase, as disabling all coprocessors will disable some security providers. An example coproccessor so affected is `org.apache.hadoop.hbase.security.access.AccessController`.\n  * `hbase.coprocessor.user.enabled`: Enables or disables loading coprocessors on tables (i.e. user coprocessors).\n  * One can statically load coprocessors, and optionally tune their priorities, via the following tunables in `hbase-site.xml`:\n    * `hbase.coprocessor.regionserver.classes`: A comma-separated list of coprocessors that are loaded by region servers\n    * `hbase.coprocessor.region.classes`: A comma-separated list of RegionObserver and Endpoint coprocessors\n    * `hbase.coprocessor.user.region.classes`: A comma-separated list of coprocessors that are loaded by all regions\n    * `hbase.coprocessor.master.classes`: A comma-separated list of coprocessors that are loaded by the master (MasterObserver coprocessors)\n    * `hbase.coprocessor.wal.classes`: A comma-separated list of WALObserver coprocessors to load\n  * `hbase.coprocessor.abortonerror`: Whether to abort the daemon which has loaded the coprocessor if the coprocessor should error other than `IOError`. If this is set to false and an access controller coprocessor should have a fatal error the coprocessor will be circumvented, as such in secure installations this is advised to be `true`; however, one may override this on a per-table basis for user coprocessors, to ensure they do not abort their running region server and are instead unloaded on error.\n  * `hbase.coprocessor.region.whitelist.paths`: A comma separated list available for those loading `org.apache.hadoop.hbase.security.access.CoprocessorWhitelistMasterObserver` whereby one can use the following options to white-list paths from which coprocessors may be loaded.\n    * Coprocessors on the classpath are implicitly white-listed\n    * `*` to wildcard all coprocessor paths\n    * An entire filesystem (e.g. `hdfs://my-cluster/`)\n    * A wildcard path to be evaluated by [FilenameUtils.wildcardMatch](https://commons.apache.org/proper/commons-io/javadocs/api-release/org/apache/commons/io/FilenameUtils.html)\n    * Note: Path can specify scheme or not (e.g. `file:///usr/hbase/lib/coprocessors` or for all filesystems `/usr/hbase/lib/coprocessors`)\n\n\n# Data Model (/docs/datamodel)\n## HBase Data Model Terminology\n\n#### Table \\[!toc]\n\nAn HBase table consists of multiple rows.\n\n#### Row \\[!toc]\n\nA row in HBase consists of a row key and one or more columns with values associated with them.\nRows are sorted alphabetically by the row key as they are stored.\nFor this reason, the design of the row key is very important.\nThe goal is to store data in such a way that related rows are near each other.\nA common row key pattern is a website domain.\nIf your row keys are domains, you should probably store them in reverse (org.apache.www, org.apache.mail, org.apache.jira). This way, all of the Apache domains are near each other in the table, rather than being spread out based on the first letter of the subdomain.\n\n#### Column \\[!toc]\n\nA column in HBase consists of a column family and a column qualifier, which are delimited by a `:` (colon) character.\n\n#### Column Family \\[!toc]\n\nColumn families physically colocate a set of columns and their values, often for performance reasons.\nEach column family has a set of storage properties, such as whether its values should be cached in memory, how its data is compressed or its row keys are encoded, and others.\nEach row in a table has the same column families, though a given row might not store anything in a given column family.\n\n#### Column Qualifier \\[!toc]\n\nA column qualifier is added to a column family to provide the index for a given piece of data.\nGiven a column family `content`, a column qualifier might be `content:html`, and another might be `content:pdf`.\nThough column families are fixed at table creation, column qualifiers are mutable and may differ greatly between rows.\n\n#### Cell \\[!toc]\n\nA cell is a combination of row, column family, and column qualifier, and contains a value and a timestamp, which represents the value's version.\n\n#### Timestamp \\[!toc]\n\nA timestamp is written alongside each value, and is the identifier for a given version of a value.\nBy default, the timestamp represents the time on the RegionServer when the data was written, but you can specify a different timestamp value when you put data into the cell.\n\n## Conceptual View\n\nYou can read a very understandable explanation of the HBase data model in the blog post [Understanding HBase and BigTable](https://dzone.com/articles/understanding-hbase-and-bigtab) by Jim R. Wilson.\nAnother good explanation is available in the PDF [Introduction to Basic Schema Design](http://0b4af6cdc2f0c5998459-c0245c5c937c5dedcca3f1764ecc9b2f.r43.cf2.rackcdn.com/9353-login1210_khurana.pdf) by Amandeep Khurana.\n\nIt may help to read different perspectives to get a solid understanding of HBase schema design.\nThe linked articles cover the same ground as the information in this section.\n\nThe following example is a slightly modified form of the one on page 2 of the [BigTable](http://research.google.com/archive/bigtable.html) paper.\nThere is a table called `webtable` that contains two rows (`com.cnn.www` and `com.example.www`) and three column families named `contents`, `anchor`, and `people`.\nIn this example, for the first row (`com.cnn.www`), `anchor` contains two columns (`anchor:cssnsi.com`, `anchor:my.look.ca`) and `contents` contains one column (`contents:html`). This example contains 5 versions of the row with the row key `com.cnn.www`, and one version of the row with the row key `com.example.www`.\nThe `contents:html` column qualifier contains the entire HTML of a given website.\nQualifiers of the `anchor` column family each contain the external site which links to the site represented by the row, along with the text it used in the anchor of its link.\nThe `people` column family represents people associated with the site.\n\n<Callout type=\"info\" title=\"Column Names\">\n  By convention, a column name is made of its column family prefix and a *qualifier*. For example,\n  the column *contents:html* is made up of the column family `contents` and the `html` qualifier.\n  The colon character (`:`) delimits the column family from the column family *qualifier*.\n</Callout>\n\n#### Table `webtable` \\[!toc]\n\n| Row Key           | Time Stamp | ColumnFamily `contents`      | ColumnFamily `anchor`         | ColumnFamily `people`      |\n| ----------------- | ---------- | ---------------------------- | ----------------------------- | -------------------------- |\n| \"com.cnn.www\"     | t9         |                              | anchor:cnnsi.com = \"CNN\"      |                            |\n| \"com.cnn.www\"     | t8         |                              | anchor:my.look.ca = \"CNN.com\" |                            |\n| \"com.cnn.www\"     | t6         | contents:html = \"\\<html>...\" |                               |                            |\n| \"com.cnn.www\"     | t5         | contents:html = \"\\<html>...\" |                               |                            |\n| \"com.cnn.www\"     | t3         | contents:html = \"\\<html>...\" |                               |                            |\n| \"com.example.www\" | t5         | contents:html = \"\\<html>...\" |                               | people:author = \"John Doe\" |\n\nCells in this table that appear to be empty do not take space, or in fact exist, in HBase.\nThis is what makes HBase \"sparse.\" A tabular view is not the only possible way to look at data in HBase, or even the most accurate.\nThe following represents the same information as a multi-dimensional map.\nThis is only a mock-up for illustrative purposes and may not be strictly accurate.\n\n```json\n{\n  \"com.cnn.www\": {\n    contents: {\n      t6: contents:html: \"<html>...\"\n      t5: contents:html: \"<html>...\"\n      t3: contents:html: \"<html>...\"\n    }\n    anchor: {\n      t9: anchor:cnnsi.com = \"CNN\"\n      t8: anchor:my.look.ca = \"CNN.com\"\n    }\n    people: {}\n  }\n  \"com.example.www\": {\n    contents: {\n      t5: contents:html: \"<html>...\"\n    }\n    anchor: {}\n    people: {\n      t5: people:author: \"John Doe\"\n    }\n  }\n}\n```\n\n## Physical View\n\nAlthough at a conceptual level tables may be viewed as a sparse set of rows, they are physically stored by column family.\nA new column qualifier (column\\_family:column\\_qualifier) can be added to an existing column family at any time.\n\n#### ColumnFamily `anchor` \\[!toc]\n\n| Row Key       | Time Stamp | Column Family `anchor`          |\n| ------------- | ---------- | ------------------------------- |\n| \"com.cnn.www\" | t9         | `anchor:cnnsi.com = \"CNN\"`      |\n| \"com.cnn.www\" | t8         | `anchor:my.look.ca = \"CNN.com\"` |\n\n#### ColumnFamily `contents` \\[!toc]\n\n| Row Key       | Time Stamp | ColumnFamily `contents:`     |\n| ------------- | ---------- | ---------------------------- |\n| \"com.cnn.www\" | t6         | contents:html = \"\\<html>...\" |\n| \"com.cnn.www\" | t5         | contents:html = \"\\<html>...\" |\n| \"com.cnn.www\" | t3         | contents:html = \"\\<html>...\" |\n\nThe empty cells shown in the conceptual view are not stored at all.\nThus a request for the value of the `contents:html` column at time stamp `t8` would return no value.\nSimilarly, a request for an `anchor:my.look.ca` value at time stamp `t9` would return no value.\nHowever, if no timestamp is supplied, the most recent value for a particular column would be returned.\nGiven multiple versions, the most recent is also the first one found, since timestamps are stored in descending order.\nThus a request for the values of all columns in the row `com.cnn.www` if no timestamp is specified would be: the value of `contents:html` from timestamp `t6`, the value of `anchor:cnnsi.com` from timestamp `t9`, the value of `anchor:my.look.ca` from timestamp `t8`.\n\nFor more information about the internals of how Apache HBase stores data, see [regions.arch](/docs/architecture/regions).\n\n## Namespace\n\nA namespace is a logical grouping of tables analogous to a database in relation database systems.\nThis abstraction lays the groundwork for upcoming multi-tenancy related features:\n\n* Quota Management ([HBASE-8410](https://issues.apache.org/jira/browse/HBASE-8410)) - Restrict the amount of resources (i.e. regions, tables) a namespace can consume.\n* Namespace Security Administration ([HBASE-9206](https://issues.apache.org/jira/browse/HBASE-9206)) - Provide another level of security administration for tenants.\n* Region server groups ([HBASE-6721](https://issues.apache.org/jira/browse/HBASE-6721)) - A namespace/table can be pinned onto a subset of RegionServers thus guaranteeing a coarse level of isolation.\n\n### Namespace management\n\nA namespace can be created, removed or altered.\nNamespace membership is determined during table creation by specifying a fully-qualified table name of the form:\n\n```xml\n<table namespace>:<table qualifier>\n```\n\n#### Examples\n\n```bash\n#Create a namespace\ncreate_namespace 'my_ns'\n```\n\n```bash\n#create my_table in my_ns namespace\ncreate 'my_ns:my_table', 'fam'\n```\n\n```bash\n#drop namespace\ndrop_namespace 'my_ns'\n```\n\n```bash\n#alter namespace\nalter_namespace 'my_ns', {METHOD => 'set', 'PROPERTY_NAME' => 'PROPERTY_VALUE'}\n```\n\n### Predefined namespaces\n\nThere are two predefined special namespaces:\n\n* hbase - system namespace, used to contain HBase internal tables\n* default - tables with no explicit specified namespace will automatically fall into this namespace\n\n#### Examples #datamodel-predefined-namespaces-examples\n\n```bash\n#namespace=foo and table qualifier=bar\ncreate 'foo:bar', 'fam'\n\n#namespace=default and table qualifier=bar\ncreate 'bar', 'fam'\n```\n\n### About hbase:namespace table\n\nWe used to have a system table called `hbase:namespace` for storing the namespace information.\n\nIt introduced some painful bugs in the past, especially that it may hang the master startup thus\nhang the whole cluster. This is because meta table also has a namespace, so it depends on namespace\ntable. But namespace table also depends on meta table as meta table stores the location of all\nregions. This is a cyclic dependency so sometimes namespace and meta table will wait for each other\nto online and hang the master start up.\n\nIt is not easy to fix so in 3.0.0, we decided to completely remove the `hbase:namespace` table and\nfold its content into the `ns` family in `hbase:meta` table. When upgrading from 2.x to 3.x, the\nmigration will be done automatically and the `hbase:namespace` table will be disabled after the\nmigration is done. You are free to leave it there for sometime and finally drop it.\n\nFor more tails, please see [https://issues.apache.org/jira/browse/HBASE-21154](https://issues.apache.org/jira/browse/HBASE-21154).\n\n## Table\n\nTables are declared up front at schema definition time.\n\n## Row\n\nRow keys are uninterpreted bytes.\nRows are lexicographically sorted with the lowest order appearing first in a table.\nThe empty byte array is used to denote both the start and end of a tables' namespace.\n\n## Column Family\n\nColumns in Apache HBase are grouped into *column families*.\nAll column members of a column family have the same prefix.\nFor example, the columns *courses:history* and *courses:math* are both members of the *courses* column family.\nThe colon character (`:`) delimits the column family from the column family qualifier.\nThe column family prefix must be composed of *printable* characters.\nThe qualifying tail, the column family *qualifier*, can be made of any arbitrary bytes.\nColumn families must be declared up front at schema definition time whereas columns do not need to be defined at schema time but can be conjured on the fly while the table is up and running.\n\nPhysically, all column family members are stored together on the filesystem.\nBecause tunings and storage specifications are done at the column family level, it is advised that all column family members have the same general access pattern and size characteristics.\n\n## Cells\n\nA *\\{row, column, version}* tuple exactly specifies a `cell` in HBase.\nCell content is uninterpreted bytes\n\n## Data Model Operations\n\nThe four primary data model operations are Get, Put, Scan, and Delete.\nOperations are applied via [Table](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html) instances.\n\n### Get\n\n[Get](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html) returns attributes for a specified row.\nGets are executed via [Table.get](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#get\\(org.apache.hadoop.hbase.client.Get\\))\n\n### Put\n\n[Put](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Put.html) either adds new rows to a table (if the key is new) or can update existing rows (if the key already exists). Puts are executed via [Table.put](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#put\\(org.apache.hadoop.hbase.client.Put\\)) (non-writeBuffer) or [Table.batch](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#batch\\(java.util.List,java.lang.Object%5B%5D\\)) (non-writeBuffer)\n\n### Scans\n\n[Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) allow iteration over multiple rows for specified attributes.\n\nThe following is an example of a Scan on a Table instance.\nAssume that a table is populated with rows with keys \"row1\", \"row2\", \"row3\", and then another set of rows with the keys \"abc1\", \"abc2\", and \"abc3\". The following example shows how to set a Scan instance to return the rows beginning with \"row\".\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\n\nTable table = ...      // instantiate a Table instance\n\nScan scan = new Scan();\nscan.addColumn(CF, ATTR);\nscan.setStartStopRowForPrefixScan(Bytes.toBytes(\"row\"));\nResultScanner rs = table.getScanner(scan);\ntry {\n  for (Result r = rs.next(); r != null; r = rs.next()) {\n    // process result...\n  }\n} finally {\n  rs.close();  // always close the ResultScanner!\n}\n```\n\nNote that generally the easiest way to specify a specific stop point for a scan is by using the [InclusiveStopFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/InclusiveStopFilter.html) class.\n\n### Delete\n\n[Delete](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Delete.html) removes a row from a table.\nDeletes are executed via [Table.delete](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#delete\\(org.apache.hadoop.hbase.client.Delete\\)).\n\nHBase does not modify data in place, and so deletes are handled by creating new markers called *tombstones*.\nThese tombstones, along with the dead values, are cleaned up on major compactions.\n\nSee [version.delete](/docs/datamodel#delete-toc) for more information on deleting versions of columns, and see [compaction](/docs/architecture/regions#compaction) for more information on compactions.\n\n## Versions\n\nA *\\{row, column, version}* tuple exactly specifies a `cell` in HBase.\nIt's possible to have an unbounded number of cells where the row and column are the same but the cell address differs only in its version dimension.\n\nWhile rows and column keys are expressed as bytes, the version is specified using a long integer.\nTypically this long contains time instances such as those returned by `java.util.Date.getTime()` or `System.currentTimeMillis()`, that is: *the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC*.\n\nThe HBase version dimension is stored in decreasing order, so that when reading from a store file, the most recent values are found first.\n\nThere is a lot of confusion over the semantics of `cell` versions, in HBase.\nIn particular:\n\n* If multiple writes to a cell have the same version, only the last written is fetchable.\n* It is OK to write cells in a non-increasing version order.\n\nBelow we describe how the version dimension in HBase currently works.\nSee [HBASE-2406](https://issues.apache.org/jira/browse/HBASE-2406) for discussion of HBase versions. [Bending time in HBase](https://web.archive.org/web/20160909085951/https://www.ngdata.com/bending-time-in-hbase/) makes for a good read on the version, or time, dimension in HBase.\nIt has more detail on versioning than is provided here.\n\nAs of this writing, the limitation *Overwriting values at existing timestamps* mentioned in the article no longer holds in HBase.\nThis section is basically a synopsis of this article by Bruno Dumon.\n\n### Specifying the Number of Versions to Store\n\nThe maximum number of versions to store for a given column is part of the column schema and is specified at table creation, or via an `alter` command, via `HColumnDescriptor.DEFAULT_VERSIONS`.\nPrior to HBase 0.96, the default number of versions kept was `3`, but in 0.96 and newer has been changed to `1`.\n\n#### Example: Modify the Maximum Number of Versions for a Column Family \\[!toc]\n\nThis example uses HBase Shell to keep a maximum of 5 versions of all columns in column family `f1`.\nYou could also use [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html).\n\n```bash\nhbase> alter 't1', NAME => 'f1', VERSIONS => 5\n```\n\n#### Example: Modify the Minimum Number of Versions for a Column Family \\[!toc]\n\nYou can also specify the minimum number of versions to store per column family.\nBy default, this is set to 0, which means the feature is disabled.\nThe following example sets the minimum number of versions on all columns in column family `f1` to `2`, via HBase Shell.\nYou could also use [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html).\n\n```bash\nhbase> alter 't1', NAME => 'f1', MIN_VERSIONS => 2\n```\n\nStarting with HBase 0.98.2, you can specify a global default for the maximum number of versions kept for all newly-created columns, by setting `hbase.column.max.version` in *hbase-site.xml*.\nSee [hbase.column.max.version](/docs/configuration/default#hbasecolumnmaxversion-toc).\n\n### Versions and HBase Operations\n\nIn this section we look at the behavior of the version dimension for each of the core HBase operations.\n\n#### Get/Scan\n\nGets are implemented on top of Scans.\nThe below discussion of [Get](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html) applies equally to [Scans](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html).\n\nBy default, i.e. if you specify no explicit version, when doing a `get`, the cell whose version has the largest value is returned (which may or may not be the latest one written, see later). The default behavior can be modified in the following ways:\n\n* to return more than one version, see [Get.readVersions(int)](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html#readVersions\\(int\\))\n* to return versions other than the latest, see [Get.setTimeRange(long,long)](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html#setTimeRange\\(long,long\\))\n\nTo retrieve the latest version that is less than or equal to a given value, thus giving the 'latest' state of the record at a certain point in time, just use a range from 0 to the desired version and set the max versions to 1.\n\n#### Default Get Example\n\nThe following Get will only retrieve the current version of the row\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\nGet get = new Get(Bytes.toBytes(\"row1\"));\nResult r = table.get(get);\nbyte[] b = r.getValue(CF, ATTR);  // returns current version of value\n```\n\n#### Versioned Get Example\n\nThe following Get will return the last 3 versions of the row.\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\nGet get = new Get(Bytes.toBytes(\"row1\"));\nget.setMaxVersions(3);  // will return last 3 versions of row\nResult r = table.get(get);\nbyte[] b = r.getValue(CF, ATTR);  // returns current version of value\nList<Cell> cells = r.getColumnCells(CF, ATTR);  // returns all versions of this column\n```\n\n#### Put\n\nDoing a put always creates a new version of a `cell`, at a certain timestamp.\nBy default the system uses the server's `currentTimeMillis`, but you can specify the version (= the long integer) yourself, on a per-column level.\nThis means you could assign a time in the past or the future, or use the long value for non-time purposes.\n\nTo overwrite an existing value, do a put at exactly the same row, column, and version as that of the cell you want to overwrite.\n\n#### Implicit Version Example \\[!toc]\n\nThe following Put will be implicitly versioned by HBase with the current time.\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\nPut put = new Put(Bytes.toBytes(row));\nput.add(CF, ATTR, Bytes.toBytes( data));\ntable.put(put);\n```\n\n#### Explicit Version Example\n\nThe following Put has the version timestamp explicitly set.\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\nPut put = new Put( Bytes.toBytes(row));\nlong explicitTimeInMs = 555;  // just an example\nput.add(CF, ATTR, explicitTimeInMs, Bytes.toBytes(data));\ntable.put(put);\n```\n\nCaution: the version timestamp is used internally by HBase for things like time-to-live calculations.\nIt's usually best to avoid setting this timestamp yourself.\nPrefer using a separate timestamp attribute of the row, or have the timestamp as a part of the row key, or both.\n\n#### Cell Version Example \\[!toc]\n\nThe following Put uses a method getCellBuilder() to get a CellBuilder instance\nthat already has relevant Type and Row set.\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\n\nPut put = new Put(Bytes.toBytes(row));\nput.add(put.getCellBuilder().setQualifier(ATTR)\n   .setFamily(CF)\n   .setValue(Bytes.toBytes(data))\n   .build());\ntable.put(put);\n```\n\n#### Delete \\[!toc]\n\nThere are three different types of internal delete markers.\nSee Lars Hofhansl's blog for discussion of his attempt adding another, [Scanning in HBase: Prefix Delete Marker](http://hadoop-hbase.blogspot.com/2012/01/scanning-in-hbase.html).\n\n* Delete: for a specific version of a column.\n* Delete column: for all versions of a column.\n* Delete family: for all columns of a particular ColumnFamily\n\nWhen deleting an entire row, HBase will internally create a tombstone for each ColumnFamily (i.e., not each individual column).\n\nDeletes work by creating *tombstone* markers.\nFor example, let's suppose we want to delete a row.\nFor this you can specify a version, or else by default the `currentTimeMillis` is used.\nWhat this means is *delete all cells where the version is less than or equal to this version*.\nHBase never modifies data in place, so for example a delete will not immediately delete (or mark as deleted) the entries in the storage file that correspond to the delete condition.\nRather, a so-called *tombstone* is written, which will mask the deleted values.\nWhen HBase does a major compaction, the tombstones are processed to actually remove the dead values, together with the tombstones themselves.\nIf the version you specified when deleting a row is larger than the version of any value in the row, then you can consider the complete row to be deleted.\n\nFor an informative discussion on how deletes and versioning interact, see the thread [Put w/timestamp -> Deleteall -> Put w/ timestamp fails](https://lists.apache.org/thread/g6s0fkx74hbmc0pplnf5r3gq5xn4vkyt) up on the user mailing list.\n\nAlso see [keyvalue](/docs/architecture/regions#keyvalue) for more information on the internal KeyValue format.\n\nDelete markers are purged during the next major compaction of the store, unless the `KEEP_DELETED_CELLS` option is set in the column family (See [Keeping Deleted Cells](/docs/regionserver-sizing#keeping-deleted-cells)).\nTo keep the deletes for a configurable amount of time, you can set the delete TTL via the `hbase.hstore.time.to.purge.deletes` property in *hbase-site.xml*.\nIf `hbase.hstore.time.to.purge.deletes` is not set, or set to 0, all delete markers, including those with timestamps in the future, are purged during the next major compaction.\nOtherwise, a delete marker with a timestamp in the future is kept until the major compaction which occurs after the time represented by the marker's timestamp plus the value of `hbase.hstore.time.to.purge.deletes`, in milliseconds.\n\n<Callout type=\"info\">\n  This behavior represents a fix for an unexpected change that was introduced in HBase 0.94, and was\n  fixed in [HBASE-10118](https://issues.apache.org/jira/browse/HBASE-10118). The change has been\n  backported to HBase 0.94 and newer branches.\n</Callout>\n\n### Optional New Version and Delete behavior in HBase-2.0.0\n\nIn `hbase-2.0.0`, the operator can specify an alternate version and\ndelete treatment by setting the column descriptor property\n`NEW_VERSION_BEHAVIOR` to true (To set a property on a column family\ndescriptor, you must first disable the table and then alter the\ncolumn family descriptor; see [Keeping Deleted Cells](/docs/regionserver-sizing#keeping-deleted-cells) for an example\nof editing an attribute on a column family descriptor).\n\nThe 'new version behavior', undoes the limitations listed below\nwhereby a `Delete` ALWAYS overshadows a `Put` if at the same\nlocation — i.e. same row, column family, qualifier and timestamp\n\\-- regardless of which arrived first. Version accounting is also\nchanged as deleted versions are considered toward total version count.\nThis is done to ensure results are not changed should a major\ncompaction intercede. See `HBASE-15968` and linked issues for\ndiscussion.\n\nRunning with this new configuration currently costs; we factor\nthe Cell MVCC on every compare so we burn more CPU. The slow\ndown will depend. In testing we've seen between 0% and 25%\ndegradation.\n\nIf replicating, it is advised that you run with the new\nserial replication feature (See `HBASE-9465`; the serial\nreplication feature did NOT make it into `hbase-2.0.0` but\nshould arrive in a subsequent hbase-2.x release) as now\nthe order in which Mutations arrive is a factor.\n\n### Current Limitations\n\nThe below limitations are addressed in hbase-2.0.0. See\nthe section above, [Optional New Version and Delete behavior in HBase-2.0.0](/docs/datamodel#optional-new-version-and-delete-behavior-in-hbase-200).\n\n#### Deletes mask Puts\n\nDeletes mask puts, even puts that happened after the delete was entered.\nSee [HBASE-2256](https://issues.apache.org/jira/browse/HBASE-2256).\nRemember that a delete writes a tombstone, which only disappears after then next major compaction has run.\nSuppose you do a delete of everything `<= T`.\nAfter this you do a new put with a timestamp `<= T`.\nThis put, even if it happened after the delete, will be masked by the delete tombstone.\nPerforming the put will not fail, but when you do a get you will notice the put did have no effect.\nIt will start working again after the major compaction has run.\nThese issues should not be a problem if you use always-increasing versions for new puts to a row.\nBut they can occur even if you do not care about time: just do delete and put immediately after each other, and there is some chance they happen within the same millisecond.\n\n#### Major compactions change query results\n\n*...create three cell versions at t1, t2 and t3, with a maximum-versions\nsetting of 2. So when getting all versions, only the values at t2 and t3 will be\nreturned. But if you delete the version at t2 or t3, the one at t1 will appear again.\nObviously, once a major compaction has run, such behavior will not be the case\nanymore...* (See *Garbage Collection* in [Bending time in HBase](https://web.archive.org/web/20160909085951/https://www.ngdata.com/bending-time-in-hbase/).)\n\n## Sort Order\n\nAll data model operations HBase return data in sorted order.\nFirst by row, then by ColumnFamily, followed by column qualifier, and finally timestamp (sorted in reverse, so newest records are returned first).\n\n## Column Metadata\n\nThere is no store of column metadata outside of the internal KeyValue instances for a ColumnFamily.\nThus, while HBase can support not only a wide number of columns per row, but a heterogeneous set of columns between rows as well, it is your responsibility to keep track of the column names.\n\nThe only way to get a complete set of columns that exist for a ColumnFamily is to process all the rows.\nFor more information about how HBase stores data internally, see [keyvalue](/docs/architecture/regions#keyvalue).\n\n## Joins\n\nWhether HBase supports joins is a common question on the dist-list, and there is a simple answer: it doesn't, at not least in the way that RDBMS' support them (e.g., with equi-joins or outer-joins in SQL). As has been illustrated in this chapter, the read data model operations in HBase are Get and Scan.\n\nHowever, that doesn't mean that equivalent join functionality can't be supported in your application, but you have to do it yourself.\nThe two primary strategies are either denormalizing the data upon writing to HBase, or to have lookup tables and do the join between HBase tables in your application or MapReduce code (and as RDBMS' demonstrate, there are several strategies for this depending on the size of the tables, e.g., nested loops vs.\nhash-joins). So which is the best approach? It depends on what you are trying to do, and as such there isn't a single answer that works for every use case.\n\n## ACID\n\nSee [ACID Semantics](/acid-semantics).\nLars Hofhansl has also written a note on [ACID in HBase](http://hadoop-hbase.blogspot.com/2012/03/acid-in-hbase.html).\n\n\n# Apache HBase External APIs (/docs/external-apis)\nFor information on using the native HBase APIs, refer to [User API Reference](https://hbase.apache.org/apidocs/index.html) and the [HBase APIs](/docs/hbase-apis) chapter.\n\n## REST\n\nRepresentational State Transfer (REST) was introduced in 2000 in the doctoral dissertation of Roy Fielding, one of the principal authors of the HTTP specification.\n\nREST itself is out of the scope of this documentation, but in general, REST allows client-server interactions via an API that is tied to the URL itself. This section discusses how to configure and run the REST server included with HBase, which exposes HBase tables, rows, cells, and metadata as URL specified resources. There is also a nice series of blogs on [How-to: Use the Apache HBase REST Interface](http://blog.cloudera.com/blog/2013/03/how-to-use-the-apache-hbase-rest-interface-part-1/) by Jesse Anderson.\n\n### Starting and Stopping the REST Server\n\nThe included REST server can run as a daemon which starts an embedded Jetty servlet container and deploys the servlet into it. Use one of the following commands to start the REST server in the foreground or background. The port is optional, and defaults to 8080.\n\n```bash\n# Foreground\n$ bin/hbase rest start -p <port>\n\n# Background, logging to a file in $HBASE_LOGS_DIR\n$ bin/hbase-daemon.sh start rest -p <port>\n```\n\nTo stop the REST server, use Ctrl-C if you were running it in the foreground, or the following command if you were running it in the background.\n\n```bash\n$ bin/hbase-daemon.sh stop rest\n```\n\n### Configuring the REST Server and Client\n\nFor information about configuring the REST server and client for SSL, as well as `doAs` impersonation for the REST server, see [Configure the Thrift Gateway to Authenticate on Behalf of the Client](/docs/security/client-access#configure-the-thrift-gateway-to-authenticate-on-behalf-of-the-client) and other portions of the [Securing Apache HBase](/docs/security) chapter.\n\n### Using REST Endpoints\n\nThe following examples use the placeholder server [http://example.com:8000](http://example.com:8000), and the following commands can all be run using `curl` or `wget` commands. You can request plain text (the default), XML , or JSON output by adding no header for plain text, or the header \"Accept: text/xml\" for XML, \"Accept: application/json\" for JSON, or \"Accept: application/x-protobuf\" to for protocol buffers.\n\n<Callout type=\"info\">\n  Unless specified, use `GET` requests for queries, `PUT` or `POST` requests for creation or\n  mutation, and `DELETE` for deletion.\n</Callout>\n\n#### Cluster-Wide Endpoints\n\n| Endpoint           | HTTP Verb | Description                              |\n| ------------------ | --------- | ---------------------------------------- |\n| `/version/cluster` | `GET`     | Version of HBase running on this cluster |\n| `/version/rest`    | `GET`     | Version of the HBase REST Server         |\n| `/status/cluster`  | `GET`     | Cluster status                           |\n| `/`                | `GET`     | List of all non-system tables            |\n\n**Examples:**\n\n```bash\n# Get cluster version\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/version/cluster\"\n\n# Get REST server version\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/version/rest\"\n\n# Get cluster status\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/status/cluster\"\n\n# List all non-system tables\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/\"\n```\n\n#### Namespace Endpoints\n\n| Endpoint                       | HTTP Verb | Description                                      |\n| ------------------------------ | --------- | ------------------------------------------------ |\n| `/namespaces`                  | `GET`     | List all namespaces                              |\n| `/namespaces/namespace`        | `GET`     | Describe a specific namespace                    |\n| `/namespaces/namespace`        | `POST`    | Create a new namespace                           |\n| `/namespaces/namespace/tables` | `GET`     | List all tables in a specific namespace          |\n| `/namespaces/namespace`        | `PUT`     | Alter an existing namespace. Currently not used. |\n| `/namespaces/namespace`        | `DELETE`  | Delete a namespace. The namespace must be empty. |\n\n**Examples:**\n\n```bash\n# List all namespaces\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/namespaces/\"\n\n# Describe a specific namespace\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/namespaces/special_ns\"\n\n# Create a new namespace\ncurl -vi -X POST \\\n  -H \"Accept: text/xml\" \\\n  \"example.com:8000/namespaces/special_ns\"\n\n# List all tables in a specific namespace\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/namespaces/special_ns/tables\"\n\n# Alter an existing namespace\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/namespaces/special_ns\n\n# Delete a namespace\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  \"example.com:8000/namespaces/special_ns\"\n```\n\n#### Table Endpoints\n\n| Endpoint         | HTTP Verb | Description                                                                      |\n| ---------------- | --------- | -------------------------------------------------------------------------------- |\n| `/table/exists`  | `GET`     | Returns if the specified table exists.                                           |\n| `/table/schema`  | `GET`     | Describe the schema of the specified table.                                      |\n| `/table/schema`  | `POST`    | Update an existing table with the provided schema fragment                       |\n| `/table/schema`  | `PUT`     | Create a new table, or replace an existing table's schema                        |\n| `/table/schema`  | `DELETE`  | Delete the table. You must use the `/table/schema` endpoint, not just `/table/`. |\n| `/table/regions` | `GET`     | List the table regions                                                           |\n\n**Examples:**\n\n```bash\n# Check if table exists\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/exists\"\n\n# Get table schema\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/schema\"\n\n# Update table schema\ncurl -vi -X POST \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\"?><TableSchema name=\"users\"><ColumnSchema name=\"cf\" KEEP_DELETED_CELLS=\"true\" /></TableSchema>' \\\n  \"http://example.com:8000/users/schema\"\n\n# Create or replace table schema\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\"?><TableSchema name=\"users\"><ColumnSchema name=\"cf\" /></TableSchema>' \\\n  \"http://example.com:8000/users/schema\"\n\n# Delete table\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/schema\"\n\n# List table regions\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/regions\"\n```\n\n#### Endpoints for `Get` Operations\n\n| Endpoint                                                                                 | HTTP Verb | Description                                                                                                                                                                                                                                                                                                             |\n| ---------------------------------------------------------------------------------------- | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row`                                                                             | `GET`     | Get all columns of a single row. Values are Base-64 encoded. This requires the \"Accept\" request header with a type that can hold multiple columns (like xml, json or protobuf).                                                                                                                                         |\n| `/table/row/column:qualifier/timestamp`                                                  | `GET`     | Get the value of a single column. Values are Base-64 encoded.                                                                                                                                                                                                                                                           |\n| `/table/row/column:qualifier`                                                            | `GET`     | Get the value of a single column. Values are Base-64 encoded.                                                                                                                                                                                                                                                           |\n| `/table/row/column:qualifier?e=b64`                                                      | `GET`     | Get the value of a single column using a binary rowkey and column name, encoded in [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5). Returned values are Base-64 encoded.                                                                                                                     |\n| `/table/row_prefix*/column`                                                              | `GET`     | Get a combination of rows which matches the given row prefix and column family. Returned values are Base-64 encoded.                                                                                                                                                                                                    |\n| `/table/row_prefix*/column:qualifier`                                                    | `GET`     | Get a combination of rows which matches the given row prefix, column family and qualifier. Returned values are Base-64 encoded.                                                                                                                                                                                         |\n| `/table/multiget?row=row&row=row/column:qualifier&row=...`                               | `GET`     | Multi-Get a combination of rows/columns. Values are Base-64 encoded.                                                                                                                                                                                                                                                    |\n| `/table/multiget?e=b64&row=row&row=row/column:qualifier&row=...`                         | `GET`     | Multi-Get a combination of rows/columns using binary rowkeys and column names, encoded in [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5). Returned values are Base-64 encoded.                                                                                                              |\n| `/table/multiget?row=row&row=row/column:qualifier&filter=url_encoded_filter`             | `GET`     | Multi-Get a combination of rows/columns with a filter. The filter should be specified according to the [Thrift Filter Language](/docs/thrift-filter-language#filter-language) and then encoded as `application/x-www-form-urlencoded` MIME format string. This example uses `PrefixFilter('row1')`.                     |\n| `/table/multiget?row=row&row=row/column:qualifier&row=...&filter_b64=b64_encoded_filter` | `GET`     | Multi-Get a combination of rows/columns with a filter. The filter should be specified according to the [Thrift Filter Language](/docs/thrift-filter-language#filter-language) and then encoded in [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5). This example uses `PrefixFilter('row1')`. |\n| `/table/row/column:qualifier/?v=number_of_versions`                                      | `GET`     | Multi-Get a specified number of versions of a given cell. Values are Base-64 encoded.                                                                                                                                                                                                                                   |\n\n**Examples:**\n\n```bash\n# Get all columns of a single row\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1\"\n\n# Get single column with timestamp\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1/cf:a/1458586888395\"\n\n# Get single column\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1/cf:a\"\n\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1/cf:a/\"\n\n# Get single column with base64 encoding\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/cm93MQ/Y2Y6YQ?e=b64\"\n\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  -H \"Encoding: base64\" \\\n  \"http://example.com:8000/users/cm93MQ/Y2Y6YQ/\"\n\n# Get rows with prefix\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row*/cf\"\n\n# Multi-get\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/multiget?row=row1&row=row2/cf:a\"\n\n# Multi-get with base64\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/multiget?e=b64&row=cm93MQ&row=cm93Mg%2FY2Y6YQ\"\n\n# Multi-get with filter\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/multiget?row=row1&row=row2/cf:a&filter=PrefixFilter%28%27row1%27%29\"\n\n# Multi-get with base64 filter\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/multiget?row=row1&row=row2/cf:a&filter_b64=UHJlZml4RmlsdGVyKCdyb3cxJyk\"\n\n# Get multiple versions\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1/cf:a?v=2\"\n```\n\n#### Endpoints for `Delete` Operations\n\n| Endpoint                                | HTTP Verb | Description                                                                                                                                          |\n| --------------------------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row`                            | `DELETE`  | Delete all columns of a single row.                                                                                                                  |\n| `/table/row/column_family:`             | `DELETE`  | Delete all columns of a single row and column family.                                                                                                |\n| `/table/row/column:qualifier/timestamp` | `DELETE`  | Delete a single column.                                                                                                                              |\n| `/table/row/column:qualifier`           | `DELETE`  | Delete a single column.                                                                                                                              |\n| `/table/row/column:qualifier?e=b64`     | `DELETE`  | Delete a single column using a binary rowkey and column name, encoded in [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5). |\n\n**Examples:**\n\n```bash\n# Delete all columns of a row\ncurl -vi -X DELETE \\\n  \"http://example.com:8000/users/row1\"\n\n# Delete all columns of a row and column family\ncurl -vi -X DELETE \\\n  \"http://example.com:8000/users/row1/cf\"\n\n# Delete a single column with timestamp\ncurl -vi -X DELETE \\\n  \"http://example.com:8000/users/row1/cf:a/1458586888395\"\n\n# Delete a single column\ncurl -vi -X DELETE \\\n  \"http://example.com:8000/users/row1/cf:a\"\n\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1/cf:a/\"\n\n# Delete with base64 encoding\ncurl -vi -X DELETE \\\n  \"http://example.com:8000/users/cm93MQ/Y2Y6YQ?e=b64\"\n\ncurl -vi -X DELETE \\\n  -H \"Encoding: base64\" \\\n  \"http://example.com:8000/users/cm93MQ/Y2Y6YQ/\"\n```\n\n#### Stateful endpoints for `Scan` Operations\n\n| Endpoint                    | HTTP Verb | Description                                                                                                                                                                                                                                                                                                                                                                                                                |\n| --------------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/scanner/`           | `PUT`     | Get a Scanner object. Required by all other Scan operations. Adjust the batch parameter to the number of rows the scan should return in a batch. See the next example for adding filters to your scanner. The scanner endpoint URL is returned as the `Location` in the HTTP response. The other examples in this table assume that the scanner endpoint is `http://example.com:8000/users/scanner/145869072824375522207`. |\n| `/table/scanner/`           | `PUT`     | To supply filters to the Scanner object or configure the Scanner in any other way, you can create a text file and add your filter to the file. For example, to return only rows for which keys start with u123 and use a batch size of 100, pass the file to the `-d` argument of the `curl` request (see example below).                                                                                                  |\n| `/table/scanner/scanner-id` | `GET`     | Get the next batch from the scanner. Cell values are byte-encoded. If the scanner has been exhausted, HTTP status `204` is returned.                                                                                                                                                                                                                                                                                       |\n| `table/scanner/scanner-id`  | `DELETE`  | Deletes the scanner and frees the resources it used.                                                                                                                                                                                                                                                                                                                                                                       |\n\nFor the filter file example, it should contain:\n\n```xml\n<Scanner batch=\"100\">\n  <filter>\n    {\n      \"type\": \"PrefixFilter\",\n      \"value\": \"u123\"\n    }\n  </filter>\n</Scanner>\n```\n\n**Examples:**\n\n```bash\n# Create a scanner\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<Scanner batch=\"1\"/>' \\\n  \"http://example.com:8000/users/scanner/\"\n\n# Create a scanner with filter from file\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type:text/xml\" \\\n  -d @filter.txt \\\n  \"http://example.com:8000/users/scanner/\"\n\n# Get next batch from scanner\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/scanner/145869072824375522207\"\n\n# Delete scanner\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/scanner/145869072824375522207\"\n```\n\n#### Stateless endpoints for `Scan` Operations\n\n| Endpoint                                                | HTTP Verb | Description                                                                                                                                                                                                                                                           |\n| ------------------------------------------------------- | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/*`                                              | `GET`     | Scanning the entire table. The stateless scanner endpoint does not require a followup call to return the results.                                                                                                                                                     |\n| `/table/*?limit=number_of_rows`                         | `GET`     | Scanning the first row of the table.                                                                                                                                                                                                                                  |\n| `/table/*?column=column:qualifier`                      | `GET`     | Scanning a given column of the table.                                                                                                                                                                                                                                 |\n| `/table/*?column=column1:qualifier1,column2:qualifier2` | `GET`     | Scanning more than one column of the table.                                                                                                                                                                                                                           |\n| `/table/*?startrow=row&limit=number_of_rows`            | `GET`     | Scanning table with start row and limit.                                                                                                                                                                                                                              |\n| `/table/row_prefix*`                                    | `GET`     | Scanning table with row prefix.                                                                                                                                                                                                                                       |\n| `/table/*?reversed=true`                                | `GET`     | Scanning table in reverse.                                                                                                                                                                                                                                            |\n| `/table/*?filter=url_encoded_filter`                    | `GET`     | Scanning with a filter `PrefixFilter('row1')`. The filter should be specified according to the [Thrift Filter Language](/docs/thrift-filter-language#filter-language) and then encoded as `application/x-www-form-urlencoded` MIME format string.                     |\n| `/table/*?filter_b64=b64_encoded_filter`                | `GET`     | Scanning with a filter `PrefixFilter('row1')`. The filter should be specified according to the [Thrift Filter Language](/docs/thrift-filter-language#filter-language) and then encoded in [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5). |\n\n**Examples:**\n\n```bash\n# Scan entire table\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*\"\n\n# Scan with limit\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?limit=1\"\n\n# Scan single column\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?column=cf:a\"\n\n# Scan multiple columns\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?column=cf:a,cf:b\"\n\n# Scan with start row and limit\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?startrow=row1&limit=2\"\n\n# Scan with row prefix\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1*\"\n\n# Scan in reverse\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?reversed=true\"\n\n# Scan with filter\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?filter=PrefixFilter%28%27row1%27%29\"\n\n# Scan with base64 filter\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?filter_b64=UHJlZml4RmlsdGVyKCdyb3cxJyk\"\n```\n\nThe [stateful scanner API](/docs/external-apis#stateful-endpoints-for-scan-operations) expects clients to restart scans if there is a REST server failure in the midst. The stateless does not store any state related to scan operation and all the parameters are specified as query parameters.\n\n<Callout type=\"info\">\n  The stateless endpoints are optimized for small results, while the [stateful scanner\n  API](/docs/external-apis#stateful-endpoints-for-scan-operations) can also be used for large\n  results.\n</Callout>\n\nThe following are the scan parameters:\n\n* `startrow` - The start row for the scan.\n* `endrow` - The end row for the scan.\n* `column` - The comma separated list of columns to scan.\n* `starttime`, `endtime` - To only retrieve columns within a specific range of version timestamps, both start and end time must be specified.\n* `maxversions` - To limit the number of versions of each column to be returned.\n* `batchsize` - To limit the maximum number of values returned for each call to next().\n* `limit` - The number of rows to return in the scan operation.\n* `cacheblocks` - Whether to use the [Block Cache](/docs/architecture/regionserver#performance-reading-from-hbase-block-cache) in the RegionServer. By default `true`.\n* `reversed` - When set to `true`, reverse scan will be executed. By default `false`.\n* `filter` - Allows to specify a filter for the scan as an `application/x-www-form-urlencoded` MIME format string.\n* `filter_b64` - On versions which include the [HBASE-28518](https://issues.apache.org/jira/browse/HBASE-28518) patch, `filter_b64` allows to specify a [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5) encoded filter for the scan. When both `filter` and `filter_b64` are specified, only `filter_b64` is considered.\n* `includeStartRow` - Whether start row should be included in the scan. By default `true`.\n* `includeStopRow` - Whether end row (stop row) should be included in the scan. By default `false`.\n\n<Callout type=\"info\">\n  `includeStartRow` and `includeStopRow` are only supported on versions that include [HBASE-28627](https://issues.apache.org/jira/browse/HBASE-28627).\n\n  Versions without this patch will either ignore these parameters or will error out if they are set to a non-default value.\n</Callout>\n\nMore on start row, end row and limit parameters:\n\n* If start row, end row and limit not specified, then the whole table will be scanned.\n* If start row and limit (say N) is specified, then the scan operation will return N rows from the start row specified.\n* If only limit parameter is specified, then the scan operation will return N rows from the start of the table.\n* If limit and end row are specified, then the scan operation will return N rows from start of table till the end row. If the end row is reached before N rows ( say M and M \\< N ), then M rows will be returned to the user.\n* If start row, end row and limit ( say N ) are specified and N \\< number of rows between start row and end row, then N rows from start row will be returned to the user. If N > (number of rows between start row and end row (say M), then M number of rows will be returned to the user.\n\n#### Endpoints for `Put` Operations\n\n| Endpoint         | HTTP Verb | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| ---------------- | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row_key` | `PUT`     | Write a row to a table. The row, column qualifier, and value must each be Base-64 encoded. To encode a string, use the `base64` command-line utility. To decode the string, use `base64 -d`. The payload is in the `--data` argument, and the `/users/fakerow` value is a placeholder. Insert multiple rows by adding them to the `<CellSet>` element. You can also save the data to be inserted to a file and pass it to the `-d` parameter with syntax like `-d @filename.txt`. |\n\n**Example:**\n\n```bash\n# XML format\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93NQo=\"><Cell column=\"Y2Y6ZQo=\">dmFsdWU1Cg==</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/fakerow\"\n\n# JSON format\ncurl -vi -X PUT \\\n  -H \"Accept: text/json\" \\\n  -H \"Content-Type: text/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93NQo=\", \"Cell\": [{\"column\":\"Y2Y6ZQo=\", \"$\":\"dmFsdWU1Cg==\"}]}]}'' \\\n  \"example.com:8000/users/fakerow\"\n```\n\n#### Endpoints for `Check-And-Put` Operations\n\n| Endpoint                    | HTTP Verb | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| --------------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row_key/?check=put` | `PUT`     | Conditional Put - Change the current version value of a cell: Compare the current or latest version value (`current-version-value`) of a cell with the `check-value`, and if `current-version-value` == `check-value`, write new data (the `new-value`) into the cell as the current or latest version. The row, column qualifier, and value must each be Base-64 encoded. To encode a string, use the `base64` command-line utility. To decode the string, use `base64 -d`. The payload is in the `--data` or `-d` argument, with `the check cell name (column family:column name) and value` always at the end and right after `the new Put cell name (column family:column name) and value` of the same row key. You can also save the data to be inserted to a file and pass it to the `-d` parameter with syntax like `-d @filename.txt`. |\n\n**Example:**\n\n```bash\n# XML format\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93MQ==\"><Cell column=\"Y2ZhOmFsaWFz\">T2xkR3V5</Cell><Cell column=\"Y2ZhOmFsaWFz\">TmV3R3V5</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row1/?check=put\"\n\n# JSON format\ncurl -vi -X PUT \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93MQ==\",\"Cell\":[{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"T2xkR3V5\"},{\"column\":\"Y2ZhOmFsaWFz\", \"$\":\"TmV3R3V5\"}] }]}' \\\n  \"http://example.com:8000/users/row1/?check=put\"\n```\n\nDetailed Explanation:\n\n* In the above json-format example:\n  1. `{\"column\":\"Y2ZhOmFsaWFz\", \"$\":\"TmV3R3V5\"}` at the end of `-d` option are `the check cell name and check cell value in Base-64` respectively: `\"Y2ZhOmFsaWFz\" for \"cfa:alias\"`, and `\"TmV3R3V5\" for \"NewGuy\"`\n  2. `{{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"T2xkR3V5\"}}` are `the new Put cell name and cell value in Base-64` respectively: `\"Y2ZhOmFsaWFz\" for \"cfa:alias\"`, and `\"T2xkR3V5\" for \"OldGuy\"`\n  3. `\"cm93MQ==\"` is `the Base-64 for \"row1\"` for the checkAndPut `row key`\n  4. `\"/?check=put\"` after the `\"row key\" in the request URL` is required for checkAndPut WebHBase operation to work\n  5. The `\"row key\" in the request URL` should be URL-encoded, e.g., `\"david%20chen\"` and `\"row1\"` are the URL-encoded formats of row keys `\"david chen\"` and `\"row1\"`, respectively\n     <Callout type=\"info\">\n       Note: \"cfa\" is the column family name and \"alias\" are the column (qualifier) name for the\n       non-Base64 encoded cell name.\n     </Callout>\n\n* Basically, the xml-format example is the same as the json-format example, and will not be explained here in detail.\n\n#### Endpoints for `Check-And-Delete` Operations\n\n| Endpoint                                                   | HTTP Verb | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| ---------------------------------------------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row_key/?check=delete`                             | `DELETE`  | Conditional Deleting a Row: Compare the value of any version of a cell (`any-version-value`) with the `check-value`, and if `any-version-value` == `check-value`, delete the row specified by the `row_key` inside the requesting URL. The row, column qualifier, and value for checking in the payload must each be Base-64 encoded. To encode a string, use the base64 command-line utility. To decode the string, use base64 -d. The payload is in the --data argument. You can also save the data to be checked to a file and pass it to the `-d` parameter with syntax like `-d @filename.txt`. |\n| `/table/row_key/column_family/?check=delete`               | `DELETE`  | Conditional Deleting a Column Family of a Row: Compare the value of any version of a cell (`any-version-value`) with the `check-value`, and if `any-version-value` == `check-value`, delete the column family of a row specified by the `row_key/column_family` inside the requesting URL. Anything else is the same as those in `Conditional Deleting a Row`.                                                                                                                                                                                                                                       |\n| `/table/row_key/column:qualifier/?check=delete`            | `DELETE`  | Conditional Deleting All Versions of a Column of a Row: Compare the value of any version of a cell (`any-version-value`) with the `check-value`, and if `any-version-value` == `check-value`, delete the column of a row specified by the `row_key/column:qualifier` inside the requesting URL. The `column:qualifier` in the requesting URL is the `column_family:column_name`. Anything else is the same as those in `Conditional Deleting a Row`.                                                                                                                                                 |\n| `/table/row_key/column:qualifier/version_id/?check=delete` | `DELETE`  | Conditional Deleting a Single Version of a Column of a Row: Compare the value of any version of a cell (`any-version-value`) with the `check-value`, and if `any-version-value` == `check-value`, delete the version of a column of a row specified by the `row_key/column:qualifier/version_id` inside the requesting URL. The `column:qualifier` in the requesting URL is the `column_family:column_name`. The `version_id` in the requesting URL is a number, which equals to `the timestamp of the targeted version + 1`. Anything else is the same as those in `Conditional Deleting a Row`.    |\n\n**Examples:**\n\n```bash\n# Conditional delete a row (XML)\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93MQ==\"><Cell column=\"Y2ZhOmFsaWFz\">TmV3R3V5</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row1/?check=delete\"\n\n# Conditional delete a row (JSON)\ncurl -vi -X DELETE \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93MQ==\",\"Cell\":[{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"TmV3R3V5\"}]}]}' \\\n  \"http://example.com:8000/users/row1/?check=delete\"\n\n# Conditional delete a column family (XML)\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93MQ==\"><Cell column=\"Y2ZhOmFsaWFz\">TmV3R3V5</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row1/cfa/?check=delete\"\n\n# Conditional delete a column family (JSON)\ncurl -vi -X DELETE \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93MQ==\",\"Cell\":[{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"TmV3R3V5\"}]}]}' \\\n  \"http://example.com:8000/users/row1/cfa/?check=delete\"\n\n# Conditional delete all versions of a column (XML)\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93MQ==\"><Cell column=\"Y2ZhOmFsaWFz\">TmV3R3V5</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row1/cfa:alias/?check=delete\"\n\n# Conditional delete all versions of a column (JSON)\ncurl -vi -X DELETE \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93MQ==\",\"Cell\":[{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"TmV3R3V5\"}]}]}' \\\n  \"http://example.com:8000/users/row1/cfa:alias/?check=delete\"\n\n# Conditional delete a single version (XML)\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93MQ==\"><Cell column=\"Y2ZhOmFsaWFz\">TmV3R3V5</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row1/cfa:alias/1519423552160/?check=delete\"\n\n# Conditional delete a single version (JSON)\ncurl -vi -X DELETE \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93MQ==\",\"Cell\":[{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"TmV3R3V5\"}]}]}' \\\n  \"http://example.com:8000/users/row1/cfa:alias/1519423552160/?check=delete\"\n```\n\nDetailed Explanation:\n\n* In the above 4 json-format examples:\n  1. `{\"column\":\"Y2ZhOmFsaWFz\", \"$\":\"TmV3R3V5\"}` at the end of `-d` option are `the check cell name and check cell value in Base-64` respectively: `\"Y2ZhOmFsaWFz\" for \"cfa:alias\"`, and `\"TmV3R3V5\" for \"NewGuy\"`\n  2. `\"cm93MQ==\"` is `the Base-64 for \"row1\"` for the checkAndDelete `row key`\n  3. `\"/?check=delete\"` at the end of `the request URL` is required for checkAndDelete WebHBase operation to work\n  4. `\"version_id\"` in the `request URL` of the last json-format example should be equivalent to the value of `\"the timestamp number + 1\"`\n  5. The `\"row key\"`, `\"column family\"`, `\"cell name\" or \"column family:column name\"`, and `\"version_id\"` in `the request URL` of a checkAndDelete WebHBase operation should be URL-encoded, e.g., `\"row1\"`, `\"cfa\"`, `\"cfa:alias\"` and `\"1519423552160\"` in the examples are the URL-encoded `\"row key\"`, `\"column family\"`, `\"column family:column name\"`, and `\"version_id\"`, respectively\n\n* Basically, the 4 xml-format examples are the same as the 4 corresponding json-format examples, and will not be explained here in detail.\n\n#### Endpoints for `Append` Operations\n\n| Endpoint                       | HTTP Verb | Description                                                                                                                                 |\n| ------------------------------ | --------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row_key/?check=append` | `PUT`     | Appends the given new value to the end of the current value of the cell. The row, column qualifier, and value must each be Base-64 encoded. |\n\n**Example:**\n\n```bash\n# XML format\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93NQo=\"><Cell column=\"Y2Y6ZQo=\">dmFsdWU1Cg==</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row5?check=append\"\n\n# JSON format\ncurl -vi -X PUT \\\n  -H \"Content-type: application/json\" \\\n  -H \"Accept: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"dGVzdHJvdzE=\",\"Cell\":[{\"column\":\"YTox\",\"$\":\"dGVzdHZhbHVlMgo\"},{\"column\":\"YToy\",\"$\":\"dGVzdHZhbHVlMTIK\"}]}]}' \\\n  \"http://localhost:8080/users/testrow1?check=append\"\n```\n\n#### Endpoints for `Increment` Operations\n\n| Endpoint                          | HTTP Verb | Description                                                                                                  |\n| --------------------------------- | --------- | ------------------------------------------------------------------------------------------------------------ |\n| `/table/row_key/?check=increment` | `PUT`     | Increments the current value of the cell. The row, column qualifier, and value must each be Base-64 encoded. |\n\n**Example:**\n\n```bash\n# XML format\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93NQo=\"><Cell column=\"YTox\">MQ==</Cell></Row></CellSet>' \\\n  \"http://localhost:8080/users/row5?check=increment\"\n\n# JSON format\ncurl -vi -X PUT \\\n  -H \"Content-type: application/json\" \\\n  -H \"Accept: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"dGVzdHJvdzE=\",\"Cell\":[{\"column\":\"YTox\",\"$\":\"MQ==\"},{\"column\":\"YToy\",\"$\":\"MQ==\"}]}]}' \\\n  \"http://localhost:8080/users/testrow1?check=increment\"\n```\n\n### REST XML Schema\n\n```xml\n<schema xmlns=\"http://www.w3.org/2001/XMLSchema\" xmlns:tns=\"RESTSchema\">\n\n  <element name=\"Version\" type=\"tns:Version\"></element>\n\n  <complexType name=\"Version\">\n    <attribute name=\"REST\" type=\"string\"></attribute>\n    <attribute name=\"JVM\" type=\"string\"></attribute>\n    <attribute name=\"OS\" type=\"string\"></attribute>\n    <attribute name=\"Server\" type=\"string\"></attribute>\n    <attribute name=\"Jersey\" type=\"string\"></attribute>\n    <attribute name=\"Version\" type=\"string\"></attribute>\n    <attribute name=\"Revision\" type=\"string\"></attribute>\n  </complexType>\n\n  <element name=\"TableList\" type=\"tns:TableList\"></element>\n\n  <complexType name=\"TableList\">\n    <sequence>\n      <element name=\"table\" type=\"tns:Table\" maxOccurs=\"unbounded\" minOccurs=\"1\"></element>\n    </sequence>\n  </complexType>\n\n  <complexType name=\"Table\">\n    <sequence>\n      <element name=\"name\" type=\"string\"></element>\n    </sequence>\n  </complexType>\n\n  <element name=\"TableInfo\" type=\"tns:TableInfo\"></element>\n\n  <complexType name=\"TableInfo\">\n    <sequence>\n      <element name=\"region\" type=\"tns:TableRegion\" maxOccurs=\"unbounded\" minOccurs=\"1\"></element>\n    </sequence>\n    <attribute name=\"name\" type=\"string\"></attribute>\n  </complexType>\n\n  <complexType name=\"TableRegion\">\n    <attribute name=\"name\" type=\"string\"></attribute>\n    <attribute name=\"id\" type=\"int\"></attribute>\n    <attribute name=\"startKey\" type=\"base64Binary\"></attribute>\n    <attribute name=\"endKey\" type=\"base64Binary\"></attribute>\n    <attribute name=\"location\" type=\"string\"></attribute>\n  </complexType>\n\n  <element name=\"TableSchema\" type=\"tns:TableSchema\"></element>\n\n  <complexType name=\"TableSchema\">\n    <sequence>\n      <element name=\"column\" type=\"tns:ColumnSchema\" maxOccurs=\"unbounded\" minOccurs=\"1\"></element>\n    </sequence>\n    <attribute name=\"name\" type=\"string\"></attribute>\n    <anyAttribute></anyAttribute>\n  </complexType>\n\n  <complexType name=\"ColumnSchema\">\n    <attribute name=\"name\" type=\"string\"></attribute>\n    <anyAttribute></anyAttribute>\n  </complexType>\n\n  <element name=\"CellSet\" type=\"tns:CellSet\"></element>\n\n  <complexType name=\"CellSet\">\n    <sequence>\n      <element name=\"row\" type=\"tns:Row\" maxOccurs=\"unbounded\" minOccurs=\"1\"></element>\n    </sequence>\n  </complexType>\n\n  <element name=\"Row\" type=\"tns:Row\"></element>\n\n  <complexType name=\"Row\">\n    <sequence>\n      <element name=\"key\" type=\"base64Binary\"></element>\n      <element name=\"cell\" type=\"tns:Cell\" maxOccurs=\"unbounded\" minOccurs=\"1\"></element>\n    </sequence>\n  </complexType>\n\n  <element name=\"Cell\" type=\"tns:Cell\"></element>\n\n  <complexType name=\"Cell\">\n    <sequence>\n      <element name=\"value\" maxOccurs=\"1\" minOccurs=\"1\">\n        <simpleType><restriction base=\"base64Binary\">\n        </simpleType>\n      </element>\n    </sequence>\n    <attribute name=\"column\" type=\"base64Binary\" />\n    <attribute name=\"timestamp\" type=\"int\" />\n  </complexType>\n\n  <element name=\"Scanner\" type=\"tns:Scanner\"></element>\n\n  <complexType name=\"Scanner\">\n    <sequence>\n      <element name=\"column\" type=\"base64Binary\" minOccurs=\"0\" maxOccurs=\"unbounded\"></element>\n    </sequence>\n    <attribute name=\"startRow\" type=\"base64Binary\"></attribute>\n    <attribute name=\"endRow\" type=\"base64Binary\"></attribute>\n    <attribute name=\"batch\" type=\"int\"></attribute>\n    <attribute name=\"startTime\" type=\"int\"></attribute>\n    <attribute name=\"endTime\" type=\"int\"></attribute>\n    <attribute name=\"filter\" type=\"string\"></attribute>\n    <attribute name=\"caching\" type=\"int\"></attribute>\n    <sequence>\n        <element name=\"labels\" type=\"string\" minOccurs=\"0\" maxOccurs=\"unbounded\"></element>\n    </sequence>\n    <attribute name=\"cacheBlocks\" type=\"boolean\"></attribute>\n    <attribute name=\"maxVersions\" type=\"int\"></attribute>\n    <attribute name=\"limit\" type=\"int\"></attribute>\n    <attribute name=\"includeStartRow\" type=\"boolean\"></attribute>\n    <attribute name=\"includeStopRow\" type=\"boolean\"></attribute>\n  </complexType>\n\n  <element name=\"StorageClusterVersion\" type=\"tns:StorageClusterVersion\" />\n\n  <complexType name=\"StorageClusterVersion\">\n    <attribute name=\"version\" type=\"string\"></attribute>\n  </complexType>\n\n  <element name=\"StorageClusterStatus\"\n    type=\"tns:StorageClusterStatus\">\n  </element>\n\n  <complexType name=\"StorageClusterStatus\">\n    <sequence>\n      <element name=\"liveNode\" type=\"tns:Node\"\n        maxOccurs=\"unbounded\" minOccurs=\"0\">\n      </element>\n      <element name=\"deadNode\" type=\"string\" maxOccurs=\"unbounded\"\n        minOccurs=\"0\">\n      </element>\n    </sequence>\n    <attribute name=\"regions\" type=\"int\"></attribute>\n    <attribute name=\"requests\" type=\"int\"></attribute>\n    <attribute name=\"averageLoad\" type=\"float\"></attribute>\n  </complexType>\n\n  <complexType name=\"Node\">\n    <sequence>\n      <element name=\"region\" type=\"tns:Region\"\n   maxOccurs=\"unbounded\" minOccurs=\"0\">\n      </element>\n    </sequence>\n    <attribute name=\"name\" type=\"string\"></attribute>\n    <attribute name=\"startCode\" type=\"int\"></attribute>\n    <attribute name=\"requests\" type=\"int\"></attribute>\n    <attribute name=\"heapSizeMB\" type=\"int\"></attribute>\n    <attribute name=\"maxHeapSizeMB\" type=\"int\"></attribute>\n  </complexType>\n\n  <complexType name=\"Region\">\n    <attribute name=\"name\" type=\"base64Binary\"></attribute>\n    <attribute name=\"stores\" type=\"int\"></attribute>\n    <attribute name=\"storefiles\" type=\"int\"></attribute>\n    <attribute name=\"storefileSizeMB\" type=\"int\"></attribute>\n    <attribute name=\"memstoreSizeMB\" type=\"int\"></attribute>\n    <attribute name=\"storefileIndexSizeKB\" type=\"int\"></attribute>\n    <attribute name=\"readRequestsCount\" type=\"int\"></attribute>\n    <attribute name=\"cpRequestsCount\" type=\"int\"></attribute>\n    <attribute name=\"writeRequestsCount\" type=\"int\"></attribute>\n    <attribute name=\"rootIndexSizeKB\" type=\"int\"></attribute>\n    <attribute name=\"totalStaticIndexSizeKB\" type=\"int\"></attribute>\n    <attribute name=\"totalStaticBloomSizeKB\" type=\"int\"></attribute>\n    <attribute name=\"totalCompactingKVs\" type=\"int\"></attribute>\n    <attribute name=\"currentCompactedKVs\" type=\"int\"></attribute>\n  </complexType>\n\n</schema>\n```\n\n### REST Protobufs Schema\n\n```protobuf\nmessage Version {\n  optional string restVersion = 1;\n  optional string jvmVersion = 2;\n  optional string osVersion = 3;\n  optional string serverVersion = 4;\n  optional string jerseyVersion = 5;\n  optional string version = 6;\n  optional string revision = 7;\n}\n\nmessage StorageClusterStatus {\n  message Region {\n    required bytes name = 1;\n    optional int32 stores = 2;\n    optional int32 storefiles = 3;\n    optional int32 storefileSizeMB = 4;\n    optional int32 memStoreSizeMB = 5;\n    optional int64 storefileIndexSizeKB = 6;\n    optional int64 readRequestsCount = 7;\n    optional int64 writeRequestsCount = 8;\n    optional int32 rootIndexSizeKB = 9;\n    optional int32 totalStaticIndexSizeKB = 10;\n    optional int32 totalStaticBloomSizeKB = 11;\n    optional int64 totalCompactingKVs = 12;\n    optional int64 currentCompactedKVs = 13;\n    optional int64 cpRequestsCount = 14;\n  }\n  message Node {\n    required string name = 1;    // name:port\n    optional int64 startCode = 2;\n    optional int32 requests = 3;\n    optional int32 heapSizeMB = 4;\n    optional int32 maxHeapSizeMB = 5;\n    repeated Region regions = 6;\n  }\n  // node status\n  repeated Node liveNodes = 1;\n  repeated string deadNodes = 2;\n  // summary statistics\n  optional int32 regions = 3;\n  optional int32 requests = 4;\n  optional double averageLoad = 5;\n}\n\nmessage TableList {\n  repeated string name = 1;\n}\n\nmessage TableInfo {\n  required string name = 1;\n  message Region {\n    required string name = 1;\n    optional bytes startKey = 2;\n    optional bytes endKey = 3;\n    optional int64 id = 4;\n    optional string location = 5;\n  }\n  repeated Region regions = 2;\n}\n\nmessage TableSchema {\n  optional string name = 1;\n  message Attribute {\n    required string name = 1;\n    required string value = 2;\n  }\n  repeated Attribute attrs = 2;\n  repeated ColumnSchema columns = 3;\n  // optional helpful encodings of commonly used attributes\n  optional bool inMemory = 4;\n  optional bool readOnly = 5;\n}\n\nmessage ColumnSchema {\n  optional string name = 1;\n  message Attribute {\n    required string name = 1;\n    required string value = 2;\n  }\n  repeated Attribute attrs = 2;\n  // optional helpful encodings of commonly used attributes\n  optional int32 ttl = 3;\n  optional int32 maxVersions = 4;\n  optional string compression = 5;\n}\n\nmessage Cell {\n  optional bytes row = 1;       // unused if Cell is in a CellSet\n  optional bytes column = 2;\n  optional int64 timestamp = 3;\n  optional bytes data = 4;\n}\n\nmessage CellSet {\n  message Row {\n    required bytes key = 1;\n    repeated Cell values = 2;\n  }\n  repeated Row rows = 1;\n}\n\nmessage Scanner {\n  optional bytes startRow = 1;\n  optional bytes endRow = 2;\n  repeated bytes columns = 3;\n  optional int32 batch = 4;\n  optional int64 startTime = 5;\n  optional int64 endTime = 6;\n  optional int32 maxVersions = 7;\n  optional string filter = 8;\n  optional int32 caching = 9;     // specifies REST scanner caching\n  repeated string labels = 10;\n  optional bool cacheBlocks = 11; // server side block caching hint\n  optional int32 limit = 12;\n  optional bool includeStartRow = 13;\n  optional bool includeStopRow = 14;\n}\n```\n\n## Thrift\n\nDocumentation about Thrift has moved to [Thrift API and Filter Language](/docs/thrift-filter-language).\n\n## C/C++ Apache HBase Client\n\nFB's Chip Turner wrote a pure C/C++ client. [Check it out](https://github.com/hinaria/native-cpp-hbase-client).\n\nC++ client implementation. To see [HBASE-14850](https://issues.apache.org/jira/browse/HBASE-14850).\n\n## Using Java Data Objects (JDO) with HBase\n\n[Java Data Objects (JDO)](https://db.apache.org/jdo/) is a standard way to access persistent data in databases, using plain old Java objects (POJO) to represent persistent data.\n\n**Dependencies**\n\nThis code example has the following dependencies:\n\n1. HBase 0.90.x or newer\n2. commons-beanutils.jar ([https://commons.apache.org/](https://commons.apache.org/))\n3. commons-pool-1.5.5.jar ([https://commons.apache.org/](https://commons.apache.org/))\n4. transactional-tableindexed for HBase 0.90 ([https://github.com/hbase-trx/hbase-transactional-tableindexed](https://github.com/hbase-trx/hbase-transactional-tableindexed))\n\n**Download `hbase-jdo`**\\\nDownload the code from [http://code.google.com/p/hbase-jdo/](http://code.google.com/p/hbase-jdo/).\n\n**JDO Example**\\\nThis example uses JDO to create a table and an index, insert a row into a table, get a row, get a column value, perform a query, and do some additional HBase operations.\n\n```java\npackage com.apache.hadoop.hbase.client.jdo.examples;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.Hashtable;\n\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.hbase.client.tableindexed.IndexedTable;\n\nimport com.apache.hadoop.hbase.client.jdo.AbstractHBaseDBO;\nimport com.apache.hadoop.hbase.client.jdo.HBaseBigFile;\nimport com.apache.hadoop.hbase.client.jdo.HBaseDBOImpl;\nimport com.apache.hadoop.hbase.client.jdo.query.DeleteQuery;\nimport com.apache.hadoop.hbase.client.jdo.query.HBaseOrder;\nimport com.apache.hadoop.hbase.client.jdo.query.HBaseParam;\nimport com.apache.hadoop.hbase.client.jdo.query.InsertQuery;\nimport com.apache.hadoop.hbase.client.jdo.query.QSearch;\nimport com.apache.hadoop.hbase.client.jdo.query.SelectQuery;\nimport com.apache.hadoop.hbase.client.jdo.query.UpdateQuery;\n\n/**\n * Hbase JDO Example.\n *\n * dependency library.\n * - commons-beanutils.jar\n * - commons-pool-1.5.5.jar\n * - hbase0.90.0-transactionl.jar\n *\n * you can expand Delete,Select,Update,Insert Query classes.\n *\n */\npublic class HBaseExample {\n  public static void main(String[] args) throws Exception {\n    AbstractHBaseDBO dbo = new HBaseDBOImpl();\n\n    //*drop if table is already exist.*\n    if(dbo.isTableExist(\"user\")){\n     dbo.deleteTable(\"user\");\n    }\n\n    //*create table*\n    dbo.createTableIfNotExist(\"user\",HBaseOrder.DESC,\"account\");\n    //dbo.createTableIfNotExist(\"user\",HBaseOrder.ASC,\"account\");\n\n    //create index.\n    String[] cols={\"id\",\"name\"};\n    dbo.addIndexExistingTable(\"user\",\"account\",cols);\n\n    //insert\n    InsertQuery insert = dbo.createInsertQuery(\"user\");\n    UserBean bean = new UserBean();\n    bean.setFamily(\"account\");\n    bean.setAge(20);\n    bean.setEmail(\"ncanis@gmail.com\");\n    bean.setId(\"ncanis\");\n    bean.setName(\"ncanis\");\n    bean.setPassword(\"1111\");\n    insert.insert(bean);\n\n    //select 1 row\n    SelectQuery select = dbo.createSelectQuery(\"user\");\n    UserBean resultBean = (UserBean)select.select(bean.getRow(),UserBean.class);\n\n    // select column value.\n    String value = (String)select.selectColumn(bean.getRow(),\"account\",\"id\",String.class);\n\n    // search with option (QSearch has EQUAL, NOT_EQUAL, LIKE)\n    // select id,password,name,email from account where id='ncanis' limit startRow,20\n    HBaseParam param = new HBaseParam();\n    param.setPage(bean.getRow(),20);\n    param.addColumn(\"id\",\"password\",\"name\",\"email\");\n    param.addSearchOption(\"id\",\"ncanis\",QSearch.EQUAL);\n    select.search(\"account\", param, UserBean.class);\n\n    // search column value is existing.\n    boolean isExist = select.existColumnValue(\"account\",\"id\",\"ncanis\".getBytes());\n\n    // update password.\n    UpdateQuery update = dbo.createUpdateQuery(\"user\");\n    Hashtable<String, byte[]> colsTable = new Hashtable<String, byte[]>();\n    colsTable.put(\"password\",\"2222\".getBytes());\n    update.update(bean.getRow(),\"account\",colsTable);\n\n    //delete\n    DeleteQuery delete = dbo.createDeleteQuery(\"user\");\n    delete.deleteRow(resultBean.getRow());\n\n    ////////////////////////////////////\n    // etc\n\n    // HTable pool with apache commons pool\n    // borrow and release. HBasePoolManager(maxActive, minIdle etc..)\n    IndexedTable table = dbo.getPool().borrow(\"user\");\n    dbo.getPool().release(table);\n\n    // upload bigFile by hadoop directly.\n    HBaseBigFile bigFile = new HBaseBigFile();\n    File file = new File(\"doc/movie.avi\");\n    FileInputStream fis = new FileInputStream(file);\n    Path rootPath = new Path(\"/files/\");\n    String filename = \"movie.avi\";\n    bigFile.uploadFile(rootPath,filename,fis,true);\n\n    // receive file stream from hadoop.\n    Path p = new Path(rootPath,filename);\n    InputStream is = bigFile.path2Stream(p,4096);\n\n  }\n}\n```\n\n## Scala\n\n### Setting the Classpath\n\nTo use Scala with HBase, your CLASSPATH must include HBase's classpath as well as the Scala JARs required by your code. First, use the following command on a server running the HBase RegionServer process, to get HBase's classpath.\n\n```bash\n$ ps aux |grep regionserver| awk -F 'java.library.path=' {'print $2'} | awk {'print $1'}\n\n/usr/lib/hadoop/lib/native:/usr/lib/hbase/lib/native/Linux-amd64-64\n```\n\nSet the `$CLASSPATH` environment variable to include the path you found in the previous step, plus the path of `scala-library.jar` and each additional Scala-related JAR needed for your project.\n\n```bash\n$ export CLASSPATH=$CLASSPATH:/usr/lib/hadoop/lib/native:/usr/lib/hbase/lib/native/Linux-amd64-64:/path/to/scala-library.jar\n```\n\n### Scala SBT File\n\nYour `build.sbt` file needs the following `resolvers` and `libraryDependencies` to work with HBase.\n\n```scala\nresolvers += \"Apache HBase\" at \"https://repository.apache.org/content/repositories/releases\"\n\nresolvers += \"Thrift\" at \"https://people.apache.org/~rawson/repo/\"\n\nlibraryDependencies ++= Seq(\n    \"org.apache.hadoop\" % \"hadoop-core\" % \"0.20.2\",\n    \"org.apache.hbase\" % \"hbase\" % \"0.90.4\"\n)\n```\n\n### Example Scala Code\n\nThis example lists HBase tables, creates a new table, adds a row to it, and gets the value of the row.\n\n```scala\nimport org.apache.hadoop.hbase.{HBaseConfiguration, TableName}\nimport org.apache.hadoop.hbase.client.{Admin, Connection, ConnectionFactory, Get, Put}\nimport org.apache.hadoop.hbase.util.Bytes\n\nval conf = HBaseConfiguration.create()\nval connection = ConnectionFactory.createConnection(conf);\nval admin = connection.getAdmin();\n\n// list the tables\nval listtables = admin.listTables()\nlisttables.foreach(println)\n\n// let's insert some data in 'mytable' and get the row\nval table = connection.getTable(TableName.valueOf(\"mytable\"))\n\nval theput = new Put(Bytes.toBytes(\"rowkey1\"))\n\ntheput.addColumn(Bytes.toBytes(\"ids\"),Bytes.toBytes(\"id1\"),Bytes.toBytes(\"one\"))\ntable.put(theput)\n\nval theget = new Get(Bytes.toBytes(\"rowkey1\"))\nval result = table.get(theget)\nval value = result.value()\nprintln(Bytes.toString(value))\n```\n\n## Jython\n\n### Setting the Classpath\n\nTo use Jython with HBase, your CLASSPATH must include HBase's classpath as well as the Jython JARs required by your code.\n\nSet the path to directory containing the `jython.jar` and each additional Jython-related JAR needed for your project. Then export HBASE\\_CLASSPATH pointing to the \\$JYTHON\\_HOME env. variable.\n\n```bash\n$ export HBASE_CLASSPATH=/directory/jython.jar\n```\n\nStart a Jython shell with HBase and Hadoop JARs in the classpath: \\$ bin/hbase org.python.util.jython\n\n### Jython Code Examples\n\n**Example: Table Creation, Population, Get, and Delete with Jython**\\\nThe following Jython code example checks for table, if it exists, deletes it and then creates it. Then it populates the table with data and fetches the data.\n\n```python\nimport java.lang\nfrom org.apache.hadoop.hbase import HBaseConfiguration, HTableDescriptor, HColumnDescriptor, TableName\nfrom org.apache.hadoop.hbase.client import Admin, Connection, ConnectionFactory, Get, Put, Result, Table\nfrom org.apache.hadoop.conf import Configuration\n\n# First get a conf object.  This will read in the configuration\n# that is out in your hbase-*.xml files such as location of the\n# hbase master node.\nconf = HBaseConfiguration.create()\nconnection = ConnectionFactory.createConnection(conf)\nadmin = connection.getAdmin()\n\n# Create a table named 'test' that has a column family\n# named 'content'.\ntableName = TableName.valueOf(\"test\")\ntable = connection.getTable(tableName)\n\ndesc = HTableDescriptor(tableName)\ndesc.addFamily(HColumnDescriptor(\"content\"))\n\n# Drop and recreate if it exists\nif admin.tableExists(tableName):\n    admin.disableTable(tableName)\n    admin.deleteTable(tableName)\n\nadmin.createTable(desc)\n\n# Add content to 'column:' on a row named 'row_x'\nrow = 'row_x'\nput = Put(row)\nput.addColumn(\"content\", \"qual\", \"some content\")\ntable.put(put)\n\n# Now fetch the content just added, returns a byte[]\nget = Get(row)\n\nresult = table.get(get)\ndata = java.lang.String(result.getValue(\"content\", \"qual\"), \"UTF8\")\n\nprint \"The fetched row contains the value '%s'\" % data\n```\n\n**Example: Table Scan Using Jython**\\\nThis example scans a table and returns the results that match a given family qualifier.\n\n```python\nimport java.lang\nfrom org.apache.hadoop.hbase import TableName, HBaseConfiguration\nfrom org.apache.hadoop.hbase.client import Connection, ConnectionFactory, Result, ResultScanner, Table, Admin\nfrom org.apache.hadoop.conf import Configuration\nconf = HBaseConfiguration.create()\nconnection = ConnectionFactory.createConnection(conf)\nadmin = connection.getAdmin()\ntableName = TableName.valueOf('wiki')\ntable = connection.getTable(tableName)\n\ncf = \"title\"\nattr = \"attr\"\nscanner = table.getScanner(cf)\nwhile 1:\n    result = scanner.next()\n    if not result:\n       break\n    print java.lang.String(result.row), java.lang.String(result.getValue(cf, attr))\n```\n\n\n# FAQ (/docs/faq)\n## General\n\n#### When should I use HBase?\n\nSee [Overview](/docs/architecture/overview) in the Architecture chapter.\n\n#### Does HBase support SQL?\n\nNot really. SQL-ish support for HBase via [Hive](https://hive.apache.org/) is in development, however Hive is based on MapReduce which is not generally suitable for low-latency requests. See the [Data Model](/docs/datamodel) section for examples on the HBase client.\n\n#### How can I find examples of NoSQL/HBase?\n\nSee the link to the BigTable paper in [Other Information About HBase](/docs/other-info), as well as the other papers.\n\n#### What is the history of HBase?\n\nSee [HBase History](/docs/hbase-history).\n\n#### Why are the cells above 10MB not recommended for HBase?\n\nLarge cells don't fit well into HBase's approach to buffering data. First, the large cells bypass the MemStoreLAB when they are written. Then, they cannot be cached in the L2 block cache during read operations. Instead, HBase has to allocate on-heap memory for them each time. This can have a significant impact on the garbage collector within the RegionServer process.\n\n## Upgrading\n\n#### How do I upgrade Maven-managed projects from HBase 0.94 to HBase 0.96+?\n\nIn HBase 0.96, the project moved to a modular structure. Adjust your project's dependencies to rely upon the `hbase-client` module or another module as appropriate, rather than a single JAR. You can model your Maven dependency after one of the following, depending on your targeted version of HBase. See Section 3.5, \"Upgrading from 0.94.x to 0.96.x\" or Section 3.3, \"Upgrading from 0.96.x to 0.98.x\" for more information.\n\n**Maven Dependency for HBase 0.98**\n\n```xml\n<dependency>\n  <groupId>org.apache.hbase</groupId>\n  <artifactId>hbase-client</artifactId>\n  <version>0.98.5-hadoop2</version>\n</dependency>\n```\n\n**Maven Dependency for HBase 0.96**\n\n```xml\n<dependency>\n  <groupId>org.apache.hbase</groupId>\n  <artifactId>hbase-client</artifactId>\n  <version>0.96.2-hadoop2</version>\n</dependency>\n```\n\n**Maven Dependency for HBase 0.94**\n\n```xml\n<dependency>\n  <groupId>org.apache.hbase</groupId>\n  <artifactId>hbase</artifactId>\n  <version>0.94.3</version>\n</dependency>\n```\n\n## Architecture\n\n#### How does HBase handle Region-RegionServer assignment and locality?\n\nSee [Regions](/docs/architecture/regions).\n\n## Configuration\n\n#### How can I get started with my first cluster?\n\nSee [Quick Start - Standalone HBase](/docs/getting-started#quick-start---standalone-hbase).\n\n#### Where can I learn about the rest of the configuration options?\n\nSee [Apache HBase Configuration](/docs/configuration).\n\n## Schema Design / Data Access\n\n#### How should I design my schema in HBase?\n\nSee [Data Model](/docs/datamodel) and [HBase and Schema Design](/docs/schema-design).\n\n#### How can I store (fill in the blank) in HBase?\n\nSee [Supported Datatypes](/docs/regionserver-sizing#supported-datatypes).\n\n#### How can I handle secondary indexes in HBase?\n\nSee [Secondary Indexes and Alternate Query Paths](/docs/regionserver-sizing#secondary-indexes-and-alternate-query-paths).\n\n#### Can I change a table's rowkeys?\n\nThis is a very common question. You can't. See [Immutability of Rowkeys](/docs/regionserver-sizing#immutability-of-rowkeys).\n\n#### What APIs does HBase support?\n\nSee [Data Model](/docs/datamodel), [Client](/docs/architecture/client), and [Apache HBase External APIs](/docs/external-apis).\n\n## MapReduce\n\n#### How can I use MapReduce with HBase?\n\nSee [HBase and MapReduce](/docs/mapreduce).\n\n## Performance and Troubleshooting\n\n#### How can I improve HBase cluster performance?\n\nSee [Apache HBase Performance Tuning](/docs/performance).\n\n#### How can I troubleshoot my HBase cluster?\n\nSee [Troubleshooting and Debugging Apache HBase](/docs/troubleshooting).\n\n## Amazon EC2\n\n#### I am running HBase on Amazon EC2 and...\n\nEC2 issues are a special case. See [Amazon EC2](/docs/troubleshooting#troubleshooting-amazon-ec2) and [Amazon EC2](/docs/performance#performance-amazon-ec2).\n\n## Operations\n\n#### How do I manage my HBase cluster?\n\nSee [Apache HBase Operational Management](/docs/operational-management).\n\n#### How do I back up my HBase cluster?\n\nSee [HBase Backup](/docs/operational-management/backup-and-snapshots#hbase-backup).\n\n## HBase in Action\n\n#### Where can I find interesting videos and presentations on HBase?\n\nSee [Other Information About HBase](/docs/other-info).\n\n\n# Getting Started (/docs/getting-started)\n## Quick Start - Standalone HBase\n\nThis section describes the setup of a single-node standalone HBase. A *standalone* instance has all HBase daemons — the Master, RegionServers, and ZooKeeper — running in a single JVM persisting to the local filesystem. It is our most basic deploy profile. We will show you how to create a table in HBase using the `hbase shell` CLI, insert rows into the table, perform put and scan operations against the table, enable or disable the table, and start and stop HBase.\n\nApart from downloading HBase, this procedure should take less than 10 minutes.\n\n## JDK Version Requirements\n\nHBase requires that a JDK be installed. See [Java](/docs/configuration/basic-prerequisites#configuration-basic-prerequisites-java) for information about supported JDK versions.\n\n## Get Started with HBase\n\n### Procedure: Download, Configure, and Start HBase in Standalone Mode\n\n<Steps>\n  <Step>\n    Choose a download site from this list of [Apache Download Mirrors](https://www.apache.org/dyn/closer.lua/hbase/). Click on the suggested top link. This will take you to a mirror of *HBase Releases*. Click on the folder named *stable* and then download the binary file that ends in *.tar.gz* to your local filesystem. Do not download the file ending in *src.tar.gz* for now.\n  </Step>\n\n  <Step>\n    Extract the downloaded file, and change to the newly-created directory.\n\n    ```bash\n    tar xzvf <FILE_NAME>.tar.gz\n    cd <DIRECTORY_NAME>\n    ```\n  </Step>\n\n  <Step>\n    You must set the `JAVA_HOME` environment variable before starting HBase. To make this easier, HBase lets you set it within the *conf/hbase-env.sh* file. You must locate where Java is installed on your machine, and one way to find this is by using the *whereis java* command. Once you have the location, edit the *conf/hbase-env.sh* file and uncomment the line starting with *#export JAVA\\_HOME=*, and then set it to your Java installation path.\n\n    *Example extract from *hbase-env.sh* where *JAVA\\_HOME* is set*\n\n    ```bash\n    # Set environment variables here.\n    # The java implementation to use.\n    export JAVA_HOME=/usr/jdk64/jdk1.8.0_112\n    ```\n  </Step>\n\n  <Step>\n    The *bin/start-hbase.sh* script is provided as a convenient way to start HBase. Issue the command, and if all goes well, a message is logged to standard output showing that HBase started successfully. You can use the `jps` command to verify that you have one running process called `HMaster`. In standalone mode HBase runs all daemons within this single JVM, i.e. the HMaster, a single HRegionServer, and the ZooKeeper daemon. Go to *[http://localhost:16010](http://localhost:16010)* to view the HBase Web UI.\n  </Step>\n</Steps>\n\n### Procedure: Use HBase For the First Time\n\n<Steps>\n  <Step>\n    #### Connect to HBase\n\n    Connect to your running instance of HBase using the `hbase shell` command, located in the *bin/* directory of your HBase install. In this example, some usage and version information that is printed when you start HBase Shell has been omitted. The HBase Shell prompt ends with a `>` character.\n\n    ```bash\n    $ ./bin/hbase shell\n    hbase(main):001:0>\n    ```\n  </Step>\n\n  <Step>\n    #### Display HBase Shell Help Text\n\n    Type `help` and press Enter, to display some basic usage information for HBase Shell, as well as several example commands. Notice that table names, rows, columns all must be enclosed in quote characters.\n  </Step>\n\n  <Step>\n    #### Create a table\n\n    Use the `create` command to create a new table. You must specify the table name and the ColumnFamily name.\n\n    ```bash\n    hbase(main):001:0> create 'test', 'cf'\n    0 row(s) in 0.4170 seconds\n\n    => Hbase::Table - test\n    ```\n  </Step>\n\n  <Step>\n    #### List Information About your Table\n\n    Use the `list` command to confirm your table exists\n\n    ```bash\n    hbase(main):002:0> list 'test'\n    TABLE\n    test\n    1 row(s) in 0.0180 seconds\n\n    => [\"test\"]\n    ```\n\n    Now use the `describe` command to see details, including configuration defaults\n\n    ```bash\n    hbase(main):003:0> describe 'test'\n    Table test is ENABLED\n    test\n    COLUMN FAMILIES DESCRIPTION\n    {NAME => 'cf', VERSIONS => '1', EVICT_BLOCKS_ON_CLOSE => 'false', NEW_VERSION_BEHAVIOR => 'false', KEEP_DELETED_CELLS => 'FALSE', CACHE_DATA_ON_WRITE =>\n    'false', DATA_BLOCK_ENCODING => 'NONE', TTL => 'FOREVER', MIN_VERSIONS => '0', REPLICATION_SCOPE => '0', BLOOMFILTER => 'ROW', CACHE_INDEX_ON_WRITE => 'f\n    alse', IN_MEMORY => 'false', CACHE_BLOOMS_ON_WRITE => 'false', PREFETCH_BLOCKS_ON_OPEN => 'false', COMPRESSION => 'NONE', BLOCKCACHE => 'true', BLOCKSIZE\n     => '65536'}\n    1 row(s)\n    Took 0.9998 seconds\n    ```\n  </Step>\n\n  <Step>\n    #### Put data into your table\n\n    To put data into your table, use the `put` command.\n\n    ```bash\n    hbase(main):003:0> put 'test', 'row1', 'cf:a', 'value1'\n    0 row(s) in 0.0850 seconds\n\n    hbase(main):004:0> put 'test', 'row2', 'cf:b', 'value2'\n    0 row(s) in 0.0110 seconds\n\n    hbase(main):005:0> put 'test', 'row3', 'cf:c', 'value3'\n    0 row(s) in 0.0100 seconds\n    ```\n\n    Here, we insert three values, one at a time. The first insert is at `row1`, column `cf:a`, with a value of `value1`. Columns in HBase are comprised of a column family prefix, `cf` in this example, followed by a colon and then a column qualifier suffix, `a` in this case.\n  </Step>\n\n  <Step>\n    #### Scan the table for all data at once\n\n    One of the ways to get data from HBase is to scan. Use the `scan` command to scan the table for data. You can limit your scan, but for now, all data is fetched.\n\n    ```bash\n    hbase(main):006:0> scan 'test'\n    ROW                                      COLUMN+CELL\n     row1                                    column=cf:a, timestamp=1421762485768, value=value1\n     row2                                    column=cf:b, timestamp=1421762491785, value=value2\n     row3                                    column=cf:c, timestamp=1421762496210, value=value3\n    3 row(s) in 0.0230 seconds\n    ```\n  </Step>\n\n  <Step>\n    #### Get a single row of data\n\n    To get a single row of data at a time, use the `get` command.\n\n    ```bash\n    hbase(main):007:0> get 'test', 'row1'\n    COLUMN                                   CELL\n     cf:a                                    timestamp=1421762485768, value=value1\n    1 row(s) in 0.0350 seconds\n    ```\n  </Step>\n\n  <Step>\n    #### Disable a table\n\n    If you want to delete a table or change its settings, as well as in some other situations, you need to disable the table first, using the `disable` command. You can re-enable it using the `enable` command.\n\n    ```bash\n    hbase(main):008:0> disable 'test'\n    0 row(s) in 1.1820 seconds\n\n    hbase(main):009:0> enable 'test'\n    0 row(s) in 0.1770 seconds\n    ```\n\n    Disable the table again if you tested the `enable` command above:\n\n    ```bash\n    hbase(main):010:0> disable 'test'\n    0 row(s) in 1.1820 seconds\n    ```\n  </Step>\n\n  <Step>\n    #### Drop the table\n\n    To drop (delete) a table, use the `drop` command.\n\n    ```bash\n    hbase(main):011:0> drop 'test'\n    0 row(s) in 0.1370 seconds\n    ```\n  </Step>\n\n  <Step>\n    #### Exit the HBase Shell\n\n    To exit the HBase Shell and disconnect from your cluster, use the `quit` command. HBase is still running in the background.\n  </Step>\n</Steps>\n\n### Procedure: Stop HBase\n\n<Steps>\n  <Step>\n    In the same way that the *bin/start-hbase.sh* script is provided to conveniently start all HBase daemons, the *bin/stop-hbase.sh* script stops them.\n\n    ```bash\n    $ ./bin/stop-hbase.sh\n    stopping hbase....................\n    ```\n  </Step>\n\n  <Step>\n    After issuing the command, it can take several minutes for the processes to shut down. Use the `jps` to be sure that the HMaster and HRegionServer processes are shut down.\n  </Step>\n</Steps>\n\nThe above has shown you how to start and stop a standalone instance of HBase. In the next sections we give a quick overview of other modes of hbase deploy.\n\n## Pseudo-Distributed for Local Testing\n\nAfter working your way through [quickstart](/docs/getting-started#quick-start---standalone-hbase) standalone mode, you can re-configure HBase to run in pseudo-distributed mode. Pseudo-distributed mode means that HBase still runs completely on a single host, but each HBase daemon (HMaster, HRegionServer, and ZooKeeper) runs as a separate process: in standalone mode all daemons ran in one jvm process/instance. By default, unless you configure the `hbase.rootdir` property as described in [quickstart](/docs/getting-started#quick-start---standalone-hbase), your data is still stored in */tmp/*. In this walk-through, we store your data in HDFS instead, assuming you have HDFS available. You can skip the HDFS configuration to continue storing your data in the local filesystem.\n\n<Callout type=\"info\">\n  This procedure assumes that you have configured Hadoop and HDFS on your local system and/or a\n  remote system, and that they are running and available. It also assumes you are using Hadoop 2.\n  The guide on [Setting up a Single Node\n  Cluster](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html)\n  in the Hadoop documentation is a good starting point.\n</Callout>\n\n<Steps>\n  <Step>\n    #### Stop HBase if it is running\n\n    If you have just finished [quickstart](/docs/getting-started#quick-start---standalone-hbase) and HBase is still running, stop it. This procedure will create a totally new directory where HBase will store its data, so any databases you created before will be lost.\n  </Step>\n\n  <Step>\n    #### Configure HBase\n\n    Edit the *hbase-site.xml* configuration. First, add the following property which directs HBase to run in distributed mode, with one JVM instance per daemon.\n\n    ```xml\n    <property>\n      <name>hbase.cluster.distributed</name>\n      <value>true</value>\n    </property>\n    ```\n\n    Next, add a configuration for `hbase.rootdir`, pointing to the address of your HDFS instance, using the `hdfs:////` URI syntax. In this example, HDFS is running on the localhost at port 8020.\n\n    ```xml\n    <property>\n      <name>hbase.rootdir</name>\n      <value>hdfs://localhost:9000/hbase</value>\n    </property>\n    ```\n\n    You do not need to create the directory in HDFS. HBase will do this for you. If you create the directory, HBase will attempt to do a migration, which is not what you want.\n\n    Finally, remove existing configuration for `hbase.tmp.dir` and `hbase.unsafe.stream.capability.enforce`.\n  </Step>\n\n  <Step>\n    #### Start HBase\n\n    Use the *bin/start-hbase.sh* command to start HBase. If your system is configured correctly, the `jps` command should show the HMaster and HRegionServer processes running.\n  </Step>\n\n  <Step>\n    #### Check the HBase directory in HDFS\n\n    If everything worked correctly, HBase created its directory in HDFS. In the configuration above, it is stored in */hbase/* on HDFS. You can use the `hadoop fs` command in Hadoop's *bin/* directory to list this directory.\n\n    ```bash\n    $ ./bin/hadoop fs -ls /hbase\n    Found 7 items\n    drwxr-xr-x   - hbase users          0 2014-06-25 18:58 /hbase/.tmp\n    drwxr-xr-x   - hbase users          0 2014-06-25 21:49 /hbase/WALs\n    drwxr-xr-x   - hbase users          0 2014-06-25 18:48 /hbase/corrupt\n    drwxr-xr-x   - hbase users          0 2014-06-25 18:58 /hbase/data\n    -rw-r--r--   3 hbase users         42 2014-06-25 18:41 /hbase/hbase.id\n    -rw-r--r--   3 hbase users          7 2014-06-25 18:41 /hbase/hbase.version\n    drwxr-xr-x   - hbase users          0 2014-06-25 21:49 /hbase/oldWALs\n    ```\n  </Step>\n\n  <Step>\n    #### Create a table and populate it with data\n\n    You can use the HBase Shell to create a table, populate it with data, scan and get values from it, using the same procedure as in [shell exercises](/docs/getting-started#procedure-use-hbase-for-the-first-time).\n  </Step>\n\n  <Step>\n    #### Start and stop a backup HBase Master (HMaster) server\n\n    <Callout type=\"info\">\n      Running multiple HMaster instances on the same hardware does not make sense in a production\n      environment, in the same way that running a pseudo-distributed cluster does not make sense for\n      production. This step is offered for testing and learning purposes only.\n    </Callout>\n\n    The HMaster server controls the HBase cluster. You can start up to 9 backup HMaster servers, which makes 10 total HMasters, counting the primary. To start a backup HMaster, use the `local-master-backup.sh`. For each backup master you want to start, add a parameter representing the port offset for that master. Each HMaster uses two ports (16000 and 16010 by default). The port offset is added to these ports, so using an offset of 2, the backup HMaster would use ports 16002 and 16012. The following command starts 3 backup servers using ports 16002/16012, 16003/16013, and 16005/16015.\n\n    ```bash\n    ./bin/local-master-backup.sh start 2 3 5\n    ```\n\n    To kill a backup master without killing the entire cluster, you need to find its process ID (PID). The PID is stored in a file with a name like */tmp/hbase-USER-X-master.pid*. The only contents of the file is the PID. You can use the `kill -9` command to kill that PID. The following command will kill the master with port offset 1, but leave the cluster running:\n\n    ```bash\n    cat /tmp/hbase-testuser-1-master.pid |xargs kill -9\n    ```\n  </Step>\n\n  <Step>\n    #### Start and stop additional RegionServers\n\n    The HRegionServer manages the data in its StoreFiles as directed by the HMaster. Generally, one HRegionServer runs per node in the cluster. Running multiple HRegionServers on the same system can be useful for testing in pseudo-distributed mode. The `local-regionservers.sh` command allows you to run multiple RegionServers. It works in a similar way to the `local-master-backup.sh` command, in that each parameter you provide represents the port offset for an instance. Each RegionServer requires two ports, and the default ports are 16020 and 16030. Since HBase version 1.1.0, HMaster doesn't use region server ports, this leaves 10 ports (16020 to 16029 and 16030 to 16039) to be used for RegionServers. For supporting additional RegionServers, set environment variables HBASE\\_RS\\_BASE\\_PORT and HBASE\\_RS\\_INFO\\_BASE\\_PORT to appropriate values before running script `local-regionservers.sh`. e.g. With values 16200 and 16300 for base ports, 99 additional RegionServers can be supported, on a server. The following command starts four additional RegionServers, running on sequential ports starting at 16022/16032 (base ports 16020/16030 plus 2).\n\n    ```bash\n    ./bin/local-regionservers.sh start 2 3 4 5\n    ```\n\n    To stop a RegionServer manually, use the `local-regionservers.sh` command with the `stop` parameter and the offset of the server to stop.\n\n    ```bash\n    ./bin/local-regionservers.sh stop 3\n    ```\n  </Step>\n\n  <Step>\n    #### Stop HBase\n\n    You can stop HBase the same way as in the [quickstart](/docs/getting-started#quick-start---standalone-hbase) procedure, using the *bin/stop-hbase.sh* command.\n  </Step>\n</Steps>\n\n## Fully Distributed for Production\n\nIn reality, you need a fully-distributed configuration to fully test HBase and to use it in real-world scenarios. In a distributed configuration, the cluster contains multiple nodes, each of which runs one or more HBase daemon. These include primary and backup Master instances, multiple ZooKeeper nodes, and multiple RegionServer nodes.\n\nThis advanced quickstart adds two more nodes to your cluster. The architecture will be as follows:\n\n| Node Name          | Master | ZooKeeper | RegionServer |\n| ------------------ | ------ | --------- | ------------ |\n| node-a.example.com | yes    | yes       | no           |\n| node-b.example.com | backup | yes       | yes          |\n| node-c.example.com | no     | yes       | yes          |\n\nDistributed Cluster Demo Architecture\n\nThis quickstart assumes that each node is a virtual machine and that they are all on the same network. It builds upon the previous quickstart, [Pseudo-Distributed for Local Testing](/docs/getting-started#pseudo-distributed-for-local-testing), assuming that the system you configured in that procedure is now `node-a`. Stop HBase on `node-a` before continuing.\n\n<Callout type=\"info\">\n  Be sure that all the nodes have full access to communicate, and that no firewall rules are in\n  place which could prevent them from talking to each other. If you see any errors like `no route to\n    host`, check your firewall.\n</Callout>\n\n### Procedure: Configure Passwordless SSH Access\n\n`node-a` needs to be able to log into `node-b` and `node-c` (and to itself) in order to start the daemons. The easiest way to accomplish this is to use the same username on all hosts, and configure password-less SSH login from `node-a` to each of the others.\n\n<Steps>\n  <Step>\n    #### On `node-a`, generate a key pair\n\n    While logged in as the user who will run HBase, generate a SSH key pair, using the following command:\n\n    ```bash\n    ssh-keygen -t rsa\n    ```\n\n    If the command succeeds, the location of the key pair is printed to standard output. The default name of the public key is *id\\_rsa.pub*.\n  </Step>\n\n  <Step>\n    #### Create the directory that will hold the shared keys on the other nodes\n\n    On `node-b` and `node-c`, log in as the HBase user and create a *.ssh/* directory in the user's home directory, if it does not already exist. If it already exists, be aware that it may already contain other keys.\n  </Step>\n\n  <Step>\n    #### Copy the public key to the other nodes\n\n    Securely copy the public key from `node-a` to each of the nodes, by using the `scp` or some other secure means. On each of the other nodes, create a new file called *.ssh/authorized\\_keys* *if it does not already exist*, and append the contents of the *id\\_rsa.pub* file to the end of it. Note that you also need to do this for `node-a` itself.\n\n    ```bash\n    cat id_rsa.pub >> ~/.ssh/authorized_keys\n    ```\n  </Step>\n\n  <Step>\n    #### Test password-less login\n\n    If you performed the procedure correctly, you should not be prompted for a password when you SSH from `node-a` to either of the other nodes using the same username.\n  </Step>\n\n  <Step>\n    Since `node-b` will run a backup Master, repeat the procedure above, substituting `node-b` everywhere you see `node-a`. Be sure not to overwrite your existing *.ssh/authorized\\_keys* files, but concatenate the new key onto the existing file using the `>>` operator rather than the `>` operator.\n  </Step>\n</Steps>\n\n### Procedure: Prepare `node-a`\n\n`node-a` will run your primary master and ZooKeeper processes, but no RegionServers. Stop the RegionServer from starting on `node-a`.\n\n<Steps>\n  <Step>\n    Edit *conf/regionservers* and remove the line which contains `localhost`. Add lines with the hostnames or IP addresses for `node-b` and `node-c`.\n\n    Even if you did want to run a RegionServer on `node-a`, you should refer to it by the hostname the other servers would use to communicate with it. In this case, that would be `node-a.example.com`. This enables you to distribute the configuration to each node of your cluster any hostname conflicts. Save the file.\n  </Step>\n\n  <Step>\n    #### Configure HBase to use `node-b` as a backup master\n\n    Create a new file in *conf/* called *backup-masters*, and add a new line to it with the hostname for `node-b`. In this demonstration, the hostname is `node-b.example.com`.\n  </Step>\n\n  <Step>\n    #### Configure ZooKeeper\n\n    In reality, you should carefully consider your ZooKeeper configuration. You can find out more about configuring ZooKeeper in [zookeeper](/docs/zookeeper) section. This configuration will direct HBase to start and manage a ZooKeeper instance on each node of the cluster.\n\n    On `node-a`, edit *conf/hbase-site.xml* and add the following properties.\n\n    ```xml\n    <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>node-a.example.com,node-b.example.com,node-c.example.com</value>\n    </property>\n    <property>\n    <name>hbase.zookeeper.property.dataDir</name>\n    <value>/usr/local/zookeeper</value>\n    </property>\n    ```\n  </Step>\n\n  <Step>\n    Everywhere in your configuration that you have referred to `node-a` as `localhost`, change the reference to point to the hostname that the other nodes will use to refer to `node-a`. In these examples, the hostname is `node-a.example.com`.\n  </Step>\n</Steps>\n\n### Procedure: Prepare `node-b` and `node-c`\n\n`node-b` will run a backup master server and a ZooKeeper instance.\n\n<Steps>\n  <Step>\n    #### Download and unpack HBase\n\n    Download and unpack HBase to `node-b`, just as you did for the standalone and pseudo-distributed quickstarts.\n  </Step>\n\n  <Step>\n    #### Copy the configuration files from `node-a` to `node-b`.and `node-c`\n\n    Each node of your cluster needs to have the same configuration information. Copy the contents of the *conf/* directory to the *conf/* directory on `node-b` and `node-c`.\n  </Step>\n</Steps>\n\n### Procedure: Start and Test Your Cluster\n\n<Steps>\n  <Step>\n    #### Be sure HBase is not running on any node\n\n    If you forgot to stop HBase from previous testing, you will have errors. Check to see whether HBase is running on any of your nodes by using the `jps` command. Look for the processes `HMaster`, `HRegionServer`, and `HQuorumPeer`. If they exist, kill them.\n  </Step>\n\n  <Step>\n    #### Start the cluster\n\n    On `node-a`, issue the `start-hbase.sh` command. Your output will be similar to that below.\n\n    ```bash\n    $ bin/start-hbase.sh\n    node-c.example.com: starting zookeeper, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-zookeeper-node-c.example.com.out\n    node-a.example.com: starting zookeeper, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-zookeeper-node-a.example.com.out\n    node-b.example.com: starting zookeeper, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-zookeeper-node-b.example.com.out\n    starting master, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-master-node-a.example.com.out\n    node-c.example.com: starting regionserver, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-regionserver-node-c.example.com.out\n    node-b.example.com: starting regionserver, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-regionserver-node-b.example.com.out\n    node-b.example.com: starting master, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-master-nodeb.example.com.out\n    ```\n\n    ZooKeeper starts first, followed by the master, then the RegionServers, and finally the backup masters.\n  </Step>\n\n  <Step>\n    #### Verify that the processes are running\n\n    On each node of the cluster, run the `jps` command and verify that the correct processes are running on each server. You may see additional Java processes running on your servers as well, if they are used for other purposes.\n\n    `node-a` `jps` Output\n\n    ```bash\n    $ jps\n    20355 Jps\n    20071 HQuorumPeer\n    20137 HMaster\n    ```\n\n    `node-b` `jps` Output\n\n    ```bash\n    $ jps\n    15930 HRegionServer\n    16194 Jps\n    15838 HQuorumPeer\n    16010 HMaster\n    ```\n\n    `node-c` `jps` Output\n\n    ```bash\n    $ jps\n    13901 Jps\n    13639 HQuorumPeer\n    13737 HRegionServer\n    ```\n\n    <Callout type=\"info\">\n      The `HQuorumPeer` process is a ZooKeeper instance which is controlled and started by HBase. If you\n      use ZooKeeper this way, it is limited to one instance per cluster node and is appropriate for\n      testing only. If ZooKeeper is run outside of HBase, the process is called `QuorumPeer`. For more\n      about ZooKeeper configuration, including using an external ZooKeeper instance with HBase, see\n      [zookeeper](/docs/zookeeper) section.\n    </Callout>\n  </Step>\n\n  <Step>\n    #### Browse to the Web UI\n\n    If everything is set up correctly, you should be able to connect to the UI for the Master `http://node-a.example.com:16010/` or the secondary master at `http://node-b.example.com:16010/` using a web browser. If you can connect via `localhost` but not from another host, check your firewall rules. You can see the web UI for each of the RegionServers at port 16030 of their IP addresses, or by clicking their links in the web UI for the Master.\n  </Step>\n\n  <Step>\n    #### Test what happens when nodes or services disappear\n\n    With a three-node cluster you have configured, things will not be very resilient. You can still test the behavior of the primary Master or a RegionServer by killing the associated processes and watching the logs.\n  </Step>\n</Steps>\n\n## Where to go next\n\nThe next chapter, [configuration](/docs/configuration), gives more information about the different HBase run modes, system requirements for running HBase, and critical configuration areas for setting up a distributed HBase cluster.\n\n\n# Apache HBase APIs (/docs/hbase-apis)\nThis information is not exhaustive, and provides a quick reference in addition to the [User API Reference](https://hbase.apache.org/apidocs/index.html).\nThe examples here are not comprehensive or complete, and should be used for purposes of illustration only.\n\nApache HBase also works with multiple external APIs.\nSee [Apache HBase External APIs](/docs/external-apis) for more information.\n\n## Examples\n\n### Create, modify and delete a Table Using Java\n\n```java\npackage com.example.hbase.admin;\n\nimport java.io.IOException;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.hbase.HBaseConfiguration;\nimport org.apache.hadoop.hbase.HColumnDescriptor;\nimport org.apache.hadoop.hbase.HConstants;\nimport org.apache.hadoop.hbase.HTableDescriptor;\nimport org.apache.hadoop.hbase.TableName;\nimport org.apache.hadoop.hbase.client.Admin;\nimport org.apache.hadoop.hbase.client.Connection;\nimport org.apache.hadoop.hbase.client.ConnectionFactory;\nimport org.apache.hadoop.hbase.io.compress.Compression.Algorithm;\n\npublic class Example {\n\n  private static final String TABLE_NAME = \"MY_TABLE_NAME_TOO\";\n  private static final String CF_DEFAULT = \"DEFAULT_COLUMN_FAMILY\";\n\n  public static void createOrOverwrite(Admin admin, HTableDescriptor table) throws IOException {\n    if (admin.tableExists(table.getTableName())) {\n      admin.disableTable(table.getTableName());\n      admin.deleteTable(table.getTableName());\n    }\n    admin.createTable(table);\n  }\n\n  public static void createSchemaTables(Configuration config) throws IOException {\n    try (Connection connection = ConnectionFactory.createConnection(config);\n         Admin admin = connection.getAdmin()) {\n\n      HTableDescriptor table = new HTableDescriptor(TableName.valueOf(TABLE_NAME));\n      table.addFamily(new HColumnDescriptor(CF_DEFAULT).setCompressionType(Algorithm.NONE));\n\n      System.out.print(\"Creating table. \");\n      createOrOverwrite(admin, table);\n      System.out.println(\" Done.\");\n    }\n  }\n\n  public static void modifySchema (Configuration config) throws IOException {\n    try (Connection connection = ConnectionFactory.createConnection(config);\n         Admin admin = connection.getAdmin()) {\n\n      TableName tableName = TableName.valueOf(TABLE_NAME);\n      if (!admin.tableExists(tableName)) {\n        System.out.println(\"Table does not exist.\");\n        System.exit(-1);\n      }\n\n      HTableDescriptor table = admin.getTableDescriptor(tableName);\n\n      // Update existing table\n      HColumnDescriptor newColumn = new HColumnDescriptor(\"NEWCF\");\n      newColumn.setCompactionCompressionType(Algorithm.GZ);\n      newColumn.setMaxVersions(HConstants.ALL_VERSIONS);\n      admin.addColumn(tableName, newColumn);\n\n      // Update existing column family\n      HColumnDescriptor existingColumn = new HColumnDescriptor(CF_DEFAULT);\n      existingColumn.setCompactionCompressionType(Algorithm.GZ);\n      existingColumn.setMaxVersions(HConstants.ALL_VERSIONS);\n      table.modifyFamily(existingColumn);\n      admin.modifyTable(tableName, table);\n\n      // Disable an existing table\n      admin.disableTable(tableName);\n\n      // Delete an existing column family\n      admin.deleteColumn(tableName, CF_DEFAULT.getBytes(\"UTF-8\"));\n\n      // Delete a table (Need to be disabled first)\n      admin.deleteTable(tableName);\n    }\n  }\n\n  public static void main(String... args) throws IOException {\n    Configuration config = HBaseConfiguration.create();\n\n    //Add any necessary configuration files (hbase-site.xml, core-site.xml)\n    config.addResource(new Path(System.getenv(\"HBASE_CONF_DIR\"), \"hbase-site.xml\"));\n    config.addResource(new Path(System.getenv(\"HADOOP_CONF_DIR\"), \"core-site.xml\"));\n    createSchemaTables(config);\n    modifySchema(config);\n  }\n}\n```\n\n\n# HBase History (/docs/hbase-history)\n* 2006: [BigTable](http://research.google.com/archive/bigtable.html) paper published by Google.\n* 2006 (end of year): HBase development starts.\n* 2008: HBase becomes Hadoop sub-project.\n* 2010: HBase becomes Apache top-level project.\n\n\n# Known Incompatibilities Among HBase Versions (/docs/hbase-incompatibilities)\n## HBase 2.0 Incompatible Changes\n\nThis appendix describes incompatible changes from earlier versions of HBase against HBase 2.0.\nThis list is not meant to be wholly encompassing of all possible incompatibilities.\nInstead, this content is intended to give insight into some obvious incompatibilities which most\nusers will face coming from HBase 1.x releases.\n\n### List of Major Changes for HBase 2.0\n\n* HBASE-1912- HBCK is an HBase database checking tool for capturing the inconsistency. As an HBase administrator, you should not use HBase version 1.0 hbck tool to check the HBase 2.0 database. Doing so will break the database and throw an exception error.\n* HBASE-16189 and HBASE-18945- You cannot open the HBase 2.0 hfiles through HBase 1.0 version. If you are an admin or an HBase user who is using HBase version 1.x, you must first do a rolling upgrade to the latest version of HBase 1.x and then upgrade to HBase 2.0.\n* HBASE-18240 - Changed the ReplicationEndpoint Interface. It also introduces a new hbase-third party 1.0 that packages all the third party utilities, which are expected to run in the hbase cluster.\n\n### Coprocessor API changes\n\n* HBASE-16769 - Deprecated PB references from MasterObserver and RegionServerObserver.\n* HBASE-17312 - \\[JDK8] Use default method for Observer Coprocessors. The interface classes of BaseMasterAndRegionObserver, BaseMasterObserver, BaseRegionObserver, BaseRegionServerObserver and BaseWALObserver uses JDK8's 'default' keyword to provide empty and no-op implementations.\n* Interface HTableInterface\n  HBase 2.0 introduces following changes to the methods listed below:\n\n#### interface CoprocessorEnvironment changes\n\n| Change                                                                    | Result                                                              |\n| ------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method getTable ( TableName ) has been removed.                  | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getTable ( TableName, ExecutorService ) has been removed. | A client program may be interrupted by NoSuchMethodError exception. |\n\n* Public Audience\n\nThe following tables describes the coprocessor changes.\n\n**class CoprocessorRpcChannel**\n\n| Change                           | Result                                                                                                                                    |\n| -------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| This class has become interface. | A client program may be interrupted by IncompatibleClassChangeError or InstantiationError exception depending on the usage of this class. |\n\n**Class CoprocessorHost\\<E>**\n\nClasses that were Audience Private but were removed.\n\n| Change                                                                                                                   | Result                                                             |\n| ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------ |\n| Type of field coprocessors has been changed from java.util.SortedSet\\<E> to org.apache.hadoop.hbase.util.SortedList\\<E>. | A client program may be interrupted by NoSuchFieldError exception. |\n\n#### MasterObserver\n\nHBase 2.0 introduces following changes to the MasterObserver interface.\n\n**interface MasterObserver**\n\n| Change                                                                                                                                                                              | Result                                                              |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method voidpostCloneSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface.   | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostCreateTable ( ObserverContext\\<MasterCoprocessorEnvironment>, HTableDescriptor, HRegionInfo\\[ ] ) has been removed from this interface.                     | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpostDeleteSnapshot (ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription ) has been removed from this interface.                     | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpostGetTableDescriptors ( ObserverContext\\<MasterCoprocessorEnvironment>, List\\<HTableDescriptor> ) has been removed from this interface.                       | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpostModifyTable ( ObserverContext\\<MasterCoprocessorEnvironment>, TableName, HTableDescriptor ) has been removed from this interface.                           | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpostRestoreSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpostSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface.        | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreCloneSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface.    | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreCreateTable ( ObserverContext\\<MasterCoprocessorEnvironment>, HTableDescriptor, HRegionInfo\\[ ] ) has been removed from this interface.                      | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreDeleteSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription ) has been removed from this interface.                     | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreGetTableDescriptors ( ObserverContext\\<MasterCoprocessorEnvironment>, List\\<TableName>, List\\<HTableDescriptor> ) has been removed from this interface.      | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreModifyTable ( ObserverContext\\<MasterCoprocessorEnvironment>, TableName, HTableDescriptor ) has been removed from this interface.                            | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreRestoreSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface.  | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface.         | A client program may be interrupted by NoSuchMethodErrorexception.  |\n\n#### RegionObserver\n\nHBase 2.0 introduces following changes to the RegionObserver interface.\n\n**interface RegionObserver**\n\n| Change                                                                                                                                                                                                                                       | Result                                                              |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method voidpostCloseRegionOperation ( ObserverContext\\<RegionCoprocessorEnvironment>, HRegion.Operation ) has been removed from this interface.                                                                                     | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostCompactSelection ( ObserverContext\\<RegionCoprocessorEnvironment>, Store, ImmutableList\\<StoreFile> ) has been removed from this interface.                                                                          | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostCompactSelection ( ObserverContext\\<RegionCoprocessorEnvironment>, Store, ImmutableList\\<StoreFile>, CompactionRequest ) has been removed from this interface.                                                       | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostGetClosestRowBefore ( ObserverContext\\<RegionCoprocessorEnvironment>, byte\\[ ], byte\\[ ], Result ) has been removed from this interface.                                                                             | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method DeleteTrackerpostInstantiateDeleteTracker ( ObserverContext\\<RegionCoprocessorEnvironment>, DeleteTracker ) has been removed from this interface.                                                                            | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostSplit ( ObserverContext\\<RegionCoprocessorEnvironment>, HRegion, HRegion ) has been removed from this interface.                                                                                                     | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostStartRegionOperation ( ObserverContext\\<RegionCoprocessorEnvironment>, HRegion.Operation ) has been removed from this interface.                                                                                     | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method StoreFile.ReaderpostStoreFileReaderOpen ( ObserverContext\\<RegionCoprocessorEnvironment>, FileSystem, Path, FSDataInputStreamWrapper, long, CacheConfig, Reference, StoreFile.Reader ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostWALRestore ( ObserverContext\\<RegionCoprocessorEnvironment>, HRegionInfo, HLogKey, WALEdit ) has been removed from this interface.                                                                                   | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method InternalScannerpreFlushScannerOpen ( ObserverContext\\<RegionCoprocessorEnvironment>, Store, KeyValueScanner, InternalScanner ) has been removed from this interface.                                                         | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpreGetClosestRowBefore ( ObserverContext\\<RegionCoprocessorEnvironment>, byte\\[ ], byte\\[ ], Result ) has been removed from this interface.                                                                              | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method StoreFile.ReaderpreStoreFileReaderOpen ( ObserverContext\\<RegionCoprocessorEnvironment>, FileSystem, Path, FSDataInputStreamWrapper, long, CacheConfig, Reference, StoreFile.Reader ) has been removed from this interface.  | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpreWALRestore ( ObserverContext\\<RegionCoprocessorEnvironment>, HRegionInfo, HLogKey, WALEdit ) has been removed from this interface.                                                                                    | A client program may be interrupted by NoSuchMethodError exception. |\n\n#### WALObserver\n\nHBase 2.0 introduces following changes to the WALObserver interface.\n\n**interface WALObserver**\n\n| Change                                                                                                                                                  | Result                                                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method voidpostWALWrite ( ObserverContext\\<WALCoprocessorEnvironment>, HRegionInfo, HLogKey, WALEdit ) has been removed from this interface.   | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method booleanpreWALWrite ( ObserverContext\\<WALCoprocessorEnvironment>, HRegionInfo, HLogKey, WALEdit ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Miscellaneous\n\nHBase 2.0 introduces changes to the following classes:\n\nhbase-server-1.0.0.jar, OnlineRegions.class package org.apache.hadoop.hbase.regionserver\n\n**OnlineRegions.getFromOnlineRegions ( String p1 ) \\[abstract] : HRegion**\\\norg/apache/hadoop/hbase/regionserver/OnlineRegions.getFromOnlineRegions:(Ljava/lang/String;)Lorg/apache/hadoop/hbase/regionserver/HRegion;\n\n| Change                                                    | Result                                                                                                                                                    |\n| --------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from Region to Region. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\nhbase-server-1.0.0.jar, RegionCoprocessorEnvironment.class package org.apache.hadoop.hbase.coprocessor\n\n**RegionCoprocessorEnvironment.getRegion ( ) \\[abstract] : HRegion**\\\norg/apache/hadoop/hbase/coprocessor/RegionCoprocessorEnvironment.getRegion:()Lorg/apache/hadoop/hbase/regionserver/HRegion;\n\n| Change                                                                                                                               | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.regionserver.HRegion to org.apache.hadoop.hbase.regionserver.Region. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\nhbase-server-1.0.0.jar, RegionCoprocessorHost.class package org.apache.hadoop.hbase.regionserver\n\n**RegionCoprocessorHost.postAppend ( Append append, Result result ) : void**\\\norg/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.postAppend:(Lorg/apache/hadoop/hbase/client/Append;Lorg/apache/hadoop/hbase/client/Result;)V\n\n| Change                                                                                 | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to org.apache.hadoop.hbase.client.Result. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n**RegionCoprocessorHost.preStoreFileReaderOpen ( FileSystem fs, Path p, FSDataInputStreamWrapper in, long size,CacheConfig cacheConf, Reference r ) : StoreFile.Reader**\\\norg/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.preStoreFileReaderOpen:(Lorg/apache/hadoop/fs/FileSystem;Lorg/apache/hadoop/fs/Path;Lorg/apache/hadoop/hbase/io/FSDataInputStreamWrapper;JLorg/apache/hadoop/hbase/io/hfile/CacheConfig;Lorg/apache/hadoop/hbase/io/Reference;)Lorg/apache/hadoop/hbase/regionserver/StoreFile\\$Reader;\n\n| Change                                                                       | Result                                                                                                                                                    |\n| ---------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from StoreFile.Reader to StoreFileReader. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### IPC\n\n#### Scheduler changes:\n\n1. Following methods became abstract:\n\npackage org.apache.hadoop.hbase.ipc\n\n**class RpcScheduler**\n\n| Change                                                                         | Result                                                              |\n| ------------------------------------------------------------------------------ | ------------------------------------------------------------------- |\n| Abstract method void dispatch ( CallRunner ) has been removed from this class. | A client program may be interrupted by NoSuchMethodError exception. |\n\nhbase-server-1.0.0.jar, RpcScheduler.class package org.apache.hadoop.hbase.ipc\n\n**RpcScheduler.dispatch ( CallRunner p1 ) \\[abstract] : void 1**\n\norg/apache/hadoop/hbase/ipc/RpcScheduler.dispatch:(Lorg/apache/hadoop/hbase/ipc/CallRunner;)V\n\n| Change                                                   | Result                                                                                                                                                    |\n| -------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to boolean. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n2. Following abstract methods have been removed:\n\n**interface PriorityFunction**\n\n| Change                                                                                                     | Result                                                              |\n| ---------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method longgetDeadline ( RPCProtos.RequestHeader, Message ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method int getPriority ( RPCProtos.RequestHeader, Message ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Server API changes:\n\n**class RpcServer**\n\n| Change                                                                                                                 | Result                                                                                              |\n| ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |\n| Type of field CurCall has been changed from java.lang.ThreadLocal\\<RpcServer.Call> to java.lang.ThreadLocal\\<RpcCall>. | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| This class became abstract.                                                                                            | A client program may be interrupted by InstantiationError exception.                                |\n| Abstract method int getNumOpenConnections ( ) has been added to this class.                                            | This class became abstract and a client program may be interrupted by InstantiationError exception. |\n| Field callQueueSize of type org.apache.hadoop.hbase.util.Counter has been removed from this class.                     | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field connectionList of type java.util.List\\<RpcServer.Connection> has been removed from this class.                   | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field maxIdleTime of type int has been removed from this class.                                                        | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field numConnections of type int has been removed from this class.                                                     | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field port of type int has been removed from this class.                                                               | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field purgeTimeout of type long has been removed from this class.                                                      | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field responder of type RpcServer.Responder has been removed from this class.                                          | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field socketSendBufferSize of type int has been removed from this class.                                               | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field thresholdIdleConnections of type int has been removed from this class.                                           | A client program may be interrupted by NoSuchFieldError exception.                                  |\n\nFollowing abstract method has been removed:\n\n| Change                                                                                                                                                                                  | Result                                                              |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method Pair\\<Message,CellScanner>call ( BlockingService, Descriptors.MethodDescriptor, Message, CellScanner, long, MonitoredRPCHandler ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n\n### Replication and WAL changes:\n\nHBASE-18733: WALKey has been purged completely in HBase 2.0.\nFollowing are the changes to the WALKey:\n\n#### classWALKey \\[!toc]\n\n| Change                                                                               | Result                                                               |\n| ------------------------------------------------------------------------------------ | -------------------------------------------------------------------- |\n| Access level of field clusterIds has been changed from protected to private.         | A client program may be interrupted by IllegalAccessError exception. |\n| Access level of field compressionContext has been changed from protected to private. | A client program may be interrupted by IllegalAccessError exception. |\n| Access level of field encodedRegionName has been changed from protected to private.  | A client program may be interrupted by IllegalAccessError exception. |\n| Access level of field tablename has been changed from protectedto private.           | A client program may be interrupted by IllegalAccessError exception. |\n| Access level of field writeTime has been changed from protectedto private.           | A client program may be interrupted by IllegalAccessError exception. |\n\nFollowing fields have been removed:\n\n| Change                                                                             | Result                                                             |\n| ---------------------------------------------------------------------------------- | ------------------------------------------------------------------ |\n| Field LOG of type org.apache.commons.logging.Log has been removed from this class. | A client program may be interrupted by NoSuchFieldError exception. |\n| Field VERSION of type WALKey.Version has been removed from this class.             | A client program may be interrupted by NoSuchFieldError exception. |\n| Field logSeqNum of type long has been removed from this class.                     | A client program may be interrupted by NoSuchFieldError exception. |\n\nFollowing are the changes to the WALEdit.class:\nhbase-server-1.0.0.jar, WALEdit.class package org.apache.hadoop.hbase.regionserver.wal\n\n#### WALEdit.getCompaction ( Cell kv ) \\[static] : WALProtos.CompactionDescriptor \\[!toc]\n\norg/apache/hadoop/hbase/regionserver/wal/WALEdit.getCompaction:(Lorg/apache/hadoop/hbase/Cell;)Lorg/apache/hadoop/hbase/protobuf/generated/WALProtos\\$CompactionDescriptor;\n\n| Change                                                                                                                                                                                                 | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.WALProtos.CompactionDescriptor to org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.CompactionDescriptor. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### WALEdit.getFlushDescriptor ( Cell cell ) \\[static] : WALProtos.FlushDescriptor \\[!toc]\n\norg/apache/hadoop/hbase/regionserver/wal/WALEdit.getFlushDescriptor:(Lorg/apache/hadoop/hbase/Cell;)Lorg/apache/hadoop/hbase/protobuf/generated/WALProtos\\$FlushDescriptor;\n\n| Change                                                                                                                                                                                       | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.WALProtos.FlushDescriptor to org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.FlushDescriptor. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### WALEdit.getRegionEventDescriptor ( Cell cell ) \\[static] : WALProtos.RegionEventDescriptor \\[!toc]\n\norg/apache/hadoop/hbase/regionserver/wal/WALEdit.getRegionEventDescriptor:(Lorg/apache/hadoop/hbase/Cell;)Lorg/apache/hadoop/hbase/protobuf/generated/WALProtos\\$RegionEventDescriptor;\n\n| Change                                                                                                                                                                                                   | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.WALProtos.RegionEventDescriptor to org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.RegionEventDescriptor. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\nFollowing is the change to the WALKey.class:\npackage org.apache.hadoop.hbase.wal\n\n#### WALKey.getBuilder ( WALCellCodec.ByteStringCompressor compressor ) : WALProtos.WALKey.Builder \\[!toc]\n\norg/apache/hadoop/hbase/wal/WALKey.getBuilder:(Lorg/apache/hadoop/hbase/regionserver/wal/WALCellCodec\\$ByteStringCompressor;)Lorg/apache/hadoop/hbase/protobuf/generated/WALProtos\\$WALKey\\$Builder;\n\n| Change                                                                                                                                                                                     | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.WALProtos.WALKey.Builder to org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.WALKey.Builder. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### Deprecated APIs or coprocessor:\n\nHBASE-16769 - PB references from MasterObserver and RegionServerObserver has been removed.\n\n### Admin Interface API changes:\n\nYou cannot administer an HBase 2.0 cluster with an HBase 1.0 client that includes RelicationAdmin, ACC, Thrift and REST usage of Admin ops. Methods returning protobufs have been changed to return POJOs instead. pb is not used in the APIs anymore. Returns have changed from void to Future for async methods.\nHBASE-18106 - Admin.listProcedures and Admin.listLocks were renamed to getProcedures and getLocks.\nMapReduce makes use of Admin doing following admin.getClusterStatus() to calcluate Splits.\n\n* Thrift usage of Admin API:\n  compact(ByteBuffer)\n  createTable(ByteBuffer, List\\<ColumnDescriptor>)\n  deleteTable(ByteBuffer)\n  disableTable(ByteBuffer)\n  enableTable(ByteBuffer)\n  getTableNames()\n  majorCompact(ByteBuffer)\n\n* REST usage of Admin API: hbase-rest org.apache.hadoop.hbase.rest RootResource getTableList() TableName\\[] tableNames = servlet.getAdmin().listTableNames(); SchemaResource delete(UriInfo) Admin admin = servlet.getAdmin(); update(TableSchemaModel, boolean, UriInfo) Admin admin = servlet.getAdmin(); StorageClusterStatusResource get(UriInfo) ClusterStatus status = servlet.getAdmin().getClusterStatus(); StorageClusterVersionResource get(UriInfo) model.setVersion(servlet.getAdmin().getClusterStatus().getHBaseVersion()); TableResource exists() return servlet.getAdmin().tableExists(TableName.valueOf(table));\n\nFollowing are the changes to the Admin interface:\n\n#### interface Admin \\[!toc]\n\n| Change                                                                                                                     | Result                                                              |\n| -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method createTableAsync ( HTableDescriptor, byte\\[ ]\\[ ] ) has been removed from this interface.                  | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method disableTableAsync ( TableName ) has been removed from this interface.                                      | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method enableTableAsync ( TableName ) has been removed from this interface.                                       | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getCompactionState ( TableName ) has been removed from this interface.                                     | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getCompactionStateForRegion ( byte\\[ ] ) has been removed from this interface.                             | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method isSnapshotFinished ( HBaseProtos.SnapshotDescription ) has been removed from this interface.               | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method snapshot ( String, TableName, HBaseProtos.SnapshotDescription.Type ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method snapshot ( HBaseProtos.SnapshotDescription ) has been removed from this interface.                         | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method takeSnapshotAsync ( HBaseProtos.SnapshotDescription ) has been removed from this interface.                | A client program may be interrupted by NoSuchMethodError exception. |\n\nFollowing are the changes to the Admin.class:\nhbase-client-1.0.0.jar, Admin.class package org.apache.hadoop.hbase.client\n\n#### Admin.createTableAsync ( HTableDescriptor p1, byte\\[ ]\\[ ] p2 ) \\[abstract] : void 1 \\[!toc]\n\norg/apache/hadoop/hbase/client/Admin.createTableAsync:(Lorg/apache/hadoop/hbase/HTableDescriptor;\\[\\[B)V\n\n| Change                                                                                        | Result                                                                                                                                                    |\n| --------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to java.util.concurrent.Future\\<java.lang.Void>. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Admin.disableTableAsync ( TableName p1 ) \\[abstract] : void 1 \\[!toc]\n\norg/apache/hadoop/hbase/client/Admin.disableTableAsync:(Lorg/apache/hadoop/hbase/TableName;)V\n\n| Change                                                                                        | Result                                                                                                                                                    |\n| --------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to java.util.concurrent.Future\\<java.lang.Void>. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Admin.enableTableAsync ( TableName p1 ) \\[abstract] : void \\[!toc]\n\norg/apache/hadoop/hbase/client/Admin.enableTableAsync:(Lorg/apache/hadoop/hbase/TableName;)V\n\n| Change                                                                                        | Result                                                                                                                                                    |\n| --------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to java.util.concurrent.Future\\<java.lang.Void>. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Admin.getCompactionState ( TableName p1 ) \\[abstract] : AdminProtos.GetRegionInfoResponse.CompactionState 1 \\[!toc]\n\norg/apache/hadoop/hbase/client/Admin.getCompactionState:(Lorg/apache/hadoop/hbase/TableName;)Lorg/apache/hadoop/hbase/protobuf/generated/AdminProtos\\$GetRegionInfoResponse\\$CompactionState;\n\n| Change                                                                                                                                                   | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.AdminProtos.GetRegionInfoResponse.CompactionState to CompactionState. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Admin.getCompactionStateForRegion ( byte\\[ ] p1 ) \\[abstract] : AdminProtos.GetRegionInfoResponse.CompactionState 1 \\[!toc]\n\norg/apache/hadoop/hbase/client/Admin.getCompactionStateForRegion:(\\[B)Lorg/apache/hadoop/hbase/protobuf/generated/AdminProtos\\$GetRegionInfoResponse\\$CompactionState;\n\n| Change                                                                                                                                                   | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.AdminProtos.GetRegionInfoResponse.CompactionState to CompactionState. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### HTableDescriptor and HColumnDescriptor changes\n\nHTableDescriptor and HColumnDescriptor has become interfaces and you can create it through Builders. HCD has become CFD. It no longer implements writable interface.\npackage org.apache.hadoop.hbase\n\n#### class HColumnDescriptor \\[!toc]\n\n| Change                                                                               | Result                                                              |\n| ------------------------------------------------------------------------------------ | ------------------------------------------------------------------- |\n| Removed super-interface org.apache.hadoop.io.WritableComparable\\<HColumnDescriptor>. | A client program may be interrupted by NoSuchMethodError exception. |\n\nHColumnDescriptor in 1.0.0\n\n```java\n@InterfaceAudience.Public\n@InterfaceStability.Evolving\npublic class HColumnDescriptor implements WritableComparable<HColumnDescriptor> {\n```\n\nHColumnDescriptor in 2.0\n\n```java\n@InterfaceAudience.Public\n@Deprecated // remove it in 3.0\npublic class HColumnDescriptor implements ColumnFamilyDescriptor, Comparable<HColumnDescriptor> {\n```\n\nFor META\\_TABLEDESC, the maker method had been deprecated already in HTD in 1.0.0. OWNER\\_KEY is still in HTD.\n\n#### class HTableDescriptor \\[!toc]\n\n| Change                                                                              | Result                                                              |\n| ----------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Removed super-interface org.apache.hadoop.io.WritableComparable\\<HTableDescriptor>. | A client program may be interrupted by NoSuchMethodError exception. |\n| Field META\\_TABLEDESC of type HTableDescriptor has been removed from this class.    | A client program may be interrupted by NoSuchFieldError exception.  |\n\nhbase-client-1.0.0.jar, HTableDescriptor.class package org.apache.hadoop.hbase\n\n**HTableDescriptor.getColumnFamilies ( ) : HColumnDescriptor\\[ ]**\\\norg/apache/hadoop/hbase/HTableDescriptor.getColumnFamilies:()\\[Lorg/apache/hadoop/hbase/HColumnDescriptor;\n\n**class HColumnDescriptor**\n\n| Change                                                                                           | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from HColumnDescriptor\\[]to client.ColumnFamilyDescriptor\\[]. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n**HTableDescriptor.getCoprocessors ( ) : List\\<String>**\\\norg/apache/hadoop/hbase/HTableDescriptor.getCoprocessors:()Ljava/util/List;\n\n| Change                                                                                             | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from java.util.List\\<java.lang.String> to java.util.Collection. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-12990 MetaScanner is removed and it is replaced by MetaTableAccessor.\n\n#### HTableWrapper changes: \\[!toc]\n\nhbase-server-1.0.0.jar, HTableWrapper.class package org.apache.hadoop.hbase.client\n\n**HTableWrapper.createWrapper ( List\\<HTableInterface> openTables, TableName tableName, CoprocessorHost.Environment env, ExecutorService pool ) \\[static] : HTableInterface 1**\n\norg/apache/hadoop/hbase/client/HTableWrapper.createWrapper:(Ljava/util/List;Lorg/apache/hadoop/hbase/TableName;Lorg/apache/hadoop/hbase/coprocessor/CoprocessorHost\\$Environment;Ljava/util/concurrent/ExecutorService;)Lorg/apache/hadoop/hbase/client/HTableInterface;\n\n| Change                                                            | Result                                                                                                                                                    |\n| ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from HTableInterface to Table. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-12586: Delete all public HTable constructors and delete ConnectionManager#\\{delete,get}Connection.\n* HBASE-9117: Remove HTablePool and all HConnection pooling related APIs.\n* HBASE-13214: Remove deprecated and unused methods from HTable class\n  Following are the changes to the Table interface:\n\n**interface Table**\n\n| Change                                                                                              | Result                                                              |\n| --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method batch ( List\\<?> ) has been removed from this interface.                            | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method batchCallback ( List\\<?>, Batch.Callback\\<R> )has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getWriteBufferSize ( ) has been removed from this interface.                        | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method setWriteBufferSize ( long ) has been removed from this interface.                   | A client program may be interrupted by NoSuchMethodError exception. |\n\n### Deprecated buffer methods in Table (in 1.0.1) and removed in 2.0.0\n\n* HBASE-13298- Clarify if Table.\\{set|get}WriteBufferSize() is deprecated or not.\n* LockTimeoutException and OperationConflictException classes have been removed.\n\n#### class OperationConflictException \\[!toc]\n\n| Change                       | Result                                                                |\n| ---------------------------- | --------------------------------------------------------------------- |\n| This class has been removed. | A client program may be interrupted by NoClassDefFoundErrorexception. |\n\n#### class class LockTimeoutException \\[!toc]\n\n| Change                       | Result                                                                |\n| ---------------------------- | --------------------------------------------------------------------- |\n| This class has been removed. | A client program may be interrupted by NoClassDefFoundErrorexception. |\n\n### Filter API changes:\n\nFollowing methods have been removed:\npackage org.apache.hadoop.hbase.filter\n\n#### class Filter \\[!toc]\n\n| Change                                                                        | Result                                                              |\n| ----------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method getNextKeyHint ( KeyValue ) has been removed from this class. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method transform ( KeyValue ) has been removed from this class.      | A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-12296 Filters should work with ByteBufferedCell.\n* HConnection is removed in HBase 2.0.\n* RegionLoad and ServerLoad internally moved to shaded PB.\n\n#### class RegionLoad \\[!toc]\n\n| Change                                                                                                                                                          | Result                                                             |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |\n| Type of field regionLoadPB has been changed from protobuf.generated.ClusterStatusProtos.RegionLoad to shaded.protobuf.generated.ClusterStatusProtos.RegionLoad. | A client program may be interrupted by NoSuchFieldError exception. |\n\n* HBASE-15783:AccessControlConstants#OP\\_ATTRIBUTE\\_ACL\\_STRATEGY\\_CELL\\_FIRST is not used any more.\n  package org.apache.hadoop.hbase.security.access\n\n#### interface AccessControlConstants \\[!toc]\n\n| Change                                                                                                | Result                                                             |\n| ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |\n| Field OP\\_ATTRIBUTE\\_ACL\\_STRATEGY of type java.lang.Stringhas been removed from this interface.      | A client program may be interrupted by NoSuchFieldError exception. |\n| Field OP\\_ATTRIBUTE\\_ACL\\_STRATEGY\\_CELL\\_FIRST of type byte\\[] has been removed from this interface. | A client program may be interrupted by NoSuchFieldError exception. |\n| Field OP\\_ATTRIBUTE\\_ACL\\_STRATEGY\\_DEFAULT of type byte\\[] has been removed from this interface.     | A client program may be interrupted by NoSuchFieldError exception. |\n\n#### ServerLoad returns long instead of int 1 \\[!toc]\n\nhbase-client-1.0.0.jar, ServerLoad.class package org.apache.hadoop.hbase\n\n#### ServerLoad.getNumberOfRequests ( ) : int 1 \\[!toc]\n\norg/apache/hadoop/hbase/ServerLoad.getNumberOfRequests:()I\n\n| Change                                               | Result                                                                                                                                                    |\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from int to long. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### ServerLoad.getReadRequestsCount ( ) : int 1 \\[!toc]\n\norg/apache/hadoop/hbase/ServerLoad.getReadRequestsCount:()I\n\n| Change                                               | Result                                                                                                                                                    |\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from int to long. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### ServerLoad.getTotalNumberOfRequests ( ) : int 1 \\[!toc]\n\norg/apache/hadoop/hbase/ServerLoad.getTotalNumberOfRequests:()I\n\n| Change                                               | Result                                                                                                                                                    |\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from int to long. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### ServerLoad.getWriteRequestsCount ( ) : int 1 \\[!toc]\n\norg/apache/hadoop/hbase/ServerLoad.getWriteRequestsCount:()I\n\n| Change                                               | Result                                                                                                                                                    |\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from int to long. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-13636 Remove deprecation for HBASE-4072 (Reading of zoo.cfg)\n* HConstants are removed. HBASE-16040 Remove configuration \"hbase.replication\"\n\n#### class HConstants \\[!toc]\n\n| Change                                                                                                  | Result                                                             |\n| ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |\n| Field DEFAULT\\_HBASE\\_CONFIG\\_READ\\_ZOOKEEPER\\_CONFIG of type boolean has been removed from this class. | A client program may be interrupted by NoSuchFieldError exception. |\n| Field HBASE\\_CONFIG\\_READ\\_ZOOKEEPER\\_CONFIG of type java.lang.String has been removed from this class. | A client program may be interrupted by NoSuchFieldError exception. |\n| Field REPLICATION\\_ENABLE\\_DEFAULT of type boolean has been removed from this class.                    | A client program may be interrupted by NoSuchFieldError exception. |\n| Field REPLICATION\\_ENABLE\\_KEY of type java.lang.String has been removed from this class.               | A client program may be interrupted by NoSuchFieldError exception. |\n| Field ZOOKEEPER\\_CONFIG\\_NAME of type java.lang.String has been removed from this class.                | A client program may be interrupted by NoSuchFieldError exception. |\n| Field ZOOKEEPER\\_USEMULTI of type java.lang.String has been removed from this class.                    | A client program may be interrupted by NoSuchFieldError exception. |\n\n* HBASE-18732: \\[compat 1-2] HBASE-14047 removed Cell methods without deprecation cycle.\n\n#### interface Cell 5 \\[!toc]\n\n| Change                                                                   | Result                                                              |\n| ------------------------------------------------------------------------ | ------------------------------------------------------------------- |\n| Abstract method getFamily ( ) has been removed from this interface.      | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getMvccVersion ( ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getQualifier ( ) has been removed from this interface.   | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getRow ( ) has been removed from this interface.         | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getValue ( ) has been removed from this interface.       | A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-18795:Expose KeyValue.getBuffer() for tests alone. Allows KV#getBuffer in tests only that was deprecated previously.\n\n### Region scanner changes:\n\n#### interface RegionScanner \\[!toc]\n\n| Change                                                                                     | Result                                                              |\n| ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------- |\n| Abstract method boolean nextRaw ( List\\<Cell>, int ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n\n### StoreFile changes:\n\n#### class StoreFile \\[!toc]\n\n| Change                       | Result                                                                                                                                    |\n| ---------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| This class became interface. | A client program may be interrupted by IncompatibleClassChangeError or InstantiationError exception dependent on the usage of this class. |\n\n### Mapreduce changes:\n\nHFile\\*Format has been removed in HBase 2.0.\n\n### ClusterStatus changes:\n\nHBASE-15843: Replace RegionState.getRegionInTransition() Map with a Set\nhbase-client-1.0.0.jar, ClusterStatus.class package org.apache.hadoop.hbase\n\n#### ClusterStatus.getRegionsInTransition ( ) : Map\\<String,RegionState> 1 \\[!toc]\n\norg/apache/hadoop/hbase/ClusterStatus.getRegionsInTransition:()Ljava/util/Map;\n\n| Change                                                                                                                              | Result                                                                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from java.util.Map\\<java.lang.String,master.RegionState> to java.util.List\\<master.RegionState>. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\nOther changes in ClusterStatus include removal of convert methods that were no longer necessary after purge of PB from API.\n\n### Purge of PBs from API\n\nPBs have been deprecated in APIs in HBase 2.0.\n\n#### HBaseSnapshotException.getSnapshotDescription ( ) : HBaseProtos.SnapshotDescription 1 \\[!toc]\n\norg/apache/hadoop/hbase/snapshot/HBaseSnapshotException.getSnapshotDescription:()Lorg/apache/hadoop/hbase/protobuf/generated/HBaseProtos\\$SnapshotDescription;\n\n| Change                                                                                                                                                                    | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.HBaseProtos.SnapshotDescription to org.apache.hadoop.hbase.client.SnapshotDescription. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-15609: Remove PB references from Result, DoubleColumnInterpreter and any such public facing class for 2.0.\n  hbase-client-1.0.0.jar, Result.class package org.apache.hadoop.hbase.client\n\n#### Result.getStats ( ) : ClientProtos.RegionLoadStats 1 \\[!toc]\n\norg/apache/hadoop/hbase/client/Result.getStats:()Lorg/apache/hadoop/hbase/protobuf/generated/ClientProtos\\$RegionLoadStats;\n\n| Change                                                                                                                              | Result                                                                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.ClientProtos.RegionLoadStats to RegionLoadStats. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### REST changes:\n\nhbase-rest-1.0.0.jar, Client.class package org.apache.hadoop.hbase.rest.client\n\n#### Client.getHttpClient ( ) : HttpClient 1 \\[!toc]\n\norg/apache/hadoop/hbase/rest/client/Client.getHttpClient:()Lorg/apache/commons/httpclient/HttpClient\n\n| Change                                                                                                                 | Result                                                                                                                                                    |\n| ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.commons.httpclient.HttpClient to org.apache.http.client.HttpClient. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\nhbase-rest-1.0.0.jar, Response.class package org.apache.hadoop.hbase.rest.client\n\n#### Response.getHeaders ( ) : Header\\[ ] 1 \\[!toc]\n\norg/apache/hadoop/hbase/rest/client/Response.getHeaders:()\\[Lorg/apache/commons/httpclient/Header;\n\n| Change                                                                                                        | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.commons.httpclient.Header\\[] to org.apache.http.Header\\[]. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### PrettyPrinter changes:\n\nhbase-server-1.0.0.jar, HFilePrettyPrinter.class package org.apache.hadoop.hbase.io.hfile\n\n#### HFilePrettyPrinter.processFile ( Path file ) : void 1 \\[!toc]\n\norg/apache/hadoop/hbase/io/hfile/HFilePrettyPrinter.processFile:(Lorg/apache/hadoop/fs/Path;)V\n\n| Change                                               | Result                                                                                                                                                    |\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to int. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### AccessControlClient changes:\n\nHBASE-13171 Change AccessControlClient methods to accept connection object to reduce setup time. Parameters have been changed in the following methods:\n\n* hbase-client-1.2.7-SNAPSHOT.jar, AccessControlClient.class\n  package org.apache.hadoop.hbase.security.access\n  AccessControlClient.getUserPermissions ( Configuration conf, String tableRegex ) \\[static] : List\\<UserPermission> **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.getUserPermissions:(Lorg/apache/hadoop/conf/Configuration;Ljava/lang/String;)Ljava/util/List;\n\n* AccessControlClient.grant ( Configuration conf, String namespace, String userName, Permission.Action... actions )\\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.grant:(Lorg/apache/hadoop/conf/Configuration;Ljava/lang/String;Ljava/lang/String;\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* AccessControlClient.grant ( Configuration conf, String userName, Permission.Action... actions ) \\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.grant:(Lorg/apache/hadoop/conf/Configuration;Ljava/lang/String;\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* AccessControlClient.grant ( Configuration conf, TableName tableName, String userName, byte\\[ ] family, byte\\[ ] qual,Permission.Action... actions ) \\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.grant:(Lorg/apache/hadoop/conf/Configuration;Lorg/apache/hadoop/hbase/TableName;Ljava/lang/String;\\[B\\[B\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* AccessControlClient.isAccessControllerRunning ( Configuration conf ) \\[static] : boolean **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.isAccessControllerRunning:(Lorg/apache/hadoop/conf/Configuration;)Z\n\n* AccessControlClient.revoke ( Configuration conf, String namespace, String userName, Permission.Action... actions )\\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.revoke:(Lorg/apache/hadoop/conf/Configuration;Ljava/lang/String;Ljava/lang/String;\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* AccessControlClient.revoke ( Configuration conf, String userName, Permission.Action... actions ) \\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.revoke:(Lorg/apache/hadoop/conf/Configuration;Ljava/lang/String;\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* AccessControlClient.revoke ( Configuration conf, TableName tableName, String username, byte\\[ ] family, byte\\[ ] qualifier,Permission.Action... actions ) \\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.revoke:(Lorg/apache/hadoop/conf/Configuration;Lorg/apache/hadoop/hbase/TableName;Ljava/lang/String;\\[B\\[B\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* HBASE-18731: \\[compat 1-2] Mark protected methods of QuotaSettings that touch Protobuf internals as IA.Private\n\n\n# hbtop (/docs/hbtop)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Usage\n\nYou can run hbtop with the following command:\n\n```bash\n$ hbase hbtop\n```\n\nIn this case, the values of `hbase.client.zookeeper.quorum` and `zookeeper.znode.parent` in `hbase-site.xml` in the classpath or the default values of them are used to connect.\n\nOr, you can specify your own zookeeper quorum and znode parent as follows:\n\n```bash\n$ hbase hbtop -Dhbase.client.zookeeper.quorum=<zookeeper quorum> -Dzookeeper.znode.parent=<znode parent>\n```\n\n<img alt=\"Top screen\" src={__img0} />\n\nThe top screen consists of a summary part and of a metrics part.\nIn the summary part, you can see `HBase Version`, `Cluster ID`, `The number of region servers`, `Region count`, `Average Cluster Load` and `Aggregated Request/s`.\nIn the metrics part, you can see metrics per Region/Namespace/Table/RegionServer depending on the selected mode.\nThe top screen is refreshed in a certain period – 3 seconds by default.\n\n### Scrolling metric records\n\nYou can scroll the metric records in the metrics part.\n\n<img alt=\"Scrolling metric records\" src={__img1} />\n\n### Command line arguments\n\n| Argument                        | Description                                                                                                                                                                                                                                                |\n| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| -d,--delay `<arg>`              | The refresh delay (in seconds); default is 3 seconds                                                                                                                                                                                                       |\n| -h,--help                       | Print usage; for help while the tool is running press `h` key                                                                                                                                                                                              |\n| -m,--mode `<arg>`               | The mode; `n` (Namespace)\\| `t` (Table)\\| `r` (Region)\\| `s` (RegionServer), default is `r`                                                                                                                                                                |\n| -n,--numberOfIterations `<arg>` | The number of iterations                                                                                                                                                                                                                                   |\n| -O,--outputFieldNames           | Print each of the available field names on a separate line, then quit                                                                                                                                                                                      |\n| -f,--fields `<arg>`             | Show only the given fields. Specify comma separated fields to show multiple fields                                                                                                                                                                         |\n| -s,--sortField `<arg>`          | The initial sort field. You can prepend a `+` or `-` to the field name to also override the sort direction. A leading `+` will force sorting high to low, whereas a `-` will ensure a low to high ordering                                                 |\n| -i,--filters `<arg>`            | The initial filters. Specify comma separated filters to set multiple filters                                                                                                                                                                               |\n| -b,--batchMode                  | Starts hbtop in Batch mode, which could be useful for sending output from hbtop to other programs or to a file. In this mode, hbtop will not accept input and runs until the iterations limit you've set with the `-n` command-line option or until killed |\n\n### Modes\n\nThere are the following modes in hbtop:\n\n| Mode         | Description                              |\n| ------------ | ---------------------------------------- |\n| Region       | Showing metric records per region        |\n| Namespace    | Showing metric records per namespace     |\n| Table        | Showing metric records per table         |\n| RegionServer | Showing metric records per region server |\n| User         | Showing metric records per user          |\n| Client       | Showing metric records per client        |\n\n#### Region mode\n\nIn Region mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field        | Description                            | Displayed by default |\n| ------------ | -------------------------------------- | -------------------- |\n| RNAME        | Region Name                            | false                |\n| NAMESPACE    | Namespace Name                         | true                 |\n| TABLE        | Table Name                             | true                 |\n| SCODE        | Start Code                             | false                |\n| REPID        | Replica ID                             | false                |\n| REGION       | Encoded Region Name                    | true                 |\n| RS           | Short Region Server Name               | true                 |\n| LRS          | Long Region Server Name                | false                |\n| #REQ/S       | Request Count per second               | true                 |\n| #READ/S      | Read Request Count per second          | true                 |\n| #FREAD/S     | Filtered Read Request Count per second | true                 |\n| #WRITE/S     | Write Request Count per second         | true                 |\n| SF           | StoreFile Size                         | true                 |\n| USF          | Uncompressed StoreFile Size            | false                |\n| #SF          | Number of StoreFiles                   | true                 |\n| MEMSTORE     | MemStore Size                          | true                 |\n| LOCALITY     | Block Locality                         | true                 |\n| SKEY         | Start Key                              | false                |\n| #COMPingCELL | Compacting Cell Count                  | false                |\n| #COMPedCELL  | Compacted Cell Count                   | false                |\n| %COMP        | Compaction Progress                    | false                |\n| LASTMCOMP    | Last Major Compaction Time             | false                |\n\n#### Namespace mode\n\nIn Namespace mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field     | Description                            | Displayed by default |\n| --------- | -------------------------------------- | -------------------- |\n| NAMESPACE | Namespace Name                         | true                 |\n| #REGION   | Region Count                           | true                 |\n| #REQ/S    | Request Count per second               | true                 |\n| #READ/S   | Read Request Count per second          | true                 |\n| #FREAD/S  | Filtered Read Request Count per second | true                 |\n| #WRITE/S  | Write Request Count per second         | true                 |\n| SF        | StoreFile Size                         | true                 |\n| USF       | Uncompressed StoreFile Size            | false                |\n| #SF       | Number of StoreFiles                   | true                 |\n| MEMSTORE  | MemStore Size                          | true                 |\n\n#### Table mode\n\nIn Table mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field     | Description                            | Displayed by default |\n| --------- | -------------------------------------- | -------------------- |\n| NAMESPACE | Namespace Name                         | true                 |\n| TABLE     | Table Name                             | true                 |\n| #REGION   | Region Count                           | true                 |\n| #REQ/S    | Request Count per second               | true                 |\n| #READ/S   | Read Request Count per second          | true                 |\n| #FREAD/S  | Filtered Read Request Count per second | true                 |\n| #WRITE/S  | Write Request Count per second         | true                 |\n| SF        | StoreFile Size                         | true                 |\n| USF       | Uncompressed StoreFile Size            | false                |\n| #SF       | Number of StoreFiles                   | true                 |\n| MEMSTORE  | MemStore Size                          | true                 |\n\n#### RegionServer mode\n\nIn RegionServer mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field    | Description                            | Displayed by default |\n| -------- | -------------------------------------- | -------------------- |\n| RS       | Short Region Server Name               | true                 |\n| LRS      | Long Region Server Name                | false                |\n| #REGION  | Region Count                           | true                 |\n| #REQ/S   | Request Count per second               | true                 |\n| #READ/S  | Read Request Count per second          | true                 |\n| #FREAD/S | Filtered Read Request Count per second | true                 |\n| #WRITE/S | Write Request Count per second         | true                 |\n| SF       | StoreFile Size                         | true                 |\n| USF      | Uncompressed StoreFile Size            | false                |\n| #SF      | Number of StoreFiles                   | true                 |\n| MEMSTORE | MemStore Size                          | true                 |\n| UHEAP    | Used Heap Size                         | true                 |\n| MHEAP    | Max Heap Size                          | true                 |\n\n#### User mode\n\nIn User mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field    | Description                            | Displayed by default |\n| -------- | -------------------------------------- | -------------------- |\n| USER     | user Name                              | true                 |\n| #CLIENT  | Client Count                           | true                 |\n| #REQ/S   | Request Count per second               | true                 |\n| #READ/S  | Read Request Count per second          | true                 |\n| #WRITE/S | Write Request Count per second         | true                 |\n| #FREAD/S | Filtered Read Request Count per second | true                 |\n\n#### Client mode\n\nIn Client mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field    | Description                            | Displayed by default |\n| -------- | -------------------------------------- | -------------------- |\n| CLIENT   | Client Hostname                        | true                 |\n| #USER    | User Count                             | true                 |\n| #REQ/S   | Request Count per second               | true                 |\n| #READ/S  | Read Request Count per second          | true                 |\n| #WRITE/S | Write Request Count per second         | true                 |\n| #FREAD/S | Filtered Read Request Count per second | true                 |\n\n### Changing mode\n\nYou can change mode by pressing `m` key in the top screen.\n\n<img alt=\"Changing mode\" src={__img2} />\n\n### Changing the refresh delay\n\nYou can change the refresh by pressing `d` key in the top screen.\n\n<img alt=\"Changing the refresh delay\" src={__img3} />\n\n### Changing the displayed fields\n\nYou can move to the field screen by pressing `f` key in the top screen. In the fields screen, you can change the displayed fields by choosing a field and pressing `d` key or `space` key.\n\n<img alt=\"Changing the displayed fields\" src={__img4} />\n\n### Changing the sort field\n\nYou can move to the fields screen by pressing `f` key in the top screen. In the field screen, you can change the sort field by choosing a field and pressing `s`. Also, you can change the sort order (ascending or descending) by pressing `R` key.\n\n<img alt=\"Changing the sort field\" src={__img5} />\n\n### Changing the order of the fields\n\nYou can move to the fields screen by pressing `f` key in the top screen. In the field screen, you can change the order of the fields.\n\n<img alt=\"Changing the sort field\" src={__img6} />\n\n### Filters\n\nYou can filter the metric records with the filter feature. We can add filters by pressing `o` key for ignoring case or `O` key for case sensitive.\n\n<img alt=\"Adding filters\" src={__img7} />\n\nThe syntax is as follows:\n\n```\n<Field><Operator><Value>\n```\n\nFor example, we can add filters like the following:\n\n```\nNAMESPACE==default\nREQ/S>1000\n```\n\nThe operators we can specify are as follows:\n\n| Operator | Description              |\n| -------- | ------------------------ |\n| =        | Partial match            |\n| ==       | Exact match              |\n| >        | Greater than             |\n| >=       | Greater than or equal to |\n| \\<       | Less than                |\n| \\<=      | Less than and equal to   |\n\nYou can see the current filters by pressing `^o` key and clear them by pressing `=` key.\n\n<img alt=\"Showing and clearing filters\" src={__img8} />\n\n### Drilling down\n\nYou can drill down the metric record by choosing a metric record that you want to drill down and pressing `i` key in the top screen. With this feature, you can find hot regions easily in a top-down manner.\n\n<img alt=\"Drilling down\" src={__img9} />\n\n### Help screen\n\nYou can see the help screen by pressing `h` key in the top screen.\n\n<img alt=\"Help screen\" src={__img10} />\n\n## Others\n\n### How hbtop gets the metrics data\n\nhbtop gets the metrics from ClusterMetrics which is returned as the result of a call to Admin#getClusterMetrics() on the current HMaster. To add metrics to hbtop, they will need to be exposed via ClusterMetrics.\n\n\n# HFile Format (/docs/hfile-format)\n\n\n\n\n## HBase File Format (version 1)\n\nAs we will be discussing changes to the HFile format, it is useful to give a short overview of the original (HFile version 1) format.\n\n### Overview of Version 1\n\nAn HFile in version 1 format is structured as follows:\n\n<img alt=\"HFile V1 Format\" src={__img0} placeholder=\"blur\" />\n\n### Block index format in version 1\n\nThe block index in version 1 is very straightforward.\nFor each entry, it contains:\n\n1. Offset (long)\n2. Uncompressed size (int)\n3. Key (a serialized byte array written using Bytes.writeByteArray)\n   * Key length as a variable-length integer (VInt)\n   * Key bytes\n\nThe number of entries in the block index is stored in the fixed file trailer, and has to be passed in to the method that reads the block index.\nOne of the limitations of the block index in version 1 is that it does not provide the compressed size of a block, which turns out to be necessary for decompression.\nTherefore, the HFile reader has to infer this compressed size from the offset difference between blocks.\nWe fix this limitation in version 2, where we store on-disk block size instead of uncompressed size, and get uncompressed size from the block header.\n\n## HBase file format with inline blocks (version 2)\n\nNote: this feature was introduced in HBase 0.92\n\n### Motivation\n\nWe found it necessary to revise the HFile format after encountering high memory usage and slow startup times caused by large Bloom filters and block indexes in the region server.\nBloom filters can get as large as 100 MB per HFile, which adds up to 2 GB when aggregated over 20 regions.\nBlock indexes can grow as large as 6 GB in aggregate size over the same set of regions.\nA region is not considered opened until all of its block index data is loaded.\nLarge Bloom filters produce a different performance problem: the first get request that requires a Bloom filter lookup will incur the latency of loading the entire Bloom filter bit array.\n\nTo speed up region server startup we break Bloom filters and block indexes into multiple blocks and write those blocks out as they fill up, which also reduces the HFile writer's memory footprint.\nIn the Bloom filter case, \"filling up a block\" means accumulating enough keys to efficiently utilize a fixed-size bit array, and in the block index case we accumulate an \"index block\" of the desired size.\nBloom filter blocks and index blocks (we call these \"inline blocks\") become interspersed with data blocks, and as a side effect we can no longer rely on the difference between block offsets to determine data block length, as it was done in version 1.\n\nHFile is a low-level file format by design, and it should not deal with application-specific details such as Bloom filters, which are handled at StoreFile level.\nTherefore, we call Bloom filter blocks in an HFile \"inline\" blocks.\nWe also supply HFile with an interface to write those inline blocks.\n\nAnother format modification aimed at reducing the region server startup time is to use a contiguous \"load-on-open\" section that has to be loaded in memory at the time an HFile is being opened.\nCurrently, as an HFile opens, there are separate seek operations to read the trailer, data/meta indexes, and file info.\nTo read the Bloom filter, there are two more seek operations for its \"data\" and \"meta\" portions.\nIn version 2, we seek once to read the trailer and seek again to read everything else we need to open the file from a contiguous block.\n\n### Overview of Version 2\n\nThe version of HBase introducing the above features reads both version 1 and 2 HFiles, but only writes version 2 HFiles.\nA version 2 HFile is structured as follows:\n\n<img alt=\"HFile Version 2 Structure\" src={__img1} placeholder=\"blur\" />\n\n### Unified version 2 block format\n\nIn the version 2 every block in the data section contains the following fields:\n\n1. 8 bytes: Block type, a sequence of bytes equivalent to version 1's \"magic records\". Supported block types are:\n   * DATA – data blocks\n   * LEAF\\_INDEX – leaf-level index blocks in a multi-level-block-index\n   * BLOOM\\_CHUNK – Bloom filter chunks\n   * META – meta blocks (not used for Bloom filters in version 2 anymore)\n   * INTERMEDIATE\\_INDEX – intermediate-level index blocks in a multi-level blockindex\n   * ROOT\\_INDEX – root-level index blocks in a multi-level block index\n   * FILE\\_INFO – the \"file info\" block, a small key-value map of metadata\n   * BLOOM\\_META – a Bloom filter metadata block in the load-on-open section\n   * TRAILER – a fixed-size file trailer. As opposed to the above, this is not an HFile v2 block but a fixed-size (for each HFile version) data structure\n   * INDEX\\_V1 – this block type is only used for legacy HFile v1 block\n2. Compressed size of the block's data, not including the header (int).\\\n   Can be used for skipping the current data block when scanning HFile data.\n3. Uncompressed size of the block's data, not including the header (int)\\\n   This is equal to the compressed size if the compression algorithm is NONE\n4. File offset of the previous block of the same type (long)\\\n   Can be used for seeking to the previous data/index block\n5. Compressed data (or uncompressed data if the compression algorithm is NONE).\n\nThe above format of blocks is used in the following HFile sections:\n\n#### Scanned block section\n\nThe section is named so because it contains all data blocks that need to be read when an HFile is scanned sequentially.\nAlso contains Leaf index blocks and Bloom chunk blocks.\n\n#### Non-scanned block section\n\nThis section still contains unified-format v2 blocks but it does not have to be read when doing a sequential scan.\nThis section contains \"meta\" blocks and intermediate-level index blocks.\n\nWe are supporting \"meta\" blocks in version 2 the same way they were supported in version 1, even though we do not store Bloom filter data in these blocks anymore.\n\n### Block index in version 2\n\nThere are three types of block indexes in HFile version 2, stored in two different formats (root and non-root):\n\n1. Data index — version 2 multi-level block index, consisting of:\n   * Version 2 root index, stored in the data block index section of the file\n   * Optionally, version 2 intermediate levels, stored in the non-root format in the data index section of the file. Intermediate levels can only be present if leaf level blocks are present\n   * Optionally, version 2 leaf levels, stored in the non-root format inline with data blocks\n2. Meta index — version 2 root index format only, stored in the meta index section of the file\n3. Bloom index — version 2 root index format only, stored in the \"load-on-open\" section as part of Bloom filter metadata.\n\n### Root block index format in version 2\n\nThis format applies to:\n\n1. Root level of the version 2 data index\n2. Entire meta and Bloom indexes in version 2, which are always single-level.\n\nA version 2 root index block is a sequence of entries of the following format, similar to entries of a version 1 block index, but storing on-disk size instead of uncompressed size.\n\n1. Offset (long)\\\n   This offset may point to a data block or to a deeper-level index block.\n2. On-disk size (int)\n3. Key (a serialized byte array stored using Bytes.writeByteArray)\n4. Key (VInt)\n5. Key bytes\n\nA single-level version 2 block index consists of just a single root index block.\nTo read a root index block of version 2, one needs to know the number of entries.\nFor the data index and the meta index the number of entries is stored in the trailer, and for the Bloom index it is stored in the compound Bloom filter metadata.\n\nFor a multi-level block index we also store the following fields in the root index block in the load-on-open section of the HFile, in addition to the data structure described above:\n\n* Middle leaf index block offset\n* Middle leaf block on-disk size (meaning the leaf index block containing the reference to the \"middle\" data block of the file)\n* The index of the mid-key (defined below) in the middle leaf-level block.\n\nThese additional fields are used to efficiently retrieve the mid-key of the HFile used in HFile splits, which we define as the first key of the block with a zero-based index of (n – 1) / 2, if the total number of blocks in the HFile is n.\nThis definition is consistent with how the mid-key was determined in HFile version 1, and is reasonable in general, because blocks are likely to be the same size on average, but we don't have any estimates on individual key/value pair sizes.\n\nWhen writing a version 2 HFile, the total number of data blocks pointed to by every leaf-level index block is kept track of.\nWhen we finish writing and the total number of leaf-level blocks is determined, it is clear which leaf-level block contains the mid-key, and the fields listed above are computed.\nWhen reading the HFile and the mid-key is requested, we retrieve the middle leaf index block (potentially from the block cache) and get the mid-key value from the appropriate position inside that leaf block.\n\n### Non-root block index format in version 2\n\nThis format applies to intermediate-level and leaf index blocks of a version 2 multi-level data block index.\nEvery non-root index block is structured as follows.\n\n1. numEntries: the number of entries (int).\n2. entryOffsets: the \"secondary index\" of offsets of entries in the block, to facilitate\n   a quick binary search on the key (`numEntries + 1` int values). The last value\n   is the total length of all entries in this index block. For example, in a non-root\n   index block with entry sizes 60, 80, 50 the \"secondary index\" will contain the\n   following int array: `{0, 60, 140, 190}`.\n3. Entries. Each entry contains:\n   * Offset of the block referenced by this entry in the file (long)\n   * On-disk size of the referenced block (int)\n   * Key. The length can be calculated from entryOffsets.\n\n### Bloom filters in version 2\n\nIn contrast with version 1, in a version 2 HFile Bloom filter metadata is stored in the load-on-open section of the HFile for quick startup.\n\n* A compound Bloom filter.\n* Bloom filter version = 3 (int). There used to be a DynamicByteBloomFilter class that had the Bloom filter version number 2\n* The total byte size of all compound Bloom filter chunks (long)\n* Number of hash functions (int)\n* Type of hash functions (int)\n* The total key count inserted into the Bloom filter (long)\n* The maximum total number of keys in the Bloom filter (long)\n* The number of chunks (int)\n* Comparator class used for Bloom filter keys, a UTF-8 encoded string stored using Bytes.writeByteArray\n* Bloom block index in the version 2 root block index format\n\n### File Info format in versions 1 and 2\n\nThe file info block is a serialized map from byte arrays to byte arrays, with the following keys, among others.\nStoreFile-level logic adds more keys to this.\n\n| Key                   | Description                                |\n| --------------------- | ------------------------------------------ |\n| hfile.LASTKEY         | The last key of the file (byte array)      |\n| hfile.AVG\\_KEY\\_LEN   | The average key length in the file (int)   |\n| hfile.AVG\\_VALUE\\_LEN | The average value length in the file (int) |\n\nIn version 2, we did not change the file format, but we moved the file info to\nthe final section of the file, which can be loaded as one block when the HFile\nis being opened.\n\nAlso, we do not store the comparator in the version 2 file info anymore.\nInstead, we store it in the fixed file trailer.\nThis is because we need to know the comparator at the time of parsing the load-on-open section of the HFile.\n\n### Fixed file trailer format differences between versions 1 and 2\n\nThe following table shows common and different fields between fixed file trailers in versions 1 and 2.\nNote that the size of the trailer is different depending on the version, so it is \"fixed\" only within one version.\nHowever, the version is always stored as the last four-byte integer in the file.\n\n#### Differences between HFile Versions 1 and 2\n\n| Version 1                                                                                                       | Version 2                                                                                                                                                      |\n| --------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n|                                                                                                                 | File info offset (long)                                                                                                                                        |\n| Data index offset (long)                                                                                        | loadOnOpenOffset (long) *The offset of the section that we need to load when opening the file.*                                                                |\n|                                                                                                                 | Number of data index entries (int)                                                                                                                             |\n| metaIndexOffset (long) *This field is not being used by the version 1 reader, so we removed it from version 2.* | uncompressedDataIndexSize (long) *The total uncompressed size of the whole data block index, including root-level, intermediate-level, and leaf-level blocks.* |\n|                                                                                                                 | Number of meta index entries (int)                                                                                                                             |\n|                                                                                                                 | Total uncompressed bytes (long)                                                                                                                                |\n| numEntries (int)                                                                                                | numEntries (long)                                                                                                                                              |\n| Compression codec: 0 = LZO, 1 = GZ, 2 = NONE (int)                                                              | Compression codec: 0 = LZO, 1 = GZ, 2 = NONE (int)                                                                                                             |\n|                                                                                                                 | The number of levels in the data block index (int)                                                                                                             |\n|                                                                                                                 | firstDataBlockOffset (long) *The offset of the first data block. Used when scanning.*                                                                          |\n|                                                                                                                 | lastDataBlockEnd (long) *The offset of the first byte after the last key/value data block. We don't need to go beyond this offset when scanning.*              |\n| Version: 1 (int)                                                                                                | Version: 2 (int)                                                                                                                                               |\n\n### getShortMidpointKey (an optimization for data index block)\n\nNote: this optimization was introduced in HBase 0.95+\n\nHFiles contain many blocks that contain a range of sorted Cells.\nEach cell has a key.\nTo save IO when reading Cells, the HFile also has an index that maps a Cell's start key to the offset of the beginning of a particular block.\nPrior to this optimization, HBase would use the key of the first cell in each data block as the index key.\n\nIn HBASE-7845, we generate a new key that is lexicographically larger than the last key of the previous block and lexicographically equal or smaller than the start key of the current block.\nWhile actual keys can potentially be very long, this \"fake key\" or \"virtual key\" can be much shorter.\nFor example, if the stop key of previous block is \"the quick brown fox\", the start key of current block is \"the who\", we could use \"the r\" as our virtual key in our hfile index.\n\nThere are two benefits to this:\n\n* having shorter keys reduces the hfile index size, (allowing us to keep more indexes in memory), and\n* using something closer to the end key of the previous block allows us to avoid a potential extra IO when the target key lives in between the \"virtual key\" and the key of the first element in the target block.\n\nThis optimization (implemented by the getShortMidpointKey method) is inspired by LevelDB's ByteWiseComparatorImpl::FindShortestSeparator() and FindShortSuccessor().\n\n## HBase File Format with Security Enhancements (version 3)\n\nNote: this feature was introduced in HBase 0.98\n\n### Motivation\n\nVersion 3 of HFile makes changes needed to ease management of encryption at rest and cell-level metadata (which in turn is needed for cell-level ACLs and cell-level visibility labels). For more information see [hbase.encryption.server](/docs/security/data-access#transparent-encryption-of-data-at-rest), [hbase.tags](/docs/security/data-access#tags), [hbase.accesscontrol.configuration](/docs/hbase-incompatibilities#interface-accesscontrolconstants), and [hbase.visibility.labels](/docs/security/data-access#visibility-labels).\n\n### Overview\n\nThe version of HBase introducing the above features reads HFiles in versions 1, 2, and 3 but only writes version 3 HFiles.\nVersion 3 HFiles are structured the same as version 2 HFiles.\nFor more information see [hfilev2.overview](/docs/hfile-format#overview-of-version-2).\n\n### File Info Block in Version 3\n\nVersion 3 added two additional pieces of information to the reserved keys in the file info block.\n\n| Key                    | Description                                                                                                                     |\n| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------- |\n| hfile.MAX\\_TAGS\\_LEN   | The maximum number of bytes needed to store the serialized tags for any single cell in this hfile (int)                         |\n| hfile.TAGS\\_COMPRESSED | Does the block encoder for this hfile compress tags? (boolean). Should only be present if hfile.MAX\\_TAGS\\_LEN is also present. |\n\nWhen reading a Version 3 HFile the presence of `MAX_TAGS_LEN` is used to determine how to deserialize the cells within a data block.\nTherefore, consumers must read the file's info block prior to reading any data blocks.\n\nWhen writing a Version 3 HFile, HBase will always include `MAX_TAGS_LEN` when flushing the memstore to underlying filesystem.\n\nWhen compacting extant files, the default writer will omit `MAX_TAGS_LEN` if all of the files selected do not themselves contain any cells with tags.\n\nSee [compaction](/docs/architecture/regions#compaction) for details on the compaction file selection algorithm.\n\n### Data Blocks in Version 3\n\nWithin an HFile, HBase cells are stored in data blocks as a sequence of KeyValues (see [hfilev1.overview](/docs/hfile-format#overview-of-version-1), or [Lars George's\nexcellent introduction to HBase Storage](http://www.larsgeorge.com/2009/10/hbase-architecture-101-storage.html)). In version 3, these KeyValue optionally will include a set of 0 or more tags:\n\n|                        | Version 1 & 2, Version 3 without MAX\\_TAGS\\_LEN | Version 3 with MAX\\_TAGS\\_LEN |\n| ---------------------- | ----------------------------------------------- | ----------------------------- |\n| Key Length (4 bytes)   | ✓                                               | ✓                             |\n| Value Length (4 bytes) | ✓                                               | ✓                             |\n| Key bytes (variable)   | ✓                                               | ✓                             |\n| Value bytes (variable) | ✓                                               | ✓                             |\n| Tags Length (2 bytes)  |                                                 | ✓                             |\n| Tags bytes (variable)  |                                                 | ✓                             |\n\nIf the info block for a given HFile contains an entry for `MAX_TAGS_LEN` each cell will have the length of that cell's tags included, even if that length is zero.\nThe actual tags are stored as a sequence of tag length (2 bytes), tag type (1 byte), tag bytes (variable). The format an individual tag's bytes depends on the tag type.\n\nNote that the dependence on the contents of the info block implies that prior to reading any data blocks you must first process a file's info block.\nIt also implies that prior to writing a data block you must know if the file's info block will include `MAX_TAGS_LEN`.\n\n### Fixed File Trailer in Version 3\n\nThe fixed file trailers written with HFile version 3 are always serialized with protocol buffers.\nAdditionally, it adds an optional field to the version 2 protocol buffer named encryption\\_key.\nIf HBase is configured to encrypt HFiles this field will store a data encryption key for this particular HFile, encrypted with the current cluster master key using AES.\nFor more information see [hbase.encryption.server](/docs/security/data-access#transparent-encryption-of-data-at-rest).\n\n\n# Preface (/docs)\nHerein you will find either the definitive documentation on an HBase topic as of its\nstanding when the referenced HBase version shipped, or it will point to the location\nin [Javadoc](https://hbase.apache.org/apidocs/index.html) or\n[JIRA](https://issues.apache.org/jira/browse/HBASE) where the pertinent information can be found.\n\n## About This Guide\n\nThis reference guide is a work in progress. The source for this guide can be found in the\n*hbase-website/app/pages/\\_docs/docs/\\_mdx/(multi-page)* directory of the HBase source. This reference guide is marked up\nusing [MDX](https://mdxjs.com/) (just extended markdown) powered by [Fumadocs](https://fumadocs.dev/) from which the finished guide is generated as part of the\n'site' build target. Run\n\n```bash\nmvn site\n```\n\nto generate this documentation.\nAmendments and improvements to the documentation are welcomed.\nClick\n[this link](https://issues.apache.org/jira/secure/CreateIssueDetails!init.jspa?pid=12310753\\&issuetype=1\\&components=12312132\\&summary=SHORT+DESCRIPTION)\nto file a new documentation bug against Apache HBase with some values pre-selected.\n\n## Contributing to the Documentation\n\nFor an overview and suggestions to get started contributing to the documentation,\nsee the [relevant section later in this documentation](/docs/contributing-to-documentation).\n\n## Heads-up if this is your first foray into the world of distributed computing...\n\nIf this is your first foray into the wonderful world of Distributed Computing, then you are in for some interesting times.\nFirst off, distributed systems are hard; making a distributed system hum requires a disparate skillset that spans systems (hardware and software) and networking.\n\nYour cluster's operation can hiccup because of any of a myriad set of reasons from bugs in HBase itself through misconfigurations — misconfiguration of HBase but also operating system misconfigurations — through to hardware problems whether it be a bug in your network card drivers or an underprovisioned RAM bus (to mention two recent examples of hardware issues that manifested as \"HBase is slow\"). You will also need to do a recalibration if up to this your computing has been bound to a single box.\nHere is one good starting point: [Fallacies of Distributed Computing](http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing).\n\nThat said, you are welcome.<br />\nIt's a fun place to be.<br />\nYours, the HBase Community.\n\n## Reporting Bugs\n\nPlease use [JIRA](https://issues.apache.org/jira/browse/hbase) to report non-security-related bugs.\n\nTo protect existing HBase installations from new vulnerabilities, please **do not** use JIRA to report security-related bugs. Instead, send your report to the mailing list [private@hbase.apache.org](mailto:private@hbase.apache.org), which allows anyone to send messages, but restricts who can read them. Someone on that list will contact you to follow up on your report.\n\n## Support and Testing Expectations\n\nThe phrases *supported*, *not supported*, *tested*, and *not tested* occur several\nplaces throughout this guide. In the interest of clarity, here is a brief explanation\nof what is generally meant by these phrases, in the context of HBase.\n\n<Callout type=\"info\">\n  Commercial technical support for Apache HBase is provided by many Hadoop vendors. This is not the\n  sense in which the term *support* is used in the context of the Apache HBase project. The Apache\n  HBase team assumes no responsibility for your HBase clusters, your configuration, or your data.\n</Callout>\n\n### Supported\n\nIn the context of Apache HBase, *supported* means that HBase is designed to work\nin the way described, and deviation from the defined behavior or functionality should\nbe reported as a bug.\n\n### Not Supported\n\nIn the context of Apache HBase, *not supported* means that a use case or use pattern\nis not expected to work and should be considered an antipattern. If you think this\ndesignation should be reconsidered for a given feature or use pattern, file a JIRA\nor start a discussion on one of the mailing lists.\n\n### Tested\n\nIn the context of Apache HBase, *tested* means that a feature is covered by unit\nor integration tests, and has been proven to work as expected.\n\n### Not Tested\n\nIn the context of Apache HBase, *not tested* means that a feature or use pattern\nmay or may not work in a given way, and may or may not corrupt your data or cause\noperational issues. It is an unknown, and there are no guarantees. If you can provide\nproof that a feature designated as *not tested* does work in a given way, please\nsubmit the tests and/or the metrics so that other users can gain certainty about\nsuch features or use patterns.\n\n\n# In-memory Compaction (/docs/inmemory-compaction)\n## Overview\n\nIn-memory Compaction (A.K.A Accordion) is a new feature in hbase-2.0.0.\nIt was first introduced on the Apache HBase Blog at\n[Accordion: HBase Breathes with In-Memory Compaction](https://blogs.apache.org/hbase/entry/accordion-hbase-breathes-with-in).\nQuoting the blog:\n\n> Accordion reapplies the LSM principal \\[*Log-Structured-Merge Tree*, the design pattern upon which HBase is based] to MemStore, in order to eliminate redundancies and other overhead while the data is still in RAM. Doing so decreases the frequency of flushes to HDFS, thereby reducing the write amplification and the overall disk footprint. With less flushes, the write operations are stalled less frequently as the MemStore overflows, therefore the write performance is improved. Less data on disk also implies less pressure on the block cache, higher hit rates, and eventually better read response times. Finally, having less disk writes also means having less compaction happening in the background, i.e., less cycles are stolen from productive (read and write) work. All in all, the effect of in-memory compaction can be envisioned as a catalyst that enables the system move faster as a whole.\n\nA developer view is available at\n[Accordion: Developer View of In-Memory Compaction](https://blogs.apache.org/hbase/entry/accordion-developer-view-of-in).\n\nIn-memory compaction works best when high data churn; overwrites or over-versions\ncan be eliminated while the data is still in memory. If the writes are all uniques,\nit may drag write throughput (In-memory compaction costs CPU). We suggest you test\nand compare before deploying to production.\n\nIn this section we describe how to enable Accordion and the available configurations.\n\n## Enabling\n\nTo enable in-memory compactions, set the *IN\\_MEMORY\\_COMPACTION* attribute\non per column family where you want the behavior. The *IN\\_MEMORY\\_COMPACTION*\nattribute can have one of four values.\n\n* *NONE*: No in-memory compaction.\n* *BASIC*: Basic policy enables flushing and keeps a pipeline of flushes until we trip the pipeline maximum threshold and then we flush to disk. No in-memory compaction but can help throughput as data is moved from the profligate, native ConcurrentSkipListMap data-type to more compact (and efficient) data types.\n* *EAGER*: This is *BASIC* policy plus in-memory compaction of flushes (much like the on-disk compactions done to hfiles); on compaction we apply on-disk rules eliminating versions, duplicates, ttl'd cells, etc.\n* *ADAPTIVE*: Adaptive compaction adapts to the workload. It applies either index compaction or data compaction based on the ratio of duplicate cells in the data. Experimental.\n\nTo enable *BASIC* on the *info* column family in the table *radish*, add the attribute to the *info* column family:\n\n```ruby\nhbase(main):003:0> alter 'radish', {NAME => 'info', IN_MEMORY_COMPACTION => 'BASIC'}\nUpdating all regions with the new schema...\nAll regions updated.\nDone.\nTook 1.2413 seconds\nhbase(main):004:0> describe 'radish'\nTable radish is DISABLED\nradish\nCOLUMN FAMILIES DESCRIPTION\n{NAME => 'info', VERSIONS => '1', EVICT_BLOCKS_ON_CLOSE => 'false', NEW_VERSION_BEHAVIOR => 'false', KEEP_DELETED_CELLS => 'FALSE', CACHE_DATA_ON_WRITE => 'false', DATA_BLOCK_ENCODING => 'NONE', TTL => 'FOREVER', MIN_VERSIONS => '0', REPLICATION_SCOPE => '0', BLOOMFILTER => 'ROW', CACHE_INDEX_ON_WRITE => 'false', IN_MEMORY => 'false', CACHE_BLOOMS_ON_WRITE => 'false', PREFETCH_BLOCKS_ON_OPEN => 'false', COMPRESSION => 'NONE', BLOCKCACHE => 'true', BLOCKSIZE => '65536', METADATA => {\n'IN_MEMORY_COMPACTION' => 'BASIC'}}\n1 row(s)\nTook 0.0239 seconds\n```\n\nNote how the IN*MEMORY\\_COMPACTION attribute shows as part of the \\_METADATA* map.\n\nThere is also a global configuration, *hbase.hregion.compacting.memstore.type* which you can set in your *hbase-site.xml* file. Use it to set the\ndefault on creation of a new table (On creation of a column family Store, we look first to the column family configuration looking for the\n*IN\\_MEMORY\\_COMPACTION* setting, and if none, we then consult the *hbase.hregion.compacting.memstore.type* value using its content; default is\n*NONE*).\n\nBy default, new hbase system tables will have *NONE* in-memory compaction set. To specify otherwise,\non new table-creation, set *hbase.systemtables.compacting.memstore.type* to *BASIC* / *EAGER* / *ADAPTIVE* (Note, setting this value\npost-creation of system tables will not have a retroactive effect; you will have to alter your tables\nto set the in-memory attribute).\n\nWhen an in-memory flush happens is calculated by dividing the configured region flush size (Set in the table descriptor\nor read from *hbase.hregion.memstore.flush.size*) by the number of column families and then multiplying by\n*hbase.memstore.inmemoryflush.threshold.factor*. Default is 0.014.\n\nThe number of flushes carried by the pipeline is monitored so as to fit within the bounds of memstore sizing\nbut you can also set a maximum on the number of flushes total by setting\n*hbase.hregion.compacting.pipeline.segments.limit*. Default is 2.\n\nWhen a column family Store is created, it says what memstore type is in effect. As of this writing\nthere is the old-school *DefaultMemStore* which fills a *ConcurrentSkipListMap* and then flushes\nto disk or the new *CompactingMemStore* that is the implementation that provides this new\nin-memory compactions facility. Here is a log-line from a RegionServer that shows a column\nfamily Store named *family* configured to use a *CompactingMemStore*:\n\n```\nNote how the IN_MEMORY_COMPACTION attribute shows as part of the _METADATA_ map.\n2018-03-30 11:02:24,466 INFO  [Time-limited test] regionserver.HStore(325): Store=family,  memstore type=CompactingMemStore, storagePolicy=HOT, verifyBulkLoads=false, parallelPutCountPrintThreshold=10\n```\n\nEnable TRACE-level logging on the CompactingMemStore class (*org.apache.hadoop.hbase.regionserver.CompactingMemStore*) to see detail on its operation.\n\n\n# HBase and MapReduce (/docs/mapreduce)\nApache MapReduce is a software framework used to analyze large amounts of data. It is provided by [Apache Hadoop](https://hadoop.apache.org/).\nMapReduce itself is out of the scope of this document.\nA good place to get started with MapReduce is [https://hadoop.apache.org/docs/r2.6.0/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html](https://hadoop.apache.org/docs/r2.6.0/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html).\nMapReduce version 2 (MR2)is now part of [YARN](https://hadoop.apache.org/docs/r2.6.0/hadoop-yarn/hadoop-yarn-site/).\n\nThis chapter discusses specific configuration steps you need to take to use MapReduce on data within HBase.\nIn addition, it discusses other interactions and issues between HBase and MapReduce jobs.\n\n<Callout type=\"info\" title=\"mapred and mapreduce\">\n  There are two mapreduce packages in HBase as in MapReduce itself: *org.apache.hadoop.hbase.mapred*\n  and *org.apache.hadoop.hbase.mapreduce*. The former does old-style API and the latter the new\n  mode. The latter has more facility though you can usually find an equivalent in the older package.\n  Pick the package that goes with your MapReduce deploy. When in doubt or starting over, pick\n  *org.apache.hadoop.hbase.mapreduce*. In the notes below, we refer to *o.a.h.h.mapreduce* but\n  replace with *o.a.h.h.mapred* if that is what you are using.\n</Callout>\n\n## HBase, MapReduce, and the CLASSPATH\n\nBy default, MapReduce jobs deployed to a MapReduce cluster do not have access to\neither the HBase configuration under `$HBASE_CONF_DIR` or the HBase classes.\n\nTo give the MapReduce jobs the access they need, you could add \\_hbase-site.xml\\_to \\_\\$HADOOP*HOME/conf* and add HBase jars to the *\\$HADOOP\\_HOME/lib* directory.\nYou would then need to copy these changes across your cluster. Or you could edit *\\$HADOOP\\_HOME/conf/hadoop-env.sh* and add hbase dependencies to the `HADOOP_CLASSPATH` variable.\nNeither of these approaches is recommended because it will pollute your Hadoop install with HBase references.\nIt also requires you restart the Hadoop cluster before Hadoop can use the HBase data.\n\nThe recommended approach is to let HBase add its dependency jars and use `HADOOP_CLASSPATH` or `-libjars`.\n\nSince HBase `0.90.x`, HBase adds its dependency JARs to the job configuration itself.\nThe dependencies only need to be available on the local `CLASSPATH` and from here they'll be picked\nup and bundled into the fat job jar deployed to the MapReduce cluster. A basic trick just passes\nthe full hbase classpath — all hbase and dependent jars as well as configurations — to the mapreduce\njob runner letting hbase utility pick out from the full-on classpath what it needs adding them to the\nMapReduce job configuration (See the source at `TableMapReduceUtil#addDependencyJars(org.apache.hadoop.mapreduce.Job)` for how this is done).\n\nThe following example runs the bundled HBase [RowCounter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html) MapReduce job against a table named `usertable`.\nIt sets into `HADOOP_CLASSPATH` the jars hbase needs to run in an MapReduce context (including configuration files such as hbase-site.xml).\nBe sure to use the correct version of the HBase JAR for your system; replace the VERSION string in the below command line w/ the version of\nyour local hbase install. The backticks (\\`\\`\\`) cause the shell to execute the sub-commands, setting the output of `hbase classpath` into `HADOOP_CLASSPATH`.\nThis example assumes you use a BASH-compatible shell.\n\n```bash\n$ HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` \\\n  ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/lib/hbase-mapreduce-VERSION.jar \\\n  org.apache.hadoop.hbase.mapreduce.RowCounter usertable\n```\n\nThe above command will launch a row counting mapreduce job against the hbase cluster that is pointed to by your local configuration on a cluster that the hadoop configs are pointing to.\n\nThe main for the `hbase-mapreduce.jar` is a Driver that lists a few basic mapreduce tasks that ship with hbase.\nFor example, presuming your install is hbase `2.0.0-SNAPSHOT`:\n\n```bash\n$ HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` \\\n  ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/lib/hbase-mapreduce-2.0.0-SNAPSHOT.jar\nAn example program must be given as the first argument.\nValid program names are:\n  CellCounter: Count cells in HBase table.\n  WALPlayer: Replay WAL files.\n  completebulkload: Complete a bulk data load.\n  copytable: Export a table from local cluster to peer cluster.\n  export: Write table data to HDFS.\n  exportsnapshot: Export the specific snapshot to a given FileSystem.\n  import: Import data written by Export.\n  importtsv: Import data in TSV format.\n  rowcounter: Count rows in HBase table.\n  verifyrep: Compare the data from tables in two different clusters. WARNING: It doesn't work for incrementColumnValues'd cells since the timestamp is changed after being appended to the log.\n```\n\nYou can use the above listed shortnames for mapreduce jobs as in the below re-run of the row counter job (again, presuming your install is hbase `2.0.0-SNAPSHOT`):\n\n```bash\n$ HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` \\\n  ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/lib/hbase-mapreduce-2.0.0-SNAPSHOT.jar \\\n  rowcounter usertable\n```\n\nYou might find the more selective `hbase mapredcp` tool output of interest; it lists the minimum set of jars needed\nto run a basic mapreduce job against an hbase install. It does not include configuration. You'll probably need to add\nthese if you want your MapReduce job to find the target cluster. You'll probably have to also add pointers to extra jars\nonce you start to do anything of substance. Just specify the extras by passing the system propery `-Dtmpjars` when\nyou run `hbase mapredcp`.\n\nFor jobs that do not package their dependencies or call `TableMapReduceUtil#addDependencyJars`, the following command structure is necessary:\n\n```bash\n$ HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase mapredcp`:${HBASE_HOME}/conf hadoop jar MyApp.jar MyJobMainClass -libjars $(${HBASE_HOME}/bin/hbase mapredcp | tr ':' ',') ...\n```\n\n<Callout type=\"info\">\n  The example may not work if you are running HBase from its build directory rather than an installed location.\n  You may see an error like the following:\n\n  ```text\n  java.lang.RuntimeException: java.lang.ClassNotFoundException: org.apache.hadoop.hbase.mapreduce.RowCounter$RowCounterMapper\n  ```\n\n  If this occurs, try modifying the command as follows, so that it uses the HBase JARs from the *target/* directory within the build environment.\n\n  ```bash\n  $ HADOOP_CLASSPATH=${HBASE_BUILD_HOME}/hbase-mapreduce/target/hbase-mapreduce-VERSION-SNAPSHOT.jar:`${HBASE_BUILD_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_BUILD_HOME}/hbase-mapreduce/target/hbase-mapreduce-VERSION-SNAPSHOT.jar rowcounter usertable\n  ```\n</Callout>\n\n<Callout type=\"warn\" title=\"Notice to MapReduce users of HBase between 0.96.1 and 0.98.4\">\n  Some MapReduce jobs that use HBase fail to launch.\n  The symptom is an exception similar to the following:\n\n  ```text\n  Exception in thread \"main\" java.lang.IllegalAccessError: class\n      com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass\n      com.google.protobuf.LiteralByteString\n      at java.lang.ClassLoader.defineClass1(Native Method)\n      at java.lang.ClassLoader.defineClass(ClassLoader.java:792)\n      at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n      at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)\n      at java.net.URLClassLoader.access$100(URLClassLoader.java:71)\n      at java.net.URLClassLoader$1.run(URLClassLoader.java:361)\n      at java.net.URLClassLoader$1.run(URLClassLoader.java:355)\n      at java.security.AccessController.doPrivileged(Native Method)\n      at java.net.URLClassLoader.findClass(URLClassLoader.java:354)\n      at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n      at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n      at\n      org.apache.hadoop.hbase.protobuf.ProtobufUtil.toScan(ProtobufUtil.java:818)\n      at\n      org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.convertScanToString(TableMapReduceUtil.java:433)\n      at\n      org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:186)\n      at\n      org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:147)\n      at\n      org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:270)\n      at\n      org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:100)\n  ...\n  ```\n\n  This is caused by an optimization introduced in [HBASE-9867](https://issues.apache.org/jira/browse/HBASE-9867) that inadvertently introduced a classloader dependency.\n\n  This affects both jobs using the `-libjars` option and \"fat jar,\" those which package their runtime dependencies in a nested `lib` folder.\n\n  In order to satisfy the new classloader requirements, `hbase-protocol.jar` must be included in Hadoop's classpath.\n  See [HBase, MapReduce, and the CLASSPATH](/docs/mapreduce#hbase-mapreduce-and-the-classpath) for current recommendations for resolving classpath errors.\n  The following is included for historical purposes.\n\n  This can be resolved system-wide by including a reference to the `hbase-protocol.jar` in Hadoop's lib directory, via a symlink or by copying the jar into the new location.\n\n  This can also be achieved on a per-job launch basis by including it in the `HADOOP_CLASSPATH` environment variable at job submission time.\n  When launching jobs that package their dependencies, all three of the following job launching commands satisfy this requirement:\n\n  ```bash\n  $ HADOOP_CLASSPATH=/path/to/hbase-protocol.jar:/path/to/hbase/conf hadoop jar MyJob.jar MyJobMainClass\n  $ HADOOP_CLASSPATH=$(hbase mapredcp):/path/to/hbase/conf hadoop jar MyJob.jar MyJobMainClass\n  $ HADOOP_CLASSPATH=$(hbase classpath) hadoop jar MyJob.jar MyJobMainClass\n  ```\n\n  For jars that do not package their dependencies, the following command structure is necessary:\n\n  ```bash\n  $ HADOOP_CLASSPATH=$(hbase mapredcp):/etc/hbase/conf hadoop jar MyApp.jar MyJobMainClass -libjars $(hbase mapredcp | tr ':' ',') ...\n  ```\n\n  See also [HBASE-10304](https://issues.apache.org/jira/browse/HBASE-10304) for further discussion of this issue.\n</Callout>\n\n## MapReduce Scan Caching\n\nTableMapReduceUtil now restores the option to set scanner caching (the number of rows which are cached before returning the result to the client) on the Scan object that is passed in.\nThis functionality was lost due to a bug in HBase 0.95 ([HBASE-11558](https://issues.apache.org/jira/browse/HBASE-11558)), which is fixed for HBase 0.98.5 and 0.96.3.\nThe priority order for choosing the scanner caching is as follows:\n\n1. Caching settings which are set on the scan object.\n2. Caching settings which are specified via the configuration option `hbase.client.scanner.caching`, which can either be set manually in *hbase-site.xml* or via the helper method `TableMapReduceUtil.setScannerCaching()`.\n3. The default value `HConstants.DEFAULT_HBASE_CLIENT_SCANNER_CACHING`, which is set to `100`.\n\nOptimizing the caching settings is a balance between the time the client waits for a result and the number of sets of results the client needs to receive.\nIf the caching setting is too large, the client could end up waiting for a long time or the request could even time out.\nIf the setting is too small, the scan needs to return results in several pieces.\nIf you think of the scan as a shovel, a bigger cache setting is analogous to a bigger shovel, and a smaller cache setting is equivalent to more shoveling in order to fill the bucket.\n\nThe list of priorities mentioned above allows you to set a reasonable default, and override it for specific operations.\n\nSee the API documentation for [Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) for more details.\n\n## Bundled HBase MapReduce Jobs\n\nThe HBase JAR also serves as a Driver for some bundled MapReduce jobs.\nTo learn about the bundled MapReduce jobs, run the following command.\n\n```bash\n$ ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-mapreduce-VERSION.jar\nAn example program must be given as the first argument.\nValid program names are:\n  copytable: Export a table from local cluster to peer cluster\n  completebulkload: Complete a bulk data load.\n  export: Write table data to HDFS.\n  import: Import data written by Export.\n  importtsv: Import data in TSV format.\n  rowcounter: Count rows in HBase table\n```\n\nEach of the valid program names are bundled MapReduce jobs.\nTo run one of the jobs, model your command after the following example.\n\n```bash\n$ ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-mapreduce-VERSION.jar rowcounter myTable\n```\n\n## HBase as a MapReduce Job Data Source and Data Sink\n\nHBase can be used as a data source, [TableInputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html), and data sink, [TableOutputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html) or [MultiTableOutputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/MultiTableOutputFormat.html), for MapReduce jobs.\nWriting MapReduce jobs that read or write HBase, it is advisable to subclass [TableMapper](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html) and/or [TableReducer](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableReducer.html).\nSee the do-nothing pass-through classes [IdentityTableMapper](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/IdentityTableMapper.html) and [IdentityTableReducer](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/IdentityTableReducer.html) for basic usage.\nFor a more involved example, see [RowCounter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html) or review the `org.apache.hadoop.hbase.mapreduce.TestTableMapReduce` unit test.\n\nIf you run MapReduce jobs that use HBase as source or sink, need to specify source and sink table and column names in your configuration.\n\nWhen you read from HBase, the `TableInputFormat` requests the list of regions from HBase and makes a map, which is either a `map-per-region` or `mapreduce.job.maps` map, whichever is smaller.\nIf your job only has two maps, raise `mapreduce.job.maps` to a number greater than the number of regions.\nMaps will run on the adjacent TaskTracker/NodeManager if you are running a TaskTracer/NodeManager and RegionServer per node.\nWhen writing to HBase, it may make sense to avoid the Reduce step and write back into HBase from within your map.\nThis approach works when your job does not need the sort and collation that MapReduce does on the map-emitted data.\nOn insert, HBase 'sorts' so there is no point double-sorting (and shuffling data around your MapReduce cluster) unless you need to.\nIf you do not need the Reduce, your map might emit counts of records processed for reporting at the end of the job, or set the number of Reduces to zero and use TableOutputFormat.\nIf running the Reduce step makes sense in your case, you should typically use multiple reducers so that load is spread across the HBase cluster.\n\nA new HBase partitioner, the [HRegionPartitioner](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/HRegionPartitioner.html), can run as many reducers the number of existing regions.\nThe HRegionPartitioner is suitable when your table is large and your upload will not greatly alter the number of existing regions upon completion.\nOtherwise use the default partitioner.\n\n## Writing HFiles Directly During Bulk Import\n\nIf you are importing into a new table, you can bypass the HBase API and write your content directly to the filesystem, formatted into HBase data files (HFiles). Your import will run faster, perhaps an order of magnitude faster.\nFor more on how this mechanism works, see [Bulk Load](/docs/architecture/bulk-loading).\n\n## RowCounter Example\n\nThe included [RowCounter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html) MapReduce job uses `TableInputFormat` and does a count of all rows in the specified table.\nTo run it, use the following command:\n\n```bash\n$ ./bin/hadoop jar hbase-X.X.X.jar\n```\n\nThis will invoke the HBase MapReduce Driver class.\nSelect `rowcounter` from the choice of jobs offered.\nThis will print rowcounter usage advice to standard output.\nSpecify the tablename, column to count, and output directory.\nIf you have classpath errors, see [HBase, MapReduce, and the CLASSPATH](/docs/mapreduce#hbase-mapreduce-and-the-classpath).\n\n## Map-Task Splitting\n\n### The Default HBase MapReduce Splitter\n\nWhen [TableInputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html) is used to source an HBase table in a MapReduce job, its splitter will make a map task for each region of the table.\nThus, if there are 100 regions in the table, there will be 100 map-tasks for the job - regardless of how many column families are selected in the Scan.\n\n### Custom Splitters\n\nFor those interested in implementing custom splitters, see the method `getSplits` in [TableInputFormatBase](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormatBase.html).\nThat is where the logic for map-task assignment resides.\n\n## HBase MapReduce Examples\n\n### HBase MapReduce Read Example\n\nThe following is an example of using HBase as a MapReduce source in read-only manner.\nSpecifically, there is a Mapper instance but no Reducer, and nothing is being emitted from the Mapper.\nThe job would be defined as follows...\n\n```java\nConfiguration config = HBaseConfiguration.create();\nJob job = new Job(config, \"ExampleRead\");\njob.setJarByClass(MyReadJob.class);     // class that contains mapper\n\nScan scan = new Scan();\nscan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs\nscan.setCacheBlocks(false);  // don't set to true for MR jobs\n// set other scan attrs\n...\n\nTableMapReduceUtil.initTableMapperJob(\n  tableName,        // input HBase table name\n  scan,             // Scan instance to control CF and attribute selection\n  MyMapper.class,   // mapper\n  null,             // mapper output key\n  null,             // mapper output value\n  job);\njob.setOutputFormatClass(NullOutputFormat.class);   // because we aren't emitting anything from mapper\n\nboolean b = job.waitForCompletion(true);\nif (!b) {\n  throw new IOException(\"error with job!\");\n}\n```\n\n...and the mapper instance would extend [TableMapper](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html)...\n\n```java\npublic static class MyMapper extends TableMapper<Text, Text> {\n\n  public void map(ImmutableBytesWritable row, Result value, Context context) throws InterruptedException, IOException {\n    // process data for the row from the Result instance.\n   }\n}\n```\n\n### HBase MapReduce Read/Write Example\n\nThe following is an example of using HBase both as a source and as a sink with MapReduce.\nThis example will simply copy data from one table to another.\n\n```java\nConfiguration config = HBaseConfiguration.create();\nJob job = new Job(config,\"ExampleReadWrite\");\njob.setJarByClass(MyReadWriteJob.class);    // class that contains mapper\n\nScan scan = new Scan();\nscan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs\nscan.setCacheBlocks(false);  // don't set to true for MR jobs\n// set other scan attrs\n\nTableMapReduceUtil.initTableMapperJob(\n  sourceTable,      // input table\n  scan,             // Scan instance to control CF and attribute selection\n  MyMapper.class,   // mapper class\n  null,             // mapper output key\n  null,             // mapper output value\n  job);\nTableMapReduceUtil.initTableReducerJob(\n  targetTable,      // output table\n  null,             // reducer class\n  job);\njob.setNumReduceTasks(0);\n\nboolean b = job.waitForCompletion(true);\nif (!b) {\n  throw new IOException(\"error with job!\");\n}\n```\n\nAn explanation is required of what `TableMapReduceUtil` is doing, especially with the reducer. [TableOutputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html) is being used as the outputFormat class, and several parameters are being set on the config (e.g., `TableOutputFormat.OUTPUT_TABLE`), as well as setting the reducer output key to `ImmutableBytesWritable` and reducer value to `Writable`.\nThese could be set by the programmer on the job and conf, but `TableMapReduceUtil` tries to make things easier.\n\nThe following is the example mapper, which will create a `Put` and matching the input `Result` and emit it.\nNote: this is what the CopyTable utility does.\n\n```java\npublic static class MyMapper extends TableMapper<ImmutableBytesWritable, Put>  {\n\n  public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {\n    // this example is just copying the data from the source table...\n      context.write(row, resultToPut(row,value));\n    }\n\n    private static Put resultToPut(ImmutableBytesWritable key, Result result) throws IOException {\n      Put put = new Put(key.get());\n      for (Cell cell : result.listCells()) {\n        put.add(cell);\n      }\n      return put;\n    }\n}\n```\n\nThere isn't actually a reducer step, so `TableOutputFormat` takes care of sending the `Put` to the target table.\n\nThis is just an example, developers could choose not to use `TableOutputFormat` and connect to the target table themselves.\n\n### HBase MapReduce Read/Write Example With Multi-Table Output\n\nTODO: example for `MultiTableOutputFormat`.\n\n### HBase MapReduce Summary to HBase Example\n\nThe following example uses HBase as a MapReduce source and sink with a summarization step.\nThis example will count the number of distinct instances of a value in a table and write those summarized counts in another table.\n\n```java\nConfiguration config = HBaseConfiguration.create();\nJob job = new Job(config,\"ExampleSummary\");\njob.setJarByClass(MySummaryJob.class);     // class that contains mapper and reducer\n\nScan scan = new Scan();\nscan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs\nscan.setCacheBlocks(false);  // don't set to true for MR jobs\n// set other scan attrs\n\nTableMapReduceUtil.initTableMapperJob(\n  sourceTable,        // input table\n  scan,               // Scan instance to control CF and attribute selection\n  MyMapper.class,     // mapper class\n  Text.class,         // mapper output key\n  IntWritable.class,  // mapper output value\n  job);\nTableMapReduceUtil.initTableReducerJob(\n  targetTable,        // output table\n  MyTableReducer.class,    // reducer class\n  job);\njob.setNumReduceTasks(1);   // at least one, adjust as required\n\nboolean b = job.waitForCompletion(true);\nif (!b) {\n  throw new IOException(\"error with job!\");\n}\n```\n\nIn this example mapper a column with a String-value is chosen as the value to summarize upon.\nThis value is used as the key to emit from the mapper, and an `IntWritable` represents an instance counter.\n\n```java\npublic static class MyMapper extends TableMapper<Text, IntWritable>  {\n  public static final byte[] CF = \"cf\".getBytes();\n  public static final byte[] ATTR1 = \"attr1\".getBytes();\n\n  private final IntWritable ONE = new IntWritable(1);\n  private Text text = new Text();\n\n  public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {\n    String val = new String(value.getValue(CF, ATTR1));\n    text.set(val);     // we can only emit Writables...\n    context.write(text, ONE);\n  }\n}\n```\n\nIn the reducer, the \"ones\" are counted (just like any other MR example that does this), and then emits a `Put`.\n\n```java\npublic static class MyTableReducer extends TableReducer<Text, IntWritable, ImmutableBytesWritable>  {\n  public static final byte[] CF = \"cf\".getBytes();\n  public static final byte[] COUNT = \"count\".getBytes();\n\n  public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n    int i = 0;\n    for (IntWritable val : values) {\n      i += val.get();\n    }\n    Put put = new Put(Bytes.toBytes(key.toString()));\n    put.add(CF, COUNT, Bytes.toBytes(i));\n\n    context.write(null, put);\n  }\n}\n```\n\n### HBase MapReduce Summary to File Example\n\nThis very similar to the summary example above, with exception that this is using HBase as a MapReduce source but HDFS as the sink.\nThe differences are in the job setup and in the reducer.\nThe mapper remains the same.\n\n```java\nConfiguration config = HBaseConfiguration.create();\nJob job = new Job(config,\"ExampleSummaryToFile\");\njob.setJarByClass(MySummaryFileJob.class);     // class that contains mapper and reducer\n\nScan scan = new Scan();\nscan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs\nscan.setCacheBlocks(false);  // don't set to true for MR jobs\n// set other scan attrs\n\nTableMapReduceUtil.initTableMapperJob(\n  sourceTable,        // input table\n  scan,               // Scan instance to control CF and attribute selection\n  MyMapper.class,     // mapper class\n  Text.class,         // mapper output key\n  IntWritable.class,  // mapper output value\n  job);\njob.setReducerClass(MyReducer.class);    // reducer class\njob.setNumReduceTasks(1);    // at least one, adjust as required\nFileOutputFormat.setOutputPath(job, new Path(\"/tmp/mr/mySummaryFile\"));  // adjust directories as required\n\nboolean b = job.waitForCompletion(true);\nif (!b) {\n  throw new IOException(\"error with job!\");\n}\n```\n\nAs stated above, the previous Mapper can run unchanged with this example.\nAs for the Reducer, it is a \"generic\" Reducer instead of extending TableMapper and emitting Puts.\n\n```java\npublic static class MyReducer extends Reducer<Text, IntWritable, Text, IntWritable>  {\n\n  public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n    int i = 0;\n    for (IntWritable val : values) {\n      i += val.get();\n    }\n    context.write(key, new IntWritable(i));\n  }\n}\n```\n\n### HBase MapReduce Summary to HBase Without Reducer\n\nIt is also possible to perform summaries without a reducer - if you use HBase as the reducer.\n\nAn HBase target table would need to exist for the job summary.\nThe Table method `incrementColumnValue` would be used to atomically increment values.\nFrom a performance perspective, it might make sense to keep a Map of values with their values to be incremented for each map-task, and make one update per key at during the `cleanup` method of the mapper.\nHowever, your mileage may vary depending on the number of rows to be processed and unique keys.\n\nIn the end, the summary results are in HBase.\n\n### HBase MapReduce Summary to RDBMS\n\nSometimes it is more appropriate to generate summaries to an RDBMS.\nFor these cases, it is possible to generate summaries directly to an RDBMS via a custom reducer.\nThe `setup` method can connect to an RDBMS (the connection information can be passed via custom parameters in the context) and the cleanup method can close the connection.\n\nIt is critical to understand that number of reducers for the job affects the summarization implementation, and you'll have to design this into your reducer.\nSpecifically, whether it is designed to run as a singleton (one reducer) or multiple reducers.\nNeither is right or wrong, it depends on your use-case.\nRecognize that the more reducers that are assigned to the job, the more simultaneous connections to the RDBMS will be created - this will scale, but only to a point.\n\n```java\npublic static class MyRdbmsReducer extends Reducer<Text, IntWritable, Text, IntWritable>  {\n\n  private Connection c = null;\n\n  public void setup(Context context) {\n    // create DB connection...\n  }\n\n  public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n    // do summarization\n    // in this example the keys are Text, but this is just an example\n  }\n\n  public void cleanup(Context context) {\n    // close db connection\n  }\n\n}\n```\n\nIn the end, the summary results are written to your RDBMS table/s.\n\n## Accessing Other HBase Tables in a MapReduce Job\n\nAlthough the framework currently allows one HBase table as input to a MapReduce job, other HBase tables can be accessed as lookup tables, etc., in a MapReduce job via creating an Table instance in the setup method of the Mapper.\n\n```java\npublic class MyMapper extends TableMapper<Text, LongWritable> {\n  private Table myOtherTable;\n\n  public void setup(Context context) {\n    // In here create a Connection to the cluster and save it or use the Connection\n    // from the existing table\n    myOtherTable = connection.getTable(\"myOtherTable\");\n  }\n\n  public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {\n    // process Result...\n    // use 'myOtherTable' for lookups\n  }\n```\n\n## Speculative Execution\n\nIt is generally advisable to turn off speculative execution for MapReduce jobs that use HBase as a source.\nThis can either be done on a per-Job basis through properties, or on the entire cluster.\nEspecially for longer running jobs, speculative execution will create duplicate map-tasks which will double-write your data to HBase; this is probably not what you want.\n\nSee [Speculative Execution](/docs/configuration/important#configuration-important-recommended-configurations-speculative-execution) for more information.\n\n\n# RegionServer Off-Heap Read/Write Path (/docs/offheap-read-write)\n\n\n\n\n## Overview\n\nTo help reduce P99/P999 RPC latencies, HBase 2.x has made the read and write path use a pool of offheap buffers. Cells are\nallocated in offheap memory outside of the purview of the JVM garbage collector with attendent reduction in GC pressure.\nIn the write path, the request packet received from client will be read in on a pre-allocated offheap buffer and retained\noffheap until those cells are successfully persisted to the WAL and Memstore. The memory data structure in Memstore does\nnot directly store the cell memory, but references the cells encoded in the offheap buffers. Similarly for the read path.\nWe'll try to read the block cache first and if a cache misses, we'll go to the HFile and read the respective block. The\nworkflow from reading blocks to sending cells to client does its best to avoid on-heap memory allocations reducing the\namount of work the GC has to do.\n\n<img alt=\"Offheap Overview\" src={__img0} placeholder=\"blur\" />\n\nFor redress for the single mention of onheap in the read-section of the diagram above see [Read block from HDFS to offheap directly](/docs/offheap-read-write#read-block-from-hdfs-to-offheap-directly).\n\n## Offheap read-path\n\nIn HBase-2.0.0, [HBASE-11425](https://issues.apache.org/jira/browse/HBASE-11425) changed the HBase read path so it\ncould hold the read-data off-heap avoiding copying of cached data (BlockCache) on to the java heap (for uncached data,\nsee note under the diagram in the section above). This reduces GC pauses given there is less garbage made and so less\nto clear. The off-heap read path can have a performance that is similar or better to that of the on-heap LRU cache.\nThis feature is available since HBase 2.0.0. Refer to below blogs for more details and test results on off heaped read path\n[Offheaping the Read Path in Apache HBase: Part 1 of 2](https://blogs.apache.org/hbase/entry/offheaping_the_read_path_in)\nand [Offheap Read-Path in Production - The Alibaba story](https://blogs.apache.org/hbase/entry/offheap-read-path-in-production)\n\nFor an end-to-end off-heaped read-path, all you have to do is enable an off-heap backed [Off-heap Block Cache](/docs/architecture/regionserver#off-heap-block-cache)(BC).\nTo do this, configure *hbase.bucketcache.ioengine* to be *offheap* in *hbase-site.xml* (See [BucketCache Deploy Modes](/docs/architecture/regionserver#bucketcache-deploy-modes) to learn\nmore about *hbase.bucketcache.ioengine* options). Also specify the total capacity of the BC using `hbase.bucketcache.size`.\nPlease remember to adjust value of 'HBASE*OFFHEAPSIZE' in \\_hbase-env.sh* (See [BucketCache Example Configuration](/docs/architecture/regionserver#bucketcache-example-configuration) for help sizing and an example\nenabling). This configuration is for specifying the maximum possible off-heap memory allocation for the RegionServer java\nprocess. This should be bigger than the off-heap BC size to accommodate usage by other features making use of off-heap memory\nsuch as Server RPC buffer pool and short-circuit reads (See discussion in [BucketCache Example Configuration](/docs/architecture/regionserver#bucketcache-example-configuration)).\n\nPlease keep in mind that there is no default for `hbase.bucketcache.ioengine` which means the `BlockCache` is OFF by default\n(See the \"Direct Memory Usage In HBase\" info section in [BucketCache Example Configuration](/docs/architecture/regionserver#bucketcache-example-configuration)).\n\nThis is all you need to do to enable off-heap read path. Most buffers in HBase are already off-heap. With BC off-heap,\nthe read pipeline will copy data between HDFS and the server socket — caveat hbase.ipc.server.reservoir.initial.max —\nsending results back to the client.\n\n### Tuning the RPC buffer pool\n\nIt is possible to tune the ByteBuffer pool on the RPC server side used to accumulate the cell bytes and create result\ncell blocks to send back to the client side. Use `hbase.ipc.server.reservoir.enabled` to turn this pool ON or OFF. By\ndefault this pool is ON and available. HBase will create off-heap ByteBuffers and pool them them by default. Please\nmake sure not to turn this OFF if you want end-to-end off-heaping in read path.\n\nIf this pool is turned off, the server will create temp buffers onheap to accumulate the cell bytes and\nmake a result cell block. This can impact the GC on a highly read loaded server.\n\n<Callout type=\"info\">\n  The config keys which start with prefix `hbase.ipc.server.reservoir` are deprecated in hbase-3.x\n  (the internal pool implementation changed). If you are still in hbase-2.2.x or older, then just\n  use the old config keys. Otherwise if in hbase-3.x or hbase-2.3.x+, please use the new config keys\n  (See [deprecated and new configs in\n  HBase3.x](/docs/offheap-read-write#read-block-from-hdfs-to-offheap-directly))\n</Callout>\n\nNext thing to tune is the ByteBuffer pool on the RPC server side. The user can tune this pool with respect to how\nmany buffers are in the pool and what should be the size of each ByteBuffer. Use the config\n`hbase.ipc.server.reservoir.initial.buffer.size` to tune each of the buffer sizes. Default is 64KB for hbase-2.2.x\nand less, changed to 65KB by default for hbase-2.3.x+\n(see [HBASE-22532](https://issues.apache.org/jira/browse/HBASE-22532))\n\nWhen the result size is larger than one 64KB (Default) ByteBuffer size, the server will try to grab more than one\nByteBuffer and make a result cell block out of a collection of fixed-sized ByteBuffers. When the pool is running\nout of buffers, the server will skip the pool and create temporary on-heap buffers.\n\nThe maximum number of ByteBuffers in the pool can be tuned using the config `hbase.ipc.server.reservoir.initial.max`.\nIts default is a factor of region server handlers count (See the config `hbase.regionserver.handler.count`). The\nmath is such that by default we consider 2 MB as the result cell block size per read result and each handler will be\nhandling a read. For 2 MB size, we need 32 buffers each of size 64 KB (See default buffer size in pool). So per handler\n32 ByteBuffers(BB). We allocate twice this size as the max BBs count such that one handler can be creating the response\nand handing it to the RPC Responder thread and then handling a new request creating a new response cell block (using\npooled buffers). Even if the responder could not send back the first TCP reply immediately, our count should allow that\nwe should still have enough buffers in our pool without having to make temporary buffers on the heap. Again for smaller\nsized random row reads, tune this max count. These are lazily created buffers and the count is the max count to be pooled.\n\nIf you still see GC issues even after making end-to-end read path off-heap, look for issues in the appropriate buffer\npool. Check for the below RegionServer log line at INFO level in HBase2.x:\n\n```\nPool already reached its max capacity : XXX and no free buffers now. Consider increasing the value for 'hbase.ipc.server.reservoir.initial.max' ?\n```\n\nOr the following log message in HBase3.x:\n\n```\nPool already reached its max capacity : XXX and no free buffers now. Consider increasing the value for 'hbase.server.allocator.max.buffer.count' ?\n```\n\nThe setting for *HBASE\\_OFFHEAPSIZE* in *hbase-env.sh* should consider this off heap buffer pool on the server side also.\nWe need to config this max off heap size for the RegionServer as a bit higher than the sum of this max pool size and\nthe off heap cache size. The TCP layer will also need to create direct bytebuffers for TCP communication. Also the DFS\nclient will need some off-heap to do its workings especially if short-circuit reads are configured. Allocating an extra\n1 - 2 GB for the max direct memory size has worked in tests.\n\nIf you are using coprocessors and refer to the Cells in the read results, DO NOT store reference to these Cells out of\nthe scope of the CP hook methods. Some times the CPs want to store info about the cell (Like its row key) for considering\nin the next CP hook call etc. For such cases, pls clone the required fields of the entire Cell as per the use cases.\n\\[ See CellUtil#cloneXXX(Cell) APIs ]\n\n## Read block from HDFS to offheap directly\n\nIn HBase-2.x, the RegionServer will read blocks from HDFS to a temporary onheap ByteBuffer and then flush to\nthe BucketCache. Even if the BucketCache is offheap, we will first pull the HDFS read onheap before writing\nit out to the offheap BucketCache. We can observe much GC pressure when cache hit ratio low (e.g. a cacheHitRatio \\~ 60% ).\n[HBASE-21879](https://issues.apache.org/jira/browse/HBASE-21879) addresses this issue (Requires hbase-2.3.x/hbase-3.x).\nIt depends on there being a supporting HDFS being in place (hadoop-2.10.x or hadoop-3.3.x) and it may require patching\nHBase itself (as of this writing); see\n[HBASE-21879 Read HFile's block to ByteBuffer directly instead of to byte for reducing young gc purpose](https://issues.apache.org/jira/browse/HBASE-21879).\nAppropriately setup, reads from HDFS can be into offheap buffers passed offheap to the offheap BlockCache to cache.\n\nFor more details about the design and performance improvement, please see the\n[Design Doc -Read HFile's block to Offheap](https://docs.google.com/document/d/1xSy9axGxafoH-Qc17zbD2Bd--rWjjI00xTWQZ8ZwI_E).\n\nHere we will share some best practice about the performance tuning but first we introduce new (hbase-3.x/hbase-2.3.x) configuration names\nthat go with the new internal pool implementation (`ByteBuffAllocator` vs the old `ByteBufferPool`), some of which mimic now deprecated\nhbase-2.2.x configurations discussed above in the [Tuning the RPC buffer pool](/docs/offheap-read-write#tuning-the-rpc-buffer-pool). Much of the advice here overlaps that given above\nin the [Tuning the RPC buffer pool](/docs/offheap-read-write#tuning-the-rpc-buffer-pool) since the implementations have similar configurations.\n\n1. `hbase.server.allocator.pool.enabled` is for whether the RegionServer will use the pooled offheap ByteBuffer allocator. Default\n   value is true. In hbase-2.x, the deprecated `hbase.ipc.server.reservoir.enabled` did similar and is mapped to this config\n   until support for the old configuration is removed. This new name will be used in hbase-3.x and hbase-2.3.x+.\n2. `hbase.server.allocator.minimal.allocate.size` is the threshold at which we start allocating from the pool. Otherwise the\n   request will be allocated from onheap directly because it would be wasteful allocating small stuff from our pool of fixed-size\n   ByteBuffers. The default minimum is `hbase.server.allocator.buffer.size/6`.\n3. `hbase.server.allocator.max.buffer.count`: The `ByteBuffAllocator`, the new pool/reservoir implementation, has fixed-size\n   ByteBuffers. This config is for how many buffers to pool. Its default value is 2MB \\_ 2 \\_ hbase.regionserver.handler.count / 65KB\n   (similar to the discussion above in [Tuning the RPC buffer pool](/docs/offheap-read-write#tuning-the-rpc-buffer-pool)). If the default `hbase.regionserver.handler.count` is 30, then the default will be 1890.\n4. `hbase.server.allocator.buffer.size`: The byte size of each ByteBuffer. The default value is 66560 (65KB), here we choose 65KB instead of 64KB\n   because of [HBASE-22532](https://issues.apache.org/jira/browse/HBASE-22532).\n\nThe three config keys —`hbase.ipc.server.reservoir.enabled`, `hbase.ipc.server.reservoir.initial.buffer.size` and `hbase.ipc.server.reservoir.initial.max` — introduced in hbase-2.x\nhave been renamed and deprecated in hbase-3.x/hbase-2.3.x. Please use the new config keys instead:\n`hbase.server.allocator.pool.enabled`, `hbase.server.allocator.buffer.size` and `hbase.server.allocator.max.buffer.count`.\n\nNext, we have some suggestions regards performance.\n\n**Please make sure that there are enough pooled DirectByteBuffer in your ByteBuffAllocator.**\\\nThe ByteBuffAllocator will allocate ByteBuffer from the DirectByteBuffer pool first. If\nthere's no available ByteBuffer in the pool, then we will allocate the ByteBuffers from onheap.\nBy default, we will pre-allocate 4MB for each RPC handler (The handler count is determined by the config:\n`hbase.regionserver.handler.count`, it has the default value 30) . That's to say, if your `hbase.server.allocator.buffer.size`\nis 65KB, then your pool will have 2MB \\_ 2 / 65KB \\_ 30 = 945 DirectByteBuffer. If you have a large scan and a big cache,\nyou may have a RPC response whose bytes size is greater than 2MB (another 2MB for receiving rpc request), then it will\nbe better to increase the `hbase.server.allocator.max.buffer.count`.\n\nThe RegionServer web UI has statistics on ByteBuffAllocator:\n\n<img alt=\"ByteBuff Allocator Stats\" src={__img1} placeholder=\"blur\" />\n\nIf the following condition is met, you may need to increase your max buffer.count:\n\n```\nheapAllocationRatio >= hbase.server.allocator.minimal.allocate.size / hbase.server.allocator.buffer.size * 100%\n```\n\n**Please make sure the buffer size is greater than your block size.**\\\nWe have the default block size of 64KB, so almost all of the data blocks will be 64KB + a small delta, where the delta is\nvery small, depending on the size of the last Cell. If we set `hbase.server.allocator.buffer.size`=64KB,\nthen each block will be allocated as two ByteBuffers: one 64KB DirectByteBuffer and one HeapByteBuffer for the delta bytes.\nIdeally, we should let the data block to be allocated as one ByteBuffer; it has a simpler data structure, faster access speed,\nand less heap usage. Also, if the blocks are a composite of multiple ByteBuffers, to validate the checksum\nwe have to perform a temporary heap copy (see [HBASE-21917](https://issues.apache.org/jira/browse/HBASE-21917))\nwhereas if it's a single ByteBuffer we can speed the checksum by calling the hadoop' checksum native lib; it's more faster.\n\nPlease also see: [HBASE-22483](https://issues.apache.org/jira/browse/HBASE-22483)\n\nDon't forget to up your *HBASE\\_OFFHEAPSIZE* accordingly.\n\n## Offheap write-path\n\nIn hbase-2.x, [HBASE-15179](https://issues.apache.org/jira/browse/HBASE-15179) made the HBase write path work off-heap. By default, the MemStores in\nHBase have always used MemStore Local Allocation Buffers (MSLABs) to avoid memory fragmentation; an MSLAB creates bigger fixed sized chunks and then the\nMemStores Cell's data gets copied into these MSLAB chunks. These chunks can be pooled also and from hbase-2.x on, the MSLAB pool is by default ON.\nWrite off-heaping makes use of the MSLAB pool. It creates MSLAB chunks as Direct ByteBuffers and pools them.\n\n`hbase.regionserver.offheap.global.memstore.size` is the configuration key which controls the amount of off-heap data. Its value is the number of megabytes\nof off-heap memory that should be used by MSLAB (e.g. `25` would result in 25MB of off-heap). Be sure to increase *HBASE\\_OFFHEAPSIZE* which will set the JVM's\nMaxDirectMemorySize property (see [Tuning the RPC buffer pool](/docs/offheap-read-write#tuning-the-rpc-buffer-pool) for more on *HBASE\\_OFFHEAPSIZE*). The default value of\n`hbase.regionserver.offheap.global.memstore.size` is 0 which means MSLAB uses onheap, not offheap, chunks by default.\n\n`hbase.hregion.memstore.mslab.chunksize` controls the size of each off-heap chunk. Default is `2097152` (2MB).\n\nWhen a Cell is added to a MemStore, the bytes for that Cell are copied into these off-heap buffers (if `hbase.regionserver.offheap.global.memstore.size` is non-zero)\nand a Cell POJO will refer to this memory area. This can greatly reduce the on-heap occupancy of the MemStores and reduce the total heap utilization for RegionServers\nin a write-heavy workload. On-heap and off-heap memory utiliazation are tracked at multiple levels to implement low level and high level memory management.\nThe decision to flush a MemStore considers both the on-heap and off-heap usage of that MemStore. At the Region level, we sum the on-heap and off-heap usages and\ncompare them against the region flush size (128MB, by default). Globally, on-heap size occupancy of all memstores are tracked as well as off-heap size. When any of\nthese sizes breache the lower mark (`hbase.regionserver.global.memstore.size.lower.limit`) or the maximum size `hbase.regionserver.global.memstore.size`), all\nregions are selected for forced flushes.\n\n\n# Backup & Snapshots (/docs/operational-management/backup-and-snapshots)\n## HBase Backup\n\nThere are two broad strategies for performing HBase backups: backing up with a full cluster shutdown, and backing up on a live cluster. Each approach has pros and cons.\n\nFor additional information, see [HBase Backup Options](https://web.archive.org/web/20160110232448/http://blog.sematext.com/2011/03/11/hbase-backup-options/) over on the Sematext Blog.\n\n### Full Shutdown Backup\n\nSome environments can tolerate a periodic full shutdown of their HBase cluster, for example if it is being used a back-end analytic capacity and not serving front-end web-pages. The benefits are that the NameNode/Master are RegionServers are down, so there is no chance of missing any in-flight changes to either StoreFiles or metadata. The obvious con is that the cluster is down. The steps include:\n\n#### Stop HBase\n\n#### Distcp\n\nDistcp could be used to either copy the contents of the HBase directory in HDFS to either the same cluster in another directory, or to a different cluster.\\\nNote: Distcp works in this situation because the cluster is down and there are no in-flight edits to files. Distcp-ing of files in the HBase directory is not generally recommended on a live cluster.\n\n#### Restore (if needed)\n\nThe backup of the hbase directory from HDFS is copied onto the 'real' hbase directory via distcp. The act of copying these files creates new HDFS metadata, which is why a restore of the NameNode edits from the time of the HBase backup isn't required for this kind of restore, because it's a restore (via distcp) of a specific HDFS directory (i.e., the HBase part) not the entire HDFS file-system.\n\n### Live Cluster Backup - Replication\n\nThis approach assumes that there is a second cluster. See the HBase page on [replication](/docs/operational-management/cluster-replication) for more information.\n\n### Live Cluster Backup - CopyTable\n\nThe [copytable](/docs/operational-management/tools#copytable) utility could either be used to copy data from one table to another on the same cluster, or to copy data to another table on another cluster.\n\nSince the cluster is up, there is a risk that edits could be missed in the copy process.\n\n### Live Cluster Backup - Export\n\nThe [export](/docs/operational-management/tools#export) approach dumps the content of a table to HDFS on the same cluster. To restore the data, the [import](/docs/operational-management/tools#import) utility would be used.\n\nSince the cluster is up, there is a risk that edits could be missed in the export process. If you want to know more about HBase back-up and restore see the page on [Backup and Restore](/docs/backup-restore).\n\n## HBase Snapshots\n\nHBase Snapshots allow you to take a copy of a table (both contents and metadata)with a very small performance impact. A Snapshot is an immutable collection of table metadata and a list of HFiles that comprised the table at the time the Snapshot was taken. A \"clone\" of a snapshot creates a new table from that snapshot, and a \"restore\" of a snapshot returns the contents of a table to what it was when the snapshot was created. The \"clone\" and \"restore\" operations do not require any data to be copied, as the underlying HFiles (the files which contain the data for an HBase table) are not modified with either action. Simiarly, exporting a snapshot to another cluster has little impact on RegionServers of the local cluster.\n\nPrior to version 0.94.6, the only way to backup or to clone a table is to use CopyTable/ExportTable, or to copy all the hfiles in HDFS after disabling the table. The disadvantages of these methods are that you can degrade region server performance (Copy/Export Table) or you need to disable the table, that means no reads or writes; and this is usually unacceptable.\n\n### Configuration\n\nTo turn on the snapshot support just set the `hbase.snapshot.enabled` property to true. (Snapshots are enabled by default in 0.95+ and off by default in 0.94.6+)\n\n```xml\n<property>\n  <name>hbase.snapshot.enabled</name>\n  <value>true</value>\n</property>\n```\n\n### Take a Snapshot\n\nYou can take a snapshot of a table regardless of whether it is enabled or disabled. The snapshot operation doesn't involve any data copying.\n\n```bash\n$ ./bin/hbase shell\nhbase> snapshot 'myTable', 'myTableSnapshot-122112'\n\n```\n\n#### Take a Snapshot Without Flushing\n\nThe default behavior is to perform a flush of data in memory before the snapshot is taken. This means that data in memory is included in the snapshot. In most cases, this is the desired behavior. However, if your set-up can tolerate data in memory being excluded from the snapshot, you can use the `SKIP_FLUSH` option of the `snapshot` command to disable and flushing while taking the snapshot.\n\n```ruby\nhbase> snapshot 'mytable', 'snapshot123', {SKIP_FLUSH => true}\n```\n\n<Callout type=\"warn\">\n  There is no way to determine or predict whether a very concurrent insert or update will be\n  included in a given snapshot, whether flushing is enabled or disabled. A snapshot is only a\n  representation of a table during a window of time. The amount of time the snapshot operation will\n  take to reach each Region Server may vary from a few seconds to a minute, depending on the\n  resource load and speed of the hardware or network, among other factors. There is also no way to\n  know whether a given insert or update is in memory or has been flushed.\n</Callout>\n\n#### Take a Snapshot With TTL\n\nSnapshots have a lifecycle that is independent from the table from which they are created. Although data in a table may be stored with TTL the data files containing them become frozen by the snapshot. Space consumed by expired cells will not be reclaimed by normal table housekeeping like compaction. While this is expected it can be inconvenient at scale. When many snapshots are under management and the data in various tables is expired by TTL some notion of optional TTL (and optional default TTL) for snapshots could be useful.\n\n```ruby\nhbase> snapshot 'mytable', 'snapshot1234', {TTL => 86400}\n```\n\nThe above command creates snapshot `snapshot1234` with TTL of 86400 sec (24 hours) and hence, the snapshot is supposed to be cleaned up after 24 hours\n\n#### Default Snapshot TTL:\n\n* User specified default TTL with config `hbase.master.snapshot.ttl`\n* FOREVER if `hbase.master.snapshot.ttl` is not set\n\nWhile creating a snapshot, if TTL in seconds is not explicitly specified, the above logic will be followed to determine the TTL. If no configs are changed, the default behavior is that all snapshots will be retained forever (until manual deletion). If a different default TTL behavior is desired, `hbase.master.snapshot.ttl` can be set to a default TTL in seconds. Any snapshot created without an explicit TTL will take this new value.\n\n<Callout type=\"info\">\n  If `hbase.master.snapshot.ttl` is set, a snapshot with an explicit \\{TTL ⇒ 0} or \\{TTL ⇒ -1} will also take this value. In this case, a TTL \\< -1 (such as \\{TTL ⇒ -2}) should be used to indicate FOREVER.\n</Callout>\n\nTo summarize concisely,\n\n1. Snapshot with TTL value \\< -1 will stay forever regardless of any server side config changes (until deleted manually by user).\n2. Snapshot with TTL value > 0 will be deleted automatically soon after TTL expires.\n3. Snapshot created without specifying TTL will always have TTL value represented by config `hbase.master.snapshot.ttl`. Default value of this config is 0, which represents: keep the snapshot forever (until deleted manually by user).\n4. From client side, TTL value 0 or -1 should never be explicitly provided because they will be treated same as snapshot without TTL (same as above point 3) and hence will use TTL as per value represented by config `hbase.master.snapshot.ttl`.\n\n#### Take a snapshot with custom MAX\\_FILESIZE\n\nOptionally, snapshots can be created with a custom max file size configuration that will be used by cloned tables, instead of the global `hbase.hregion.max.filesize` configuration property. This is mostly useful when exporting snapshots between different clusters. If the HBase cluster where the snapshot is originally taken has a much larger value set for `hbase.hregion.max.filesize` than one or more clusters where the snapshot is being exported to, a storm of region splits may occur when restoring the snapshot on destination clusters. Specifying `MAX_FILESIZE` on properties passed to `snapshot` command will save informed value into the table's `MAX_FILESIZE` decriptor at snapshot creation time. If the table already defines `MAX_FILESIZE` descriptor, this property would be ignored and have no effect.\n\n```ruby\nsnapshot 'table01', 'snap01', {MAX_FILESIZE => 21474836480}\n```\n\n#### Enable/Disable Snapshot Auto Cleanup on running cluster:\n\nBy default, snapshot auto cleanup based on TTL would be enabled for any new cluster. At any point in time, if snapshot cleanup is supposed to be stopped due to some snapshot restore activity or any other reason, it is advisable to disable it using shell command:\n\n```ruby\nhbase> snapshot_cleanup_switch false\n```\n\nWe can re-enable it using:\n\n```ruby\nhbase> snapshot_cleanup_switch true\n```\n\nThe shell command with switch false would disable snapshot auto cleanup activity based on TTL and return the previous state of the activity(true: running already, false: disabled already)\n\nA sample output for above commands:\n\n```text\nPrevious snapshot cleanup state : true\nTook 0.0069 seconds\n=> \"true\"\n```\n\nWe can query whether snapshot auto cleanup is enabled for cluster using:\n\n```ruby\nhbase> snapshot_cleanup_enabled\n```\n\nThe command would return output in true/false.\n\n### Listing Snapshots\n\nList all snapshots taken (by printing the names and relative information).\n\n```bash\n$ ./bin/hbase shell\nhbase> list_snapshots\n```\n\n### Deleting Snapshots\n\nYou can remove a snapshot, and the files retained for that snapshot will be removed if no longer needed.\n\n```bash\n$ ./bin/hbase shell\nhbase> delete_snapshot 'myTableSnapshot-122112'\n```\n\n### Clone a table from snapshot\n\nFrom a snapshot you can create a new table (clone operation) with the same data that you had when the snapshot was taken. The clone operation, doesn't involve data copies, and a change to the cloned table doesn't impact the snapshot or the original table.\n\n```bash\n$ ./bin/hbase shell\nhbase> clone_snapshot 'myTableSnapshot-122112', 'myNewTestTable'\n```\n\n### Restore a snapshot\n\nThe restore operation requires the table to be disabled, and the table will be restored to the state at the time when the snapshot was taken, changing both data and schema if required.\n\n```bash\n$ ./bin/hbase shell\nhbase> disable 'myTable'\nhbase> restore_snapshot 'myTableSnapshot-122112'\n```\n\n<Callout type=\"info\">\n  Since Replication works at log level and snapshots at file-system level, after a restore, the\n  replicas will be in a different state from the master. If you want to use restore, you need to\n  stop replication and redo the bootstrap.\n</Callout>\n\nIn case of partial data-loss due to misbehaving client, instead of a full restore that requires the table to be disabled, you can clone the table from the snapshot and use a Map-Reduce job to copy the data that you need, from the clone to the main one.\n\n### Snapshots operations and ACLs\n\nIf you are using security with the AccessController Coprocessor (See [hbase.accesscontrol.configuration](/docs/security/data-access#access-control-labels-acls)), only a global administrator can take, clone, or restore a snapshot, and these actions do not capture the ACL rights. This means that restoring a table preserves the ACL rights of the existing table, while cloning a table creates a new table that has no ACL rights until the administrator adds them.\n\n### Export to another cluster\n\nThe ExportSnapshot tool copies all the data related to a snapshot (hfiles, logs, snapshot metadata) to another cluster. The tool executes a Map-Reduce job, similar to distcp, to copy files between the two clusters, and since it works at file-system level the hbase cluster does not have to be online.\n\nTo copy a snapshot called MySnapshot to an HBase cluster srv2 (hdfs\\:///srv2:8082/hbase) using 16 mappers:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.snapshot.ExportSnapshot -snapshot MySnapshot -copy-to hdfs://srv2:8082/hbase -mappers 16\n```\n\n#### Limiting Bandwidth Consumption\n\nYou can limit the bandwidth consumption when exporting a snapshot, by specifying the `-bandwidth` parameter, which expects an integer representing megabytes per second. The following example limits the above example to 200 MB/sec.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.snapshot.ExportSnapshot -snapshot MySnapshot -copy-to hdfs://srv2:8082/hbase -mappers 16 -bandwidth 200\n```\n\n## Storing Snapshots in an Amazon S3 Bucket\n\nYou can store and retrieve snapshots from Amazon S3, using the following procedure.\n\n<Callout type=\"info\">\n  You can also store snapshots in Microsoft Azure Blob Storage. See [Storing Snapshots in Microsoft\n  Azure Blob\n  Storage](/docs/operational-management/backup-and-snapshots#storing-snapshots-in-microsoft-azure-blob-storage).\n</Callout>\n\n### Prerequisites\n\n* You must be using HBase 1.0 or higher and Hadoop 2.6.1 or higher, which is the first configuration that uses the Amazon AWS SDK.\n* You must use the `s3a://` protocol to connect to Amazon S3. The older `s3n://` and `s3://` protocols have various limitations and do not use the Amazon AWS SDK.\n* The `s3a://` URI must be configured and available on the server where you run the commands to export and restore the snapshot.\n\nAfter you have fulfilled the prerequisites, take the snapshot like you normally would. Afterward, you can export it using the `org.apache.hadoop.hbase.snapshot.ExportSnapshot` command like the one below, substituting your own `s3a://` path in the `copy-from` or `copy-to` directive and substituting or modifying other options as required:\n\n```bash\n$ hbase org.apache.hadoop.hbase.snapshot.ExportSnapshot \\\n    -snapshot MySnapshot \\\n    -copy-from hdfs://srv2:8082/hbase \\\n    -copy-to s3a://<bucket>/<namespace>/hbase \\\n    -chuser MyUser \\\n    -chgroup MyGroup \\\n    -chmod 700 \\\n    -mappers 16\n```\n\n```bash\n$ hbase org.apache.hadoop.hbase.snapshot.ExportSnapshot \\\n    -snapshot MySnapshot\n    -copy-from s3a://<bucket>/<namespace>/hbase \\\n    -copy-to hdfs://srv2:8082/hbase \\\n    -chuser MyUser \\\n    -chgroup MyGroup \\\n    -chmod 700 \\\n    -mappers 16\n```\n\nYou can also use the `org.apache.hadoop.hbase.snapshot.SnapshotInfo` utility with the `s3a://` path by including the `-remote-dir` option.\n\n```bash\n$ hbase org.apache.hadoop.hbase.snapshot.SnapshotInfo \\\n    -remote-dir s3a://<bucket>/<namespace>/hbase \\\n    -list-snapshots\n```\n\n## Storing Snapshots in Microsoft Azure Blob Storage\n\nYou can store snapshots in Microsoft Azure Blog Storage using the same techniques as in [Storing Snapshots in an Amazon S3 Bucket](/docs/operational-management/backup-and-snapshots#storing-snapshots-in-an-amazon-s3-bucket).\n\n### Prerequisites\n\n* You must be using HBase 1.2 or higher with Hadoop 2.7.1 or higher. No version of HBase supports Hadoop 2.7.0.\n* Your hosts must be configured to be aware of the Azure blob storage filesystem. See [https://hadoop.apache.org/docs/r2.7.1/hadoop-azure/index.html](https://hadoop.apache.org/docs/r2.7.1/hadoop-azure/index.html).\n\nAfter you meet the prerequisites, follow the instructions in [Storing Snapshots in an Amazon S3 Bucket](/docs/operational-management/backup-and-snapshots#storing-snapshots-in-an-amazon-s3-bucket), replacingthe protocol specifier with `wasb://` or `wasbs://`.\n\n## Storing Snapshots in Aliyun Object Storage Service\n\nYou can store snapshots in Aliyun Object Storage Service(Aliyun OSS) using the same techniques as in [Storing Snapshots in an Amazon S3 Bucket](/docs/operational-management/backup-and-snapshots#storing-snapshots-in-an-amazon-s3-bucket).\n\n### Prerequisites\n\n* You must be using HBase 1.2 or higher with Hadoop 2.9.1 or higher.\n* Your hosts must be configured to be aware of the Aliyun oss filesystem. See [https://hadoop.apache.org/docs/stable/hadoop-aliyun/tools/hadoop-aliyun/index.html](https://hadoop.apache.org/docs/stable/hadoop-aliyun/tools/hadoop-aliyun/index.html).\n\nAfter you meet the prerequisites, follow the instructions in [Storing Snapshots in an Amazon S3 Bucket](/docs/operational-management/backup-and-snapshots#storing-snapshots-in-an-amazon-s3-bucket), replacing the protocol specifier with `oss://`.\n\n\n# Cluster Replication (/docs/operational-management/cluster-replication)\n\n\n\n\n## Cluster Replication\n\nHBase provides a cluster replication mechanism which allows you to keep one cluster's state synchronized with that of another cluster, using the write-ahead log (WAL) of the source cluster to propagate the changes. Some use cases for cluster replication include:\n\n* Backup and disaster recovery\n* Data aggregation\n* Geographic data distribution\n* Online data ingestion combined with offline data analytics\n\n<Callout type=\"info\">\n  Replication is enabled at the granularity of the column family. Before enabling replication for a\n  column family, create the table and all column families to be replicated, on the destination\n  cluster.\n</Callout>\n\n<Callout type=\"info\">\n  Replication is asynchronous as we send WAL to another cluster in background, which means that when\n  you want to do recovery through replication, you could loss some data. To address this problem, we\n  have introduced a new feature called synchronous replication. As the mechanism is a bit different\n  so we use a separated section to describe it. Please see [Synchronous\n  Replication](/docs/sync-replication).\n</Callout>\n\n<Callout type=\"info\">\n  At present, there is compatibility problem if Replication and WAL Compression are used together.\n  If you need to use Replication, it is recommended to set the\n  `hbase.regionserver.wal.enablecompression` property to `false`. See\n  ([HBASE-26849](https://issues.apache.org/jira/browse/HBASE-26849)) for details.\n</Callout>\n\n### Replication Overview\n\nCluster replication uses a source-push methodology. An HBase cluster can be a source (also called master or active, meaning that it is the originator of new data), a destination (also called slave or passive, meaning that it receives data via replication), or can fulfill both roles at once. Replication is asynchronous, and the goal of replication is eventual consistency. When the source receives an edit to a column family with replication enabled, that edit is propagated to all destination clusters using the WAL for that for that column family on the RegionServer managing the relevant region.\n\nWhen data is replicated from one cluster to another, the original source of the data is tracked via a cluster ID which is part of the metadata. In HBase 0.96 and newer ([HBASE-7709](https://issues.apache.org/jira/browse/HBASE-7709)), all clusters which have already consumed the data are also tracked. This prevents replication loops.\n\nThe WALs for each region server must be kept in HDFS as long as they are needed to replicate data to any slave cluster. Each region server reads from the oldest log it needs to replicate and keeps track of its progress processing WALs inside ZooKeeper to simplify failure recovery. The position marker which indicates a slave cluster's progress, as well as the queue of WALs to process, may be different for every slave cluster.\n\nThe clusters participating in replication can be of different sizes. The master cluster relies on randomization to attempt to balance the stream of replication on the slave clusters. It is expected that the slave cluster has storage capacity to hold the replicated data, as well as any data it is responsible for ingesting. If a slave cluster does run out of room, or is inaccessible for other reasons, it throws an error and the master retains the WAL and retries the replication at intervals.\n\n<Callout type=\"warn\" title=\"Consistency Across Replicated Clusters\">\n  How your application builds on top of the HBase API matters when replication is in play. HBase's replication system provides at-least-once delivery of client edits for an enabled column family to each configured destination cluster. In the event of failure to reach a given destination, the replication system will retry sending edits in a way that might repeat a given message. HBase provides two ways of replication, one is the original replication and the other is serial replication. In the previous way of replication, there is not a guaranteed order of delivery for client edits. In the event of a RegionServer failing, recovery of the replication queue happens independent of recovery of the individual regions that server was previously handling. This means that it is possible for the not-yet-replicated edits to be serviced by a RegionServer that is currently slower to replicate than the one that handles edits from after the failure.\n\n  The combination of these two properties (at-least-once delivery and the lack of message ordering) means that some destination clusters may end up in a different state if your application makes use of operations that are not idempotent, e.g. Increments.\n\n  To solve the problem, HBase now supports serial replication, which sends edits to destination cluster as the order of requests from client. See [Serial Replication](/docs/operational-management/cluster-replication#serial-replication).\n</Callout>\n\n<Callout type=\"info\" title=\"Terminology Changes\">\n  Previously, terms such as **master-master**, **master-slave**, and **cyclical** were used to\n  describe replication relationships in HBase. These terms added confusion, and have been abandoned\n  in favor of discussions about cluster topologies appropriate for different scenarios.\n</Callout>\n\n#### Cluster Topologies\n\n* A central source cluster might propagate changes out to multiple destination clusters, for failover or due to geographic distribution.\n* A source cluster might push changes to a destination cluster, which might also push its own changes back to the original cluster.\n* Many different low-latency clusters might push changes to one centralized cluster for backup or resource-intensive data analytics jobs. The processed data might then be replicated back to the low-latency clusters.\n\nMultiple levels of replication may be chained together to suit your organization's needs. The following diagram shows a hypothetical scenario. Use the arrows to follow the data paths.\n\n***Example of a Complex Cluster Replication Configuration***\n<img alt=\"hbase replication diagram\" src={__img0} placeholder=\"blur\" />\n\nHBase replication borrows many concepts from the **statement-based replication** design used by MySQL. Instead of SQL statements, entire WALEdits (consisting of multiple cell inserts coming from Put and Delete operations on the clients) are replicated in order to maintain atomicity.\n\n### Managing and Configuring Cluster Replication\n\n#### Cluster Configuration Overview\n\n1. Configure and start the source and destination clusters. Create tables with the same names and column families on both the source and destination clusters, so that the destination cluster knows where to store data it will receive.\n2. All hosts in the source and destination clusters should be reachable to each other.\n3. If both clusters use the same ZooKeeper cluster, you must use a different `zookeeper.znode.parent`, because they cannot write in the same folder.\n4. On the source cluster, in HBase Shell, add the destination cluster as a peer, using the `add_peer` command.\n5. On the source cluster, in HBase Shell, enable the table replication, using the `enable_table_replication` command.\n6. Check the logs to see if replication is taking place. If so, you will see messages like the following, coming from the ReplicationSource.\n\n```java\nLOG.info(\"Replicating \"+clusterId + \" -> \" + peerClusterId);\n```\n\n#### Serial Replication Configuration\n\nSee [Serial Replication](/docs/operational-management/cluster-replication#serial-replication)\n\n#### Cluster Management Commands\n\n**add\\_peer `<ID>` `<CLUSTER_KEY>`**\\\nAdds a replication relationship between two clusters.\n\n* ID — a unique string, which must not contain a hyphen.\n* CLUSTER\\_KEY: composed using the following template, with appropriate place-holders: `hbase.zookeeper.quorum:hbase.zookeeper.property.clientPort:zookeeper.znode.parent`. This value can be found on the Master UI info page.\n* STATE(optional): ENABLED or DISABLED, default value is ENABLED\n\n**list\\_peers**\\\nlist all replication relationships known by this cluster\n\n**enable\\_peer `<ID>`**\\\nEnable a previously-disabled replication relationship\n\n**disable\\_peer `<ID>`**\\\nDisable a replication relationship. HBase will no longer send edits to that peer cluster, but it still keeps track of all the new WALs that it will need to replicate if and when it is re-enabled. WALs are retained when enabling or disabling replication as long as peers exist.\n\n**remove\\_peer `<ID>`**\\\nDisable and remove a replication relationship. HBase will no longer send edits to that peer cluster or keep track of WALs.\n\n**enable\\_table\\_replication `<TABLE_NAME>`**\\\nEnable the table replication switch for all its column families. If the table is not found in the destination cluster then it will create one with the same name and column families.\n\n**disable\\_table\\_replication `<TABLE_NAME>`**\\\nDisable the table replication switch for all its column families.\n\n**peer\\_modification\\_switch `<enable_or_disable>`, `<drain_procedures>`**\\\nEnabled/Disable peer modification operations, such as adding/removing replication peers. The second parameter means whether you want to wait until all existing peer modification procedures to finish before returning when disabling peer modification.\n\n**peer\\_modification\\_enabled**\\\nCheck whether peer modification is enabled.\n\n### Migrate Across Different Replication Peer Storages\n\nStarting from 2.6.0, we introduce a file system based `ReplicationPeerStorage`, which stores the replication peer state with files on HFile file system, instead of znodes on ZooKeeper. And we have also implemented a tool to copy replication peer state across different replication peer storages.\n\n```bash\n./bin/hbase copyreppeers <SRC_REPLICATION_PEER_STORAGE> <DST_REPLICATION_PEER_STORAGE>\n```\n\nTo support doing the migrate online, we introduce a shell command called `peer_modification_switch`.\n\n```ruby\nhbase> peer_modification_switch false, true\n```\n\nUse the above command can disable peer modification operations. The second `true` means you want to wait until all the existing replication peer modification procedures to finish before returning. After disabling the peer modification, it is safe for you to copy replication peer state with the above tool, and then update all the *hbase-site.xml* files in the cluster to specify the new replication peer storage, and finally trigger an online configuration update to load the new replication peer storage.\n\n## Serial Replication\n\nNote: this feature is introduced in HBase 2.1\n\n**Function of serial replication**\\\nSerial replication supports to push logs to the destination cluster in the same order as logs reach to the source cluster.\n\n### Why need serial replication?\n\nIn replication of HBase, we push mutations to destination cluster by reading WAL in each region server. We have a queue for WAL files so we can read them in order of creation time. However, when region-move or RS failure occurs in source cluster, the hlog entries that are not pushed before region-move or RS-failure will be pushed by original RS(for region move) or another RS which takes over the remained hlog of dead RS(for RS failure), and the new entries for the same region(s) will be pushed by the RS which now serves the region(s), but they push the hlog entries of a same region concurrently without coordination.\n\nThis treatment can possibly lead to data inconsistency between source and destination clusters:\n\n1. there are put and then delete written to source cluster.\n2. due to region-move / RS-failure, they are pushed by different replication-source threads to peer cluster.\n3. if delete is pushed to peer cluster before put, and flush and major-compact occurs in peer cluster before put is pushed to peer cluster, the delete is collected and the put remains in peer cluster, but in source cluster the put is masked by the delete, hence data inconsistency between source and destination clusters.\n\n### Serial replication configuration\n\nSet the serial flag to true for a repliation peer. And the default serial flag is false.\n\n* Add a new replication peer which serial flag is true\n\n  ```ruby\n  hbase> add_peer '1', CLUSTER_KEY => \"server1.cie.com:2181:/hbase\", SERIAL => true\n  ```\n\n* Set a replication peer's serial flag to false\n\n  ```ruby\n  hbase> set_peer_serial '1', false\n  ```\n\n* Set a replication peer's serial flag to true\n\n  ```ruby\n  hbase> set_peer_serial '1', true\n  ```\n\nThe serial replication feature had been done firstly in [HBASE-9465](https://issues.apache.org/jira/browse/HBASE-9465) and then reverted and redone in [HBASE-20046](https://issues.apache.org/jira/browse/HBASE-20046). You can find more details in these issues.\n\n### Verifying Replicated Data\n\nThe `VerifyReplication` MapReduce job, which is included in HBase, performs a systematic comparison of replicated data between two different clusters. Run the VerifyReplication job on the master cluster, supplying it with the peer ID and table name to use for validation. You can limit the verification further by specifying a time range or specific families. The job's short name is `verifyrep`. To run the job, use a command like the following:\n\n```bash\n$ HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` \"${HADOOP_HOME}/bin/hadoop\" jar \"${HBASE_HOME}/hbase-mapreduce-VERSION.jar\" verifyrep --starttime=<timestamp> --endtime=<timestamp> --families=<myFam> <ID> <tableName>\n```\n\n* The `VerifyReplication` command prints out `GOODROWS` and `BADROWS` counters to indicate rows that did and did not replicate correctly.\n\n### Detailed Information About Cluster Replication\n\n***Replication Architecture Overview***\n<img alt=\"replication overview\" src={__img1} placeholder=\"blur\" />\n\n#### Life of a WAL Edit\n\nA single WAL edit goes through several steps in order to be replicated to a slave cluster.\n\n1. An HBase client uses a Put or Delete operation to manipulate data in HBase.\n2. The region server writes the request to the WAL in a way allows it to be replayed if it is not written successfully.\n3. If the changed cell corresponds to a column family that is scoped for replication, the edit is added to the queue for replication.\n4. In a separate thread, the edit is read from the log, as part of a batch process. Only the KeyValues that are eligible for replication are kept. Replicable KeyValues are part of a column family whose schema is scoped GLOBAL, are not part of a catalog such as `hbase:meta`, did not originate from the target slave cluster, and have not already been consumed by the target slave cluster.\n5. The edit is tagged with the master's UUID and added to a buffer. When the buffer is filled, or the reader reaches the end of the file, the buffer is sent to a random region server on the slave cluster.\n6. The region server reads the edits sequentially and separates them into buffers, one buffer per table. After all edits are read, each buffer is flushed using [Table](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html), HBase's normal client. The master's UUID and the UUIDs of slaves which have already consumed the data are preserved in the edits they are applied, in order to prevent replication loops.\n7. In the master, the offset for the WAL that is currently being replicated is registered in ZooKeeper.\n8. The first three steps, where the edit is inserted, are identical.\n9. Again in a separate thread, the region server reads, filters, and edits the log edits in the same way as above. The slave region server does not answer the RPC call.\n10. The master sleeps and tries again a configurable number of times.\n11. If the slave region server is still not available, the master selects a new subset of region server to replicate to, and tries again to send the buffer of edits.\n12. Meanwhile, the WALs are rolled and stored in a queue in ZooKeeper. Logs that are **archived** by their region server, by moving them from the region server's log directory to a central log directory, will update their paths in the in-memory queue of the replicating thread.\n13. When the slave cluster is finally available, the buffer is applied in the same way as during normal processing. The master region server will then replicate the backlog of logs that accumulated during the outage.\n\n**Spreading Queue Failover Load**\\\nWhen replication is active, a subset of region servers in the source cluster is responsible for shipping edits to the sink. This responsibility must be failed over like all other region server functions should a process or node crash. The following configuration settings are recommended for maintaining an even distribution of replication activity over the remaining live servers in the source cluster:\n\n* Set `replication.source.maxretriesmultiplier` to `300`.\n* Set `replication.source.sleepforretries` to `1` (1 second). This value, combined with the value of `replication.source.maxretriesmultiplier`, causes the retry cycle to last about 5 minutes.\n* Set `replication.sleep.before.failover` to `30000` (30 seconds) in the source cluster site configuration.\n\n**Preserving Tags During Replication**\\\nBy default, the codec used for replication between clusters strips tags, such as cell-level ACLs, from cells. To prevent the tags from being stripped, you can use a different codec which does not strip them. Configure `hbase.replication.rpc.codec` to use `org.apache.hadoop.hbase.codec.KeyValueCodecWithTags`, on both the source and sink RegionServers involved in the replication. This option was introduced in [HBASE-10322](https://issues.apache.org/jira/browse/HBASE-10322).\n\n#### Replication Internals\n\n**Replication State Storage**\\\nIn HBASE-15867, we abstract two interfaces for storing replication state, `ReplicationPeerStorage` and `ReplicationQueueStorage`. The former one is for storing the replication peer related states, and the latter one is for storing the replication queue related states. HBASE-15867 is only half done, as although we have abstract these two interfaces, we still only have zookeeper based implementations.\n\nAnd in HBASE-27110, we have implemented a file system based replication peer storage, to store replication peer state on file system. Of course you can still use the zookeeper based replication peer storage.\n\nAnd in HBASE-27109, we have changed the replication queue storage from zookeeper based to hbase table based. See the below `Replication Queue State` in hbase:replication table section for more details.\n\n**Replication State in ZooKeeper**\\\nBy default, the state is contained in the base node */hbase/replication*. Usually this nodes contains two child nodes, the peers znode is for storing replication peer state, and the rs znodes is for storing replication queue state. And if you choose the file system based replication peer storage, you will not see the peers znode. And starting from 3.0.0, we have moved the replication queue state to `hbase:replication` table (see below), so you will not see the rs znode.\n\n**The `Peers` Znode**\\\nThe `peers` znode is stored in */hbase/replication/peers* by default. It consists of a list of all peer replication clusters, along with the status of each of them. The value of each peer is its cluster key, which is provided in the HBase Shell. The cluster key contains a list of ZooKeeper nodes in the cluster's quorum, the client port for the ZooKeeper quorum, and the base znode for HBase in HDFS on that cluster. Starting from 3.0.0, you can also specify connection URI as a cluster key. See [Connection URI](/docs/architecture/client#connection-uri) for more details about connection URI.\n\n**The `RS` Znode**\\\nThe `rs` znode contains a list of WAL logs which need to be replicated. This list is divided into a set of queues organized by region server and the peer cluster the region server is shipping the logs to. The rs znode has one child znode for each region server in the cluster. The child znode name is the region server's hostname, client port, and start code. This list includes both live and dead region servers.\n\n**The hbase:replication Table**\\\nAfter 3.0.0, the `Queue` has been stored in the hbase:replication table, where the row key is `<PeerId>-<ServerName>[/<SourceServerName>]`, the WAL group will be the qualifier, and the serialized ReplicationGroupOffset will be the value. The ReplicationGroupOffset includes the wal file of the corresponding queue (`<PeerId>-<ServerName>[/<SourceServerName>]`) and its offset. Because we track replication offset per queue instead of per file, we only need to store one replication offset per queue.\n\n**Other implementations for `ReplicationPeerStorage`**\\\nStarting from 2.6.0, we introduce a file system based `ReplicationPeerStorage`, which stores the replication peer state with files on HFile file system, instead of znodes on ZooKeeper. The layout is almost the same with znodes on zookeeper, the main difference is that, the HFile file system may not support atomic rename, so we use two files to store the state and when reading we will read them both and compare the timestamp to find out the newer one. So typically, you will see two peer config files. And for enable/disable state, we just touch a disabled file if the peer is disabled, and remove the file when enabling the peer.\n\n#### Choosing Region Servers to Replicate To\n\nWhen a master cluster region server initiates a replication source to a slave cluster, it first connects to the slave's ZooKeeper ensemble using the provided cluster key . It then scans the *rs/* directory to discover all the available sinks (region servers that are accepting incoming streams of edits to replicate) and randomly chooses a subset of them using a configured ratio which has a default value of 10%. For example, if a slave cluster has 150 machines, 15 will be chosen as potential recipient for edits that this master cluster region server sends. Because this selection is performed by each master region server, the probability that all slave region servers are used is very high, and this method works for clusters of any size. For example, a master cluster of 10 machines replicating to a slave cluster of 5 machines with a ratio of 10% causes the master cluster region servers to choose one machine each at random.\n\nA ZooKeeper watcher is placed on the `$zookeeper.znode.parent/rs` node of the slave cluster by each of the master cluster's region servers. This watch is used to monitor changes in the composition of the slave cluster. When nodes are removed from the slave cluster, or if nodes go down or come back up, the master cluster's region servers will respond by selecting a new pool of slave region servers to replicate to.\n\n#### Keeping Track of Logs(based on ZooKeeper)\n\nEach master cluster region server has its own znode in the replication znodes hierarchy. It contains one znode per peer cluster (if 5 slave clusters, 5 znodes are created), and each of these contain a queue of WALs to process. Each of these queues will track the WALs created by that region server, but they can differ in size. For example, if one slave cluster becomes unavailable for some time, the WALs should not be deleted, so they need to stay in the queue while the others are processed. See [rs.failover.details](/docs/operational-management/cluster-replication#region-server-failover) for an example.\n\nWhen a source is instantiated, it contains the current WAL that the region server is writing to. During log rolling, the new file is added to the queue of each slave cluster's znode just before it is made available. This ensures that all the sources are aware that a new log exists before the region server is able to append edits into it, but this operations is now more expensive. The queue items are discarded when the replication thread cannot read more entries from a file (because it reached the end of the last block) and there are other files in the queue. This means that if a source is up to date and replicates from the log that the region server writes to, reading up to the \"end\" of the current file will not delete the item in the queue.\n\nA log can be archived if it is no longer used or if the number of logs exceeds `hbase.regionserver.maxlogs` because the insertion rate is faster than regions are flushed. When a log is archived, the source threads are notified that the path for that log changed. If a particular source has already finished with an archived log, it will just ignore the message. If the log is in the queue, the path will be updated in memory. If the log is currently being replicated, the change will be done atomically so that the reader doesn't attempt to open the file when has already been moved. Because moving a file is a NameNode operation , if the reader is currently reading the log, it won't generate any exception.\n\n#### Keeping Track of Logs(based on hbase table)\n\nAfter 3.0.0, for table based implementation, we have server name in row key, which means we will have lots of rows for a given peer.\n\nFor a normal replication queue, the WAL files belong to the region server that is still alive, all the WAL files are kept in memory, so we do not need to get the WAL files from replication queue storage. And for a recovered replication queue, we could get the WAL files of the dead region server by listing the old WAL directory on HDFS. So theoretically, we do not need to store every WAL file in replication queue storage. And what's more, we store the created time(usually) in the WAL file name, so for all the WAL files in a WAL group, we can sort them(actually we will sort them in the current replication framework), which means we only need to store one replication offset per queue. When starting a recovered replication queue, we will skip all the files before this offset, and start replicating from this offset.\n\nFor ReplicationLogCleaner, all the files before this offset can be deleted, otherwise not.\n\n#### Reading, Filtering and Sending Edits\n\nBy default, a source attempts to read from a WAL and ship log entries to a sink as quickly as possible. Speed is limited by the filtering of log entries Only KeyValues that are scoped GLOBAL and that do not belong to catalog tables will be retained. Speed is also limited by total size of the list of edits to replicate per slave, which is limited to 64 MB by default. With this configuration, a master cluster region server with three slaves would use at most 192 MB to store data to replicate. This does not account for the data which was filtered but not garbage collected.\n\nOnce the maximum size of edits has been buffered or the reader reaches the end of the WAL, the source thread stops reading and chooses at random a sink to replicate to (from the list that was generated by keeping only a subset of slave region servers). It directly issues a RPC to the chosen region server and waits for the method to return. If the RPC was successful, the source determines whether the current file has been emptied or it contains more data which needs to be read. If the file has been emptied, the source deletes the znode in the queue. Otherwise, it registers the new offset in the log's znode. If the RPC threw an exception, the source will retry 10 times before trying to find a different sink.\n\n#### Cleaning Logs\n\nIf replication is not enabled, the master's log-cleaning thread deletes old logs using a configured TTL. This TTL-based method does not work well with replication, because archived logs which have exceeded their TTL may still be in a queue. The default behavior is augmented so that if a log is past its TTL, the cleaning thread looks up every queue until it finds the log, while caching queues it has found. If the log is not found in any queues, the log will be deleted. The next time the cleaning process needs to look for a log, it starts by using its cached list.\n\n<Callout type=\"info\">\n  WALs are saved when replication is enabled or disabled as long as peers exist.\n</Callout>\n\n#### Region Server Failover\n\nWhen no region servers are failing, keeping track of the logs in ZooKeeper adds no value. Unfortunately, region servers do fail, and since ZooKeeper is highly available, it is useful for managing the transfer of the queues in the event of a failure. Each of the master cluster region servers keeps a watcher on every other region server, in order to be notified when one dies (just as the master does). When a failure happens, they all race to create a znode called `lock` inside the dead region server's znode that contains its queues. The region server that creates it successfully then transfers all the queues to its own znode, one at a time since ZooKeeper does not support renaming queues. After queues are all transferred, they are deleted from the old location. The znodes that were recovered are renamed with the ID of the slave cluster appended with the name of the dead server.\n\nNext, the master cluster region server creates one new source thread per copied queue, and each of the source threads follows the read/filter/ship pattern. The main difference is that those queues will never receive new data, since they do not belong to their new region server. When the reader hits the end of the last log, the queue's znode is deleted and the master cluster region server closes that replication source.\n\nAnd starting from 2.5.0, the failover logic has been moved to SCP, where we add a SERVER\\_CRASH\\_CLAIM\\_REPLICATION\\_QUEUES step in SCP to claim the replication queues for a dead server. And starting from 3.0.0, where we changed the replication queue storage from zookeeper to table, the update to the replication queue storage is async, so we also need an extra step to add the missing replication queues before claiming.\n\n#### The replication queue claiming (based on ZooKeeper)\n\nGiven a master cluster with 3 region servers replicating to a single slave with id `2`, the following hierarchy represents what the znodes layout could be at some point in time. The region servers' znodes all contain a `peers` znode which contains a single queue. The znode names in the queues represent the actual file names on HDFS in the form `address,port.timestamp`.\n\n```text\n/hbase/replication/rs/\n  1.1.1.1,60020,123456780/\n    2/\n      1.1.1.1,60020.1234  (Contains a position)\n      1.1.1.1,60020.1265\n  1.1.1.2,60020,123456790/\n    2/\n      1.1.1.2,60020.1214  (Contains a position)\n      1.1.1.2,60020.1248\n      1.1.1.2,60020.1312\n  1.1.1.3,60020,    123456630/\n    2/\n      1.1.1.3,60020.1280  (Contains a position)\n```\n\nAssume that 1.1.1.2 loses its ZooKeeper session. The survivors will race to create a lock, and, arbitrarily, 1.1.1.3 wins. It will then start transferring all the queues to its local peers znode by appending the name of the dead server. Right before 1.1.1.3 is able to clean up the old znodes, the layout will look like the following:\n\n```text\n/hbase/replication/rs/\n  1.1.1.1,60020,123456780/\n    2/\n      1.1.1.1,60020.1234  (Contains a position)\n      1.1.1.1,60020.1265\n  1.1.1.2,60020,123456790/\n    lock\n    2/\n      1.1.1.2,60020.1214  (Contains a position)\n      1.1.1.2,60020.1248\n      1.1.1.2,60020.1312\n  1.1.1.3,60020,123456630/\n    2/\n      1.1.1.3,60020.1280  (Contains a position)\n\n    2-1.1.1.2,60020,123456790/\n      1.1.1.2,60020.1214  (Contains a position)\n      1.1.1.2,60020.1248\n      1.1.1.2,60020.1312\n```\n\nSome time later, but before 1.1.1.3 is able to finish replicating the last WAL from 1.1.1.2, it dies too. Some new logs were also created in the normal queues. The last region server will then try to lock 1.1.1.3's znode and will begin transferring all the queues. The new layout will be:\n\n```text\n/hbase/replication/rs/\n  1.1.1.1,60020,123456780/\n    2/\n      1.1.1.1,60020.1378  (Contains a position)\n\n    2-1.1.1.3,60020,123456630/\n      1.1.1.3,60020.1325  (Contains a position)\n      1.1.1.3,60020.1401\n\n    2-1.1.1.2,60020,123456790-1.1.1.3,60020,123456630/\n      1.1.1.2,60020.1312  (Contains a position)\n  1.1.1.3,60020,123456630/\n    lock\n    2/\n      1.1.1.3,60020.1325  (Contains a position)\n      1.1.1.3,60020.1401\n\n    2-1.1.1.2,60020,123456790/\n      1.1.1.2,60020.1312  (Contains a position)\n```\n\n#### The replication queue claiming(based on hbase table)\n\nGiven a master cluster with 3 region servers replicating to a single slave with id `2`, the following info represents what the storage layout of queue in the hbase:replication at some point in time. Row key is `<PeerId>-<ServerName>[/<SourceServerName>]`, and value is WAL && Offset.\n\n```text\n  <PeerId>-<ServerName>[/<SourceServerName>]                        WAL && Offset\n  2-1.1.1.1,60020,123456780                            1.1.1.1,60020.1234  (Contains a position)\n  2-1.1.1.2,60020,123456790                            1.1.1.2,60020.1214  (Contains a position)\n  2-1.1.1.3,60020,123456630                            1.1.1.3,60020.1280  (Contains a position)\n```\n\nAssume that 1.1.1.2 failed. The survivors will claim queue of that, and, arbitrarily, 1.1.1.3 wins. It will claim all the queue of 1.1.1.2, including removing the row of a replication queue, and inserting a new row(where we change the server name to the region server which claims the queue). Finally, the layout will look like the following:\n\n```text\n  <PeerId>-<ServerName>[/<SourceServerName>]                        WAL && Offset\n  2-1.1.1.1,60020,123456780                            1.1.1.1,60020.1234  (Contains a position)\n  2-1.1.1.3,60020,123456630                            1.1.1.3,60020.1280  (Contains a position)\n  2-1.1.1.3,60020,123456630 1.1.1.2,60020,123456790    1.1.1.2,60020.1214  (Contains a position)\n```\n\n### Replication Metrics\n\nThe following metrics are exposed at the global region server level and at the peer level:\n\n`source.sizeOfLogQueue`\\\nnumber of WALs to process (excludes the one which is being processed) at the Replication source\n\n`source.shippedOps`\\\nnumber of mutations shipped\n\n`source.logEditsRead`\\\nnumber of mutations read from WALs at the replication source\n\n`source.ageOfLastShippedOp`\\\nage of last batch that was shipped by the replication source\n\n`source.completedLogs`\\\nThe number of write-ahead-log files that have completed their acknowledged sending to the peer associated with this source. Increments to this metric are a part of normal operation of HBase replication.\n\n`source.completedRecoverQueues`\\\nThe number of recovery queues this source has completed sending to the associated peer. Increments to this metric are a part of normal recovery of HBase replication in the face of failed Region Servers.\n\n`source.uncleanlyClosedLogs`\\\nThe number of write-ahead-log files the replication system considered completed after reaching the end of readable entries in the face of an uncleanly closed file.\n\n`source.ignoredUncleanlyClosedLogContentsInBytes`\\\nWhen a write-ahead-log file is not closed cleanly, there will likely be some entry that has been partially serialized. This metric contains the number of bytes of such entries the HBase replication system believes were remaining at the end of files skipped in the face of an uncleanly closed file. Those bytes should either be in different file or represent a client write that was not acknowledged.\n\n`source.restartedLogReading`\\\nThe number of times the HBase replication system detected that it failed to correctly parse a cleanly closed write-ahead-log file. In this circumstance, the system replays the entire log from the beginning, ensuring that no edits fail to be acknowledged by the associated peer. Increments to this metric indicate that the HBase replication system is having difficulty correctly handling failures in the underlying distributed storage system. No dataloss should occur, but you should check Region Server log files for details of the failures.\n\n`source.repeatedLogFileBytes`\\\nWhen the HBase replication system determines that it needs to replay a given write-ahead-log file, this metric is incremented by the number of bytes the replication system believes had already been acknowledged by the associated peer prior to starting over.\n\n`source.closedLogsWithUnknownFileLength`\\\nIncremented when the HBase replication system believes it is at the end of a write-ahead-log file but it can not determine the length of that file in the underlying distributed storage system. Could indicate dataloss since the replication system is unable to determine if the end of readable entries lines up with the expected end of the file. You should check Region Server log files for details of the failures.\n\n### Replication Configuration Options\n\n| Option                                  | Description                                                                                                   | Default                      |\n| --------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ---------------------------- |\n| zookeeper.znode.parent                  | The name of the base ZooKeeper znode used for HBase                                                           | /hbase                       |\n| zookeeper.znode.replication             | The name of the base znode used for replication                                                               | replication                  |\n| zookeeper.znode.replication.peers       | The name of the peer znode                                                                                    | peers                        |\n| zookeeper.znode.replication.peers.state | The name of peer-state znode                                                                                  | peer-state                   |\n| zookeeper.znode.replication.rs          | The name of the rs znode                                                                                      | rs                           |\n| replication.sleep.before.failover       | How many milliseconds a worker should sleep before attempting to replicate a dead region server's WAL queues. |                              |\n| replication.executor.workers            | The number of region servers a given region server should attempt to failover simultaneously.                 | 1                            |\n| hbase.replication.peer.storage.impl     | The replication peer storage implementation                                                                   | zookeeper                    |\n| hbase.replication.peers.directory       | The directory for storing replication peer state, when filesystem replication peer storage is specified       | peers                        |\n| hbase.replication.queue.table.name      | The table for storing replication queue state                                                                 | hbase:replication            |\n| hbase.replication.queue.storage.impl    | The replication queue storage implementation                                                                  | TableReplicationQueueStorage |\n\n### Monitoring Replication Status\n\nYou can use the HBase Shell command `status 'replication'` to monitor the replication status on your cluster. The command has three variations:\n\n* `status 'replication'` — prints the status of each source and its sinks, sorted by hostname.\n* `status 'replication', 'source'` — prints the status for each replication source, sorted by hostname.\n* `status 'replication', 'sink'` — prints the status for each replication sink, sorted by hostname.\n\n#### Understanding the output\n\nThe command output will vary according to the state of replication. For example right after a restart and if destination peer is not reachable, no replication source threads would be running, so no metrics would get displayed:\n\n```text\nhbase01.home:\nSOURCE: PeerID=1\nNormal Queue: 1\nNo Reader/Shipper threads runnning yet.\nSINK: TimeStampStarted=1591985197350, Waiting for OPs...\n```\n\nUnder normal circumstances, a healthy, active-active replication deployment would show the following:\n\n```text\n    hbase01.home:\n      SOURCE: PeerID=1\n         Normal Queue: 1\n           AgeOfLastShippedOp=0, TimeStampOfLastShippedOp=Fri Jun 12 18:49:23 BST 2020, SizeOfLogQueue=1, EditsReadFromLogQueue=1, OpsShippedToTarget=1, TimeStampOfNextToReplicate=Fri Jun 12 18:49:23 BST 2020, Replication Lag=0\n      SINK: TimeStampStarted=1591983663458, AgeOfLastAppliedOp=0, TimeStampsOfLastAppliedOp=Fri Jun 12 18:57:18 BST 2020\n```\n\nThe definition for each of these metrics is detailed below:\n\n| Type   | Metric Name                | Description                                                                                                                        |\n| ------ | -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |\n| Source | AgeOfLastShippedOp         | How long last successfully shipped edit took to effectively get replicated on target.                                              |\n| Source | TimeStampOfLastShippedOp   | The actual date of last successful edit shipment.                                                                                  |\n| Source | SizeOfLogQueue             | Number of wal files on this given queue.                                                                                           |\n| Source | EditsReadFromLogQueue      | How many edits have been read from this given queue since this source thread started.                                              |\n| Source | OpsShippedToTarget         | How many edits have been shipped to target since this source thread started.                                                       |\n| Source | TimeStampOfNextToReplicate | Date of the current edit been attempted to replicate.                                                                              |\n| Source | Replication Lag            | The elapsed time (in millis), since the last edit to replicate was read by this source thread and effectively replicated to target |\n| Sink   | TimeStampStarted           | Date (in millis) of when this Sink thread started.                                                                                 |\n| Sink   | AgeOfLastAppliedOp         | How long it took to apply the last successful shipped edit.                                                                        |\n| Sink   | TimeStampsOfLastAppliedOp  | Date of last successful applied edit.                                                                                              |\n\nGrowing values for `Source.TimeStampsOfLastAppliedOp` and/or `Source.Replication Lag` would indicate replication delays. If those numbers keep going up, while `Source.TimeStampOfLastShippedOp`, `Source.EditsReadFromLogQueue`, `Source.OpsShippedToTarget` or `Source.TimeStampOfNextToReplicate` do not change at all, then replication flow is failing to progress, and there might be problems within clusters communication. This could also happen if replication is manually paused (via hbase shell `disable_peer` command, for example), but data keeps getting ingested in the source cluster tables.\n\n### Replication Observability Framework\n\nThe core idea is to create `replication marker rows` periodically and insert them into WAL. These marker rows will help track the replication delays/bugs back to the `originating region server, WAL and timestamp of occurrence`. This tracker rows' WAL entries are interleaved with the regular table WAL entries and have a very high chance of running into the same replication delays/bugs that the user tables are seeing. Details as follows:\n\n#### REPLICATION.WALEVENTTRACKER table\n\nCreate a new table called `REPLICATION.WALEVENTTRACKER` table and persist all the WAL events (like `ACTIVE`, `ROLLING`, `ROLLED`) to this table.\\\nThe properties of this table are: Replication is set to 0, Block Cache is Disabled, Max versions is 1, TTL is 1 year.\n\nThis table has single ColumnFamily: `info`\\\n`info` contains multiple qualifiers:\n\n* `info:region_server_name`\n* `info:wal_name`\n* `info:timestamp`\n* `info:wal_state`\n* `info:wal_length`\n\nWhenever we roll a WAL (`old-wal-name` → `new-wal-name`), it will create 3 rows in this table.\\\n`<region_server_name>, <old-wal-name>, <current timestamp>, <ROLLING>, <length of old-wal-name>`\\\n`<region_server_name>, <old-wal-name>, <current timestamp>, <ROLLED>, <length of old-wal-name>`\\\n`<region_server_name>, <new-wal-name>, <current timestamp>, <ACTIVE>, 0`\n\n**Configuration**\\\nTo enable persisting WAL events, there is a configuration property: `hbase.regionserver.wal.event.tracker.enabled` (defaults to false)\n\n#### REPLICATION.SINK\\_TRACKER table\n\nCreate a new table called `REPLICATION.SINK_TRACKER`.\\\nThe properties of this table are: Replication is set to 0, Block Cache is Disabled, Max versions is 1, TTL is 1 year.\n\nThis table has single ColumnFamily: `info`\\\n`info` contains multiple qualifiers:\n\n* `info:region_server_name`\n* `info:wal_name`\n* `info:timestamp`\n* `info:offset`\n\n**Configuration**\\\nTo create the above table, there is a configuration property: `hbase.regionserver.replication.sink.tracker.enabled` (defaults to false)\n\n#### ReplicationMarker Chore\n\nWe introduced a new chore called `ReplicationMarkerChore` which will create the marker rows periodically into active WAL. The marker rows has the following metadata: `region_server_name, wal_name, timestamp and offset within WAL`. These markers are replicated (with special handling) and they are persisted into a sink side table `REPLICATION.SINK_TRACKER`.\n\n**Configuration:**\\\n`ReplicationMarkerChore` is enabled with configuration property: `hbase.regionserver.replication.marker.enabled` (defaults to false) and the period at which it creates marker rows is controlled by `hbase.regionserver.replication.marker.chore.duration` (defaults to 30 seconds). Sink cluster can choose to process these marker rows and persist to `REPLICATION.SINK_TRACKER` table or it can ignore these rows. This behavior is controlled by configuration property `hbase.regionserver.replication.sink.tracker.enabled` (defaults to false). If set to false, it will ignore the marker rows.\n\n#### How to enable end-to-end feature ?\n\nTo use this whole feature, we will need to enable the above configuration properties in 2 phases/releases.\\\nIn first phase/release, set the following configuration properties to `true`:\n\n* `hbase.regionserver.wal.event.tracker.enabled`: This will just persist all the WAL events to REPLICATION.WALEVENTTRACKER table.\n* `hbase.regionserver.replication.sink.tracker.enabled`: This will create REPLICATION.SINK\\_TRACKER table and will process special marker rows coming from source cluster.\n\nIn second phase/release, set the following configuration property to `true`:\n\n* `hbase.regionserver.replication.marker.enabled`: This will create marker rows periodically and sink cluster will persist these marker rows in `REPLICATION.SINK_TRACKER` table.\n\n\n# Apache HBase Operational Management (/docs/operational-management)\nThe subject of operations is related to the topics of [Troubleshooting and Debugging Apache HBase](/docs/troubleshooting), [Apache HBase Performance Tuning](/docs/performance), and [Apache HBase Configuration](/docs/configuration) but is a distinct topic in itself.\n\n\n# Metrics & Monitoring (/docs/operational-management/metrics-and-monitoring)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## HBase Metrics\n\nHBase emits metrics which adhere to the [Hadoop Metrics](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/Metrics.html) API. Starting with HBase 0.95\\[^1], HBase is configured to emit a default set of metrics with a default sampling period of every 10 seconds. You can use HBase metrics in conjunction with Ganglia. You can also filter which metrics are emitted and extend the metrics framework to capture custom metrics appropriate for your environment.\n\n### Metric Setup\n\nFor HBase 0.95 and newer, HBase ships with a default metrics configuration, or ***sink***. This includes a wide variety of individual metrics, and emits them every 10 seconds by default. To configure metrics for a given region server, edit the *conf/hadoop-metrics2-hbase.properties* file. Restart the region server for the changes to take effect.\n\nTo change the sampling rate for the default sink, edit the line beginning with `*.period`. To filter which metrics are emitted or to extend the metrics framework, see [https://hadoop.apache.org/docs/current/api/org/apache/hadoop/metrics2/package-summary.html](https://hadoop.apache.org/docs/current/api/org/apache/hadoop/metrics2/package-summary.html)\n\n<Callout type=\"info\" title=\"HBase Metrics and Ganglia\">\n  By default, HBase emits a large number of metrics per region server. Ganglia may have difficulty\n  processing all these metrics. Consider increasing the capacity of the Ganglia server or reducing\n  the number of metrics emitted by HBase. See [Metrics\n  Filtering](https://hadoop.apache.org/docs/current/api/org/apache/hadoop/metrics2/package-summary.html#filtering).\n</Callout>\n\n### Disabling Metrics\n\nTo disable metrics for a region server, edit the *conf/hadoop-metrics2-hbase.properties* file and comment out any uncommented lines. Restart the region server for the changes to take effect.\n\n### Enabling Metrics Servlets\n\nHBase exposes the metrics in many formats such as JSON, prometheus-format through different servlets (`/jmx`, `/metrics`, `/prometheus`). Any of these servlets can be enabled or disabled by the configuration property `hbase.http.metrics.servlets`. The value for the property should be a comma separated list of the servlet aliases which are `{jmx, metrics, prometheus}`. `/jmx`, `/metrics`, `/prometheus` are enabled by default. To get metrics using these servlets access the URL `http://SERVER_HOSTNAME:SERVER_WEB_UI_PORT/endpoint`. Where endpoint is one of `/jmx`, `/metrics`, or `/prometheus`. Eg. `http://my.rs.xyz.com:16030/prometheus`\n\n### Prometheus servlets\n\nHBase exposes the metrics in prometheus friendly format through a servlet, `/prometheus`. Currently `/prometheus` exposes all the available metrics.\n\n### Discovering Available Metrics\n\nRather than listing each metric which HBase emits by default, you can browse through the available metrics, either as a JSON output or via JMX. Different metrics are exposed for the Master process and each region server process.\n\n**Procedure: Access a JSON Output of Available Metrics**\n\n<Steps>\n  <Step>\n    After starting HBase, access the region server's web UI, at http\\://REGIONSERVER\\_HOSTNAME:16030 by default.\n  </Step>\n\n  <Step>\n    Click the **Metrics Dump** link near the top. The metrics for the region server are presented as a dump of the JMX bean in JSON format. This will dump out all metrics names and their values. To include metrics descriptions in the listing — this can be useful when you are exploring what is available — add a query string of `?description=true` so your URL becomes http\\://REGIONSERVER\\_HOSTNAME:16030/jmx?description=true. Not all beans and attributes have descriptions.\n  </Step>\n\n  <Step>\n    To view metrics for the Master, connect to the Master's web UI instead (defaults to [http://localhost:16010](http://localhost:16010)) and click its **Metrics Dump** link. To include metrics descriptions in the listing — this can be useful when you are exploring what is available — add a query string of `?description=true` so your URL becomes http\\://REGIONSERVER\\_HOSTNAME:16010/jmx?description=true. Not all beans and attributes have descriptions.\n  </Step>\n</Steps>\n\nYou can use many different tools to view JMX content by browsing MBeans. This procedure uses `jvisualvm`, which is an application usually available in the JDK.\n\n**Procedure: Browse the JMX Output of Available Metrics**\n\n<Steps>\n  <Step>\n    Start HBase, if it is not already running.\n  </Step>\n\n  <Step>\n    Run the command `jvisualvm` command on a host with a GUI display. You can launch it from the command line or another method appropriate for your operating system.\n  </Step>\n\n  <Step>\n    Be sure the **VisualVM-MBeans** plugin is installed. Browse to **Tools → Plugins**. Click **Installed** and check whether the plugin is listed. If not, click **Available Plugins**, select it, and click Install. When finished, click Close.\n  </Step>\n\n  <Step>\n    To view details for a given HBase process, double-click the process in the **Local** sub-tree in the left-hand panel. A detailed view opens in the right-hand panel. Click the **MBeans** tab which appears as a tab in the top of the right-hand panel.\n  </Step>\n\n  <Step>\n    To access the HBase metrics, navigate to the appropriate sub-bean: .\\* Master: .\\* RegionServer:\n  </Step>\n\n  <Step>\n    The name of each metric and its current value is displayed in the **Attributes** tab. For a view which includes more details, including the description of each attribute, click the **Metadata** tab.\n  </Step>\n</Steps>\n\n### Units of Measure for Metrics\n\nDifferent metrics are expressed in different units, as appropriate. Often, the unit of measure is in the name (as in the metric `shippedKBs`). Otherwise, use the following guidelines. When in doubt, you may need to examine the source for a given metric.\n\n* Metrics that refer to a point in time are usually expressed as a timestamp.\n* Metrics that refer to an age (such as `ageOfLastShippedOp`) are usually expressed in milliseconds.\n* Metrics that refer to memory sizes are in bytes.\n* Sizes of queues (such as `sizeOfLogQueue`) are expressed as the number of items in the queue. Determine the size by multiplying by the block size (default is 64 MB in HDFS).\n* Metrics that refer to things like the number of a given type of operations (such as `logEditsRead`) are expressed as an integer.\n\n### Most Important Master Metrics\n\nNote: Counts are usually over the last metrics reporting interval.\n\n**hbase.master.numRegionServers**\\\nNumber of live regionservers\n\n**hbase.master.numDeadRegionServers**\\\nNumber of dead regionservers\n\n**hbase.master.ritCount**\\\nThe number of regions in transition\n\n**hbase.master.ritCountOverThreshold**\\\nThe number of regions that have been in transition longer than a threshold time (default: 60 seconds)\n\n**hbase.master.ritOldestAge**\\\nThe age of the longest region in transition, in milliseconds\n\n### Most Important RegionServer Metrics\n\nNote: Counts are usually over the last metrics reporting interval.\n\n**hbase.regionserver.regionCount**\\\nThe number of regions hosted by the regionserver\n\n**hbase.regionserver.storeFileCount**\\\nThe number of store files on disk currently managed by the regionserver\n\n**hbase.regionserver.storeFileSize**\\\nAggregate size of the store files on disk\n\n**hbase.regionserver.hlogFileCount**\\\nThe number of write ahead logs not yet archived\n\n**hbase.regionserver.totalRequestCount**\\\nThe total number of requests received\n\n**hbase.regionserver.readRequestCount**\\\nThe number of read requests received\n\n**hbase.regionserver.writeRequestCount**\\\nThe number of write requests received\n\n**hbase.regionserver.numOpenConnections**\\\nThe number of open connections at the RPC layer\n\n**hbase.regionserver.numActiveHandler**\\\nThe number of RPC handlers actively servicing requests\n\n**hbase.regionserver.numCallsInGeneralQueue**\\\nThe number of currently enqueued user requests\n\n**hbase.regionserver.numCallsInReplicationQueue**\\\nThe number of currently enqueued operations received from replication\n\n**hbase.regionserver.numCallsInPriorityQueue**\\\nThe number of currently enqueued priority (internal housekeeping) requests\n\n**hbase.regionserver.flushQueueLength**\\\nCurrent depth of the memstore flush queue. If increasing, we are falling behind with clearing memstores out to HDFS.\n\n**hbase.regionserver.updatesBlockedTime**\\\nNumber of milliseconds updates have been blocked so the memstore can be flushed\n\n**hbase.regionserver.compactionQueueLength**\\\nCurrent depth of the compaction request queue. If increasing, we are falling behind with storefile compaction.\n\n**hbase.regionserver.blockCacheHitCount**\\\nThe number of block cache hits\n\n**hbase.regionserver.blockCacheMissCount**\\\nThe number of block cache misses\n\n**hbase.regionserver.blockCacheExpressHitPercent**\\\nThe percent of the time that requests with the cache turned on hit the cache\n\n**hbase.regionserver.percentFilesLocal**\\\nPercent of store file data that can be read from the local DataNode, 0-100\n\n**hbase.regionserver.\\<op>\\_\\<measure>**\\\nOperation latencies, where \\<op> is one of Append, Delete, Mutate, Get, Replay, Increment; and where \\<measure> is one of min, max, mean, median, 75th\\_percentile, 95th\\_percentile, 99th\\_percentile\n\n**hbase.regionserver.slow\\<op>Count**\\\nThe number of operations we thought were slow, where \\<op> is one of the list above\n\n**hbase.regionserver.GcTimeMillis**\\\nTime spent in garbage collection, in milliseconds\n\n**hbase.regionserver.GcTimeMillisParNew**\\\nTime spent in garbage collection of the young generation, in milliseconds\n\n**hbase.regionserver.GcTimeMillisConcurrentMarkSweep**\\\nTime spent in garbage collection of the old generation, in milliseconds\n\n**hbase.regionserver.authenticationSuccesses**\\\nNumber of client connections where authentication succeeded\n\n**hbase.regionserver.authenticationFailures**\\\nNumber of client connection authentication failures\n\n**hbase.regionserver.mutationsWithoutWALCount**\\\nCount of writes submitted with a flag indicating they should bypass the write ahead log\n\n### Meta Table Load Metrics\n\nHBase meta table metrics collection feature is available in HBase 1.4+ but it is disabled by default, as it can affect the performance of the cluster. When it is enabled, it helps to monitor client access patterns by collecting the following statistics:\n\n* number of get, put and delete operations on the `hbase:meta` table\n* number of get, put and delete operations made by the top-N clients\n* number of operations related to each table\n* number of operations related to the top-N regions\\\n  **When to use the feature**\\\n  This feature can help to identify hot spots in the meta table by showing the regions or tables where the meta info is modified (e.g. by create, drop, split or move tables) or retrieved most frequently. It can also help to find misbehaving client applications by showing which clients are using the meta table most heavily, which can for example suggest the lack of meta table buffering or the lack of re-using open client connections in the client application.\n\n<Callout type=\"warn\" title=\"Possible side-effects of enabling this feature\">\n  Having large number of clients and regions in the cluster can cause the registration and tracking\n  of a large amount of metrics, which can increase the memory and CPU footprint of the HBase region\n  server handling the `hbase:meta` table. It can also cause the significant increase of the JMX dump\n  size, which can affect the monitoring or log aggregation system you use beside HBase. It is\n  recommended to turn on this feature only during debugging.\n</Callout>\n\n**Where to find the metrics in JMX**\\\nEach metric attribute name will start with the ‘MetaTable\\_' prefix. For all the metrics you will see five different JMX attributes: count, mean rate, 1 minute rate, 5 minute rate and 15 minute rate. You will find these metrics in JMX under the following MBean: `Hadoop → HBase → RegionServer → Coprocessor.Region.CP_org.apache.hadoop.hbase.coprocessor.MetaTableMetrics`.\n\n**Examples: some Meta Table metrics you can see in your JMX dump**\n\n```json\n{\n  \"MetaTable_get_request_count\": 77309,\n  \"MetaTable_put_request_mean_rate\": 0.06339092997186495,\n  \"MetaTable_table_MyTestTable_request_15min_rate\": 1.1020599841623246,\n  \"MetaTable_client_/172.30.65.42_lossy_request_count\": 1786\n  \"MetaTable_client_/172.30.65.45_put_request_5min_rate\": 0.6189810954855728,\n  \"MetaTable_region_1561131112259.c66e4308d492936179352c80432ccfe0._lossy_request_count\": 38342,\n  \"MetaTable_region_1561131043640.5bdffe4b9e7e334172065c853cf0caa6._lossy_request_1min_rate\": 0.04925099917433935,\n}\n```\n\n**Configuration**\\\nTo turn on this feature, you have to enable a custom coprocessor by adding the following section to hbase-site.xml. This coprocessor will run on all the HBase RegionServers, but will be active (i.e. consume memory / CPU) only on the server, where the `hbase:meta` table is located. It will produce JMX metrics which can be downloaded from the web UI of the given RegionServer or by a simple REST call. These metrics will not be present in the JMX dump of the other RegionServers.\n\n**Enabling the Meta Table Metrics feature**\n\n```xml\n<property>\n    <name>hbase.coprocessor.region.classes</name>\n    <value>org.apache.hadoop.hbase.coprocessor.MetaTableMetrics</value>\n</property>\n```\n\n<Callout type=\"info\" title=\"How the top-N metrics are calculated?\">\n  The 'top-N' type of metrics will be counted using the Lossy Counting Algorithm (as defined in [Motwani, R; Manku, G.S (2002). \"Approximate frequency counts over data streams\"](http://www.vldb.org/conf/2002/S10P03.pdf)), which is designed to identify elements in a data stream whose frequency count exceed a user-given threshold. The frequency computed by this algorithm is not always accurate but has an error threshold that can be specified by the user as a configuration parameter. The run time space required by the algorithm is inversely proportional to the specified error threshold, hence larger the error parameter, the smaller the footprint and the less accurate are the metrics.\n\n  You can specify the error rate of the algorithm as a floating-point value between 0 and 1 (exclusive), it's default value is 0.02. Having the error rate set to `E` and having `N` as the total number of meta table operations, then (assuming the uniform distribution of the activity of low frequency elements) at most `7 / E` meters will be kept and each kept element will have a frequency higher than `E * N`.\n\n  An example: Let's assume we are interested in the HBase clients that are most active in accessing the meta table. When there was 1,000,000 operations on the meta table so far and the error rate parameter is set to 0.02, then we can assume that only at most 350 client IP address related counters will be present in JMX and each of these clients accessed the meta table at least 20,000 times.\n\n  ```xml\n  <property>\n      <name>hbase.util.default.lossycounting.errorrate</name>\n      <value>0.02</value>\n  </property>\n  ```\n</Callout>\n\n## HBase Monitoring\n\n### Overview\n\nThe following metrics are arguably the most important to monitor for each RegionServer for \"macro monitoring\", preferably with a system like [OpenTSDB](http://opentsdb.net/). If your cluster is having performance issues it's likely that you'll see something unusual with this group.\n\n#### HBase \\[!toc]\n\n* See [rs metrics](/docs/operational-management/metrics-and-monitoring#most-important-regionserver-metrics)\n\n#### OS \\[!toc]\n\n* IO Wait\n* User CPU\n\n#### Java \\[!toc]\n\n* GC\n\n### Slow Query Log\n\nThe HBase slow query log consists of parseable JSON structures describing the properties of those client operations (Gets, Puts, Deletes, etc.) that either took too long to run, or produced too much output. The thresholds for \"too long to run\" and \"too much output\" are configurable, as described below. The output is produced inline in the main region server logs so that it is easy to discover further details from context with other logged events. It is also prepended with identifying tags `(responseTooSlow)`, `(responseTooLarge)`, `(operationTooSlow)`, and `(operationTooLarge)` in order to enable easy filtering with grep, in case the user desires to see only slow queries.\n\n#### Configuration\n\nThere are four configuration knobs that can be used to adjust the thresholds for when queries are logged. Two of these knobs control the size and time thresholds for all queries. Because Scans can often be larger and slower than other types of queries, there are two additional knobs which can control size and time thresholds for Scans specifically.\n\n* `hbase.ipc.warn.response.time` Maximum number of milliseconds that a query can be run without being logged. Defaults to 10000, or 10 seconds. Can be set to -1 to disable logging by time.\n* `hbase.ipc.warn.response.size` Maximum byte size of response that a query can return without being logged. Defaults to 100 megabytes. Can be set to -1 to disable logging by size.\n* `hbase.ipc.warn.response.time.scan` Maximum number of milliseconds that a Scan can be run without being logged. Defaults to the `hbase.ipc.warn.response.time` value. Can be set to -1 to disable logging by time.\n* `hbase.ipc.warn.response.size.scan` Maximum byte size of response that a Scan can return without being logged. Defaults to the `hbase.ipc.warn.response.size` value. Can be set to -1 to disable logging by size.\n\n#### Metrics\n\nThe slow query log exposes to metrics to JMX.\n\n* `hadoop.regionserver_rpc_slowResponse` a global metric reflecting the durations of all responses that triggered logging.\n* `hadoop.regionserver_rpc_methodName.aboveOneSec` A metric reflecting the durations of all responses that lasted for more than one second.\n\n#### Output\n\nThe output is tagged with operation e.g. `(operationTooSlow)` if the call was a client operation, such as a Put, Get, or Delete, which we expose detailed fingerprint information for. If not, it is tagged `(responseTooSlow)` and still produces parseable JSON output, but with less verbose information solely regarding its duration and size in the RPC itself. `TooLarge` is substituted for `TooSlow` if the response size triggered the logging, with `TooLarge` appearing even in the case that both size and duration triggered logging.\n\n#### Example\n\n```text\n2011-09-08 10:01:25,824 WARN org.apache.hadoop.ipc.HBaseServer: (operationTooSlow): {\"tables\":{\"riley2\":{\"puts\":[{\"totalColumns\":11,\"families\":{\"actions\":[{\"timestamp\":1315501284459,\"qualifier\":\"0\",\"vlen\":9667580},{\"timestamp\":1315501284459,\"qualifier\":\"1\",\"vlen\":10122412},{\"timestamp\":1315501284459,\"qualifier\":\"2\",\"vlen\":11104617},{\"timestamp\":1315501284459,\"qualifier\":\"3\",\"vlen\":13430635}]},\"row\":\"cfcd208495d565ef66e7dff9f98764da:0\"}],\"families\":[\"actions\"]}},\"processingtimems\":956,\"client\":\"10.47.34.63:33623\",\"starttimems\":1315501284456,\"queuetimems\":0,\"totalPuts\":1,\"class\":\"HRegionServer\",\"responsesize\":0,\"method\":\"multiPut\"}\n```\n\nNote that everything inside the \"tables\" structure is output produced by MultiPut's fingerprint, while the rest of the information is RPC-specific, such as processing time and client IP/port. Other client operations follow the same pattern and the same general structure, with necessary differences due to the nature of the individual operations. In the case that the call is not a client operation, that detailed fingerprint information will be completely absent.\n\nThis particular example, for example, would indicate that the likely cause of slowness is simply a very large (on the order of 100MB) multiput, as we can tell by the \"vlen,\" or value length, fields of each put in the multiPut.\n\n#### Get Slow Response Log from shell\n\nWhen an individual RPC exceeds a configurable time bound we log a complaint by way of the logging subsystem\n\ne.g.\n\n```text\n2019-10-02 10:10:22,195 WARN [,queue=15,port=60020] ipc.RpcServer - (responseTooSlow):\n{\"call\":\"Scan(org.apache.hadoop.hbase.protobuf.generated.ClientProtos$ScanRequest)\",\n\"starttimems\":1567203007549,\n\"responsesize\":6819737,\n\"method\":\"Scan\",\n\"param\":\"region { type: REGION_NAME value: \\\"t1,\\\\000\\\\000\\\\215\\\\f)o\\\\\\\\\\\\024\\\\302\\\\220\\\\000\\\\000\\\\000\\\\000\\\\000\\\\001\\\\000\\\\000\\\\000\\\\000\\\\000\\\\006\\\\000\\\\000\\\\000\\\\000\\\\000\\\\005\\\\000\\\\000<TRUNCATED>\",\n\"processingtimems\":28646,\n\"client\":\"10.253.196.215:41116\",\n\"queuetimems\":22453,\n\"class\":\"HRegionServer\"}\n```\n\nUnfortunately often the request parameters are truncated as per above Example. The truncation is unfortunate because it eliminates much of the utility of the warnings. For example, the region name, the start and end keys, and the filter hierarchy are all important clues for debugging performance problems caused by moderate to low selectivity queries or queries made at a high rate.\n\nHBASE-22978 introduces maintaining an in-memory ring buffer of requests that were judged to be too slow in addition to the responseTooSlow logging. The in-memory representation can be complete. There is some chance a high rate of requests will cause information on other interesting requests to be overwritten before it can be read. This is an acceptable trade off.\n\nIn order to enable the in-memory ring buffer at RegionServers, we need to enable config:\n\n```text\nhbase.regionserver.slowlog.buffer.enabled\n```\n\nOne more config determines the size of the ring buffer:\n\n```text\nhbase.regionserver.slowlog.ringbuffer.size\n```\n\nCheck the config section for the detailed description.\n\nThis config would be disabled by default. Turn it on and these shell commands would provide expected results from the ring-buffers.\n\nshell commands to retrieve slowlog responses from RegionServers:\n\n```text\nRetrieve latest SlowLog Responses maintained by each or specific RegionServers.\nSpecify '*' to include all RS otherwise array of server names for specific\nRS. A server name is the host, port plus startcode of a RegionServer.\ne.g.: host187.example.com,60020,1289493121758 (find servername in\nmaster ui or when you do detailed status in shell)\n\nProvide optional filter parameters as Hash.\nDefault Limit of each server for providing no of slow log records is 10. User can specify\nmore limit by 'LIMIT' param in case more than 10 records should be retrieved.\n\nExamples:\n\n  hbase> get_slowlog_responses '*'                                 => get slowlog responses from all RS\n  hbase> get_slowlog_responses '*', {'LIMIT' => 50}                => get slowlog responses from all RS\n                                                                      with 50 records limit (default limit: 10)\n  hbase> get_slowlog_responses ['SERVER_NAME1', 'SERVER_NAME2']    => get slowlog responses from SERVER_NAME1,\n                                                                      SERVER_NAME2\n  hbase> get_slowlog_responses '*', {'REGION_NAME' => 'hbase:meta,,1'}\n                                                                   => get slowlog responses only related to meta\n                                                                      region\n  hbase> get_slowlog_responses '*', {'TABLE_NAME' => 't1'}         => get slowlog responses only related to t1 table\n  hbase> get_slowlog_responses '*', {'CLIENT_IP' => '192.162.1.40:60225', 'LIMIT' => 100}\n                                                                   => get slowlog responses with given client\n                                                                      IP address and get 100 records limit\n                                                                      (default limit: 10)\n  hbase> get_slowlog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1'}\n                                                                   => get slowlog responses with given region name\n                                                                      or table name\n  hbase> get_slowlog_responses '*', {'USER' => 'user_name', 'CLIENT_IP' => '192.162.1.40:60225'}\n                                                                   => get slowlog responses that match either\n                                                                      provided client IP address or user name\n```\n\nAll of above queries with filters have default OR operation applied i.e. all records with any of the provided filters applied will be returned. However, we can also apply AND operator i.e. all records that match all (not any) of the provided filters should be returned.\n\n```ruby\n  hbase> get_slowlog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1', 'FILTER_BY_OP' => 'AND'}\n                                                                   => get slowlog responses with given region name\n                                                                      and table name, both should match\n\n  hbase> get_slowlog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1', 'FILTER_BY_OP' => 'OR'}\n                                                                   => get slowlog responses with given region name\n                                                                      or table name, any one can match\n\n  hbase> get_slowlog_responses '*', {'TABLE_NAME' => 't1', 'CLIENT_IP' => '192.163.41.53:52781', 'FILTER_BY_OP' => 'AND'}\n                                                                   => get slowlog responses with given region name\n                                                                      and client IP address, both should match\n```\n\nSince OR is the default filter operator, without providing 'FILTER\\_BY\\_OP', query will have same result as providing 'FILTER\\_BY\\_OP' ⇒ 'OR'.\n\nSometimes output can be long pretty printed json for user to scroll in a single screen and hence user might prefer redirecting output of get\\_slowlog\\_responses to a file.\n\nExample:\n\n```bash\necho \"get_slowlog_responses '*'\" | hbase shell > xyz.out 2>&1\n```\n\nSimilar to slow RPC logs, client can also retrieve large RPC logs. Sometimes, slow logs important to debug perf issues turn out to be larger in size.\n\n```ruby\n  hbase> get_largelog_responses '*'                                 => get largelog responses from all RS\n  hbase> get_largelog_responses '*', {'LIMIT' => 50}                => get largelog responses from all RS\n                                                                       with 50 records limit (default limit: 10)\n  hbase> get_largelog_responses ['SERVER_NAME1', 'SERVER_NAME2']    => get largelog responses from SERVER_NAME1,\n                                                                       SERVER_NAME2\n  hbase> get_largelog_responses '*', {'REGION_NAME' => 'hbase:meta,,1'}\n                                                                    => get largelog responses only related to meta\n                                                                       region\n  hbase> get_largelog_responses '*', {'TABLE_NAME' => 't1'}         => get largelog responses only related to t1 table\n  hbase> get_largelog_responses '*', {'CLIENT_IP' => '192.162.1.40:60225', 'LIMIT' => 100}\n                                                                    => get largelog responses with given client\n                                                                       IP address and get 100 records limit\n                                                                       (default limit: 10)\n  hbase> get_largelog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1'}\n                                                                    => get largelog responses with given region name\n                                                                       or table name\n  hbase> get_largelog_responses '*', {'USER' => 'user_name', 'CLIENT_IP' => '192.162.1.40:60225'}\n                                                                    => get largelog responses that match either\n                                                                       provided client IP address or user name\n\n  hbase> get_largelog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1', 'FILTER_BY_OP' => 'AND'}\n                                                                   => get largelog responses with given region name\n                                                                      and table name, both should match\n\n  hbase> get_largelog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1', 'FILTER_BY_OP' => 'OR'}\n                                                                   => get largelog responses with given region name\n                                                                      or table name, any one can match\n\n  hbase> get_largelog_responses '*', {'TABLE_NAME' => 't1', 'CLIENT_IP' => '192.163.41.53:52781', 'FILTER_BY_OP' => 'AND'}\n                                                                   => get largelog responses with given region name\n                                                                      and client IP address, both should match\n```\n\nshell command to clear slow/largelog responses from RegionServer:\n\n```\nClears SlowLog Responses maintained by each or specific RegionServers.\nSpecify array of server names for specific RS. A server name is\nthe host, port plus startcode of a RegionServer.\ne.g.: host187.example.com,60020,1289493121758 (find servername in\nmaster ui or when you do detailed status in shell)\n\nExamples:\n\n  hbase> clear_slowlog_responses                                     => clears slowlog responses from all RS\n  hbase> clear_slowlog_responses ['SERVER_NAME1', 'SERVER_NAME2']    => clears slowlog responses from SERVER_NAME1,\n                                                                        SERVER_NAME2\n```\n\n#### Get Slow/Large Response Logs from System table hbase:slowlog\n\nThe above section provides details about Admin APIs:\n\n* get\\_slowlog\\_responses\n* get\\_largelog\\_responses\n* clear\\_slowlog\\_responses\n\nAll of the above APIs access online in-memory ring buffers from individual RegionServers and accumulate logs from ring buffers to display to end user. However, since the logs are stored in memory, after RegionServer is restarted, all the objects held in memory of that RegionServer will be cleaned up and previous logs are lost. What if we want to persist all these logs forever? What if we want to store them in such a manner that operator can get all historical records with some filters? e.g get me all large/slow RPC logs that are triggered by user1 and are related to region: cluster\\_test,cccccccc,1589635796466.aa45e1571d533f5ed0bb31cdccaaf9cf. ?\n\nIf we have a system table that stores such logs in increasing (not so strictly though) order of time, it can definitely help operators debug some historical events (scan, get, put, compaction, flush etc) with detailed inputs.\n\nConfig which enabled system table to be created and store all log events is `hbase.regionserver.slowlog.systable.enabled`.\n\nThe default value for this config is `false`. If provided `true` (Note: `hbase.regionserver.slowlog.buffer.enabled` should also be `true`), a cron job running in every RegionServer will persist the slow/large logs into table hbase:slowlog. By default cron job runs every 10 min. Duration can be configured with key: `hbase.slowlog.systable.chore.duration`. By default, RegionServer will store upto 1000(config key: `hbase.regionserver.slowlog.systable.queue.size`) slow/large logs in an internal queue and the chore will retrieve these logs from the queue and perform batch insertion in hbase:slowlog.\n\nhbase:slowlog has single ColumnFamily: `info` `info` contains multiple qualifiers which are the same attributes present as part of `get_slowlog_responses` API response.\n\n* info:call\\_details\n* info:client\\_address\n* info:method\\_name\n* info:param\n* info:processing\\_time\n* info:queue\\_time\n* info:region\\_name\n* info:response\\_size\n* info:server\\_class\n* info:start\\_time\n* info:type\n* info:username\n\nAnd example of 2 rows from hbase:slowlog scan result:\n\n```text\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:call_details, timestamp=2020-05-16T14:58:14.211Z, value=Scan(org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos$ScanRequest)\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:client_address, timestamp=2020-05-16T14:58:14.211Z, value=172.20.10.2:57347\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:method_name, timestamp=2020-05-16T14:58:14.211Z, value=Scan\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:param, timestamp=2020-05-16T14:58:14.211Z, value=region { type: REGION_NAME value: \"hbase:meta,,1\" } scan { column { family: \"info\" } attribute { name: \"_isolationle\n                                                             vel_\" value: \"\\x5C000\" } start_row: \"cluster_test,33333333,99999999999999\" stop_row: \"cluster_test,,\" time_range { from: 0 to: 9223372036854775807 } max_versions: 1 cache_blocks\n                                                             : true max_result_size: 2097152 reversed: true caching: 10 include_stop_row: true readType: PREAD } number_of_rows: 10 close_scanner: false client_handles_partials: true client_\n                                                             handles_heartbeats: true track_scan_metrics: false\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:processing_time, timestamp=2020-05-16T14:58:14.211Z, value=18\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:queue_time, timestamp=2020-05-16T14:58:14.211Z, value=0\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:region_name, timestamp=2020-05-16T14:58:14.211Z, value=hbase:meta,,1\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:response_size, timestamp=2020-05-16T14:58:14.211Z, value=1575\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:server_class, timestamp=2020-05-16T14:58:14.211Z, value=HRegionServer\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:start_time, timestamp=2020-05-16T14:58:14.211Z, value=1589640743732\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:type, timestamp=2020-05-16T14:58:14.211Z, value=ALL\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:username, timestamp=2020-05-16T14:58:14.211Z, value=user2\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:call_details, timestamp=2020-05-16T14:59:58.764Z, value=Scan(org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos$ScanRequest)\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:client_address, timestamp=2020-05-16T14:59:58.764Z, value=172.20.10.2:57348\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:method_name, timestamp=2020-05-16T14:59:58.764Z, value=Scan\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:param, timestamp=2020-05-16T14:59:58.764Z, value=region { type: REGION_NAME value: \"cluster_test,cccccccc,1589635796466.aa45e1571d533f5ed0bb31cdccaaf9cf.\" } scan { a\n                                                             ttribute { name: \"_isolationlevel_\" value: \"\\x5C000\" } start_row: \"cccccccc\" time_range { from: 0 to: 9223372036854775807 } max_versions: 1 cache_blocks: true max_result_size: 2\n                                                             097152 caching: 2147483647 include_stop_row: false } number_of_rows: 2147483647 close_scanner: false client_handles_partials: true client_handles_heartbeats: true track_scan_met\n                                                             rics: false\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:processing_time, timestamp=2020-05-16T14:59:58.764Z, value=24\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:queue_time, timestamp=2020-05-16T14:59:58.764Z, value=0\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:region_name, timestamp=2020-05-16T14:59:58.764Z, value=cluster_test,cccccccc,1589635796466.aa45e1571d533f5ed0bb31cdccaaf9cf.\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:response_size, timestamp=2020-05-16T14:59:58.764Z, value=211227\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:server_class, timestamp=2020-05-16T14:59:58.764Z, value=HRegionServer\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:start_time, timestamp=2020-05-16T14:59:58.764Z, value=1589640743932\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:type, timestamp=2020-05-16T14:59:58.764Z, value=ALL\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:username, timestamp=2020-05-16T14:59:58.764Z, value=user1\n```\n\nOperator can use ColumnValueFilter to filter records based on region\\_name, username, client\\_address etc.\n\nTime range based queries will also be very useful. Example:\n\n```bash\nscan 'hbase:slowlog', { TIMERANGE => [1589621394000, 1589637999999] }\n```\n\n### Block Cache Monitoring\n\nStarting with HBase 0.98, the HBase Web UI includes the ability to monitor and report on the performance of the block cache. To view the block cache reports, see the Block Cache section of the region server UI. Following are a few examples of the reporting capabilities.\n\n***Basic Info shows the cache implementation.***\n<img alt=\"bc basic\" src={__img0} placeholder=\"blur\" />\n\n***Config shows all cache configuration options.***\n<img alt=\"bc config\" src={__img1} placeholder=\"blur\" />\n\n***Stats shows statistics about the performance of the cache.***\n<img alt=\"bc stats\" src={__img2} placeholder=\"blur\" />\n\n***L1 and L2 show information about the L1 and L2 caches.***\n<img alt=\"bc l1\" src={__img3} placeholder=\"blur\" />\n\nThis is not an exhaustive list of all the screens and reports available. Have a look in the Web UI.\n\n### Snapshot Space Usage Monitoring\n\nStarting with HBase 0.95, Snapshot usage information on individual snapshots was shown in the HBase Master Web UI. This was further enhanced starting with HBase 1.3 to show the total Storefile size of the Snapshot Set. The following metrics are shown in the Master Web UI with HBase 1.3 and later.\n\n* Shared Storefile Size is the Storefile size shared between snapshots and active tables.\n* Mob Storefile Size is the Mob Storefile size shared between snapshots and active tables.\n* Archived Storefile Size is the Storefile size in Archive.\n\nThe format of Archived Storefile Size is NNN(MMM). NNN is the total Storefile size in Archive, MMM is the total Storefile size in Archive that is specific to the snapshot (not shared with other snapshots and tables).\n\n***Master Snapshot Overview***\n<img alt=\"master-snapshot\" src={__img4} placeholder=\"blur\" />\n\n***Snapshot Storefile Stats Example 1***\n<img alt=\"1 snapshot\" src={__img5} placeholder=\"blur\" />\n\n***Snapshot Storefile Stats Example 2***\n<img alt=\"2 snapshot\" src={__img6} placeholder=\"blur\" />\n\n***Empty Snapshot Storfile Stats Example***\n<img alt=\"empty snapshots\" src={__img7} placeholder=\"blur\" />\n\n\n# Node Management (/docs/operational-management/node)\n## Node Management\n\n### Node Decommission\n\nYou can stop an individual RegionServer by running the following script in the HBase directory on the particular node:\n\n```bash\n$ ./bin/hbase-daemon.sh stop regionserver\n```\n\nThe RegionServer will first close all regions and then shut itself down. On shutdown, the RegionServer's ephemeral node in ZooKeeper will expire. The master will notice the RegionServer gone and will treat it as a 'crashed' server; it will reassign the nodes the RegionServer was carrying.\n\n<Callout type=\"info\" title=\"Disable the Load Balancer before Decommissioning a node\">\n  If the load balancer runs while a node is shutting down, then there could be contention between\n  the Load Balancer and the Master's recovery of the just decommissioned RegionServer. Avoid any\n  problems by disabling the balancer first. See the \"Load Balancer\" info section below.\n</Callout>\n\n<Callout type=\"info\" title=\"Kill Node Tool\">\n  In hbase-2.0, in the bin directory, we added a script named *considerAsDead.sh* that can be used\n  to kill a regionserver. Hardware issues could be detected by specialized monitoring tools before\n  the zookeeper timeout has expired. *considerAsDead.sh* is a simple function to mark a RegionServer\n  as dead. It deletes all the znodes of the server, starting the recovery process. Plug in the\n  script into your monitoring/fault detection tools to initiate faster failover. Be careful how you\n  use this disruptive tool. Copy the script if you need to make use of it in a version of hbase\n  previous to hbase-2.0.\n</Callout>\n\nA downside to the above stop of a RegionServer is that regions could be offline for a good period of time. Regions are closed in order. If many regions on the server, the first region to close may not be back online until all regions close and after the master notices the RegionServer's znode gone. A node can be asked to gradually shed its load and then shutdown itself using the *graceful\\_stop.sh* script. Here is its usage:\n\n```\n$ ./bin/graceful_stop.sh\nUsage: graceful_stop.sh [--config <conf-dir>] [-e] [--restart [--reload]] [--thrift] [--rest] [-n |--noack] [--maxthreads <number of threads>] [--movetimeout <timeout in seconds>] [-nob |--nobalancer] [-d |--designatedfile <file path>] [-x |--excludefile <file path>] <hostname>\n thrift         If we should stop/start thrift before/after the hbase stop/start\n rest           If we should stop/start rest before/after the hbase stop/start\n restart        If we should restart after graceful stop\n reload         Move offloaded regions back on to the restarted server\n n|noack        Enable noAck mode in RegionMover. This is a best effort mode for moving regions\n maxthreads xx  Limit the number of threads used by the region mover. Default value is 1.\n movetimeout xx Timeout for moving regions. If regions are not moved by the timeout value,exit with error. Default value is INT_MAX.\n hostname       Hostname of server we are to stop\n e|failfast     Set -e so exit immediately if any command exits with non-zero status\n nob|nobalancer Do not manage balancer states. This is only used as optimization in rolling_restart.sh to avoid multiple calls to hbase shell\n d|designatedfile xx Designated file with <hostname:port> per line as unload targets\n x|excludefile xx Exclude file should have <hostname:port> per line. We do not unload regions to hostnames given in exclude file\n```\n\nTo decommission a loaded RegionServer, run the following: \\$ ./bin/graceful\\_stop.sh HOSTNAME where `HOSTNAME` is the host carrying the RegionServer you would decommission.\n\n<Callout type=\"info\" title=\"On HOSTNAME\">\n  The `HOSTNAME` passed to *graceful\\_stop.sh* must match the hostname that hbase is using to\n  identify RegionServers. HBase uses fully-qualified domain names usually. Check the list of\n  RegionServers in the master UI for how HBase is referring to servers. Whatever HBase is using,\n  this is what you should pass the *graceful\\_stop.sh* decommission script. If you pass IPs, the\n  script is not yet smart enough to make a hostname (or FQDN) of it and so it will fail when it\n  checks if server is currently running; the graceful unloading of regions will not run.\n</Callout>\n\nThe *graceful\\_stop.sh* script will move the regions off the decommissioned RegionServer one at a time to minimize region churn. It will verify the region deployed in the new location before it will moves the next region and so on until the decommissioned server is carrying zero regions. At this point, the *graceful\\_stop.sh* tells the RegionServer `stop`. The master will at this point notice the RegionServer gone but all regions will have already been redeployed and because the RegionServer went down cleanly, there will be no WAL logs to split.\n\n<Callout type=\"info\" title=\"Load Balancer\">\n  It is assumed that the Region Load Balancer is disabled while the `graceful_stop` script runs (otherwise the balancer and the decommission script will end up fighting over region deployments). Use the shell to disable the balancer:\n\n  ```ruby\n  hbase(main):001:0> balance_switch false\n  true\n  0 row(s) in 0.3590 seconds\n  ```\n\n  This turns the balancer OFF. To reenable, do:\n\n  ```ruby\n  hbase(main):001:0> balance_switch true\n  false\n  0 row(s) in 0.3590 seconds\n  ```\n\n  The `graceful_stop` will check the balancer and if enabled, will turn it off before it goes to work. If it exits prematurely because of error, it will not have reset the balancer. Hence, it is better to manage the balancer apart from `graceful_stop` reenabling it after you are done w/ graceful\\_stop.\n</Callout>\n\n#### Decommissioning several Regions Servers concurrently\n\nIf you have a large cluster, you may want to decommission more than one machine at a time by gracefully stopping multiple RegionServers concurrently. To gracefully drain multiple regionservers at the same time, RegionServers can be put into a \"draining\" state. This is done by marking a RegionServer as a draining node by creating an entry in ZooKeeper under the *hbase\\_root/draining* znode. This znode has format `name,port,startcode` just like the regionserver entries under *hbase\\_root/rs* znode.\n\nWithout this facility, decommissioning multiple nodes may be non-optimal because regions that are being drained from one region server may be moved to other regionservers that are also draining. Marking RegionServers to be in the draining state prevents this from happening. See this [blog post](http://inchoate-clatter.blogspot.com/2012/03/hbase-ops-automation.html) for more details.\n\n#### Bad or Failing Disk\n\nIt is good having [dfs.datanode.failed.volumes.tolerated](/docs/configuration/important#dfsdatanodefailedvolumestolerated) set if you have a decent number of disks per machine for the case where a disk plain dies. But usually disks do the \"John Wayne\" — i.e. take a while to go down spewing errors in *dmesg* — or for some reason, run much slower than their companions. In this case you want to decommission the disk. You have two options. You can [decommission the datanode](https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsDataNodeAdminGuide.html) or, less disruptive in that only the bad disks data will be rereplicated, can stop the datanode, unmount the bad volume (You can't umount a volume while the datanode is using it), and then restart the datanode (presuming you have set dfs.datanode.failed.volumes.tolerated > 0). The regionserver will throw some errors in its logs as it recalibrates where to get its data from — it will likely roll its WAL log too — but in general but for some latency spikes, it should keep on chugging.\n\n<Callout type=\"info\" title=\"Short Circuit Reads\">\n  If you are doing short-circuit reads, you will have to move the regions off the regionserver\n  before you stop the datanode; when short-circuiting reading, though chmod'd so regionserver cannot\n  have access, because it already has the files open, it will be able to keep reading the file\n  blocks from the bad disk even though the datanode is down. Move the regions back after you restart\n  the datanode.\n</Callout>\n\n### Rolling Restart\n\nSome cluster configuration changes require either the entire cluster, or the RegionServers, to be restarted in order to pick up the changes. In addition, rolling restarts are supported for upgrading to a minor or maintenance release, and to a major release if at all possible. See the release notes for release you want to upgrade to, to find out about limitations to the ability to perform a rolling upgrade.\n\nThere are multiple ways to restart your cluster nodes, depending on your situation. These methods are detailed below.\n\n#### Using the `rolling-restart.sh` Script\n\nHBase ships with a script, *bin/rolling-restart.sh*, that allows you to perform rolling restarts on the entire cluster, the master only, or the RegionServers only. The script is provided as a template for your own script, and is not explicitly tested. It requires password-less SSH login to be configured and assumes that you have deployed using a tarball. The script requires you to set some environment variables before running it. Examine the script and modify it to suit your needs.\n\n***rolling-restart.sh* General Usage**\n\n```bash\n$ ./bin/rolling-restart.sh --help\nUsage: rolling-restart.sh [--config <hbase-confdir>] [--rs-only] [--master-only] [--graceful] [--maxthreads xx]\n```\n\n**Rolling Restart on RegionServers Only**\\\nTo perform a rolling restart on the RegionServers only, use the `--rs-only` option. This might be necessary if you need to reboot the individual RegionServer or if you make a configuration change that only affects RegionServers and not the other HBase processes.\n\n**Rolling Restart on Masters Only**\\\nTo perform a rolling restart on the active and backup Masters, use the `--master-only` option. You might use this if you know that your configuration change only affects the Master and not the RegionServers, or if you need to restart the server where the active Master is running.\n\n**Graceful Restart**\\\nIf you specify the `--graceful` option, RegionServers are restarted using the *bin/graceful\\_stop.sh* script, which moves regions off a RegionServer before restarting it. This is safer, but can delay the restart.\n\nLimiting the Number of Threads\\\nTo limit the rolling restart to using only a specific number of threads, use the `--maxthreads` option.\n\n#### Manual Rolling Restart\n\nTo retain more control over the process, you may wish to manually do a rolling restart across your cluster. This uses the `graceful-stop.sh` command [decommission](/docs/operational-management/node#node-decommission). In this method, you can restart each RegionServer individually and then move its old regions back into place, retaining locality. If you also need to restart the Master, you need to do it separately, and restart the Master before restarting the RegionServers using this method. The following is an example of such a command. You may need to tailor it to your environment. This script does a rolling restart of RegionServers only. It disables the load balancer before moving the regions.\n\n```bash\n$ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i; done &> /tmp/log.txt &;\n```\n\nMonitor the output of the */tmp/log.txt* file to follow the progress of the script.\n\n#### Logic for Crafting Your Own Rolling Restart Script\n\nUse the following guidelines if you want to create your own rolling restart script.\n\n1. Extract the new release, verify its configuration, and synchronize it to all nodes of your cluster using `rsync`, `scp`, or another secure synchronization mechanism.\n\n2. Restart the master first. You may need to modify these commands if your new HBase directory is different from the old one, such as for an upgrade.\n\n   ```bash\n   $ ./bin/hbase-daemon.sh stop master; ./bin/hbase-daemon.sh start master\n   ```\n\n3. Gracefully restart each RegionServer, using a script such as the following, from the Master.\n\n   ```bash\n   $ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i; done &> /tmp/log.txt &\n   ```\n\n   If you are running Thrift or REST servers, pass the --thrift or --rest options. For other available options, run the `bin/graceful-stop.sh --help` command.\n\n   It is important to drain HBase regions slowly when restarting multiple RegionServers. Otherwise, multiple regions go offline simultaneously and must be reassigned to other nodes, which may also go offline soon. This can negatively affect performance. You can inject delays into the script above, for instance, by adding a Shell command such as `sleep`. To wait for 5 minutes between each RegionServer restart, modify the above script to the following:\n\n   ```bash\n   $ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i & sleep 5m; done &> /tmp/log.txt &\n   ```\n\n4. Restart the Master again, to clear out the dead servers list and re-enable the load balancer.\n\n### Adding a New Node\n\nAdding a new regionserver in HBase is essentially free, you simply start it like this: `$ ./bin/hbase-daemon.sh start regionserver` and it will register itself with the master. Ideally you also started a DataNode on the same machine so that the RS can eventually start to have local files. If you rely on ssh to start your daemons, don't forget to add the new hostname in *conf/regionservers* on the master.\n\nAt this point the region server isn't serving data because no regions have moved to it yet. If the balancer is enabled, it will start moving regions to the new RS. On a small/medium cluster this can have a very adverse effect on latency as a lot of regions will be offline at the same time. It is thus recommended to disable the balancer the same way it's done when decommissioning a node and move the regions manually (or even better, using a script that moves them one by one).\n\nThe moved regions will all have 0% locality and won't have any blocks in cache so the region server will have to use the network to serve requests. Apart from resulting in higher latency, it may also be able to use all of your network card's capacity. For practical purposes, consider that a standard 1GigE NIC won't be able to read much more than *100MB/s*. In this case, or if you are in a OLAP environment and require having locality, then it is recommended to major compact the moved regions.\n\n\n# Region & Capacity Management (/docs/operational-management/region-and-capacity)\n## Region Management\n\n### Major Compaction\n\nMajor compactions can be requested via the HBase shell or [Admin.majorCompact](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Admin.html#majorCompact\\(org.apache.hadoop.hbase.TableName\\)).\n\nNote: major compactions do NOT do region merges. See [compaction](/docs/architecture/regions#compaction) for more information about compactions.\n\n### Merge\n\nMerge is a utility that can merge adjoining regions in the same table (see org.apache.hadoop.hbase.util.Merge).\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.util.Merge <tablename> <region1> <region2>\n```\n\nIf you feel you have too many regions and want to consolidate them, Merge is the utility you need. Merge must run be done when the cluster is down. See the [O'Reilly HBase Book](https://web.archive.org/web/20111231002503/http://ofps.oreilly.com/titles/9781449396107/performance.html) for an example of usage.\n\nYou will need to pass 3 parameters to this application. The first one is the table name. The second one is the fully qualified name of the first region to merge, like \"table\\_name,\\x0A,1342956111995.7cef47f192318ba7ccc75b1bbf27a82b.\". The third one is the fully qualified name for the second region to merge.\n\nAdditionally, there is a Ruby script attached to [HBASE-1621](https://issues.apache.org/jira/browse/HBASE-1621) for region merging.\n\n## Capacity Planning and Region Sizing\n\nThere are several considerations when planning the capacity for an HBase cluster and performing the initial configuration. Start with a solid understanding of how HBase handles data internally.\n\n### Node count and hardware/VM configuration\n\n#### Physical data size\n\nPhysical data size on disk is distinct from logical size of your data and is affected by the following:\n\n* Increased by HBase overhead\n* See [keyvalue](/docs/architecture/regions#keyvalue) and [keysize](/docs/regionserver-sizing#try-to-minimize-row-and-column-sizes). At least 24 bytes per key-value (cell), can be more. Small keys/values means more relative overhead.\n* KeyValue instances are aggregated into blocks, which are indexed. Indexes also have to be stored. Blocksize is configurable on a per-ColumnFamily basis. See [regions.arch](/docs/architecture/regions).\n* Decreased by [compression](/docs/compression) and data block encoding, depending on data. You might want to test what compression and encoding (if any) make sense for your data.\n* Increased by size of region server \\[wal]/docs/architecture/regionserver#write-ahead-log-wal (usually fixed and negligible - less than half of RS memory size, per RS).\n* Increased by HDFS replication - usually x3.\n\nAside from the disk space necessary to store the data, one RS may not be able to serve arbitrarily large amounts of data due to some practical limits on region count and size (see [ops.capacity.regions](/docs/operational-management/region-and-capacity#determining-region-count-and-size)).\n\n#### Read/Write throughput\n\nNumber of nodes can also be driven by required throughput for reads and/or writes. The throughput one can get per node depends a lot on data (esp. key/value sizes) and request patterns, as well as node and system configuration. Planning should be done for peak load if it is likely that the load would be the main driver of the increase of the node count. PerformanceEvaluation and [ycsb](/docs/ycsb) tools can be used to test single node or a test cluster.\n\nFor write, usually 5-15Mb/s per RS can be expected, since every region server has only one active WAL. There's no good estimate for reads, as it depends vastly on data, requests, and cache hit rate. [perf.casestudy](/docs/performance#performance-case-studies) might be helpful.\n\n#### JVM GC limitations\n\nRS cannot currently utilize very large heap due to cost of GC. There's also no good way of running multiple RS-es per server (other than running several VMs per machine). Thus, \\~20-24Gb or less memory dedicated to one RS is recommended. GC tuning is required for large heap sizes. See [gcpause](/docs/performance#long-gc-pauses), [trouble.log.gc](/docs/troubleshooting#jvm-garbage-collection-logs) and elsewhere (TODO: where?)\n\n### Determining region count and size\n\nGenerally less regions makes for a smoother running cluster (you can always manually split the big regions later (if necessary) to spread the data, or request load, over the cluster); 20-200 regions per RS is a reasonable range. The number of regions cannot be configured directly (unless you go for fully [disable.splitting](/docs/configuration/important#managed-splitting)); adjust the region size to achieve the target region size given table size.\n\nWhen configuring regions for multiple tables, note that most region settings can be set on a per-table basis via [TableDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/TableDescriptorBuilder.html), as well as shell commands. These settings will override the ones in `hbase-site.xml`. That is useful if your tables have different workloads/use cases.\n\nAlso note that in the discussion of region sizes here, *HDFS replication factor is not (and should not be) taken into account, whereas other factors [ops.capacity.nodes.datasize](/docs/operational-management/region-and-capacity#physical-data-size) should be.* So, if your data is compressed and replicated 3 ways by HDFS, \"9 Gb region\" means 9 Gb of compressed data. HDFS replication factor only affects your disk usage and is invisible to most HBase code.\n\n#### Viewing the Current Number of Regions\n\nYou can view the current number of regions for a given table using the HMaster UI. In the **Tables** section, the number of online regions for each table is listed in the **Online Regions** column. This total only includes the in-memory state and does not include disabled or offline regions.\n\n#### Number of regions per RS - upper bound\n\nIn production scenarios, where you have a lot of data, you are normally concerned with the maximum number of regions you can have per server. [too many regions](/docs/architecture/regions#why-should-i-keep-my-region-count-low) has technical discussion on the subject. Basically, the maximum number of regions is mostly determined by memstore memory usage. Each region has its own memstores; these grow up to a configurable size; usually in 128-256 MB range, see [hbase.hregion.memstore.flush.size](/docs/configuration/default#hbasehregionmemstoreflushsize-toc). One memstore exists per column family (so there's only one per region if there's one CF in the table). The RS dedicates some fraction of total memory to its memstores (see [hbase.regionserver.global.memstore.size](/docs/configuration/default#hbaseregionserverglobalmemstoresize-toc)). If this memory is exceeded (too much memstore usage), it can cause undesirable consequences such as unresponsive server or compaction storms. A good starting point for the number of regions per RS (assuming one table) is:\n\n```text\n((RS memory) * (total memstore fraction)) / ((memstore size)*(# column families))\n```\n\nThis formula is pseudo-code. Here are two formulas using the actual tunable parameters, first for HBase 0.98+ and second for HBase 0.94.x.\n\n**HBase 0.98.x**\n\n```text\n((RS Xmx) * hbase.regionserver.global.memstore.size) / (hbase.hregion.memstore.flush.size * (# column families))\n```\n\n**HBase 0.94.x**\n\n```text\n((RS Xmx) * hbase.regionserver.global.memstore.upperLimit) / (hbase.hregion.memstore.flush.size * (# column families))+\n```\n\nIf a given RegionServer has 16 GB of RAM, with default settings, the formula works out to 16384\\*0.4/128 \\~ 51 regions per RS is a starting point. The formula can be extended to multiple tables; if they all have the same configuration, just use the total number of families.\n\nThis number can be adjusted; the formula above assumes all your regions are filled at approximately the same rate. If only a fraction of your regions are going to be actively written to, you can divide the result by that fraction to get a larger region count. Then, even if all regions are written to, all region memstores are not filled evenly, and eventually jitter appears even if they are (due to limited number of concurrent flushes). Thus, one can have as many as 2-3 times more regions than the starting point; however, increased numbers carry increased risk.\n\nFor write-heavy workload, memstore fraction can be increased in configuration at the expense of block cache; this will also allow one to have more regions.\n\n#### Number of regions per RS - lower bound\n\nHBase scales by having regions across many servers. Thus if you have 2 regions for 16GB data, on a 20 node machine your data will be concentrated on just a few machines - nearly the entire cluster will be idle. This really can't be stressed enough, since a common problem is loading 200MB data into HBase and then wondering why your awesome 10 node cluster isn't doing anything.\n\nOn the other hand, if you have a very large amount of data, you may also want to go for a larger number of regions to avoid having regions that are too large.\n\n#### Maximum region size\n\nFor large tables in production scenarios, maximum region size is mostly limited by compactions - very large compactions, esp. major, can degrade cluster performance. Currently, the recommended maximum region size is 10-20Gb, and 5-10Gb is optimal. For older 0.90.x codebase, the upper-bound of regionsize is about 4Gb, with a default of 256Mb.\n\nThe size at which the region is split into two is generally configured via [hbase.hregion.max.filesize](/docs/configuration/default#hbasehregionmaxfilesize-toc); for details, see [arch.region.splits](/docs/architecture/regions#region-splits).\n\nIf you cannot estimate the size of your tables well, when starting off, it's probably best to stick to the default region size, perhaps going smaller for hot tables (or manually split hot regions to spread the load over the cluster), or go with larger region sizes if your cell sizes tend to be largish (100k and up).\n\nIn HBase 0.98, experimental stripe compactions feature was added that would allow for larger regions, especially for log data. See [ops.stripe](/docs/architecture/regions#experimental-stripe-compactions).\n\n#### Total data size per region server\n\nAccording to above numbers for region size and number of regions per region server, in an optimistic estimate 10 GB x 100 regions per RS will give up to 1TB served per region server, which is in line with some of the reported multi-PB use cases. However, it is important to think about the data vs cache size ratio at the RS level. With 1TB of data per server and 10 GB block cache, only 1% of the data will be cached, which may barely cover all block indices.\n\n### Initial configuration and tuning\n\nFirst, see [important configurations](/docs/configuration/important). Note that some configurations, more than others, depend on specific scenarios. Pay special attention to:\n\n* [hbase.regionserver.handler.count](/docs/configuration/default#hbaseregionserverhandlercount-toc) - request handler thread count, vital for high-throughput workloads.\n* [config.wals](/docs/configuration/important#configuring-the-size-and-number-of-wal-files) - the blocking number of WAL files depends on your memstore configuration and should be set accordingly to prevent potential blocking when doing high volume of writes.\n\nThen, there are some considerations when setting up your cluster and tables.\n\n#### Compactions\n\nDepending on read/write volume and latency requirements, optimal compaction settings may be different. See [compaction](/docs/architecture/regions#compaction) for some details.\n\nWhen provisioning for large data sizes, however, it's good to keep in mind that compactions can affect write throughput. Thus, for write-intensive workloads, you may opt for less frequent compactions and more store files per regions. Minimum number of files for compactions (`hbase.hstore.compaction.min`) can be set to higher value; [hbase.hstore.blockingStoreFiles](/docs/configuration/default#hbasehstoreblockingStoreFiles-toc) should also be increased, as more files might accumulate in such case. You may also consider manually managing compactions: [managed.compactions](/docs/configuration/important#managed-compactions)\n\n#### Pre-splitting the table\n\nBased on the target number of the regions per RS (see [ops.capacity.regions.count](/docs/operational-management/region-and-capacity#number-of-regions-per-rs---upper-bound)) and number of RSes, one can pre-split the table at creation time. This would both avoid some costly splitting as the table starts to fill up, and ensure that the table starts out already distributed across many servers.\n\nIf the table is expected to grow large enough to justify that, at least one region per RS should be created. It is not recommended to split immediately into the full target number of regions (e.g. 50 \\* number of RSes), but a low intermediate value can be chosen. For multiple tables, it is recommended to be conservative with presplitting (e.g. pre-split 1 region per RS at most), especially if you don't know how much each table will grow. If you split too much, you may end up with too many regions, with some tables having too many small regions.\n\nFor pre-splitting howto, see [manual region splitting decisions](/docs/architecture/regions#manual-region-splitting) and [precreate.regions](/docs/performance#table-creation-pre-creating-regions).\n\n## RegionServer Grouping\n\nRegionServer Grouping (A.K.A `rsgroup`) is an advanced feature for partitioning regionservers into distinctive groups for strict isolation. It should only be used by users who are sophisticated enough to understand the full implications and have a sufficient background in managing HBase clusters. It was developed by Yahoo! and they run it at scale on their large grid cluster. See [HBase at Yahoo! Scale](http://www.slideshare.net/HBaseCon/keynote-apache-hbase-at-yahoo-scale).\n\nRSGroups can be defined and managed with both admin methods and shell commands. A server can be added to a group with hostname and port pair and tables can be moved to this group so that only regionservers in the same rsgroup can host the regions of the table. The group for a table is stored in its TableDescriptor, the property name is `hbase.rsgroup.name`. You can also set this property on a namespace, so it will cause all the tables under this namespace to be placed into this group. RegionServers and tables can only belong to one rsgroup at a time. By default, all tables and regionservers belong to the `default` rsgroup. System tables can also be put into a rsgroup using the regular APIs. A custom balancer implementation tracks assignments per rsgroup and makes sure to move regions to the relevant regionservers in that rsgroup. The rsgroup information is stored in a regular HBase table, and a zookeeper-based read-only cache is used at cluster bootstrap time.\n\nTo enable, add the following to your hbase-site.xml and restart your Master:\n\n```xml\n<property>\n  <name>hbase.balancer.rsgroup.enabled</name>\n  <value>true</value>\n</property>\n```\n\nThen use the admin/shell *rsgroup* methods/commands to create and manipulate RegionServer groups: e.g. to add a rsgroup and then add a server to it. To see the list of rsgroup commands available in the hbase shell type:\n\n```bash\n hbase(main):008:0> help 'rsgroup'\n Took 0.5610 seconds\n```\n\nHigh level, you create a rsgroup that is other than the `default` group using *add\\_rsgroup* command. You then add servers and tables to this group with the *move\\_servers\\_rsgroup* and *move\\_tables\\_rsgroup* commands. If necessary, run a balance for the group if tables are slow to migrate to the groups dedicated server with the *balance\\_rsgroup* command (Usually this is not needed). To monitor effect of the commands, see the `Tables` tab toward the end of the Master UI home page. If you click on a table, you can see what servers it is deployed across. You should see here a reflection of the grouping done with your shell commands. View the master log if issues.\n\nHere is example using a few of the rsgroup commands. To add a group, do as follows:\n\n```bash\n hbase(main):008:0> add_rsgroup 'my_group'\n Took 0.5610 seconds\n```\n\n<Callout type=\"info\" title=\"RegionServer Groups must be Enabled\">\n  If you have not enabled the rsgroup feature and you call any of the rsgroup admin methods or shell\n  commands the call will fail with a `DoNotRetryIOException` with a detail message that says the\n  rsgroup feature is disabled.\n</Callout>\n\nAdd a server (specified by hostname + port) to the just-made group using the *move\\_servers\\_rsgroup* command as follows:\n\n```bash\n hbase(main):010:0> move_servers_rsgroup 'my_group',['k.att.net:51129']\n```\n\n<Callout type=\"info\" title=\"Hostname and Port vs ServerName\">\n  The rsgroup feature refers to servers in a cluster with hostname and port only. It does not make\n  use of the HBase ServerName type identifying RegionServers; i.e. hostname + port + starttime to\n  distinguish RegionServer instances. The rsgroup feature keeps working across RegionServer restarts\n  so the starttime of ServerName — and hence the ServerName type — is not appropriate.\n  Administration\n</Callout>\n\nServers come and go over the lifetime of a Cluster. Currently, you must manually align the servers referenced in rsgroups with the actual state of nodes in the running cluster. What we mean by this is that if you decommission a server, then you must update rsgroups as part of your server decommission process removing references. Notice that, by calling `clearDeadServers` manually will also remove the dead servers from any rsgroups, but the problem is that we will lost track of the dead servers after master restarts, which means you still need to update the rsgroup by your own.\n\nPlease use `Admin.removeServersFromRSGroup` or shell command *remove\\_servers\\_rsgroup* to remove decommission servers from rsgroup.\n\nThe `default` group is not like other rsgroups in that it is dynamic. Its server list mirrors the current state of the cluster; i.e. if you shutdown a server that was part of the `default` rsgroup, and then do a *get\\_rsgroup* `default` to list its content in the shell, the server will no longer be listed. For non-default groups, though a mode may be offline, it will persist in the non-default group's list of servers. But if you move the offline server from the non-default rsgroup to default, it will not show in the `default` list. It will just be dropped.\n\n### Best Practice\n\nThe authors of the rsgroup feature, the Yahoo! HBase Engineering team, have been running it on their grid for a good while now and have come up with a few best practices informed by their experience.\n\n#### Isolate System Tables\n\nEither have a system rsgroup where all the system tables are or just leave the system tables in `default` rsgroup and have all user-space tables are in non-default rsgroups.\n\n#### Dead Nodes\n\nYahoo! Have found it useful at their scale to keep a special rsgroup of dead or questionable nodes; this is one means of keeping them out of the running until repair.\n\nBe careful replacing dead nodes in an rsgroup. Ensure there are enough live nodes before you start moving out the dead. Move in good live nodes first if you have to.\n\n### Troubleshooting\n\nViewing the Master log will give you insight on rsgroup operation.\n\nIf it appears stuck, restart the Master process.\n\n### Remove RegionServer Grouping\n\nSimply disable RegionServer Grouping feature is easy, just remove the 'hbase.balancer.rsgroup.enabled' from hbase-site.xml or explicitly set it to false in hbase-site.xml.\n\n```xml\n<property>\n  <name>hbase.balancer.rsgroup.enabled</name>\n  <value>false</value>\n</property>\n```\n\nBut if you change the 'hbase.balancer.rsgroup.enabled' to true, the old rsgroup configs will take effect again. So if you want to completely remove the RegionServer Grouping feature from a cluster, so that if the feature is re-enabled in the future, the old meta data will not affect the functioning of the cluster, there are more steps to do.\n\n* Move all tables in non-default rsgroups to `default` regionserver group\n\n  ```text\n  #Reassigning table t1 from non default group - hbase shell\n  hbase(main):005:0> move_tables_rsgroup 'default',['t1']\n  ```\n\n* Move all regionservers in non-default rsgroups to `default` regionserver group\n\n  ```text\n  #Reassigning all the servers in the non-default rsgroup to default - hbase shell\n  hbase(main):008:0> move_servers_rsgroup 'default',['rs1.xxx.com:16206','rs2.xxx.com:16202','rs3.xxx.com:16204']\n  ```\n\n* Remove all non-default rsgroups. `default` rsgroup created implicitly doesn't have to be removed\n\n  ```text\n  #removing non default rsgroup - hbase shell\n  hbase(main):009:0> remove_rsgroup 'group2'\n  ```\n\n* Remove the changes made in `hbase-site.xml` and restart the cluster\n\n* Drop the table `hbase:rsgroup` from `hbase`\n\n  ```text\n  #Through hbase shell drop table hbase:rsgroup\n  hbase(main):001:0> disable 'hbase:rsgroup'\n  0 row(s) in 2.6270 seconds\n\n  hbase(main):002:0> drop 'hbase:rsgroup'\n  0 row(s) in 1.2730 seconds\n  ```\n\n* Remove znode `rsgroup` from the cluster ZooKeeper using zkCli.sh\n\n  ```text\n  #From ZK remove the node /hbase/rsgroup through zkCli.sh\n  rmr /hbase/rsgroup\n  ```\n\n### ACL\n\nTo enable ACL, add the following to your hbase-site.xml and restart your Master:\n\n```xml\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n<property>\n```\n\n### Migrating From Old Implementation\n\nThe coprocessor `org.apache.hadoop.hbase.rsgroup.RSGroupAdminEndpoint` is deprected, but for compatible, if you want the pre 3.0.0 hbase client/shell to communicate with the new hbase cluster, you still need to add this coprocessor to master.\n\nThe `hbase.rsgroup.grouploadbalancer.class` config has been deprecated, as now the top level load balancer will always be `RSGroupBasedLoadBalaner`, and the `hbase.master.loadbalancer.class` config is for configuring the balancer within a group. This also means you should not set `hbase.master.loadbalancer.class` to `RSGroupBasedLoadBalaner` any more even if rsgroup feature is enabled.\n\nAnd we have done some special changes for compatibility. First, if coprocessor `org.apache.hadoop.hbase.rsgroup.RSGroupAdminEndpoint` is specified, the `hbase.balancer.rsgroup.enabled` flag will be set to true automatically to enable rs group feature. Second, we will load `hbase.rsgroup.grouploadbalancer.class` prior to `hbase.master.loadbalancer.class`. And last, if you do not set `hbase.rsgroup.grouploadbalancer.class` but only set `hbase.master.loadbalancer.class` to `RSGroupBasedLoadBalancer`, we will load the default load balancer to avoid infinite nesting. This means you do not need to change anything when upgrading if you have already enabled rs group feature.\n\nThe main difference comparing to the old implementation is that, now the rsgroup for a table is stored in `TableDescriptor`, instead of in `RSGroupInfo`, so the `getTables` method of `RSGroupInfo` has been deprecated. And if you use the `Admin` methods to get the `RSGroupInfo`, its `getTables` method will always return empty. This is because that in the old implementation, this method is a bit broken as you can set rsgroup on namespace and make all the tables under this namespace into this group but you can not get these tables through `RSGroupInfo.getTables`. Now you should use the two new methods `listTablesInRSGroup` and `getConfiguredNamespacesAndTablesInRSGroup` in `Admin` to get tables and namespaces in a rsgroup.\n\nOf course the behavior for the old RSGroupAdminEndpoint is not changed, we will fill the tables field of the RSGroupInfo before returning, to make it compatible with old hbase client/shell.\n\nWhen upgrading, the migration between the RSGroupInfo and TableDescriptor will be done automatically. It will take sometime, but it is fine to restart master in the middle, the migration will continue after restart. And during the migration, the rs group feature will still work and in most cases the region will not be misplaced(since this is only a one time job and will not last too long so we have not test it very seriously to make sure the region will not be misplaced always, so we use the word 'in most cases'). The implementation is a bit tricky, you can see the code in `RSGroupInfoManagerImpl.migrate` if interested.\n\n## Region Normalizer\n\nThe Region Normalizer tries to make Regions all in a table about the same in size. It does this by first calculating total table size and average size per region. It splits any region that is larger than twice this size. Any region that is much smaller is merged into an adjacent region. The Normalizer runs on a regular schedule, which is configurable. It can also be disabled entirely via a runtime \"switch\". It can be run manually via the shell or Admin API call. Even if normally disabled, it is good to run manually after the cluster has been running a while or say after a burst of activity such as a large delete.\n\nThe Normalizer works well for bringing a table's region boundaries into alignment with the reality of data distribution after an initial effort at pre-splitting a table. It is also a nice compliment to the data TTL feature when the schema includes timestamp in the rowkey, as it will automatically merge away regions whose contents have expired.\n\n(The bulk of the below detail was copied wholesale from the blog by Romil Choksi at [HBase Region Normalizer](https://community.cloudera.com/t5/Community-Articles/HBase-Region-Normalizer/ta-p/247266)).\n\nThe Region Normalizer is feature available since HBase-1.2. It runs a set of pre-calculated merge/split actions to resize regions that are either too large or too small compared to the average region size for a given table. Region Normalizer when invoked computes a normalization 'plan' for all of the tables in HBase. System tables (such as hbase:meta, hbase:namespace, Phoenix system tables etc) and user tables with normalization disabled are ignored while computing the plan. For normalization enabled tables, normalization plan is carried out in parallel across multiple tables.\n\nNormalizer can be enabled or disabled globally for the entire cluster using the ‘normalizer\\_switch' command in the HBase shell. Normalization can also be controlled on a per table basis, which is disabled by default when a table is created. Normalization for a table can be enabled or disabled by setting the NORMALIZATION\\_ENABLED table attribute to true or false.\n\nTo check normalizer status and enable/disable normalizer\n\n```bash\nhbase(main):001:0> normalizer_enabled\ntrue\n0 row(s) in 0.4870 seconds\n\nhbase(main):002:0> normalizer_switch false\ntrue\n0 row(s) in 0.0640 seconds\n\nhbase(main):003:0> normalizer_enabled\nfalse\n0 row(s) in 0.0120 seconds\n\nhbase(main):004:0> normalizer_switch true\nfalse\n0 row(s) in 0.0200 seconds\n\nhbase(main):005:0> normalizer_enabled\ntrue\n0 row(s) in 0.0090 seconds\n```\n\nWhen enabled, Normalizer is invoked in the background every 5 mins (by default), which can be configured using `hbase.normalization.period` in `hbase-site.xml`. Normalizer can also be invoked manually/programmatically at will using HBase shell's `normalize` command. HBase by default uses `SimpleRegionNormalizer`, but users can design their own normalizer as long as they implement the RegionNormalizer Interface. Details about the logic used by `SimpleRegionNormalizer` to compute its normalization plan can be found [here](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.html).\n\nThe below example shows a normalization plan being computed for an user table, and merge action being taken as a result of the normalization plan computed by SimpleRegionNormalizer.\n\nConsider an user table with some pre-split regions having 3 equally large regions (about 100K rows) and 1 relatively small region (about 25K rows). Following is the snippet from an hbase meta table scan showing each of the pre-split regions for the user table.\n\n```\ntable_p8ddpd6q5z,,1469494305548.68b9892220865cb6048 column=info:regioninfo, timestamp=1469494306375, value={ENCODED => 68b9892220865cb604809c950d1adf48, NAME => 'table_p8ddpd6q5z,,1469494305548.68b989222 09c950d1adf48.   0865cb604809c950d1adf48.', STARTKEY => '', ENDKEY => '1'}\n....\ntable_p8ddpd6q5z,1,1469494317178.867b77333bdc75a028 column=info:regioninfo, timestamp=1469494317848, value={ENCODED => 867b77333bdc75a028bb4c5e4b235f48, NAME => 'table_p8ddpd6q5z,1,1469494317178.867b7733 bb4c5e4b235f48.  3bdc75a028bb4c5e4b235f48.', STARTKEY => '1', ENDKEY => '3'}\n....\ntable_p8ddpd6q5z,3,1469494328323.98f019a753425e7977 column=info:regioninfo, timestamp=1469494328486, value={ENCODED => 98f019a753425e7977ab8636e32deeeb, NAME => 'table_p8ddpd6q5z,3,1469494328323.98f019a7 ab8636e32deeeb.  53425e7977ab8636e32deeeb.', STARTKEY => '3', ENDKEY => '7'}\n....\ntable_p8ddpd6q5z,7,1469494339662.94c64e748979ecbb16 column=info:regioninfo, timestamp=1469494339859, value={ENCODED => 94c64e748979ecbb166f6cc6550e25c6, NAME => 'table_p8ddpd6q5z,7,1469494339662.94c64e74 6f6cc6550e25c6.   8979ecbb166f6cc6550e25c6.', STARTKEY => '7', ENDKEY => '8'}\n....\ntable_p8ddpd6q5z,8,1469494339662.6d2b3f5fd1595ab8e7 column=info:regioninfo, timestamp=1469494339859, value={ENCODED => 6d2b3f5fd1595ab8e7c031876057b1ee, NAME => 'table_p8ddpd6q5z,8,1469494339662.6d2b3f5f c031876057b1ee.   d1595ab8e7c031876057b1ee.', STARTKEY => '8', ENDKEY => ''}\n```\n\nInvoking the normalizer using 'normalize' int the HBase shell, the below log snippet from HMaster log shows the normalization plan computed as per the logic defined for SimpleRegionNormalizer. Since the total region size (in MB) for the adjacent smallest regions in the table is less than the average region size, the normalizer computes a plan to merge these two regions.\n\n```\n2016-07-26 07:08:26,928 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] master.HMaster: Skipping normalization for table: hbase:namespace, as it's either system table or doesn't have auto\nnormalization turned on\n2016-07-26 07:08:26,928 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] master.HMaster: Skipping normalization for table: hbase:backup, as it's either system table or doesn't have auto normalization turned on\n2016-07-26 07:08:26,928 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] master.HMaster: Skipping normalization for table: hbase:meta, as it's either system table or doesn't have auto normalization turned on\n2016-07-26 07:08:26,928 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] master.HMaster: Skipping normalization for table: table_h2osxu3wat, as it's either system table or doesn't have autonormalization turned on\n2016-07-26 07:08:26,928 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] normalizer.SimpleRegionNormalizer: Computing normalization plan for table: table_p8ddpd6q5z, number of regions: 5\n2016-07-26 07:08:26,929 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] normalizer.SimpleRegionNormalizer: Table table_p8ddpd6q5z, total aggregated regions size: 12\n2016-07-26 07:08:26,929 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] normalizer.SimpleRegionNormalizer: Table table_p8ddpd6q5z, average region size: 2.4\n2016-07-26 07:08:26,929 INFO  [B.fifo.QRpcServer.handler=20,queue=2,port=20000] normalizer.SimpleRegionNormalizer: Table table_p8ddpd6q5z, small region size: 0 plus its neighbor size: 0, less thanthe avg size 2.4, merging them\n2016-07-26 07:08:26,971 INFO  [B.fifo.QRpcServer.handler=20,queue=2,port=20000] normalizer.MergeNormalizationPlan: Executing merging normalization plan: MergeNormalizationPlan{firstRegion={ENCODED=> d51df2c58e9b525206b1325fd925a971, NAME => 'table_p8ddpd6q5z,,1469514755237.d51df2c58e9b525206b1325fd925a971.', STARTKEY => '', ENDKEY => '1'}, secondRegion={ENCODED => e69c6b25c7b9562d078d9ad3994f5330, NAME => 'table_p8ddpd6q5z,1,1469514767669.e69c6b25c7b9562d078d9ad3994f5330.',\nSTARTKEY => '1', ENDKEY => '3'}}\n```\n\nRegion normalizer as per it's computed plan, merged the region with start key as ‘' and end key as ‘1', with another region having start key as ‘1' and end key as ‘3'. Now, that these regions have been merged we see a single new region with start key as ‘' and end key as ‘3'\n\n```text\ntable_p8ddpd6q5z,,1469516907210.e06c9b83c4a252b130e column=info:mergeA, timestamp=1469516907431,\nvalue=PBUF\\x08\\xA5\\xD9\\x9E\\xAF\\xE2*\\x12\\x1B\\x0A\\x07default\\x12\\x10table_p8ddpd6q5z\\x1A\\x00\"\\x011(\\x000\\x00 ea74d246741ba.   8\\x00\ntable_p8ddpd6q5z,,1469516907210.e06c9b83c4a252b130e column=info:mergeB, timestamp=1469516907431,\nvalue=PBUF\\x08\\xB5\\xBA\\x9F\\xAF\\xE2*\\x12\\x1B\\x0A\\x07default\\x12\\x10table_p8ddpd6q5z\\x1A\\x011\"\\x013(\\x000\\x0 ea74d246741ba.   08\\x00\ntable_p8ddpd6q5z,,1469516907210.e06c9b83c4a252b130e column=info:regioninfo, timestamp=1469516907431, value={ENCODED => e06c9b83c4a252b130eea74d246741ba, NAME => 'table_p8ddpd6q5z,,1469516907210.e06c9b83c ea74d246741ba.   4a252b130eea74d246741ba.', STARTKEY => '', ENDKEY => '3'}\n....\ntable_p8ddpd6q5z,3,1469514778736.bf024670a847c0adff column=info:regioninfo, timestamp=1469514779417, value={ENCODED => bf024670a847c0adffb74b2e13408b32, NAME => 'table_p8ddpd6q5z,3,1469514778736.bf024670 b74b2e13408b32.  a847c0adffb74b2e13408b32.' STARTKEY => '3', ENDKEY => '7'}\n....\ntable_p8ddpd6q5z,7,1469514790152.7c5a67bc755e649db2 column=info:regioninfo, timestamp=1469514790312, value={ENCODED => 7c5a67bc755e649db22f49af6270f1e1, NAME => 'table_p8ddpd6q5z,7,1469514790152.7c5a67bc 2f49af6270f1e1.  755e649db22f49af6270f1e1.', STARTKEY => '7', ENDKEY => '8'}\n....\ntable_p8ddpd6q5z,8,1469514790152.58e7503cda69f98f47 column=info:regioninfo, timestamp=1469514790312, value={ENCODED => 58e7503cda69f98f4755178e74288c3a, NAME => 'table_p8ddpd6q5z,8,1469514790152.58e7503c 55178e74288c3a.  da69f98f4755178e74288c3a.', STARTKEY => '8', ENDKEY => ''}\n```\n\nA similar example can be seen for an user table with 3 smaller regions and 1 relatively large region. For this example, we have an user table with 1 large region containing 100K rows, and 3 relatively smaller regions with about 33K rows each. As seen from the normalization plan, since the larger region is more than twice the average region size it ends being split into two regions – one with start key as ‘1' and end key as ‘154717' and the other region with start key as '154717' and end key as ‘3'\n\n```text\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] master.HMaster: Skipping normalization for table: hbase:backup, as it's either system table or doesn't have auto normalization turned on\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Computing normalization plan for table: table_p8ddpd6q5z, number of regions: 4\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Table table_p8ddpd6q5z, total aggregated regions size: 12\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Table table_p8ddpd6q5z, average region size: 3.0\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: No normalization needed, regions look good for table: table_p8ddpd6q5z\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Computing normalization plan for table: table_h2osxu3wat, number of regions: 5\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Table table_h2osxu3wat, total aggregated regions size: 7\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Table table_h2osxu3wat, average region size: 1.4\n2016-07-26 07:39:45,636 INFO  [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Table table_h2osxu3wat, large region table_h2osxu3wat,1,1469515926544.27f2fdbb2b6612ea163eb6b40753c3db. has size 4, more than twice avg size, splitting\n2016-07-26 07:39:45,640 INFO [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SplitNormalizationPlan: Executing splitting normalization plan: SplitNormalizationPlan{regionInfo={ENCODED => 27f2fdbb2b6612ea163eb6b40753c3db, NAME => 'table_h2osxu3wat,1,1469515926544.27f2fdbb2b6612ea163eb6b40753c3db.', STARTKEY => '1', ENDKEY => '3'}, splitPoint=null}\n2016-07-26 07:39:45,656 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] master.HMaster: Skipping normalization for table: hbase:namespace, as it's either system table or doesn't have auto normalization turned on\n2016-07-26 07:39:45,656 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] master.HMaster: Skipping normalization for table: hbase:meta, as it's either system table or doesn't\nhave auto normalization turned on ..............\n2016-07-26 07:39:46,246 DEBUG [AM.ZK.Worker-pool2-t278] master.RegionStates: Onlined 54de97dae764b864504704c1c8d3674a on hbase-test-rc-5.openstacklocal,16020,1469419333913 {ENCODED => 54de97dae764b864504704c1c8d3674a, NAME => 'table_h2osxu3wat,1,1469518785661.54de97dae764b864504704c1c8d3674a.', STARTKEY => '1', ENDKEY => '154717'}\n2016-07-26 07:39:46,246 INFO  [AM.ZK.Worker-pool2-t278] master.RegionStates: Transition {d6b5625df331cfec84dce4f1122c567f state=SPLITTING_NEW, ts=1469518786246, server=hbase-test-rc-5.openstacklocal,16020,1469419333913} to {d6b5625df331cfec84dce4f1122c567f state=OPEN, ts=1469518786246,\nserver=hbase-test-rc-5.openstacklocal,16020,1469419333913}\n2016-07-26 07:39:46,246 DEBUG [AM.ZK.Worker-pool2-t278] master.RegionStates: Onlined d6b5625df331cfec84dce4f1122c567f on hbase-test-rc-5.openstacklocal,16020,1469419333913 {ENCODED => d6b5625df331cfec84dce4f1122c567f, NAME => 'table_h2osxu3wat,154717,1469518785661.d6b5625df331cfec84dce4f1122c567f.', STARTKEY => '154717', ENDKEY => '3'}\n```\n\n## Auto Region Reopen\n\nWe can leak store reader references if a coprocessor or core function somehow opens a scanner, or wraps one, and then does not take care to call close on the scanner or the wrapped instance. Leaked store files can not be removed even after it is invalidated via compaction. A reasonable mitigation for a reader reference leak would be a fast reopen of the region on the same server. This will release all resources, like the refcount, leases, etc. The clients should gracefully ride over this like any other region in transition. By default this auto reopen of region feature would be disabled. To enabled it, please provide high ref count value for config `hbase.regions.recovery.store.file.ref.count`.\n\nPlease refer to config descriptions for `hbase.master.regions.recovery.check.interval` and `hbase.regions.recovery.store.file.ref.count`.\n\n\n# Running Multiple Workloads On a Single Cluster (/docs/operational-management/running-multiple-workloads-on-a-single-cluster)\nHBase provides the following mechanisms for managing the performance of a cluster handling multiple workloads:\n\n* [Quotas](/docs/operational-management/running-multiple-workloads-on-a-single-cluster#quotas)\n* [Request Queues](/docs/operational-management/running-multiple-workloads-on-a-single-cluster#request-queues)\n* [Multiple-Typed Queues](/docs/operational-management/running-multiple-workloads-on-a-single-cluster#multiple-typed-queues)\n\n## Quotas\n\nHBASE-11598 introduces RPC quotas, which allow you to throttle requests based on the following limits:\n\n1. [The number or size of requests(read, write, or read+write) in a given timeframe](/docs/operational-management/running-multiple-workloads-on-a-single-cluster#setting-request-quotas)\n2. [The number of tables allowed in a namespace](/docs/operational-management/running-multiple-workloads-on-a-single-cluster#setting-namespace-quotas)\n\nThese limits can be enforced for a specified user, table, or namespace.\n\n### Enabling Quotas\n\nQuotas are disabled by default. To enable the feature, set the `hbase.quota.enabled` property to `true` in *hbase-site.xml* file for all cluster nodes.\n\n### General Quota Syntax\n\n1. THROTTLE\\_TYPE can be expressed as READ, WRITE, or the default type(read + write).\n2. Timeframes can be expressed in the following units: `sec`, `min`, `hour`, `day`\n3. Request sizes can be expressed in the following units: `B` (bytes), `K` (kilobytes), `M` (megabytes), `G` (gigabytes), `T` (terabytes), `P` (petabytes)\n4. Numbers of requests are expressed as an integer followed by the string `req`\n5. Limits relating to time are expressed as req/time or size/time. For instance `10req/day` or `100P/hour`.\n6. Numbers of tables or regions are expressed as integers.\n\n### Setting Request Quotas\n\nYou can set quota rules ahead of time, or you can change the throttle at runtime. The change will propagate after the quota refresh period has expired. This expiration period defaults to 5 minutes. To change it, modify the `hbase.quota.refresh.period` property in `hbase-site.xml`. This property is expressed in milliseconds and defaults to `300000`.\n\n```ruby\n# Limit user u1 to 10 requests per second\nhbase> set_quota TYPE => THROTTLE, USER => 'u1', LIMIT => '10req/sec'\n\n# Limit user u1 to 10 read requests per second\nhbase> set_quota TYPE => THROTTLE, THROTTLE_TYPE => READ, USER => 'u1', LIMIT => '10req/sec'\n\n# Limit user u1 to 10 M per day everywhere\nhbase> set_quota TYPE => THROTTLE, USER => 'u1', LIMIT => '10M/day'\n\n# Limit user u1 to 10 M write size per sec\nhbase> set_quota TYPE => THROTTLE, THROTTLE_TYPE => WRITE, USER => 'u1', LIMIT => '10M/sec'\n\n# Limit user u1 to 5k per minute on table t2\nhbase> set_quota TYPE => THROTTLE, USER => 'u1', TABLE => 't2', LIMIT => '5K/min'\n\n# Limit user u1 to 10 read requests per sec on table t2\nhbase> set_quota TYPE => THROTTLE, THROTTLE_TYPE => READ, USER => 'u1', TABLE => 't2', LIMIT => '10req/sec'\n\n# Remove an existing limit from user u1 on namespace ns2\nhbase> set_quota TYPE => THROTTLE, USER => 'u1', NAMESPACE => 'ns2', LIMIT => NONE\n\n# Limit all users to 10 requests per hour on namespace ns1\nhbase> set_quota TYPE => THROTTLE, NAMESPACE => 'ns1', LIMIT => '10req/hour'\n\n# Limit all users to 10 T per hour on table t1\nhbase> set_quota TYPE => THROTTLE, TABLE => 't1', LIMIT => '10T/hour'\n\n# Remove all existing limits from user u1\nhbase> set_quota TYPE => THROTTLE, USER => 'u1', LIMIT => NONE\n\n# List all quotas for user u1 in namespace ns2\nhbase> list_quotas USER => 'u1, NAMESPACE => 'ns2'\n\n# List all quotas for namespace ns2\nhbase> list_quotas NAMESPACE => 'ns2'\n\n# List all quotas for table t1\nhbase> list_quotas TABLE => 't1'\n\n# list all quotas\nhbase> list_quotas\n```\n\nYou can also place a global limit and exclude a user or a table from the limit by applying the `GLOBAL_BYPASS` property.\n\n```ruby\nhbase> set_quota NAMESPACE => 'ns1', LIMIT => '100req/min'               # a per-namespace request limit\nhbase> set_quota USER => 'u1', GLOBAL_BYPASS => true                     # user u1 is not affected by the limit\n```\n\n### Enabling, Disabling, and Checking RPC Throttling\n\nHBase provides shell commands to control RPC throttling at runtime. When throttling is disabled, HBase will not apply any request throttling. This can be useful in production environments that require temporary unthrottled operation.\n\nThe following HBase shell commands are available:\n\n```ruby\n# Enable RPC throttling\nhbase> enable_rpc_throttle\n\n# Disable RPC throttling\nhbase> disable_rpc_throttle\n\n# Check whether RPC throttling is enabled\nhbase> rpc_throttle_enabled\n```\n\n`enable_rpc_throttle` and `disable_rpc_throttle` return the previous RPC throttling state as a boolean value. `rpc_throttle_enabled` returns the current state.\n\n<Callout type=\"info\">\n  If no quotas are configured, RPC throttling is not applied, and enabling or disabling throttling\n  will always return false.\n</Callout>\n\n### Setting Namespace Quotas\n\nYou can specify the maximum number of tables or regions allowed in a given namespace, either when you create the namespace or by altering an existing namespace, by setting the `hbase.namespace.quota.maxtables property` on the namespace.\n\n### Limiting Tables Per Namespace\n\n```ruby\n# Create a namespace with a max of 5 tables\nhbase> create_namespace 'ns1', {'hbase.namespace.quota.maxtables'=>'5'}\n\n# Alter an existing namespace to have a max of 8 tables\nhbase> alter_namespace 'ns2', {METHOD => 'set', 'hbase.namespace.quota.maxtables'=>'8'}\n\n# Show quota information for a namespace\nhbase> describe_namespace 'ns2'\n\n# Alter an existing namespace to remove a quota\nhbase> alter_namespace 'ns2', {METHOD => 'unset', NAME=>'hbase.namespace.quota.maxtables'}\n```\n\n### Limiting Regions Per Namespace\n\n```ruby\n# Create a namespace with a max of 10 regions\nhbase> create_namespace 'ns1', {'hbase.namespace.quota.maxregions'=>'10'}\n\n# Show quota information for a namespace\nhbase> describe_namespace 'ns1'\n\n# Alter an existing namespace to have a max of 20 tables\nhbase> alter_namespace 'ns2', {METHOD => 'set', 'hbase.namespace.quota.maxregions'=>'20'}\n\n# Alter an existing namespace to remove a quota\nhbase> alter_namespace 'ns2', {METHOD => 'unset', NAME=> 'hbase.namespace.quota.maxregions'}\n```\n\n## Request Queues\n\nIf no throttling policy is configured, when the RegionServer receives multiple requests, they are now placed into a queue waiting for a free execution slot (HBASE-6721). The simplest queue is a FIFO queue, where each request waits for all previous requests in the queue to finish before running. Fast or interactive queries can get stuck behind large requests.\n\nIf you are able to guess how long a request will take, you can reorder requests by pushing the long requests to the end of the queue and allowing short requests to preempt them. Eventually, you must still execute the large requests and prioritize the new requests behind them. The short requests will be newer, so the result is not terrible, but still suboptimal compared to a mechanism which allows large requests to be split into multiple smaller ones.\n\nHBASE-10993 introduces such a system for deprioritizing long-running scanners. There are two types of queues, `fifo` and `deadline`. To configure the type of queue used, configure the `hbase.ipc.server.callqueue.type` property in `hbase-site.xml`. There is no way to estimate how long each request may take, so de-prioritization only affects scans, and is based on the number of “next” calls a scan request has made. An assumption is made that when you are doing a full table scan, your job is not likely to be interactive, so if there are concurrent requests, you can delay long-running scans up to a limit tunable by setting the `hbase.ipc.server.queue.max.call.delay` property. The slope of the delay is calculated by a simple square root of `(numNextCall * weight)` where the weight is configurable by setting the `hbase.ipc.server.scan.vtime.weight` property.\n\n## Multiple-Typed Queues\n\nYou can also prioritize or deprioritize different kinds of requests by configuring a specified number of dedicated handlers and queues. You can segregate the scan requests in a single queue with a single handler, and all the other available queues can service short `Get` requests.\n\nYou can adjust the IPC queues and handlers based on the type of workload, using static tuning options. This approach is an interim first step that will eventually allow you to change the settings at runtime, and to dynamically adjust values based on the load.\n\n### Multiple Queues\n\nTo avoid contention and separate different kinds of requests, configure the `hbase.ipc.server.callqueue.handler.factor` property, which allows you to increase the number of queues and control how many handlers can share the same queue., allows admins to increase the number of queues and decide how many handlers share the same queue.\n\nUsing more queues reduces contention when adding a task to a queue or selecting it from a queue. You can even configure one queue per handler. The trade-off is that if some queues contain long-running tasks, a handler may need to wait to execute from that queue rather than stealing from another queue which has waiting tasks.\n\n### Read and Write Queues\n\nWith multiple queues, you can now divide read and write requests, giving more priority (more queues) to one or the other type. Use the `hbase.ipc.server.callqueue.read.ratio` property to choose to serve more reads or more writes.\n\n### Get and Scan Queues\n\nSimilar to the read/write split, you can split gets and scans by tuning the `hbase.ipc.server.callqueue.scan.ratio` property to give more priority to gets or to scans. A scan ratio of `0.1` will give more queue/handlers to the incoming gets, which means that more gets can be processed at the same time and that fewer scans can be executed at the same time. A value of `0.9` will give more queue/handlers to scans, so the number of scans executed will increase and the number of gets will decrease.\n\n## Space Quotas\n\n[HBASE-16961](https://issues.apache.org/jira/browse/HBASE-16961) introduces a new type of quotas for HBase to leverage: filesystem quotas. These \"space\" quotas limit the amount of space on the filesystem that HBase namespaces and tables can consume. If a user, malicious or ignorant, has the ability to write data into HBase, with enough time, that user can effectively crash HBase (or worse HDFS) by consuming all available space. When there is no filesystem space available, HBase crashes because it can no longer create/sync data to the write-ahead log.\n\nThis feature allows a for a limit to be set on the size of a table or namespace. When a space quota is set on a namespace, the quota's limit applies to the sum of usage of all tables in that namespace. When a table with a quota exists in a namespace with a quota, the table quota takes priority over the namespace quota. This allows for a scenario where a large limit can be placed on a collection of tables, but a single table in that collection can have a fine-grained limit set.\n\nThe existing `set_quota` and `list_quota` HBase shell commands can be used to interact with space quotas. Space quotas are quotas with a `TYPE` of `SPACE` and have `LIMIT` and `POLICY` attributes. The `LIMIT` is a string that refers to the amount of space on the filesystem that the quota subject (e.g. the table or namespace) may consume. For example, valid values of `LIMIT` are `'10G'`, `'2T'`, or `'256M'`. The `POLICY` refers to the action that HBase will take when the quota subject's usage exceeds the `LIMIT`. The following are valid `POLICY` values.\n\n* `NO_INSERTS` - No new data may be written (e.g. `Put`, `Increment`, `Append`).\n* `NO_WRITES` - Same as `NO_INSERTS` but `Deletes` are also disallowed.\n* `NO_WRITES_COMPACTIONS` - Same as `NO_WRITES` but compactions are also disallowed.\n  * This policy only prevents user-submitted compactions. System can still run compactions.\n* `DISABLE` - The table(s) are disabled, preventing all read/write access.\n\n### Setting simple space quotas\n\n```ruby\n# Sets a quota on the table 't1' with a limit of 1GB, disallowing Puts/Increments/Appends when the table exceeds 1GB\nhbase> set_quota TYPE => SPACE, TABLE => 't1', LIMIT => '1G', POLICY => NO_INSERTS\n\n# Sets a quota on the namespace 'ns1' with a limit of 50TB, disallowing Puts/Increments/Appends/Deletes\nhbase> set_quota TYPE => SPACE, NAMESPACE => 'ns1', LIMIT => '50T', POLICY => NO_WRITES\n\n# Sets a quota on the table 't3' with a limit of 2TB, disallowing any writes and compactions when the table exceeds 2TB.\nhbase> set_quota TYPE => SPACE, TABLE => 't3', LIMIT => '2T', POLICY => NO_WRITES_COMPACTIONS\n\n# Sets a quota on the table 't2' with a limit of 50GB, disabling the table when it exceeds 50GB\nhbase> set_quota TYPE => SPACE, TABLE => 't2', LIMIT => '50G', POLICY => DISABLE\n```\n\nConsider the following scenario to set up quotas on a namespace, overriding the quota on tables in that namespace\n\n### Table and Namespace space quotas\n\n```ruby\nhbase> create_namespace 'ns1'\nhbase> create 'ns1:t1'\nhbase> create 'ns1:t2'\nhbase> create 'ns1:t3'\nhbase> set_quota TYPE => SPACE, NAMESPACE => 'ns1', LIMIT => '100T', POLICY => NO_INSERTS\nhbase> set_quota TYPE => SPACE, TABLE => 'ns1:t2', LIMIT => '200G', POLICY => NO_WRITES\nhbase> set_quota TYPE => SPACE, TABLE => 'ns1:t3', LIMIT => '20T', POLICY => NO_WRITES\n```\n\nIn the above scenario, the tables in the namespace `ns1` will not be allowed to consume more than 100TB of space on the filesystem among each other. The table 'ns1:t2' is only allowed to be 200GB in size, and will disallow all writes when the usage exceeds this limit. The table 'ns1:t3' is allowed to grow to 20TB in size and also will disallow all writes then the usage exceeds this limit. Because there is no table quota on 'ns1:t1', this table can grow up to 100TB, but only if 'ns1:t2' and 'ns1:t3' have a usage of zero bytes. Practically, it's limit is 100TB less the current usage of 'ns1:t2' and 'ns1:t3'.\n\n## Disabling Automatic Space Quota Deletion\n\nBy default, if a table or namespace is deleted that has a space quota, the quota itself is also deleted. In some cases, it may be desirable for the space quota to not be automatically deleted. In these cases, the user may configure the system to not delete any space quota automatically via hbase-site.xml.\n\n```xml\n<property>\n  <name>hbase.quota.remove.on.table.delete</name>\n  <value>false</value>\n</property>\n```\n\nThe value is set to `true` by default.\n\n## HBase Snapshots with Space Quotas\n\nOne common area of unintended-filesystem-use with HBase is via HBase snapshots. Because snapshots exist outside of the management of HBase tables, it is not uncommon for administrators to suddenly realize that hundreds of gigabytes or terabytes of space is being used by HBase snapshots which were forgotten and never removed.\n\n[HBASE-17748](https://issues.apache.org/jira/browse/HBASE-17748) is the umbrella JIRA issue which expands on the original space quota functionality to also include HBase snapshots. While this is a confusing subject, the implementation attempts to present this support in as reasonable and simple of a manner as possible for administrators. This feature does not make any changes to administrator interaction with space quotas, only in the internal computation of table/namespace usage. Table and namespace usage will automatically incorporate the size taken by a snapshot per the rules defined below.\n\nAs a review, let's cover a snapshot's lifecycle: a snapshot is metadata which points to a list of HFiles on the filesystem. This is why creating a snapshot is a very cheap operation; no HBase table data is actually copied to perform a snapshot. Cloning a snapshot into a new table or restoring a table is a cheap operation for the same reason; the new table references the files which already exist on the filesystem without a copy. To include snapshots in space quotas, we need to define which table \"owns\" a file when a snapshot references the file (\"owns\" refers to encompassing the filesystem usage of that file).\n\nConsider a snapshot which was made against a table. When the snapshot refers to a file and the table no longer refers to that file, the \"originating\" table \"owns\" that file. When multiple snapshots refer to the same file and no table refers to that file, the snapshot with the lowest-sorting name (lexicographically) is chosen and the table which that snapshot was created from \"owns\" that file. HFiles are not \"double-counted\" hen a table and one or more snapshots refer to that HFile.\n\nWhen a table is \"rematerialized\" (via `clone_snapshot` or `restore_snapshot`), a similar problem of file ownership arises. In this case, while the rematerialized table references a file which a snapshot also references, the table does not \"own\" the file. The table from which the snapshot was created still \"owns\" that file. When the rematerialized table is compacted or the snapshot is deleted, the rematerialized table will uniquely refer to a new file and \"own\" the usage of that file. Similarly, when a table is duplicated via a snapshot and `restore_snapshot`, the new table will not consume any quota size until the original table stops referring to the files, either due to a compaction on the original table, a compaction on the new table, or the original table being deleted.\n\nOne new HBase shell command was added to inspect the computed sizes of each snapshot in an HBase instance.\n\n```ruby\nhbase> list_snapshot_sizes\nSNAPSHOT                                      SIZE\n t1.s1                                        1159108\n```\n\n\n# Table Rename (/docs/operational-management/table-rename)\nIn versions 0.90.x of hbase and earlier, we had a simple script that would rename the hdfs table directory and then do an edit of the hbase:meta table replacing all mentions of the old table name with the new. The script was called `./bin/rename_table.rb`. The script was deprecated and removed mostly because it was unmaintained and the operation performed by the script was brutal.\n\nAs of hbase 0.94.x, you can use the snapshot facility renaming a table. Here is how you would do it using the hbase shell:\n\n```ruby\nhbase shell> disable 'tableName'\nhbase shell> snapshot 'tableName', 'tableSnapshot'\nhbase shell> clone_snapshot 'tableSnapshot', 'newTableName'\nhbase shell> delete_snapshot 'tableSnapshot'\nhbase shell> drop 'tableName'\n```\n\nor in code it would be as follows:\n\n```java\nvoid rename(Admin admin, String oldTableName, TableName newTableName) {\n  String snapshotName = randomName();\n  admin.disableTable(oldTableName);\n  admin.snapshot(snapshotName, oldTableName);\n  admin.cloneSnapshot(snapshotName, newTableName);\n  admin.deleteSnapshot(snapshotName);\n  admin.deleteTable(oldTableName);\n}\n```\n\n\n# HBase Tools and Utilities (/docs/operational-management/tools)\nHBase provides several tools for administration, analysis, and debugging of your cluster. The entry-point to most of these tools is the *bin/hbase* command, though some tools are available in the *dev-support/* directory.\n\nTo see usage instructions for *bin/hbase* command, run it with no arguments, or with the `-h` argument. These are the usage instructions for HBase 0.98.x. Some commands, such as `version`, `pe`, `ltt`, `clean`, are not available in previous versions.\n\n```text\n$ bin/hbase\nUsage: hbase [<options>] <command> [<args>]\nOptions:\n  --config DIR     Configuration direction to use. Default: ./conf\n  --hosts HOSTS    Override the list in 'regionservers' file\n  --auth-as-server Authenticate to ZooKeeper using servers configuration\n\nCommands:\nSome commands take arguments. Pass no args or -h for usage.\n  shell           Run the HBase shell\n  hbck            Run the HBase 'fsck' tool. Defaults read-only hbck1.\n                  Pass '-j /path/to/HBCK2.jar' to run hbase-2.x HBCK2.\n  snapshot        Tool for managing snapshots\n  wal             Write-ahead-log analyzer\n  hfile           Store file analyzer\n  zkcli           Run the ZooKeeper shell\n  master          Run an HBase HMaster node\n  regionserver    Run an HBase HRegionServer node\n  zookeeper       Run a ZooKeeper server\n  rest            Run an HBase REST server\n  thrift          Run the HBase Thrift server\n  thrift2         Run the HBase Thrift2 server\n  clean           Run the HBase clean up script\n  jshell          Run a jshell with HBase on the classpath\n  classpath       Dump hbase CLASSPATH\n  mapredcp        Dump CLASSPATH entries required by mapreduce\n  pe              Run PerformanceEvaluation\n  ltt             Run LoadTestTool\n  canary          Run the Canary tool\n  version         Print the version\n  backup          Backup tables for recovery\n  restore         Restore tables from existing backup image\n  regionsplitter  Run RegionSplitter tool\n  rowcounter      Run RowCounter tool\n  cellcounter     Run CellCounter tool\n  CLASSNAME       Run the class named CLASSNAME\n\n```\n\nSome of the tools and utilities below are Java classes which are passed directly to the *bin/hbase* command, as referred to in the last line of the usage instructions. Others, such as `hbase shell` ([The Apache HBase Shell](/docs/shell)), `hbase upgrade` ([Upgrading](/docs/upgrading)), and `hbase thrift` ([Thrift API and Filter Language](/docs/thrift-filter-language)), are documented elsewhere in this guide.\n\n## Canary\n\nThe Canary tool can help users \"canary-test\" the HBase cluster status. The default \"region mode\" fetches a row from every column-family of every regions. In \"regionserver mode\", the Canary tool will fetch a row from a random region on each of the cluster's RegionServers. In \"zookeeper mode\", the Canary will read the root znode on each member of the zookeeper ensemble.\n\nTo see usage, pass the `-help` parameter (if you pass no parameters, the Canary tool starts executing in the default region \"mode\" fetching a row from every region in the cluster).\n\n```text\n2018-10-16 13:11:27,037 INFO  [main] tool.Canary: Execution thread count=16\nUsage: canary [OPTIONS] [<TABLE1> [<TABLE2]...] | [<REGIONSERVER1> [<REGIONSERVER2]..]\nWhere [OPTIONS] are:\n -h,-help        show this help and exit.\n -regionserver   set 'regionserver mode'; gets row from random region on server\n -allRegions     get from ALL regions when 'regionserver mode', not just random one.\n -zookeeper      set 'zookeeper mode'; grab zookeeper.znode.parent on each ensemble member\n -daemon         continuous check at defined intervals.\n -interval <N>   interval between checks in seconds\n -e              consider table/regionserver argument as regular expression\n -f <B>          exit on first error; default=true\n -failureAsError treat read/write failure as error\n -t <N>          timeout for canary-test run; default=600000ms\n -writeSniffing  enable write sniffing\n -writeTable     the table used for write sniffing; default=hbase:canary\n -writeTableTimeout <N>  timeout for writeTable; default=600000ms\n -readTableTimeouts <tableName>=<read timeout>,<tableName>=<read timeout>,...\n            comma-separated list of table read timeouts (no spaces);\n            logs 'ERROR' if takes longer. default=600000ms\n -permittedZookeeperFailures <N>  Ignore first N failures attempting to\n            connect to individual zookeeper nodes in ensemble\n\n -D<configProperty>=<value> to assign or override configuration params\n -Dhbase.canary.read.raw.enabled=<true/false> Set to enable/disable raw scan; default=false\n\nCanary runs in one of three modes: region (default), regionserver, or zookeeper.\nTo sniff/probe all regions, pass no arguments.\nTo sniff/probe all regions of a table, pass tablename.\nTo sniff/probe regionservers, pass -regionserver, etc.\nSee http://hbase.apache.org/book.html#_canary for Canary documentation.\n```\n\n<Callout type=\"info\">\n  The `Sink` class is instantiated using the `hbase.canary.sink.class` configuration property.\n</Callout>\n\nThis tool will return non zero error codes to user for collaborating with other monitoring tools, such as Nagios. The error code definitions are:\n\n```java\nprivate static final int USAGE_EXIT_CODE = 1;\nprivate static final int INIT_ERROR_EXIT_CODE = 2;\nprivate static final int TIMEOUT_ERROR_EXIT_CODE = 3;\nprivate static final int ERROR_EXIT_CODE = 4;\nprivate static final int FAILURE_EXIT_CODE = 5;\n```\n\nHere are some examples based on the following given case: given two Table objects called test-01 and test-02 each with two column family cf1 and cf2 respectively, deployed on 3 RegionServers. See the following table.\n\n| RegionServer | test-01 | test-02 |\n| ------------ | ------- | ------- |\n| rs1          | r1      | r2      |\n| rs2          | r2      |         |\n| rs3          | r2      | r1      |\n\nFollowing are some example outputs based on the previous given case.\n\n### Canary test for every column family (store) of every region of every table\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary\n\n3/12/09 03:26:32 INFO tool.Canary: read from region test-01,,1386230156732.0e3c7d77ffb6361ea1b996ac1042ca9a. column family cf1 in 2ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-01,,1386230156732.0e3c7d77ffb6361ea1b996ac1042ca9a. column family cf2 in 2ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-01,0004883,1386230156732.87b55e03dfeade00f441125159f8ca87. column family cf1 in 4ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-01,0004883,1386230156732.87b55e03dfeade00f441125159f8ca87. column family cf2 in 1ms\n...\n13/12/09 03:26:32 INFO tool.Canary: read from region test-02,,1386559511167.aa2951a86289281beee480f107bb36ee. column family cf1 in 5ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-02,,1386559511167.aa2951a86289281beee480f107bb36ee. column family cf2 in 3ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-02,0004883,1386559511167.cbda32d5e2e276520712d84eaaa29d84. column family cf1 in 31ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-02,0004883,1386559511167.cbda32d5e2e276520712d84eaaa29d84. column family cf2 in 8ms\n\n```\n\nSo you can see, table test-01 has two regions and two column families, so the Canary tool in the default \"region mode\" will pick 4 small piece of data from 4 (2 region \\* 2 store) different stores. This is a default behavior.\n\n### Canary test for every column family (store) of every region of a specific table(s)\n\nYou can also test one or more specific tables by passing table names.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary test-01 test-02\n\n```\n\n### Canary test with RegionServer granularity\n\nIn \"regionserver mode\", the Canary tool will pick one small piece of data from each RegionServer (You can also pass one or more RegionServer names as arguments to the canary-test when in \"regionserver mode\").\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -regionserver\n\n13/12/09 06:05:17 INFO tool.Canary: Read from table:test-01 on region server:rs2 in 72ms\n13/12/09 06:05:17 INFO tool.Canary: Read from table:test-02 on region server:rs3 in 34ms\n13/12/09 06:05:17 INFO tool.Canary: Read from table:test-01 on region server:rs1 in 56ms\n\n```\n\n### Canary test with regular expression pattern\n\nYou can pass regexes for table names when in \"region mode\" or for servernames when in \"regionserver mode\". The below will test both table test-01 and test-02.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -e test-0[1-2]\n\n```\n\n### Run canary test as a \"daemon\"\n\nRun repeatedly with an interval defined via the option `-interval` (default value is 60 seconds). This daemon will stop itself and return non-zero error code if any error occur. To have the daemon keep running across errors, pass the -f flag with its value set to false (see usage above).\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -daemon\n\n```\n\nTo run repeatedly with 5 second intervals and not stop on errors, do the following.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -daemon -interval 5 -f false\n\n```\n\n### Force timeout if canary test stuck\n\nIn some cases the request is stuck and no response is sent back to the client. This can happen with dead RegionServers which the master has not yet noticed. Because of this we provide a timeout option to kill the canary test and return a non-zero error code. The below sets the timeout value to 60 seconds (the default value is 600 seconds).\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -t 60000\n\n```\n\n### Enable write sniffing in canary\n\nBy default, the canary tool only checks read operations. To enable the write sniffing, you can run the canary with the `-writeSniffing` option set. When write sniffing is enabled, the canary tool will create an hbase table and make sure the regions of the table are distributed to all region servers. In each sniffing period, the canary will try to put data to these regions to check the write availability of each region server.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -writeSniffing\n\n```\n\nThe default write table is `hbase:canary` and can be specified with the option `-writeTable`.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -writeSniffing -writeTable ns:canary\n\n```\n\nThe default value size of each put is 10 bytes. You can set it via the config key: `hbase.canary.write.value.size`.\n\n### Treat read / write failure as error\n\nBy default, the canary tool only logs read failures — due to e.g. RetriesExhaustedException, etc. — and will return the 'normal' exit code. To treat read/write failure as errors, you can run canary with the `-treatFailureAsError` option. When enabled, read/write failures will result in an error exit code.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -treatFailureAsError\n\n```\n\n### Running Canary in a Kerberos-enabled Cluster\n\nTo run the Canary in a Kerberos-enabled cluster, configure the following two properties in *hbase-site.xml*:\n\n* `hbase.client.keytab.file`\n* `hbase.client.kerberos.principal`\n\nKerberos credentials are refreshed every 30 seconds when Canary runs in daemon mode.\n\nTo configure the DNS interface for the client, configure the following optional properties in *hbase-site.xml*.\n\n* `hbase.client.dns.interface`\n* `hbase.client.dns.nameserver`\n\n**Example Canary in a Kerberos-Enabled Cluster**\\\nThis example shows each of the properties with valid values.\n\n```xml\n<property>\n  <name>hbase.client.kerberos.principal</name>\n  <value>hbase/_HOST@YOUR-REALM.COM</value>\n</property>\n<property>\n  <name>hbase.client.keytab.file</name>\n  <value>/etc/hbase/conf/keytab.krb5</value>\n</property>\n\n<property>\n  <name>hbase.client.dns.interface</name>\n  <value>default</value>\n</property>\n<property>\n  <name>hbase.client.dns.nameserver</name>\n  <value>default</value>\n</property>\n```\n\n## RegionSplitter\n\n```text\nusage: bin/hbase regionsplitter <TABLE> <SPLITALGORITHM>\nSPLITALGORITHM is the java class name of a class implementing\n                      SplitAlgorithm, or one of the special strings\n                      HexStringSplit or DecimalStringSplit or\n                      UniformSplit, which are built-in split algorithms.\n                      HexStringSplit treats keys as hexadecimal ASCII, and\n                      DecimalStringSplit treats keys as decimal ASCII, and\n                      UniformSplit treats keys as arbitrary bytes.\n -c <region count>        Create a new table with a pre-split number of\n                          regions\n -D <property=value>      Override HBase Configuration Settings\n -f <family:family:...>   Column Families to create with new table.\n                          Required with -c\n    --firstrow <arg>      First Row in Table for Split Algorithm\n -h                       Print this usage help\n    --lastrow <arg>       Last Row in Table for Split Algorithm\n -o <count>               Max outstanding splits that have unfinished\n                          major compactions\n -r                       Perform a rolling split of an existing region\n    --risky               Skip verification steps to complete\n                          quickly. STRONGLY DISCOURAGED for production\n                          systems.\n```\n\nFor additional detail, see [Manual Region Splitting](/docs/architecture/regions#manual-region-splitting).\n\n## Health Checker\n\nYou can configure HBase to run a script periodically and if it fails N times (configurable), have the server exit. See *HBASE-7351 Periodic health check script* for configurations and detail.\n\n## Driver\n\nSeveral frequently-accessed utilities are provided as `Driver` classes, and executed by the *bin/hbase* command. These utilities represent MapReduce jobs which run on your cluster. They are run in the following way, replacing *UtilityName* with the utility you want to run. This command assumes you have set the environment variable `HBASE_HOME` to the directory where HBase is unpacked on your server.\n\n```bash\n${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.mapreduce.UtilityName\n```\n\nThe following utilities are available:\n\n`LoadIncrementalHFiles`\\\nComplete a bulk data load.\n\n`CopyTable`\\\nExport a table from the local cluster to a peer cluster.\n\n`Export`\\\nWrite table data to HDFS.\n\n`Import`\\\nImport data written by a previous `Export` operation.\n\n`ImportTsv`\\\nImport data in TSV format.\n\n`RowCounter`\\\nCount rows in an HBase table.\n\n`CellCounter`\\\nCount cells in an HBase table.\n\n`replication.VerifyReplication`\\\nCompare the data from tables in two different clusters. WARNING: It doesn't work for incrementColumnValues'd cells since the timestamp is changed. Note that this command is in a different package than the others.\n\nEach command except `RowCounter` and `CellCounter` accept a single `--help` argument to print usage instructions.\n\n## HBase `hbck`\n\nThe `hbck` tool that shipped with hbase-1.x has been made read-only in hbase-2.x. It is not able to repair hbase-2.x clusters as hbase internals have changed. Nor should its assessments in read-only mode be trusted as it does not understand hbase-2.x operation.\n\nA new tool, [HBase `HBCK2`](/docs/operational-management/tools#hbase-hbck2), described in the next section, replaces `hbck`.\n\n## HBase `HBCK2`\n\n`HBCK2` is the successor to [HBase `HBCK`](/docs/operational-management/tools#hbase-hbck), the hbase-1.x fix tool (A.K.A `hbck1`). Use it in place of `hbck1` making repairs against hbase-2.x installs.\n\n`HBCK2` does not ship as part of hbase. It can be found as a subproject of the companion [hbase-operator-tools](https://github.com/apache/hbase-operator-tools) repository at [Apache HBase HBCK2 Tool](https://github.com/apache/hbase-operator-tools/tree/master/hbase-hbck2). `HBCK2` was moved out of hbase so it could evolve at a cadence apart from that of hbase core.\n\nSee the [HBCK2](https://github.com/apache/hbase-operator-tools/tree/master/hbase-hbck2) Home Page for how `HBCK2` differs from `hbck1`, and for how to build and use it.\n\nOnce built, you can run `HBCK2` as follows:\n\n```bash\n$ hbase hbck -j /path/to/HBCK2.jar\n\n```\n\nThis will generate `HBCK2` usage describing commands and options.\n\n## HFile Tool\n\nSee [HFile Tool](/docs/architecture/regions##architecture-regions-store-hfile-tool).\n\n## WAL Tools\n\nFor bulk replaying WAL files or *recovered.edits* files, see [WALPlayer](/docs/operational-management/tools#walplayer). For reading/verifying individual files, read on.\n\n### WALPrettyPrinter\n\nThe `WALPrettyPrinter` is a tool with configurable options to print the contents of a WAL or a *recovered.edits* file. You can invoke it via the HBase cli with the 'wal' command.\n\n```bash\n $ ./bin/hbase wal hdfs://example.org:9000/hbase/WALs/example.org,60020,1283516293161/10.10.21.10%3A60020.1283973724012\n```\n\n<Callout type=\"info\" title=\"WAL Printing in older versions of HBase\">\n  Prior to version 2.0, the `WALPrettyPrinter` was called the `HLogPrettyPrinter`, after an internal name for HBase's write ahead log. In those versions, you can print the contents of a WAL using the same configuration as above, but with the 'hlog' command.\n\n  ```bash\n   $ ./bin/hbase hlog hdfs://example.org:9000/hbase/.logs/example.org,60020,1283516293161/10.10.21.10%3A60020.1283973724012\n  ```\n</Callout>\n\n## Compression Tool\n\nSee [compression.test](/docs/compression#compressiontest).\n\n## CopyTable\n\nCopyTable is a utility that can copy part or of all of a table, either to the same cluster or another cluster. The target table must first exist. The usage is as follows:\n\n```bash\n$ ./bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable --help\n/bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable --help\nUsage: CopyTable [general options] [--starttime=X] [--endtime=Y] [--new.name=NEW] [--peer.adr=ADR] <tablename>\n\nOptions:\n rs.class     hbase.regionserver.class of the peer cluster,\n              specify if different from current cluster\n rs.impl      hbase.regionserver.impl of the peer cluster,\n startrow     the start row\n stoprow      the stop row\n starttime    beginning of the time range (unixtime in millis)\n              without endtime means from starttime to forever\n endtime      end of the time range.  Ignored if no starttime specified.\n versions     number of cell versions to copy\n new.name     new table's name\n peer.uri     The URI of the peer cluster\n peer.adr     Address of the peer cluster given in the format\n              hbase.zookeeer.quorum:hbase.zookeeper.client.port:zookeeper.znode.parent\n              Do not take effect if peer.uri is specified\n              Deprecated, please use peer.uri instead\n families     comma-separated list of families to copy\n              To copy from cf1 to cf2, give sourceCfName:destCfName.\n              To keep the same name, just give \"cfName\"\n all.cells    also copy delete markers and deleted cells\n\nArgs:\n tablename    Name of the table to copy\n\nExamples:\n To copy 'TestTable' to a cluster that uses replication for a 1 hour window:\n $ bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable --starttime=1265875194289 --endtime=1265878794289 --peer.adr=server1,server2,server3:2181:/hbase --families=myOldCf:myNewCf,cf2,cf3 TestTable\n\nFor performance consider the following general options:\n  It is recommended that you set the following to >=100. A higher value uses more memory but\n  decreases the round trip time to the server and may increase performance.\n    -Dhbase.client.scanner.caching=100\n  The following should always be set to false, to prevent writing data twice, which may produce\n  inaccurate results.\n    -Dmapred.map.tasks.speculative.execution=false\n```\n\nStarting from 3.0.0, we introduce a `peer.uri` option so the `peer.adr` option is deprecated. Please use connection URI for specifying HBase clusters. For all previous versions, you should still use the `peer.adr` option.\n\n<Callout type=\"info\" title=\"Scanner Caching\">\n  Caching for the input Scan is configured via `hbase.client.scanner.caching` in the job\n  configuration.\n</Callout>\n\n<Callout type=\"info\" title=\"Versions\">\n  By default, CopyTable utility only copies the latest version of row cells unless `--versions=n` is\n  explicitly specified in the command.\n</Callout>\n\n<Callout type=\"info\" title=\"Data Load\">\n  CopyTable does not perform a diff, it copies all Cells in between the specified startrow/stoprow\n  starttime/endtime range. This means that already existing cells with same values will still be\n  copied.\n</Callout>\n\nSee Jonathan Hsieh's [Online HBase Backups with CopyTable](https://blog.cloudera.com/blog/2012/06/online-hbase-backups-with-copytable-2/) blog post for more on `CopyTable`.\n\n## HashTable/SyncTable\n\nHashTable/SyncTable is a two steps tool for synchronizing table data, where each of the steps are implemented as MapReduce jobs. Similarly to CopyTable, it can be used for partial or entire table data syncing, under same or remote cluster. However, it performs the sync in a more efficient way than CopyTable. Instead of copying all cells in specified row key/time period range, HashTable (the first step) creates hashed indexes for batch of cells on source table and output those as results. On the next stage, SyncTable scans the source table and now calculates hash indexes for table cells, compares these hashes with the outputs of HashTable, then it just scans (and compares) cells for diverging hashes, only updating mismatching cells. This results in less network traffic/data transfers, which can be impacting when syncing large tables on remote clusters.\n\n### Step 1, HashTable\n\nFirst, run HashTable on the source table cluster (this is the table whose state will be copied to its counterpart).\n\nUsage:\n\n```bash\n$ ./bin/hbase org.apache.hadoop.hbase.mapreduce.HashTable --help\nUsage: HashTable [options] <tablename> <outputpath>\n\nOptions:\n batchsize         the target amount of bytes to hash in each batch\n                   rows are added to the batch until this size is reached\n                   (defaults to 8000 bytes)\n numhashfiles      the number of hash files to create\n                   if set to fewer than number of regions then\n                   the job will create this number of reducers\n                   (defaults to 1/100 of regions — at least 1)\n startrow          the start row\n stoprow           the stop row\n starttime         beginning of the time range (unixtime in millis)\n                   without endtime means from starttime to forever\n endtime           end of the time range.  Ignored if no starttime specified.\n scanbatch         scanner batch size to support intra row scans\n versions          number of cell versions to include\n families          comma-separated list of families to include\n ignoreTimestamps  if true, ignores cell timestamps\n\nArgs:\n tablename     Name of the table to hash\n outputpath    Filesystem path to put the output data\n\nExamples:\n To hash 'TestTable' in 32kB batches for a 1 hour window into 50 files:\n $ bin/hbase org.apache.hadoop.hbase.mapreduce.HashTable --batchsize=32000 --numhashfiles=50 --starttime=1265875194289 --endtime=1265878794289 --families=cf2,cf3 TestTable /hashes/testTable\n```\n\nThe **batchsize** property defines how much cell data for a given region will be hashed together in a single hash value. Sizing this properly has a direct impact on the sync efficiency, as it may lead to less scans executed by mapper tasks of SyncTable (the next step in the process). The rule of thumb is that, the smaller the number of cells out of sync (lower probability of finding a diff), larger batch size values can be determined.\n\n### Step 2, SyncTable\n\nOnce HashTable has completed on source cluster, SyncTable can be ran on target cluster. Just like replication and other synchronization jobs, it requires that all RegionServers/DataNodes on source cluster be accessible by NodeManagers on the target cluster (where SyncTable job tasks will be running).\n\nUsage:\n\n```bash\n$ ./bin/hbase org.apache.hadoop.hbase.mapreduce.SyncTable --help\nUsage: SyncTable [options] <sourcehashdir> <sourcetable> <targettable>\n\nOptions:\n sourceuri        Cluster connection uri of the source table\n                  (defaults to cluster in classpath's config)\n sourcezkcluster  ZK cluster key of the source table\n                  (defaults to cluster in classpath's config)\n                  Do not take effect if sourceuri is specifie\n                  Deprecated, please use sourceuri instead\n targeturi        Cluster connection uri of the target table\n                  (defaults to cluster in classpath's config)\n targetzkcluster  ZK cluster key of the target table\n                  (defaults to cluster in classpath's config)\n                  Do not take effect if targeturi is specified\n                  Deprecated, please use targeturi instead\n dryrun           if true, output counters but no writes\n                  (defaults to false)\n doDeletes        if false, does not perform deletes\n                  (defaults to true)\n doPuts           if false, does not perform puts\n                  (defaults to true)\n ignoreTimestamps if true, ignores cells timestamps while comparing\n                  cell values. Any missing cell on target then gets\n                  added with current time as timestamp\n                  (defaults to false)\n\nArgs:\n sourcehashdir    path to HashTable output dir for source table\n                  (see org.apache.hadoop.hbase.mapreduce.HashTable)\n sourcetable      Name of the source table to sync from\n targettable      Name of the target table to sync to\n\nExamples:\n For a dry run SyncTable of tableA from a remote source cluster\n to a local target cluster:\n $ bin/hbase org.apache.hadoop.hbase.mapreduce.SyncTable --dryrun=true --sourcezkcluster=zk1.example.com,zk2.example.com,zk3.example.com:2181:/hbase hdfs://nn:9000/hashes/tableA tableA tableA\n```\n\nStarting from 3.0.0, we introduce `sourceuri` and `targeturi` options so `sourcezkcluster` and `targetzkcluster` are deprecated. Please use connection URI for specifying HBase clusters. For all previous versions, you should still use `sourcezkcluster` and `targetzkcluster`.\n\nCell comparison takes ROW/FAMILY/QUALIFIER/TIMESTAMP/VALUE into account for equality. When syncing at the target, missing cells will be added with original timestamp value from source. That may cause unexpected results after SyncTable completes, for example, if missing cells on target have a delete marker with a timestamp T2 (say, a bulk delete performed by mistake), but source cells timestamps have an older value T1, then those cells would still be unavailable at target because of the newer delete marker timestamp. Since cell timestamps might not be relevant to all use cases, *ignoreTimestamps* option adds the flexibility to avoid using cells timestamp in the comparison. When using *ignoreTimestamps* set to true, this option must be specified for both HashTable and SyncTable steps.\n\nThe **dryrun** option is useful when a read only, diff report is wanted, as it will produce only COUNTERS indicating the differences, but will not perform any actual changes. It can be used as an alternative to VerifyReplication tool.\n\nBy default, SyncTable will cause target table to become an exact copy of source table (at least, for the specified startrow/stoprow or/and starttime/endtime).\n\nSetting doDeletes to false modifies default behaviour to not delete target cells that are missing on source. Similarly, setting doPuts to false modifies default behaviour to not add missing cells on target. Setting both doDeletes and doPuts to false would give same effect as setting dryrun to true.\n\n<Callout type=\"info\" title=\"Additional info on doDeletes/doPuts\">\n  \"doDeletes/doPuts\" were only added by\n  [HBASE-20305](https://issues.apache.org/jira/browse/HBASE-20305), so these may not be available on\n  all released versions. For major 1.x versions, minimum minor release including it is **1.4.10**.\n  For major 2.x versions, minimum minor release including it is **2.1.5**.\n</Callout>\n\n<Callout type=\"info\" title=\"Additional info on ignoreTimestamps\">\n  \"ignoreTimestamps\" was only added by\n  [HBASE-24302](https://issues.apache.org/jira/browse/HBASE-24302), so it may not be available on\n  all released versions. For major 1.x versions, minimum minor release including it is **1.4.14**.\n  For major 2.x versions, minimum minor release including it is **2.2.5**.\n</Callout>\n\n<Callout type=\"info\" title=\"Set doDeletes to false on Two-Way Replication scenarios\">\n  On Two-Way Replication or other scenarios where both source and target clusters can have data\n  ingested, it's advisable to always set doDeletes option to false, as any additional cell inserted\n  on SyncTable target cluster and not yet replicated to source would be deleted, and potentially\n  lost permanently.\n</Callout>\n\n<Callout type=\"info\" title=\"Set sourcezkcluster to the actual source cluster ZK quorum\">\n  Although not required, if sourcezkcluster is not set, SyncTable will connect to local HBase\n  cluster for both source and target, which does not give any meaningful result.\n</Callout>\n\n<Callout type=\"info\" title=\"Remote Clusters on different Kerberos Realms\">\n  Often, remote clusters may be deployed on different Kerberos Realms.\n  [HBASE-20586](https://issues.apache.org/jira/browse/HBASE-20586) added SyncTable support for cross\n  realm authentication, allowing a SyncTable process running on target cluster to connect to source\n  cluster and read both HashTable output files and the given HBase table when performing the\n  required comparisons.\n</Callout>\n\n## Export\n\nExport is a utility that will dump the contents of table to HDFS in a sequence file. The Export can be run via a Coprocessor Endpoint or MapReduce. Invoke via:\n\n**mapreduce-based Export**\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.mapreduce.Export TABLENAME OUTPUTDIR [VERSIONS [STARTTIME [ENDTIME]]]\n```\n\n**endpoint-based Export**\n\n<Callout type=\"info\">\n  Make sure the Export coprocessor is enabled by adding `org.apache.hadoop.hbase.coprocessor.Export`\n  to `hbase.coprocessor.region.classes`.\n</Callout>\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.coprocessor.Export TABLENAME OUTPUTDIR [VERSIONS [STARTTIME [ENDTIME]]]\n```\n\nThe outputdir is a HDFS directory that does not exist prior to the export. When done, the exported files will be owned by the user invoking the export command.\n\n**The Comparison of Endpoint-based Export And Mapreduce-based Export**\n\n|                           | Endpoint-based Export                                           | Mapreduce-based Export                                           |\n| ------------------------- | --------------------------------------------------------------- | ---------------------------------------------------------------- |\n| HBase version requirement | 2.0+                                                            | 0.2.1+                                                           |\n| Maven dependency          | hbase-endpoint                                                  | hbase-mapreduce (2.0+), hbase-server(prior to 2.0)               |\n| Requirement before dump   | mount the endpoint.Export on the target table                   | deploy the MapReduce framework                                   |\n| Read latency              | low, directly read the data from region                         | normal, traditional RPC scan                                     |\n| Read Scalability          | depend on number of regions                                     | depend on number of mappers (see TableInputFormatBase#getSplits) |\n| Timeout                   | operation timeout. configured by hbase.client.operation.timeout | scan timeout. configured by hbase.client.scanner.timeout.period  |\n| Permission requirement    | READ, EXECUTE                                                   | READ                                                             |\n| Fault tolerance           | no                                                              | depend on MapReduce                                              |\n\n<Callout type=\"info\">\n  To see usage instructions, run the command with no options. Available options include specifying\n  column families and applying filters during the export.\n</Callout>\n\nBy default, the `Export` tool only exports the newest version of a given cell, regardless of the number of versions stored. To export more than one version, replace ***\\<versions>*** with the desired number of versions.\n\nFor mapreduce based Export, if you want to export cell tags then set the following config property `hbase.client.rpc.codec` to `org.apache.hadoop.hbase.codec.KeyValueCodecWithTags`\n\nNote: caching for the input Scan is configured via `hbase.client.scanner.caching` in the job configuration.\n\n## Import\n\nImport is a utility that will load data that has been exported back into HBase. Invoke via:\n\n```bash\n$ bin/hbase -Dhbase.import.version=0.94 org.apache.hadoop.hbase.mapreduce.Import <tablename> <inputdir>\n```\n\n<Callout type=\"info\">\n  To see usage instructions, run the command with no options.\n</Callout>\n\nTo import 0.94 exported files in a 0.96 cluster or onwards, you need to set system property \"hbase.import.version\" when running the import command as below:\n\n```bash\n$ bin/hbase -Dhbase.import.version=0.94 org.apache.hadoop.hbase.mapreduce.Import TABLENAME INPUTDIR\n```\n\nIf you want to import cell tags then set the following config property `hbase.client.rpc.codec` to `org.apache.hadoop.hbase.codec.KeyValueCodecWithTags`\n\n## ImportTsv\n\nImportTsv is a utility that will load data in TSV format into HBase. It has two distinct usages: loading data from TSV format in HDFS into HBase via Puts, and preparing StoreFiles to be loaded via the `completebulkload`.\n\nTo load data via Puts (i.e., non-bulk loading):\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=a,b,c <tablename> <hdfs-inputdir>\n```\n\nTo generate StoreFiles for bulk-loading:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=a,b,c -Dimporttsv.bulk.output=hdfs://storefile-outputdir <tablename> <hdfs-data-inputdir>\n```\n\nThese generated StoreFiles can be loaded into HBase via [completebulkload](/docs/operational-management/tools#completebulkload).\n\n### ImportTsv Options\n\nRunning `ImportTsv` with no arguments prints brief usage information:\n\n```text\nUsage: importtsv -Dimporttsv.columns=a,b,c TABLENAME INPUTDIR\n\nImports the given input directory of TSV data into the specified table.\n\nThe column names of the TSV data must be specified using the -Dimporttsv.columns\noption. This option takes the form of comma-separated column names, where each\ncolumn name is either a simple column family, or a columnfamily:qualifier. The special\ncolumn name HBASE_ROW_KEY is used to designate that this column should be used\nas the row key for each imported record. You must specify exactly one column\nto be the row key, and you must specify a column name for every column that exists in the\ninput data.\n\nBy default importtsv will load data directly into HBase. To instead generate\nHFiles of data to prepare for a bulk data load, pass the option:\n  -Dimporttsv.bulk.output=/path/for/output\n  Note: the target table will be created with default column family descriptors if it does not already exist.\n\nOther options that may be specified with -D include:\n  -Dimporttsv.skip.bad.lines=false - fail if encountering an invalid line\n  '-Dimporttsv.separator=|' - eg separate on pipes instead of tabs\n  -Dimporttsv.timestamp=currentTimeAsLong - use the specified timestamp for the import\n  -Dimporttsv.mapper.class=my.Mapper - A user-defined Mapper to use instead of org.apache.hadoop.hbase.mapreduce.TsvImporterMapper\n\n```\n\n### ImportTsv Example\n\nFor example, assume that we are loading data into a table called 'datatsv' with a ColumnFamily called 'd' with two columns \"c1\" and \"c2\".\n\nAssume that an input file exists as follows:\n\n```text\nrow1    c1  c2\nrow2    c1  c2\nrow3    c1  c2\nrow4    c1  c2\nrow5    c1  c2\nrow6    c1  c2\nrow7    c1  c2\nrow8    c1  c2\nrow9    c1  c2\nrow10   c1  c2\n\n```\n\nFor ImportTsv to use this input file, the command line needs to look like this:\n\n```bash\n HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-mapreduce-VERSION.jar importtsv -Dimporttsv.columns=HBASE_ROW_KEY,d:c1,d:c2 -Dimporttsv.bulk.output=hdfs://storefileoutput datatsv hdfs://inputfile\n\n```\n\n... and in this example the first column is the rowkey, which is why the HBASE\\_ROW\\_KEY is used. The second and third columns in the file will be imported as \"d:c1\" and \"d:c2\", respectively.\n\n### ImportTsv Warning\n\nIf you have preparing a lot of data for bulk loading, make sure the target HBase table is pre-split appropriately.\n\n### See Also\n\nFor more information about bulk-loading HFiles into HBase, see [arch.bulk.load](/docs/architecture/bulk-loading)\n\n## CompleteBulkLoad\n\nThe `completebulkload` utility will move generated StoreFiles into an HBase table. This utility is often used in conjunction with output from [importtsv](/docs/operational-management/tools#importtsv).\n\nThere are two ways to invoke this utility, with explicit classname and via the driver:\n\n**Explicit Classname**\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.tool.LoadIncrementalHFiles hdfs://storefileoutput TABLENAME\n\n```\n\n**Driver**\n\n```bash\nHADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-mapreduce-VERSION.jar completebulkload hdfs://storefileoutput TABLENAME\n\n```\n\n### CompleteBulkLoad Warning\n\nData generated via MapReduce is often created with file permissions that are not compatible with the running HBase process. Assuming you're running HDFS with permissions enabled, those permissions will need to be updated before you run CompleteBulkLoad.\n\nFor more information about bulk-loading HFiles into HBase, see [arch.bulk.load](/docs/architecture/bulk-loading).\n\n## WALPlayer\n\nWALPlayer is a utility to replay WAL files into HBase.\n\nThe WAL can be replayed for a set of tables or all tables, and a timerange can be provided (in milliseconds). The WAL is filtered to this set of tables. The output can optionally be mapped to another set of tables.\n\nWALPlayer can also generate HFiles for later bulk importing, in that case only a single table and no mapping can be specified.\n\nFinally, you can use WALPlayer to replay the content of a Regions `recovered.edits` directory (the files under `recovered.edits` directory have the same format as WAL files).\n\n<Callout type=\"info\" title=\"WALPrettyPrinter\">\n  To read or verify single WAL files or *recovered.edits* files, since they share the WAL format,\n  see [WAL Tools](/docs/operational-management/tools#wal-tools).\n</Callout>\n\nInvoke via:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.mapreduce.WALPlayer [options] <WAL inputdir> [<tables> <tableMappings>]>\n```\n\nFor example:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.mapreduce.WALPlayer /backuplogdir oldTable1,oldTable2 newTable1,newTable2\n```\n\nWALPlayer, by default, runs as a mapreduce job. To NOT run WALPlayer as a mapreduce job on your cluster, force it to run all in the local process by adding the flags `-Dmapreduce.jobtracker.address=local` on the command line.\n\n### WALPlayer Options\n\nRunning `WALPlayer` with no arguments prints brief usage information:\n\n```text\nUsage: WALPlayer [options] <WAL inputdir> [<tables> <tableMappings>]\n <WAL inputdir>   directory of WALs to replay.\n <tables>         comma separated list of tables. If no tables specified,\n                  all are imported (even hbase:meta if present).\n <tableMappings>  WAL entries can be mapped to a new set of tables by passing\n                  <tableMappings>, a comma separated list of target tables.\n                  If specified, each table in <tables> must have a mapping.\nTo generate HFiles to bulk load instead of loading HBase directly, pass:\n -Dwal.bulk.output=/path/for/output\n Only one table can be specified, and no mapping allowed!\nTo specify a time range, pass:\n -Dwal.start.time=[date|ms]\n -Dwal.end.time=[date|ms]\n The start and the end date of timerange (inclusive). The dates can be\n expressed in milliseconds-since-epoch or yyyy-MM-dd'T'HH:mm:ss.SS format.\n E.g. 1234567890120 or 2009-02-13T23:32:30.12\nOther options:\n -Dmapreduce.job.name=jobName\n Use the specified mapreduce job name for the wal player\n -Dwal.input.separator=' '\n Change WAL filename separator (WAL dir names use default ','.)\nFor performance also consider the following options:\n  -Dmapreduce.map.speculative=false\n  -Dmapreduce.reduce.speculative=false\n```\n\n## RowCounter\n\n[RowCounter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html) is a mapreduce job to count all the rows of a table. This is a good utility to use as a sanity check to ensure that HBase can read all the blocks of a table if there are any concerns of metadata inconsistency. It will run the mapreduce all in a single process but it will run faster if you have a MapReduce cluster in place for it to exploit. It is possible to limit the time range of data to be scanned by using the `--starttime=[starttime]` and `--endtime=[endtime]` flags. The scanned data can be limited based on keys using the `--range=[startKey],[endKey][;[startKey],[endKey]...]` option.\n\n```bash\n$ bin/hbase rowcounter [options] <tablename> [--starttime=<start> --endtime=<end>] [--range=[startKey],[endKey][;[startKey],[endKey]...]] [<column1> <column2>...]\n```\n\nRowCounter only counts one version per cell.\n\nFor performance consider to use `-Dhbase.client.scanner.caching=100` and `-Dmapreduce.map.speculative=false` options.\n\n## CellCounter\n\nHBase ships another diagnostic mapreduce job called [CellCounter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/CellCounter.html). Like RowCounter, it gathers more fine-grained statistics about your table. The statistics gathered by CellCounter are more fine-grained and include:\n\n* Total number of rows in the table.\n* Total number of CFs across all rows.\n* Total qualifiers across all rows.\n* Total occurrence of each CF.\n* Total occurrence of each qualifier.\n* Total number of versions of each qualifier.\n\nThe program allows you to limit the scope of the run. Provide a row regex or prefix to limit the rows to analyze. Specify a time range to scan the table by using the `--starttime=<starttime>` and `--endtime=<endtime>` flags.\n\nUse `hbase.mapreduce.scan.column.family` to specify scanning a single column family.\n\n```bash\n$ bin/hbase cellcounter TABLENAME OUTPUT_DIR [reportSeparator] [regex or prefix] [--starttime=STARTTIME --endtime=ENDTIME]\n```\n\nNote: just like RowCounter, caching for the input Scan is configured via `hbase.client.scanner.caching` in the job configuration.\n\n## mlockall\n\nIt is possible to optionally pin your servers in physical memory making them less likely to be swapped out in oversubscribed environments by having the servers call [mlockall](http://linux.die.net/man/2/mlockall) on startup. See [HBASE-4391 Add ability to start RS as root and call mlockall](https://issues.apache.org/jira/browse/HBASE-4391) for how to build the optional library and have it run on startup.\n\n## Offline Compaction Tool\n\n**CompactionTool** provides a way of running compactions (either minor or major) as an independent process from the RegionServer. It reuses same internal implementation classes executed by RegionServer compaction feature. However, since this runs on a complete separate independent java process, it releases RegionServers from the overhead involved in rewrite a set of hfiles, which can be critical for latency sensitive use cases.\n\nUsage:\n\n```\n$ ./bin/hbase org.apache.hadoop.hbase.regionserver.CompactionTool\n\nUsage: java org.apache.hadoop.hbase.regionserver.CompactionTool \\\n  [-compactOnce] [-major] [-mapred] [-D<property=value>]* files...\n\nOptions:\n mapred         Use MapReduce to run compaction.\n compactOnce    Execute just one compaction step. (default: while needed)\n major          Trigger major compaction.\n\nNote: -D properties will be applied to the conf used.\nFor example:\n To stop delete of compacted file, pass -Dhbase.compactiontool.delete=false\n To set tmp dir, pass -Dhbase.tmp.dir=ALTERNATE_DIR\n\nExamples:\n To compact the full 'TestTable' using MapReduce:\n $ hbase org.apache.hadoop.hbase.regionserver.CompactionTool -mapred hdfs://hbase/data/default/TestTable\n\n To compact column family 'x' of the table 'TestTable' region 'abc':\n $ hbase org.apache.hadoop.hbase.regionserver.CompactionTool hdfs://hbase/data/default/TestTable/abc/x\n```\n\nAs shown by usage options above, **CompactionTool** can run as a standalone client or a mapreduce job. When running as mapreduce job, each family dir is handled as an input split, and is processed by a separate map task.\n\nThe **compactionOnce** parameter controls how many compaction cycles will be performed until **CompactionTool** program decides to finish its work. If omitted, it will assume it should keep running compactions on each specified family as determined by the given compaction policy configured. For more info on compaction policy, see [compaction](/docs/architecture/regions#compaction).\n\nIf a major compaction is desired, **major** flag can be specified. If omitted, **CompactionTool** will assume minor compaction is wanted by default.\n\nIt also allows for configuration overrides with `-D` flag. In the usage section above, for example, `-Dhbase.compactiontool.delete=false` option will instruct compaction engine to not delete original files from temp folder.\n\nFiles targeted for compaction must be specified as parent hdfs dirs. It allows for multiple dirs definition, as long as each for these dirs are either a **family**, a **region**, or a **table** dir. If a table or region dir is passed, the program will recursively iterate through related sub-folders, effectively running compaction for each family found below the table/region level.\n\nSince these dirs are nested under **hbase** hdfs directory tree, **CompactionTool** requires hbase super user permissions in order to have access to required hfiles.\n\n<Callout type=\"info\" title=\"Running in MapReduce mode\">\n  MapReduce mode offers the ability to process each family dir in parallel, as a separate map task.\n  Generally, it would make sense to run in this mode when specifying one or more table dirs as\n  targets for compactions. The caveat, though, is that if number of families to be compacted become\n  too large, the related mapreduce job may have indirect impacts on **RegionServers** performance .\n  Since **NodeManagers** are normally co-located with RegionServers, such large jobs could compete\n  for IO/Bandwidth resources with the **RegionServers**.\n</Callout>\n\n<Callout type=\"info\" title=\"MajorCompaction completely disabled on RegionServers due performance impacts\">\n  **Major compactions** can be a costly operation (see\n  [compaction](/docs/architecture/regions#compaction)), and can indeed impact performance on\n  RegionServers, leading operators to completely disable it for critical low latency application.\n  **CompactionTool** could be used as an alternative in such scenarios, although, additional custom\n  application logic would need to be implemented, such as deciding scheduling and selection of\n  tables/regions/families target for a given compaction run.\n</Callout>\n\nFor additional details about CompactionTool, see also [CompactionTool](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/regionserver/CompactionTool.html).\n\n## `hbase clean`\n\nThe `hbase clean` command cleans HBase data from ZooKeeper, HDFS, or both. It is appropriate to use for testing. Run it with no options for usage instructions. The `hbase clean` command was introduced in HBase 0.98.\n\n```text\n$ bin/hbase clean\nUsage: hbase clean (--cleanZk|--cleanHdfs|--cleanAll)\nOptions:\n    --cleanZk   cleans hbase related data from zookeeper.\n    --cleanHdfs cleans hbase related data from hdfs.\n    --cleanAll  cleans hbase related data from both zookeeper and hdfs.\n```\n\n## `hbase pe`\n\nThe `hbase pe` command runs the PerformanceEvaluation tool, which is used for testing.\n\nThe PerformanceEvaluation tool accepts many different options and commands. For usage instructions, run the command with no options.\n\nThe PerformanceEvaluation tool has received many updates in recent HBase releases, including support for namespaces, support for tags, cell-level ACLs and visibility labels, multiget support for RPC calls, increased sampling sizes, an option to randomly sleep during testing, and ability to \"warm up\" the cluster before testing starts.\n\n## `hbase ltt`\n\nThe `hbase ltt` command runs the LoadTestTool utility, which is used for testing.\n\nYou must specify either `-init_only` or at least one of `-write`, `-update`, or `-read`. For general usage instructions, pass the `-h` option.\n\nThe LoadTestTool has received many updates in recent HBase releases, including support for namespaces, support for tags, cell-level ACLS and visibility labels, testing security-related features, ability to specify the number of regions per server, tests for multi-get RPC calls, and tests relating to replication.\n\n## Pre-Upgrade validator\n\nPre-Upgrade validator tool can be used to check the cluster for known incompatibilities before upgrading from HBase 1 to HBase 2.\n\n```bash\n$ bin/hbase pre-upgrade command ...\n```\n\n### Coprocessor validation\n\nHBase supports co-processors for a long time, but the co-processor API can be changed between major releases. Co-processor validator tries to determine whether the old co-processors are still compatible with the actual HBase version.\n\n```bash\n$ bin/hbase pre-upgrade validate-cp [-jar ...] [-class ... | -table ... | -config]\nOptions:\n -e            Treat warnings as errors.\n -jar <arg>    Jar file/directory of the coprocessor.\n -table <arg>  Table coprocessor(s) to check.\n -class <arg>  Coprocessor class(es) to check.\n -config         Scan jar for observers.\n```\n\nThe co-processor classes can be explicitly declared by `-class` option, or they can be obtained from HBase configuration by `-config` option. Table level co-processors can be also checked by `-table` option. The tool searches for co-processors on its classpath, but it can be extended by the `-jar` option. It is possible to test multiple classes with multiple `-class`, multiple tables with multiple `-table` options as well as adding multiple jars to the classpath with multiple `-jar` options.\n\nThe tool can report errors and warnings. Errors mean that HBase won't be able to load the coprocessor, because it is incompatible with the current version of HBase. Warnings mean that the co-processors can be loaded, but they won't work as expected. If `-e` option is given, then the tool will also fail for warnings.\n\nPlease note that this tool cannot validate every aspect of jar files, it just does some static checks.\n\nFor example:\n\n```bash\n$ bin/hbase pre-upgrade validate-cp -jar my-coprocessor.jar -class MyMasterObserver -class MyRegionObserver\n```\n\nIt validates `MyMasterObserver` and `MyRegionObserver` classes which are located in `my-coprocessor.jar`.\n\n```bash\n$ bin/hbase pre-upgrade validate-cp -table .*\n```\n\nIt validates every table level co-processors where the table name matches to `.*` regular expression.\n\n### DataBlockEncoding validation\n\nHBase 2.0 removed `PREFIX_TREE` Data Block Encoding from column families. For further information please check [*prefix-tree* encoding removed](/docs/upgrading/paths#prefix-tree-encoding-removed-toc). To verify that none of the column families are using incompatible Data Block Encodings in the cluster run the following command.\n\n```bash\n$ bin/hbase pre-upgrade validate-dbe\n```\n\nThis check validates all column families and print out any incompatibilities. For example:\n\n```\n2018-07-13 09:58:32,028 WARN  [main] tool.DataBlockEncodingValidator: Incompatible DataBlockEncoding for table: t, cf: f, encoding: PREFIX_TREE\n```\n\nWhich means that Data Block Encoding of table `t`, column family `f` is incompatible. To fix, use `alter` command in HBase shell:\n\n```ruby\nalter 't', { NAME => 'f', DATA_BLOCK_ENCODING => 'FAST_DIFF' }\n```\n\nPlease also validate HFiles, which is described in the next section.\n\n### HFile Content validation\n\nEven though Data Block Encoding is changed from `PREFIX_TREE` it is still possible to have HFiles that contain data encoded that way. To verify that HFiles are readable with HBase 2 please use *HFile content validator*.\n\n```bash\n$ bin/hbase pre-upgrade validate-hfile\n```\n\nThe tool will log the corrupt HFiles and details about the root cause. If the problem is about PREFIX\\_TREE encoding it is necessary to change encodings before upgrading to HBase 2.\n\nThe following log message shows an example of incorrect HFiles.\n\n```text\n2018-06-05 16:20:46,976 WARN  [hfilevalidator-pool1-t3] hbck.HFileCorruptionChecker: Found corrupt HFile hdfs://example.com:9000/hbase/data/default/t/72ea7f7d625ee30f959897d1a3e2c350/prefix/7e6b3d73263c4851bf2b8590a9b3791e\norg.apache.hadoop.hbase.io.hfile.CorruptHFileException: Problem reading HFile Trailer from file hdfs://example.com:9000/hbase/data/default/t/72ea7f7d625ee30f959897d1a3e2c350/prefix/7e6b3d73263c4851bf2b8590a9b3791e\n    ...\nCaused by: java.io.IOException: Invalid data block encoding type in file info: PREFIX_TREE\n    ...\nCaused by: java.lang.IllegalArgumentException: No enum constant org.apache.hadoop.hbase.io.encoding.DataBlockEncoding.PREFIX_TREE\n    ...\n2018-06-05 16:20:47,322 INFO  [main] tool.HFileContentValidator: Corrupted file: hdfs://example.com:9000/hbase/data/default/t/72ea7f7d625ee30f959897d1a3e2c350/prefix/7e6b3d73263c4851bf2b8590a9b3791e\n2018-06-05 16:20:47,383 INFO  [main] tool.HFileContentValidator: Corrupted file: hdfs://example.com:9000/hbase/archive/data/default/t/56be41796340b757eb7fff1eb5e2a905/f/29c641ae91c34fc3bee881f45436b6d1\n```\n\n#### Fixing PREFIX\\_TREE errors\n\nIt's possible to get `PREFIX_TREE` errors after changing Data Block Encoding to a supported one. It can happen because there are some HFiles which still encoded with `PREFIX_TREE` or there are still some snapshots.\n\nFor fixing HFiles, please run a major compaction on the table (it was `default:t` according to the log message):\n\n```ruby\nmajor_compact 't'\n```\n\nHFiles can be referenced from snapshots, too. It's the case when the HFile is located under `archive/data`. The first step is to determine which snapshot references that HFile (the name of the file was `29c641ae91c34fc3bee881f45436b6d1` according to the logs):\n\n```bash\nfor snapshot in $(hbase snapshotinfo -list-snapshots 2> /dev/null | tail -n -1 | cut -f 1 -d \\|);\ndo\n  echo \"checking snapshot named '${snapshot}'\";\n  hbase snapshotinfo -snapshot \"${snapshot}\" -files 2> /dev/null | grep 29c641ae91c34fc3bee881f45436b6d1;\ndone\n```\n\nThe output of this shell script is:\n\n```text\nchecking snapshot named 't_snap'\n   1.0 K t/56be41796340b757eb7fff1eb5e2a905/f/29c641ae91c34fc3bee881f45436b6d1 (archive)\n```\n\nWhich means `t_snap` snapshot references the incompatible HFile. If the snapshot is still needed, then it has to be recreated with HBase shell:\n\n```text\n# creating a new namespace for the cleanup process\ncreate_namespace 'pre_upgrade_cleanup'\n\n# creating a new snapshot\nclone_snapshot 't_snap', 'pre_upgrade_cleanup:t'\nalter 'pre_upgrade_cleanup:t', { NAME => 'f', DATA_BLOCK_ENCODING => 'FAST_DIFF' }\nmajor_compact 'pre_upgrade_cleanup:t'\n\n# removing the invalid snapshot\ndelete_snapshot 't_snap'\n\n# creating a new snapshot\nsnapshot 'pre_upgrade_cleanup:t', 't_snap'\n\n# removing temporary table\ndisable 'pre_upgrade_cleanup:t'\ndrop 'pre_upgrade_cleanup:t'\ndrop_namespace 'pre_upgrade_cleanup'\n```\n\nFor further information, please refer to [HBASE-20649](https://issues.apache.org/jira/browse/HBASE-20649?focusedCommentId=16535476#comment-16535476).\n\n## Data Block Encoding Tool\n\nTests various compression algorithms with different data block encoder for key compression on an existing HFile. Useful for testing, debugging and benchmarking.\n\nYou must specify `-f` which is the full path of the HFile.\n\nThe result shows both the performance (MB/s) of compression/decompression and encoding/decoding, and the data savings on the HFile.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.regionserver.DataBlockEncodingTool\nUsages: hbase org.apache.hadoop.hbase.regionserver.DataBlockEncodingTool\nOptions:\n        -f HFile to analyse (REQUIRED)\n        -n Maximum number of key/value pairs to process in a single benchmark run.\n        -b Whether to run a benchmark to measure read throughput.\n        -c If this is specified, no correctness testing will be done.\n        -a What kind of compression algorithm use for test. Default value: GZ.\n        -t Number of times to run each benchmark. Default value: 12.\n        -omit Number of first runs of every benchmark to omit from statistics. Default value: 2.\n```\n\n## HBase Conf Tool\n\nHBase Conf tool can be used to print out the current value of a configuration. It can be used by passing the configuration key on the command-line.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.util.HBaseConfTool <configuration_key>\n```\n\n\n# Apache HBase Orca (/docs/orca)\n\n\n\n\nDefault:\n<img alt=\"Apache HBase Orca Logo\" src={__img0} />\n\nFor dark theme:\n<img alt=\"Apache HBase Orca Logo for dark theme\" src={__img1} />\n\n[An Orca is the Apache HBase mascot.](https://issues.apache.org/jira/browse/HBASE-4920) See NOTICES.txt. Our Orca logo we got here: [http://www.vectorfree.com/jumping-orca](http://www.vectorfree.com/jumping-orca) It is licensed Creative Commons Attribution 3.0. See [https://creativecommons.org/licenses/by/3.0/us/](https://creativecommons.org/licenses/by/3.0/us/) We changed the logo by stripping the colored background, inverting it and then rotating it some.\n\nThe 'official' HBase color is \"International Orange (Engineering)\", the color of the [Golden Gate bridge](https://en.wikipedia.org/wiki/International_orange) in San Francisco and for space suits used by NASA.\n\nOur 'font' is [Bitsumishi](http://www.dafont.com/bitsumishi.font).\n\n\n# Other Information About HBase (/docs/other-info)\n## HBase Videos\n\n* [Introduction to HBase](https://vimeo.com/23400732) by Todd Lipcon (Chicago Data Summit 2011).\n\n* [Building Real Time Services at Facebook with HBase](https://www.youtube.com/watch?v=DdGKAorSSZ0) by Jonathan Gray (Berlin buzzwords 2011)\n\n## HBase Presentations (Slides)\n\n[Advanced HBase Schema Design](https://www.slideshare.net/cloudera/hadoop-world-2011-advanced-hbase-schema-design-lars-george-cloudera) by Lars George (Hadoop World 2011).\n\n[Introduction to HBase](http://www.slideshare.net/cloudera/chicago-data-summit-apache-hbase-an-introduction) by Todd Lipcon (Chicago Data Summit 2011).\n\n[Getting The Most From Your HBase Install](http://www.slideshare.net/cloudera/hw09-practical-h-base-getting-the-most-from-your-h-base-install) by Ryan Rawson, Jonathan Gray (Hadoop World 2009).\n\n## HBase Papers\n\n[BigTable](http://research.google.com/archive/bigtable.html) by Google (2006).\n\n[HBase and HDFS Locality](http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html) by Lars George (2010).\n\n[No Relation: The Mixed Blessings of Non-Relational Databases](http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf) by Ian Varley (2009).\n\n## HBase Sites\n\n[Cloudera's HBase Blog](https://blog.cloudera.com/blog/category/hbase/) has a lot of links to useful HBase information.\n\n[CAP Confusion](https://blog.cloudera.com/blog/2010/04/cap-confusion-problems-with-partition-tolerance/) is a relevant entry for background information on distributed storage systems.\n\n[HBase RefCard](http://refcardz.dzone.com/refcardz/hbase) from DZone.\n\n## HBase Books\n\n[HBase: The Definitive Guide](http://shop.oreilly.com/product/0636920014348.do) by Lars George.\n\n## Hadoop Books\n\n[Hadoop: The Definitive Guide](http://shop.oreilly.com/product/9780596521981.do) by Tom White.\n\n\n# Apache HBase Performance Tuning (/docs/performance)\n## Operating System\n\n### Memory\n\nRAM, RAM, RAM. Don't starve HBase.\n\n### 64-bit\n\nUse a 64-bit platform (and 64-bit JVM).\n\n### Swapping\n\nWatch out for swapping. Set `swappiness` to 0.\n\n### CPU\n\nMake sure you have set up your Hadoop to use native, hardware checksumming. See [hadoop.native.lib](/docs/compression#making-use-of-hadoop-native-libraries-in-hbase).\n\n## Network\n\nPerhaps the most important factor in avoiding network issues degrading Hadoop and HBase performance is the switching hardware that is used, decisions made early in the scope of the project can cause major problems when you double or triple the size of your cluster (or more).\n\nImportant items to consider:\n\n* Switching capacity of the device\n* Number of systems connected\n* Uplink capacity\n\n### Single Switch\n\nThe single most important factor in this configuration is that the switching capacity of the hardware is capable of handling the traffic which can be generated by all systems connected to the switch. Some lower priced commodity hardware can have a slower switching capacity than could be utilized by a full switch.\n\n### Multiple Switches\n\nMultiple switches are a potential pitfall in the architecture. The most common configuration of lower priced hardware is a simple 1Gbps uplink from one switch to another. This often overlooked pinch point can easily become a bottleneck for cluster communication. Especially with MapReduce jobs that are both reading and writing a lot of data the communication across this uplink could be saturated.\n\nMitigation of this issue is fairly simple and can be accomplished in multiple ways:\n\n* Use appropriate hardware for the scale of the cluster which you're attempting to build.\n* Use larger single switch configurations i.e. single 48 port as opposed to 2x 24 port\n* Configure port trunking for uplinks to utilize multiple interfaces to increase cross switch bandwidth.\n\n### Multiple Racks\n\nMultiple rack configurations carry the same potential issues as multiple switches, and can suffer performance degradation from two main areas:\n\n* Poor switch capacity performance\n* Insufficient uplink to another rack\n\nIf the switches in your rack have appropriate switching capacity to handle all the hosts at full speed, the next most likely issue will be caused by homing more of your cluster across racks. The easiest way to avoid issues when spanning multiple racks is to use port trunking to create a bonded uplink to other racks. The downside of this method however, is in the overhead of ports that could potentially be used. An example of this is, creating an 8Gbps port channel from rack A to rack B, using 8 of your 24 ports to communicate between racks gives you a poor ROI, using too few however can mean you're not getting the most out of your cluster.\n\nUsing 10Gbe links between racks will greatly increase performance, and assuming your switches support a 10Gbe uplink or allow for an expansion card will allow you to save your ports for machines as opposed to uplinks.\n\n### Network Interfaces\n\nAre all the network interfaces functioning correctly? Are you sure? See the Troubleshooting Case Study in [Case Study #1 (Performance Issue On A Single Node)](/docs/case-studies#case-study-1-performance-issue-on-a-single-node).\n\n### Network Consistency and Partition Tolerance\n\nThe [CAP Theorem](http://en.wikipedia.org/wiki/CAP_theorem) states that a distributed system can maintain two out of the following three characteristics:\n\n* ***C***&#x6F;nsistency — all nodes see the same data.\n* ***A***&#x76;ailability — every request receives a response about whether it succeeded or failed.\n* ***P***&#x61;rtition tolerance — the system continues to operate even if some of its components become unavailable to the others.\n\nHBase favors consistency and partition tolerance, where a decision has to be made. Coda Hale explains why partition tolerance is so important, in [http://codahale.com/you-cant-sacrifice-partition-tolerance/](http://codahale.com/you-cant-sacrifice-partition-tolerance/).\n\nRobert Yokota used an automated testing framework called [Jepson](https://aphyr.com/tags/jepsen) to test HBase's partition tolerance in the face of network partitions, using techniques modeled after Aphyr's [Call Me Maybe](https://aphyr.com/posts/281-call-me-maybe-carly-rae-jepsen-and-the-perils-of-network-partitions) series. The results, available as a [blog post](https://rayokota.wordpress.com/2015/09/30/call-me-maybe-hbase/) and an [addendum](https://rayokota.wordpress.com/2015/09/30/call-me-maybe-hbase-addendum/), show that HBase performs correctly.\n\n## Java\n\n### The Garbage Collector and Apache HBase\n\n#### Long GC pauses\n\nIn his presentation, [Avoiding Full GCs with MemStore-Local Allocation Buffers](http://www.slideshare.net/cloudera/hbase-hug-presentation), Todd Lipcon describes two cases of stop-the-world garbage collections common in HBase, especially during loading; CMS failure modes and old generation heap fragmentation brought.\n\nTo address the first, start the CMS earlier than default by adding `-XX:CMSInitiatingOccupancyFraction` and setting it down from defaults. Start at 60 or 70 percent (The lower you bring down the threshold, the more GCing is done, the more CPU used). To address the second fragmentation issue, Todd added an experimental facility, (MSLAB), that must be explicitly enabled in Apache HBase 0.90.x (It's defaulted to be *on* in Apache 0.92.x HBase). Set `hbase.hregion.memstore.mslab.enabled` to true in your `Configuration`. See the cited slides for background and detail. The latest JVMs do better regards fragmentation so make sure you are running a recent release. Read down in the message, [Identifying concurrent mode failures caused by fragmentation](http://osdir.com/ml/hotspot-gc-use/2011-11/msg00002.html). Be aware that when enabled, each MemStore instance will occupy at least an MSLAB instance of memory. If you have thousands of regions or lots of regions each with many column families, this allocation of MSLAB may be responsible for a good portion of your heap allocation and in an extreme case cause you to OOME. Disable MSLAB in this case, or lower the amount of memory it uses or float less regions per server.\n\nIf you have a write-heavy workload, check out [HBASE-8163 MemStoreChunkPool: An improvement for JAVA GC when using MSLAB](https://issues.apache.org/jira/browse/HBASE-8163). It describes configurations to lower the amount of young GC during write-heavy loadings. If you do not have HBASE-8163 installed, and you are trying to improve your young GC times, one trick to consider — courtesy of our Liang Xie — is to set the GC config `-XX:PretenureSizeThreshold` in *hbase-env.sh* to be just smaller than the size of `hbase.hregion.memstore.mslab.chunksize` so MSLAB allocations happen in the tenured space directly rather than first in the young gen. You'd do this because these MSLAB allocations are going to likely make it to the old gen anyways and rather than pay the price of a copies between s0 and s1 in eden space followed by the copy up from young to old gen after the MSLABs have achieved sufficient tenure, save a bit of YGC churn and allocate in the old gen directly.\n\nOther sources of long GCs can be the JVM itself logging. See [Eliminating Large JVM GC Pauses Caused by Background IO Traffic](https://engineering.linkedin.com/blog/2016/02/eliminating-large-jvm-gc-pauses-caused-by-background-io-traffic)\n\nFor more information about GC logs, see [JVM Garbage Collection Logs](/docs/troubleshooting#jvm-garbage-collection-logs).\n\nConsider also enabling the off-heap Block Cache. This has been shown to mitigate GC pause times. See [Block Cache](/docs/architecture/regionserver#architecture-regionserver-block-cache)\n\n## HBase Configurations\n\nSee [Recommended Configurations](/docs/configuration/important#recommended-configurations).\n\n### Improving the 99th Percentile\n\nTry [hedged\\_reads](/docs/performance#hedged-reads).\n\n### Managing Compactions\n\nFor larger systems, managing [compactions and splits](/docs/configuration/important#managed-compactions) may be something you want to consider.\n\n### `hbase.regionserver.handler.count`\n\nSee [hbase.regionserver.handler.count](/docs/configuration/default#hbaseregionserverhandlercount-toc).\n\n### `hfile.block.cache.size`\n\nSee [hfile.block.cache.size](/docs/configuration/default#hfileblockcachesize-toc). A memory setting for the RegionServer process.\n\n### Prefetch Option for Blockcache\n\n[HBASE-9857](https://issues.apache.org/jira/browse/HBASE-9857) adds a new option to prefetch HFile contents when opening the BlockCache, if a Column family or RegionServer property is set. This option is available for HBase 0.98.3 and later. The purpose is to warm the BlockCache as rapidly as possible after the cache is opened, using in-memory table data, and not counting the prefetching as cache misses. This is great for fast reads, but is not a good idea if the data to be preloaded will not fit into the BlockCache. It is useful for tuning the IO impact of prefetching versus the time before all data blocks are in cache.\n\nTo enable prefetching on a given column family, you can use HBase Shell or use the API.\n\n**Enable Prefetch Using HBase Shell**\n\n```ruby\nhbase> create 'MyTable', { NAME => 'myCF', PREFETCH_BLOCKS_ON_OPEN => 'true' }\n```\n\n**Enable Prefetch Using the API**\n\n```java\n// ...\nHTableDescriptor tableDesc = new HTableDescriptor(\"myTable\");\nHColumnDescriptor cfDesc = new HColumnDescriptor(\"myCF\");\ncfDesc.setPrefetchBlocksOnOpen(true);\ntableDesc.addFamily(cfDesc);\n// ...\n```\n\nSee the API documentation for [CacheConfig](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html).\n\nTo see prefetch in operation, enable TRACE level logging on `org.apache.hadoop.hbase.io.hfile.HFileReaderImpl` in hbase-2.0+ or on `org.apache.hadoop.hbase.io.hfile.HFileReaderV2` in earlier versions, hbase-1.x, of HBase.\n\n### `hbase.regionserver.global.memstore.size`\n\nSee [hbase.regionserver.global.memstore.size](/docs/configuration/default#hbaseregionserverglobalmemstoresize-toc). This memory setting is often adjusted for the RegionServer process depending on needs.\n\n### `hbase.regionserver.global.memstore.size.lower.limit`\n\nSee [hbase.regionserver.global.memstore.size.lower.limit](/docs/configuration/default#hbaseregionserverglobalmemstoresizelowerlimit-toc). This memory setting is often adjusted for the RegionServer process depending on needs.\n\n### `hbase.hstore.blockingStoreFiles`\n\nSee [hbase.hstore.blockingStoreFiles](/docs/configuration/default#hbasehstoreblockingStoreFiles-toc). If there is blocking in the RegionServer logs, increasing this can help.\n\n### `hbase.hregion.memstore.block.multiplier`\n\nSee [hbase.hregion.memstore.block.multiplier](/docs/configuration/default#hbasehregionmemstoreblockmultiplier-toc). If there is enough RAM, increasing this can help.\n\n### `hbase.regionserver.checksum.verify`\n\nHave HBase write the checksum into the datablock and save having to do the checksum seek whenever you read.\n\nSee [hbase.regionserver.checksum.verify](/docs/configuration/default#hbaseregionserverchecksumverify-toc), [hbase.hstore.bytes.per.checksum](/docs/configuration/default#hbasehstorebytesperchecksum-toc) and [hbase.hstore.checksum.algorithm](/docs/configuration/default#hbasehstorechecksumalgorithm-toc). For more information see the release note on [HBASE-5074 support checksums in HBase block cache](https://issues.apache.org/jira/browse/HBASE-5074).\n\n### Tuning `callQueue` Options\n\n[HBASE-11355](https://issues.apache.org/jira/browse/HBASE-11355) introduces several callQueue tuning mechanisms which can increase performance. See the JIRA for some benchmarking information.\n\nTo increase the number of callqueues, set `hbase.ipc.server.num.callqueue` to a value greater than `1`. To split the callqueue into separate read and write queues, set `hbase.ipc.server.callqueue.read.ratio` to a value between `0` and `1`. This factor weights the queues toward writes (if below .5) or reads (if above .5). Another way to say this is that the factor determines what percentage of the split queues are used for reads. The following examples illustrate some of the possibilities. Note that you always have at least one write queue, no matter what setting you use.\n\n* The default value of `0` does not split the queue.\n* A value of `.3` uses 30% of the queues for reading and 70% for writing. Given a value of `10` for `hbase.ipc.server.num.callqueue`, 3 queues would be used for reads and 7 for writes.\n* A value of `.5` uses the same number of read queues and write queues. Given a value of `10` for `hbase.ipc.server.num.callqueue`, 5 queues would be used for reads and 5 for writes.\n* A value of `.6` uses 60% of the queues for reading and 40% for writing. Given a value of `10` for `hbase.ipc.server.num.callqueue`, 6 queues would be used for reads and 4 for writes.\n* A value of `1.0` uses one queue to process write requests, and all other queues process read requests. A value higher than `1.0` has the same effect as a value of `1.0`. Given a value of `10` for `hbase.ipc.server.num.callqueue`, 9 queues would be used for reads and 1 for writes.\n\nYou can also split the read queues so that separate queues are used for short reads (from Get operations) and long reads (from Scan operations), by setting the `hbase.ipc.server.callqueue.scan.ratio` option. This option is a factor between 0 and 1, which determine the ratio of read queues used for Gets and Scans. More queues are used for Gets if the value is below `.5` and more are used for scans if the value is above `.5`. No matter what setting you use, at least one read queue is used for Get operations.\n\n* A value of `0` does not split the read queue.\n* A value of `.3` uses 70% of the read queues for Gets and 30% for Scans. Given a value of `20` for `hbase.ipc.server.num.callqueue` and a value of `.5` for `hbase.ipc.server.callqueue.read.ratio`, 10 queues would be used for reads, out of those 10, 7 would be used for Gets and 3 for Scans.\n* A value of `.5` uses half the read queues for Gets and half for Scans. Given a value of `20` for `hbase.ipc.server.num.callqueue` and a value of `.5` for `hbase.ipc.server.callqueue.read.ratio`, 10 queues would be used for reads, out of those 10, 5 would be used for Gets and 5 for Scans.\n* A value of `.7` uses 30% of the read queues for Gets and 70% for Scans. Given a value of `20` for `hbase.ipc.server.num.callqueue` and a value of `.5` for `hbase.ipc.server.callqueue.read.ratio`, 10 queues would be used for reads, out of those 10, 3 would be used for Gets and 7 for Scans.\n* A value of `1.0` uses all but one of the read queues for Scans. Given a value of `20` for `hbase.ipc.server.num.callqueue` and a value of `.5` for `hbase.ipc.server.callqueue.read.ratio`, 10 queues would be used for reads, out of those 10, 1 would be used for Gets and 9 for Scans.\n\nYou can use the new option `hbase.ipc.server.callqueue.handler.factor` to programmatically tune the number of queues:\n\n* A value of `0` uses a single shared queue between all the handlers.\n* A value of `1` uses a separate queue for each handler.\n* A value between `0` and `1` tunes the number of queues against the number of handlers. For instance, a value of `.5` shares one queue between each two handlers.\\\n  Having more queues, such as in a situation where you have one queue per handler, reduces contention when adding a task to a queue or selecting it from a queue. The trade-off is that if you have some queues with long-running tasks, a handler may end up waiting to execute from that queue rather than processing another queue which has waiting tasks.\n\nFor these values to take effect on a given RegionServer, the RegionServer must be restarted. These parameters are intended for testing purposes and should be used carefully.\n\n## ZooKeeper\n\nSee [ZooKeeper](/docs/zookeeper) for information on configuring ZooKeeper, and see the part about having a dedicated disk.\n\n## Schema Design\n\n### Number of Column Families\n\nSee [On the number of column families](/docs/regionserver-sizing#on-the-number-of-column-families).\n\n### Key and Attribute Lengths\n\nSee [Try to minimize row and column sizes](/docs/regionserver-sizing#try-to-minimize-row-and-column-sizes). See also [However...](/docs/performance#however) for compression caveats.\n\n### Table RegionSize\n\nThe regionsize can be set on a per-table basis via `setMaxFileSize` on [TableDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/TableDescriptorBuilder.html) in the event where certain tables require different regionsizes than the configured default regionsize.\n\nSee [Determining region count and size](/docs/operational-management/region-and-capacity#determining-region-count-and-size) for more information.\n\n### Bloom Filters\n\nA Bloom filter, named for its creator, Burton Howard Bloom, is a data structure which is designed to predict whether a given element is a member of a set of data. A positive result from a Bloom filter is not always accurate, but a negative result is guaranteed to be accurate. Bloom filters are designed to be \"accurate enough\" for sets of data which are so large that conventional hashing mechanisms would be impractical. For more information about Bloom filters in general, refer to [http://en.wikipedia.org/wiki/Bloom\\_filter](http://en.wikipedia.org/wiki/Bloom_filter).\n\nIn terms of HBase, Bloom filters provide a lightweight in-memory structure to reduce the number of disk reads for a given Get operation (Bloom filters do not work with Scans) to only the StoreFiles likely to contain the desired Row. The potential performance gain increases with the number of parallel reads.\n\nThe Bloom filters themselves are stored in the metadata of each HFile and never need to be updated. When an HFile is opened because a region is deployed to a RegionServer, the Bloom filter is loaded into memory.\n\nHBase includes some tuning mechanisms for folding the Bloom filter to reduce the size and keep the false positive rate within a desired range.\n\nBloom filters were introduced in [HBASE-1200](https://issues.apache.org/jira/browse/HBASE-1200). Since HBase 0.96, row-based Bloom filters are enabled by default. ([HBASE-8450](https://issues.apache.org/jira/browse/HBASE-8450))\n\nFor more information on Bloom filters in relation to HBase, see [Bloom Filters](/docs/performance#bloom-filters) for more information, or the following Quora discussion: [How are bloom filters used in HBase?](http://www.quora.com/How-are-bloom-filters-used-in-HBase).\n\n#### When To Use Bloom Filters\n\nSince HBase 0.96, row-based Bloom filters are enabled by default. You may choose to disable them or to change some tables to use row+column Bloom filters, depending on the characteristics of your data and how it is loaded into HBase.\n\nTo determine whether Bloom filters could have a positive impact, check the value of `blockCacheHitRatio` in the RegionServer metrics. If Bloom filters are enabled, the value of `blockCacheHitRatio` should increase, because the Bloom filter is filtering out blocks that are definitely not needed.\n\nYou can choose to enable Bloom filters for a row or for a row+column combination. If you generally scan entire rows, the row+column combination will not provide any benefit. A row-based Bloom filter can operate on a row+column Get, but not the other way around. However, if you have a large number of column-level Puts, such that a row may be present in every StoreFile, a row-based filter will always return a positive result and provide no benefit. Unless you have one column per row, row+column Bloom filters require more space, in order to store more keys. Bloom filters work best when the size of each data entry is at least a few kilobytes in size.\n\nOverhead will be reduced when your data is stored in a few larger StoreFiles, to avoid extra disk IO during low-level scans to find a specific row.\n\nBloom filters need to be rebuilt upon deletion, so may not be appropriate in environments with a large number of deletions.\n\n#### Enabling Bloom Filters\n\nBloom filters are enabled on a Column Family. You can do this by using the setBloomFilterType method of HColumnDescriptor or using the HBase API. Valid values are `NONE`, `ROW` (default), or `ROWCOL`. See [When To Use Bloom Filters](/docs/performance#when-to-use-bloom-filters) for more information on `ROW` versus `ROWCOL`. See also the API documentation for [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html).\n\nThe following example creates a table and enables a ROWCOL Bloom filter on the `colfam1` column family.\n\n```ruby\nhbase> create 'mytable',{NAME => 'colfam1', BLOOMFILTER => 'ROWCOL'}\n```\n\n#### Configuring Server-Wide Behavior of Bloom Filters\n\nYou can configure the following settings in the *hbase-site.xml*.\n\n| Parameter                                | Default   | Description                                                                                                                                                    |\n| ---------------------------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| io.storefile.bloom.enabled               | yes       | Set to no to kill bloom filters server-wide if something goes wrong                                                                                            |\n| io.storefile.bloom.error.rate            | .01       | The average false positive rate for bloom filters. Folding is used to maintain the false positive rate. Expressed as a decimal representation of a percentage. |\n| io.storefile.bloom.max.fold              | 7         | The guaranteed maximum fold rate. Changing this setting should not be necessary and is not recommended.                                                        |\n| io.storefile.bloom.max.keys              | 128000000 | For default (single-block) Bloom filters, this specifies the maximum number of keys.                                                                           |\n| io.storefile.delete.family.bloom.enabled | true      | Master switch to enable Delete Family Bloom filters and store them in the StoreFile.                                                                           |\n| io.storefile.bloom.block.size            | 131072    | Target Bloom block size. Bloom filter blocks of approximately this size are interleaved with data blocks.                                                      |\n| hfile.block.bloom.cacheonwrite           | false     | Enables cache-on-write for inline blocks of a compound Bloom filter.                                                                                           |\n\n### ColumnFamily BlockSize\n\nThe blocksize can be configured for each ColumnFamily in a table, and defaults to 64k. Larger cell values require larger blocksizes. There is an inverse relationship between blocksize and the resulting StoreFile indexes (i.e., if the blocksize is doubled then the resulting indexes should be roughly halved).\n\nSee [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html) and [Store](/docs/architecture/regions#store) for more information.\n\n### In-Memory ColumnFamilies\n\nColumnFamilies can optionally be defined as in-memory. Data is still persisted to disk, just like any other ColumnFamily. In-memory blocks have the highest priority in the [Block Cache](/docs/architecture/regionserver#architecture-regionserver-block-cache), but it is not a guarantee that the entire table will be in memory.\n\nSee [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html) for more information.\n\n### Compression\n\nProduction systems should use compression with their ColumnFamily definitions. See [Compression and Data Block Encoding In HBase](/docs/compression) for more information.\n\n#### However...\n\nCompression deflates data *on disk*. When it's in-memory (e.g., in the MemStore) or on the wire (e.g., transferring between RegionServer and Client) it's inflated. So while using ColumnFamily compression is a best practice, but it's not going to completely eliminate the impact of over-sized Keys, over-sized ColumnFamily names, or over-sized Column names.\n\nSee [Try to minimize row and column sizes](/docs/regionserver-sizing#try-to-minimize-row-and-column-sizes) on for schema design tips, and [KeyValue](/docs/architecture/regions#keyvalue) for more information on HBase stores data internally.\n\n## HBase General Patterns\n\n### Constants\n\nWhen people get started with HBase they have a tendency to write code that looks like this:\n\n```java\nGet get = new Get(rowkey);\nResult r = table.get(get);\nbyte[] b = r.getValue(Bytes.toBytes(\"cf\"), Bytes.toBytes(\"attr\"));  // returns current version of value\n```\n\nBut especially when inside loops (and MapReduce jobs), converting the columnFamily and column-names to byte-arrays repeatedly is surprisingly expensive. It's better to use constants for the byte-arrays, like this:\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\nGet get = new Get(rowkey);\nResult r = table.get(get);\nbyte[] b = r.getValue(CF, ATTR);  // returns current version of value\n```\n\n## Writing to HBase\n\n### Batch Loading\n\nUse the bulk load tool if you can. See [Bulk Loading](/docs/architecture/bulk-loading). Otherwise, pay attention to the below.\n\n### Table Creation: Pre-Creating Regions\n\nTables in HBase are initially created with one region by default. For bulk imports, this means that all clients will write to the same region until it is large enough to split and become distributed across the cluster. A useful pattern to speed up the bulk import process is to pre-create empty regions. Be somewhat conservative in this, because too-many regions can actually degrade performance.\n\nThere are two different approaches to pre-creating splits using the HBase API. The first approach is to rely on the default `Admin` strategy (which is implemented in `Bytes.split`)...\n\n```java\nbyte[] startKey = ...;      // your lowest key\nbyte[] endKey = ...;        // your highest key\nint numberOfRegions = ...;  // # of regions to create\nadmin.createTable(table, startKey, endKey, numberOfRegions);\n```\n\nAnd the other approach, using the HBase API, is to define the splits yourself...\n\n```java\nbyte[][] splits = ...;   // create your own splits\nadmin.createTable(table, splits);\n```\n\nYou can achieve a similar effect using the HBase Shell to create tables by specifying split options.\n\n```ruby\n# create table with specific split points\nhbase>create 't1','f1',SPLITS => ['\\x10\\x00', '\\x20\\x00', '\\x30\\x00', '\\x40\\x00']\n\n# create table with four regions based on random bytes keys\nhbase>create 't2','f1', { NUMREGIONS => 4 , SPLITALGO => 'UniformSplit' }\n\n# create table with five regions based on hex keys\ncreate 't3','f1', { NUMREGIONS => 5, SPLITALGO => 'HexStringSplit' }\n```\n\nSee [Relationship Between RowKeys and Region Splits](/docs/regionserver-sizing#relationship-between-rowkeys-and-region-splits) for issues related to understanding your keyspace and pre-creating regions. See [manual region splitting decisions](/docs/architecture/regions#manual-region-splitting) for discussion on manually pre-splitting regions. See [Pre-splitting tables with the HBase Shell](/docs/shell#pre-splitting-tables-with-the-hbase-shell) for more details of using the HBase Shell to pre-split tables.\n\n### Table Creation: Deferred Log Flush\n\nThe default behavior for Puts using the Write Ahead Log (WAL) is that `WAL` edits will be written immediately. If deferred log flush is used, WAL edits are kept in memory until the flush period. The benefit is aggregated and asynchronous `WAL`- writes, but the potential downside is that if the RegionServer goes down the yet-to-be-flushed edits are lost. This is safer, however, than not using WAL at all with Puts.\n\nDeferred log flush can be configured on tables via [TableDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/TableDescriptorBuilder.html). The default value of `hbase.regionserver.optionallogflushinterval` is 1000ms.\n\n### HBase Client: Turn off WAL on Puts\n\nA frequent request is to disable the WAL to increase performance of Puts. This is only appropriate for bulk loads, as it puts your data at risk by removing the protection of the WAL in the event of a region server crash. Bulk loads can be re-run in the event of a crash, with little risk of data loss.\n\n<Callout type=\"warn\">\n  If you disable the WAL for anything other than bulk loads, your data is at risk.\n</Callout>\n\nIn general, it is best to use WAL for Puts, and where loading throughput is a concern to use bulk loading techniques instead. For normal Puts, you are not likely to see a performance improvement which would outweigh the risk. To disable the WAL, see [Disabling the WAL](/docs/architecture/regionserver#disabling-the-wal).\n\n### HBase Client: Group Puts by RegionServer\n\nIn addition to using the writeBuffer, grouping `Put`s by RegionServer can reduce the number of client RPC calls per writeBuffer flush. There is a utility `HTableUtil` currently on MASTER that does this, but you can either copy that or implement your own version for those still on 0.90.x or earlier.\n\n### MapReduce: Skip The Reducer\n\nWhen writing a lot of data to an HBase table from a MR job (e.g., with [TableOutputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html)), and specifically where Puts are being emitted from the Mapper, skip the Reducer step. When a Reducer step is used, all of the output (Puts) from the Mapper will get spooled to disk, then sorted/shuffled to other Reducers that will most likely be off-node. It's far more efficient to just write directly to HBase.\n\nFor summary jobs where HBase is used as a source and a sink, then writes will be coming from the Reducer step (e.g., summarize values then write out result). This is a different processing problem than from the above case.\n\n### Anti-Pattern: One Hot Region\n\nIf all your data is being written to one region at a time, then re-read the section on processing timeseries data.\n\nAlso, if you are pre-splitting regions and all your data is *still* winding up in a single region even though your keys aren't monotonically increasing, confirm that your keyspace actually works with the split strategy. There are a variety of reasons that regions may appear \"well split\" but won't work with your data. As the HBase client communicates directly with the RegionServers, this can be obtained via [RegionLocator.getRegionLocation](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/RegionLocator.html#getRegionLocation\\(byte%5B%5D\\)).\n\nSee [Table Creation: Pre-Creating Regions](/docs/performance#table-creation-pre-creating-regions), as well as [HBase Configurations](/docs/performance#hbase-configurations)\n\n## Reading from HBase\n\nThe mailing list can help if you are having performance issues.\n\n### Scan Caching\n\nIf HBase is used as an input source for a MapReduce job, for example, make sure that the input [Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) instance to the MapReduce job has `setCaching` set to something greater than the default (which is 1). Using the default value means that the map-task will make call back to the region-server for every record processed. Setting this value to 500, for example, will transfer 500 rows at a time to the client to be processed. There is a cost/benefit to have the cache value be large because it costs more in memory for both client and RegionServer, so bigger isn't always better.\n\n#### Scan Caching in MapReduce Jobs\n\nScan settings in MapReduce jobs deserve special attention. Timeouts can result (e.g., UnknownScannerException) in Map tasks if it takes longer to process a batch of records before the client goes back to the RegionServer for the next set of data. This problem can occur because there is non-trivial processing occurring per row. If you process rows quickly, set caching higher. If you process rows more slowly (e.g., lots of transformations per row, writes), then set caching lower.\n\nTimeouts can also happen in a non-MapReduce use case (i.e., single threaded HBase client doing a Scan), but the processing that is often performed in MapReduce jobs tends to exacerbate this issue.\n\n### Scan Attribute Selection\n\nWhenever a Scan is used to process large numbers of rows (and especially when used as a MapReduce source), be aware of which attributes are selected. If `scan.addFamily` is called then *all* of the attributes in the specified ColumnFamily will be returned to the client. If only a small number of the available attributes are to be processed, then only those attributes should be specified in the input scan because attribute over-selection is a non-trivial performance penalty over large datasets.\n\n### Avoid scan seeks\n\nWhen columns are selected explicitly with `scan.addColumn`, HBase will schedule seek operations to seek between the selected columns. When rows have few columns and each column has only a few versions this can be inefficient. A seek operation is generally slower if does not seek at least past 5-10 columns/versions or 512-1024 bytes.\n\nIn order to opportunistically look ahead a few columns/versions to see if the next column/version can be found that way before a seek operation is scheduled, a new attribute `Scan.HINT_LOOKAHEAD` can be set on the Scan object. The following code instructs the RegionServer to attempt two iterations of next before a seek is scheduled:\n\n```java\nScan scan = new Scan();\nscan.addColumn(...);\nscan.setAttribute(Scan.HINT_LOOKAHEAD, Bytes.toBytes(2));\ntable.getScanner(scan);\n```\n\n### MapReduce - Input Splits\n\nFor MapReduce jobs that use HBase tables as a source, if there a pattern where the \"slow\" map tasks seem to have the same Input Split (i.e., the RegionServer serving the data), see the Troubleshooting Case Study in [Case Study #1 (Performance Issue On A Single Node)](/docs/case-studies#case-study-1-performance-issue-on-a-single-node).\n\n### Close ResultScanners\n\nThis isn't so much about improving performance but rather *avoiding* performance problems. If you forget to close [ResultScanners](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ResultScanner.html) you can cause problems on the RegionServers. Always have ResultScanner processing enclosed in try/catch blocks.\n\n```java\nScan scan = new Scan();\n// set attrs...\nResultScanner rs = table.getScanner(scan);\ntry {\n  for (Result r = rs.next(); r != null; r = rs.next()) {\n    // process result...\n  }\n} finally {\n  rs.close();  // always close the ResultScanner!\n}\ntable.close();\n```\n\n### Block Cache\n\n[Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) instances can be set to use the block cache in the RegionServer via the `setCacheBlocks` method. For input Scans to MapReduce jobs, this should be `false`. For frequently accessed rows, it is advisable to use the block cache.\n\nCache more data by moving your Block Cache off-heap. See [Off-heap Block Cache](/docs/architecture/regionserver#off-heap-block-cache)\n\n### Optimal Loading of Row Keys\n\nWhen performing a table [scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) where only the row keys are needed (no families, qualifiers, values or timestamps), add a FilterList with a `MUST_PASS_ALL` operator to the scanner using `setFilter`. The filter list should include both a [FirstKeyOnlyFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html) and a [KeyOnlyFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/KeyOnlyFilter.html). Using this filter combination will result in a worst case scenario of a RegionServer reading a single value from disk and minimal network traffic to the client for a single row.\n\n### Concurrency: Monitor Data Spread\n\nWhen performing a high number of concurrent reads, monitor the data spread of the target tables. If the target table(s) have too few regions then the reads could likely be served from too few nodes.\n\nSee [Table Creation: Pre-Creating Regions](/docs/performance#table-creation-pre-creating-regions), as well as [HBase Configurations](/docs/performance#hbase-configurations)\n\n### Bloom Filters\n\nEnabling Bloom Filters can save your having to go to disk and can help improve read latencies.\n\n[Bloom filters](http://en.wikipedia.org/wiki/Bloom_filter) were developed over in [HBase-1200 Add bloomfilters](https://issues.apache.org/jira/browse/HBASE-1200). For description of the development process — why static blooms rather than dynamic — and for an overview of the unique properties that pertain to blooms in HBase, as well as possible future directions, see the *Development Process* section of the document [BloomFilters in HBase](https://issues.apache.org/jira/secure/attachment/12444007/Bloom_Filters_in_HBase.pdf) attached to [HBASE-1200](https://issues.apache.org/jira/browse/HBASE-1200). The bloom filters described here are actually version two of blooms in HBase. In versions up to 0.19.x, HBase had a dynamic bloom option based on work done by the [European Commission One-Lab Project 034819](http://www.onelab.org). The core of the HBase bloom work was later pulled up into Hadoop to implement org.apache.hadoop.io.BloomMapFile. Version 1 of HBase blooms never worked that well. Version 2 is a rewrite from scratch though again it starts with the one-lab work.\n\nSee also [Bloom Filters](/docs/performance#bloom-filters).\n\n#### Bloom StoreFile footprint\n\nBloom filters add an entry to the `StoreFile` general `FileInfo` data structure and then two extra entries to the `StoreFile` metadata section.\n\n**BloomFilter in the `StoreFile` `FileInfo` data structure**\\\n`FileInfo` has a `BLOOM_FILTER_TYPE` entry which is set to `NONE`, `ROW` or `ROWCOL.`\n\n**BloomFilter entries in `StoreFile` metadata**\\\n`BLOOM_FILTER_META` holds Bloom Size, Hash Function used, etc. It's small in size and is cached on `StoreFile.Reader` load.\\\n`BLOOM_FILTER_DATA` is the actual bloomfilter data. Obtained on-demand. Stored in the LRU cache, if it is enabled (It's enabled by default).\n\n#### Bloom Filter Configuration\n\n**`io.storefile.bloom.enabled` global kill switch**\\\n`io.storefile.bloom.enabled` in `Configuration` serves as the kill switch in case something goes wrong. Default = `true`.\n\n`io.storefile.bloom.error.rate`\\\n`io.storefile.bloom.error.rate` = average false positive rate. Default = 1%. Decrease rate by ½ (e.g. to .5%) == +1 bit per bloom entry.\n\n`io.storefile.bloom.max.fold`\\\n`io.storefile.bloom.max.fold` = guaranteed minimum fold rate. Most people should leave this alone. Default = 7, or can collapse to at least 1/128th of original size. See the *Development Process* section of the document [BloomFilters in HBase](https://issues.apache.org/jira/secure/attachment/12444007/Bloom_Filters_in_HBase.pdf) for more on what this option means.\n\n### Hedged Reads\n\nHedged reads are a feature of HDFS, introduced in Hadoop 2.4.0 with [HDFS-5776](https://issues.apache.org/jira/browse/HDFS-5776). Normally, a single thread is spawned for each read request. However, if hedged reads are enabled, the client waits some configurable amount of time, and if the read does not return, the client spawns a second read request, against a different block replica of the same data. Whichever read returns first is used, and the other read request is discarded.\n\nHedged reads are \"...very good at eliminating outlier datanodes, which in turn makes them very good choice for latency sensitive setups. But, if you are looking for maximizing throughput, hedged reads tend to create load amplification as things get slower in general. In short, the thing to watch out for is the non-graceful performance degradation when you are running close a certain throughput threshold.\" (Quote from Ashu Pachauri in HBASE-17083).\n\nOther concerns to keep in mind while running with hedged reads enabled include:\n\n* They may lead to network congestion. See [HBASE-17083](https://issues.apache.org/jira/browse/HBASE-17083)\n* Make sure you set the thread pool large enough so as blocking on the pool does not become a bottleneck (Again see [HBASE-17083](https://issues.apache.org/jira/browse/HBASE-17083))\n\n(From Yu Li up in HBASE-17083)\n\nBecause an HBase RegionServer is a HDFS client, you can enable hedged reads in HBase, by adding the following properties to the RegionServer's hbase-site.xml and tuning the values to suit your environment.\n\n**Configuration for Hedged Reads**\n\n* `dfs.client.hedged.read.threadpool.size` - the number of threads dedicated to servicing hedged reads. If this is set to 0 (the default), hedged reads are disabled.\n* `dfs.client.hedged.read.threshold.millis` - the number of milliseconds to wait before spawning a second read thread.\n\n**Hedged Reads Configuration Example**\n\n```xml\n<property>\n  <name>dfs.client.hedged.read.threadpool.size</name>\n  <value>20</value>  <!-- 20 threads -->\n</property>\n<property>\n  <name>dfs.client.hedged.read.threshold.millis</name>\n  <value>10</value>  <!-- 10 milliseconds -->\n</property>\n```\n\nUse the following metrics to tune the settings for hedged reads on your cluster. See [HBase Metrics](/docs/operational-management/metrics-and-monitoring) for more information.\n\n**Metrics for Hedged Reads**\n\n* hedgedReadOps - the number of times hedged read threads have been triggered. This could indicate that read requests are often slow, or that hedged reads are triggered too quickly.\n* hedgeReadOpsWin - the number of times the hedged read thread was faster than the original thread. This could indicate that a given RegionServer is having trouble servicing requests.\n* hedgedReadOpsInCurThread - the number of times hedged read was rejected from executor and needed to fallback to be executed in current thread. This could indicate that current hedged read thread pool size is not appropriate.\n\n## Deleting from HBase\n\n### Using HBase Tables as Queues\n\nHBase tables are sometimes used as queues. In this case, special care must be taken to regularly perform major compactions on tables used in this manner. As is documented in [Data Model](/docs/datamodel), marking rows as deleted creates additional StoreFiles which then need to be processed on reads. Tombstones only get cleaned up with major compactions.\n\nSee also [Compaction](/docs/architecture/regions#compaction) and [Admin.majorCompact](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Admin.html#majorCompact\\(org.apache.hadoop.hbase.TableName\\)).\n\n### Delete RPC Behavior\n\nBe aware that `Table.delete(Delete)` doesn't use the writeBuffer. It will execute an RegionServer RPC with each invocation. For a large number of deletes, consider `Table.delete(List)`.\n\nSee [hbase.client.Delete](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#delete\\(org.apache.hadoop.hbase.client.Delete\\))\n\n## HDFS\n\nBecause HBase runs on [HDFS](/docs/architecture/hdfs) it is important to understand how it works and how it affects HBase.\n\n### Current Issues With Low-Latency Reads\n\nThe original use-case for HDFS was batch processing. As such, there low-latency reads were historically not a priority. With the increased adoption of Apache HBase this is changing, and several improvements are already in development. See the [Umbrella Jira Ticket for HDFS Improvements for HBase](https://issues.apache.org/jira/browse/HDFS-1599).\n\n### Leveraging local data\n\nSince Hadoop 1.0.0 (also 0.22.1, 0.23.1, CDH3u3 and HDP 1.0) via [HDFS-2246](https://issues.apache.org/jira/browse/HDFS-2246), it is possible for the DFSClient to take a \"short circuit\" and read directly from the disk instead of going through the DataNode when the data is local. What this means for HBase is that the RegionServers can read directly off their machine's disks instead of having to open a socket to talk to the DataNode, the former being generally much faster. See JD's [Performance Talk](http://files.meetup.com/1350427/hug_ebay_jdcryans.pdf). Also see [HBase, mail # dev - read short circuit](https://lists.apache.org/thread.html/ce2ce3a3bbd20806d0c017b2e7528e78a46ccb87c063831db051949d%401347548325%40%3Cdev.hbase.apache.org%3E) thread for more discussion around short circuit reads.\n\nTo enable \"short circuit\" reads, it will depend on your version of Hadoop. The original shortcircuit read patch was much improved upon in Hadoop 2 in [HDFS-347](https://issues.apache.org/jira/browse/HDFS-347). See [http://blog.cloudera.com/blog/2013/08/how-improved-short-circuit-local-reads-bring-better-performance-and-security-to-hadoop/](http://blog.cloudera.com/blog/2013/08/how-improved-short-circuit-local-reads-bring-better-performance-and-security-to-hadoop/) for details on the difference between the old and new implementations. See [Hadoop shortcircuit reads configuration page](http://archive.cloudera.com/cdh4/cdh/4/hadoop/hadoop-project-dist/hadoop-hdfs/ShortCircuitLocalReads.html) for how to enable the latter, better version of shortcircuit. For example, here is a minimal config. enabling short-circuit reads added to *hbase-site.xml*:\n\n```xml\n<property>\n  <name>dfs.client.read.shortcircuit</name>\n  <value>true</value>\n  <description>\n    This configuration parameter turns on short-circuit local reads.\n  </description>\n</property>\n<property>\n  <name>dfs.domain.socket.path</name>\n  <value>/home/stack/sockets/short_circuit_read_socket_PORT</value>\n  <description>\n    Optional.  This is a path to a UNIX domain socket that will be used for\n    communication between the DataNode and local HDFS clients.\n    If the string \"_PORT\" is present in this path, it will be replaced by the\n    TCP port of the DataNode.\n  </description>\n</property>\n```\n\nBe careful about permissions for the directory that hosts the shared domain socket; dfsclient will complain if open to other than the hbase user.\n\nIf you are running on an old Hadoop, one that is without [HDFS-347](https://issues.apache.org/jira/browse/HDFS-347) but that has [HDFS-2246](https://issues.apache.org/jira/browse/HDFS-2246), you must set two configurations. First, the hdfs-site.xml needs to be amended. Set the property `dfs.block.local-path-access.user` to be the *only* user that can use the shortcut. This has to be the user that started HBase. Then in hbase-site.xml, set `dfs.client.read.shortcircuit` to be `true`\n\nServices — at least the HBase RegionServers — will need to be restarted in order to pick up the new configurations.\n\n<Callout type=\"info\" title=\"dfs.client.read.shortcircuit.buffer.size\">\n  The default for this value is too high when running on a highly trafficked HBase. In HBase, if\n  this value has not been set, we set it down from the default of 1M to 128k (Since HBase 0.98.0 and\n  0.96.1). See [HBASE-8143 HBase on Hadoop 2 with local short circuit reads (ssr) causes\n  OOM](https://issues.apache.org/jira/browse/HBASE-8143). The Hadoop DFSClient in HBase will\n  allocate a direct byte buffer of this size for *each* block it has open; given HBase keeps its\n  HDFS files open all the time, this can add up quickly.\n</Callout>\n\n### Performance Comparisons of HBase vs. HDFS\n\nA fairly common question on the dist-list is why HBase isn't as performant as HDFS files in a batch context (e.g., as a MapReduce source or sink). The short answer is that HBase is doing a lot more than HDFS (e.g., reading the KeyValues, returning the most current row or specified timestamps, etc.), and as such HBase is 4-5 times slower than HDFS in this processing context. There is room for improvement and this gap will, over time, be reduced, but HDFS will always be faster in this use-case.\n\n## Amazon EC2\n\nPerformance questions are common on Amazon EC2 environments because it is a shared environment. You will not see the same throughput as a dedicated server. In terms of running tests on EC2, run them several times for the same reason (i.e., it's a shared environment and you don't know what else is happening on the server).\n\nIf you are running on EC2 and post performance questions on the dist-list, please state this fact up-front that because EC2 issues are practically a separate class of performance issues.\n\n## Collocating HBase and MapReduce\n\nIt is often recommended to have different clusters for HBase and MapReduce. A better qualification of this is: don't collocate an HBase that serves live requests with a heavy MR workload. OLTP and OLAP-optimized systems have conflicting requirements and one will lose to the other, usually the former. For example, short latency-sensitive disk reads will have to wait in line behind longer reads that are trying to squeeze out as much throughput as possible. MR jobs that write to HBase will also generate flushes and compactions, which will in turn invalidate blocks in the [Block Cache](/docs/architecture/regionserver#architecture-regionserver-block-cache).\n\nIf you need to process the data from your live HBase cluster in MR, you can ship the deltas with [CopyTable](/docs/operational-management/tools#copytable) or use replication to get the new data in real time on the OLAP cluster. In the worst case, if you really need to collocate both, set MR to use less Map and Reduce slots than you'd normally configure, possibly just one.\n\nWhen HBase is used for OLAP operations, it's preferable to set it up in a hardened way like configuring the ZooKeeper session timeout higher and giving more memory to the MemStores (the argument being that the Block Cache won't be used much since the workloads are usually long scans).\n\n## Case Studies\n\nFor Performance and Troubleshooting Case Studies, see [Apache HBase Case Studies](/docs/case-studies).\n\n\n# Profiler Servlet (/docs/profiler)\n## Background\n\n[HBASE-21926](https://issues.apache.org/jira/browse/HBASE-21926) introduced a new servlet that\nsupports integrated, on-demand profiling via the\n[Async Profiler](https://github.com/jvm-profiling-tools/async-profiler) project.\n\n## Prerequisites\n\nGo to the [Async Profiler Home Page](https://github.com/jvm-profiling-tools/async-profiler), download\na release appropriate for your platform, and install on every cluster host. If running a Linux\nkernel v4.6 or later, be sure to set proc variables as per the\n[Basic Usage](https://github.com/jvm-profiling-tools/async-profiler#basic-usage) section. Not doing\nso will result in flame graphs that contain no content.\n\nSet `ASYNC_PROFILER_HOME` in the environment (put it in hbase-env.sh) to the root directory of the\nasync-profiler install location, or pass it on the HBase daemon's command line as a system property\nas `-Dasync.profiler.home=/path/to/async-profiler`.\n\n## Usage\n\nOnce the prerequisites are satisfied, access to async-profiler is available by way of the HBase UI\nor direct interaction with the infoserver.\n\nExamples:\n\n* To collect 30 second CPU profile of current process (returns FlameGraph svg)\n  `curl http://localhost:16030/prof`\n* To collect 1 minute CPU profile of current process and output in tree format (html)\n  `curl http://localhost:16030/prof?output=tree&duration=60`\n* To collect 30 second heap allocation profile of current process (returns FlameGraph svg)\n  `curl http://localhost:16030/prof?event=alloc`\n* To collect lock contention profile of current process (returns FlameGraph svg)\n  `curl http://localhost:16030/prof?event=lock`\n\nThe following event types are supported by async-profiler. Use the 'event' parameter to specify. Default is 'cpu'. Not all operating systems will support all types.\n\nPerf events:\n\n* cpu\n* page-faults\n* context-switches\n* cycles\n* instructions\n* cache-references\n* cache-misses\n* branches\n* branch-misses\n* bus-cycles\n* L1-dcache-load-misses\n* LLC-load-misses\n* dTLB-load-misses\n\nJava events:\n\n* alloc\n* lock\n\nThe following output formats are supported. Use the 'output' parameter to specify. Default is 'flamegraph'.\n\nOutput formats:\n\n* summary: A dump of basic profiling statistics.\n* traces: Call traces.\n* flat: Flat profile (top N hot methods).\n* collapsed: Collapsed call traces in the format used by FlameGraph script. This is a collection of call stacks, where each line is a semicolon separated list of frames followed by a counter.\n* svg: FlameGraph in SVG format.\n* tree: Call tree in HTML format.\n* jfr: Call traces in Java Flight Recorder format.\n\nThe 'duration' parameter specifies how long to collect trace data before generating output, specified in seconds. The default is 10 seconds.\n\n## UI\n\nIn the UI, there is a new entry 'Profiler' in the top menu that will run the default action, which is to profile the CPU usage of the local process for thirty seconds and then produce FlameGraph SVG output.\n\n## Notes\n\nThe query parameter `pid` can be used to specify the process id of a specific process to be profiled. If this parameter is missing the local process in which the infoserver is embedded will be profiled. Profile targets that are not JVMs might work but is not specifically supported. There are security implications. Access to the infoserver should be appropriately restricted.\n\n\n# Protobuf in HBase (/docs/protobuf)\n## Protobuf\n\nHBase uses Google's [protobufs](https://developers.google.com/protocol-buffers/) wherever\nit persists metadata — in the tail of hfiles or Cells written by\nHBase into the system hbase:meta table or when HBase writes znodes\nto zookeeper, etc. — and when it passes objects over the wire making\n[RPCs](/docs/rpc). HBase uses protobufs to describe the RPC\nInterfaces (Services) we expose to clients, for example the `Admin` and `Client`\nInterfaces that the RegionServer fields,\nor specifying the arbitrary extensions added by developers via our\n[Coprocessor Endpoint](/docs/cp) mechanism.\n\nWith protobuf, you describe serializations and services in a `.protos` file.\nYou then feed these descriptors to a protobuf tool, the `protoc` binary,\nto generate classes that can marshall and unmarshall the described serializations\nand field the specified Services.\n\nSee the `README.txt` in the HBase sub-modules for details on how\nto run the class generation on a per-module basis;\ne.g. see `hbase-protocol/README.txt` for how to generate protobuf classes\nin the hbase-protocol module.\n\nIn HBase, `.proto` files are either in the `hbase-protocol` module; a module\ndedicated to hosting the common proto files and the protoc generated classes\nthat HBase uses internally serializing metadata. For extensions to hbase\nsuch as REST or Coprocessor Endpoints that need their own descriptors; their\nprotos are located inside the function's hosting module: e.g. `hbase-rest`\nis home to the REST proto files and the `hbase-rsgroup` table grouping\nCoprocessor Endpoint has all protos that have to do with table grouping.\n\nProtos are hosted by the module that makes use of them. While\nthis makes it so generation of protobuf classes is distributed, done\nper module, we do it this way so modules encapsulate all to do with\nthe functionality they bring to hbase.\n\nExtensions whether REST or Coprocessor Endpoints will make use\nof core HBase protos found back in the hbase-protocol module. They'll\nuse these core protos when they want to serialize a Cell or a Put or\nrefer to a particular node via ServerName, etc., as part of providing the\nCPEP Service. Going forward, after the release of hbase-2.0.0, this\npractice needs to whither. We'll explain why in the later\n[hbase-2.0.0](/docs/protobuf#hbase-200-and-the-shading-of-protobufs-hbase-15638) section.\n\n### hbase-2.0.0 and the shading of protobufs (HBASE-15638)\n\nAs of hbase-2.0.0, our protobuf usage gets a little more involved. HBase\ncore protobuf references are offset so as to refer to a private,\nbundled protobuf. Core stops referring to protobuf\nclasses at com.google.protobuf.\\_ and instead references protobuf at\nthe HBase-specific offset\norg.apache.hadoop.hbase.shaded.com.google.protobuf.\\_. We do this indirection\nso hbase core can evolve its protobuf version independent of whatever our\ndependencies rely on. For instance, HDFS serializes using protobuf.\nHDFS is on our CLASSPATH. Without the above described indirection, our\nprotobuf versions would have to align. HBase would be stuck\non the HDFS protobuf version until HDFS decided to upgrade. HBase\nand HDFS versions would be tied.\n\nWe had to move on from protobuf-2.5.0 because we need facilities\nadded in protobuf-3.1.0; in particular being able to save on\ncopies and avoiding bringing protobufs onheap for\nserialization/deserialization.\n\nIn hbase-2.0.0, we introduced a new module, `hbase-protocol-shaded`\ninside which we contained all to do with protobuf and its subsequent\nrelocation/shading. This module is in essence a copy of much of the old\n`hbase-protocol` but with an extra shading/relocation step.\nCore was moved to depend on this new module.\n\nThat said, a complication arises around Coprocessor Endpoints (CPEPs).\nCPEPs depend on public HBase APIs that reference protobuf classes at\n`com.google.protobuf.*` explicitly. For example, in our Table Interface\nwe have the below as the means by which you obtain a CPEP Service\nto make invocations against:\n\n```java\n...\n  <T extends com.google.protobuf.Service,R> Map<byte[],R> coprocessorService(\n   Class<T> service, byte[] startKey, byte[] endKey,\n     org.apache.hadoop.hbase.client.coprocessor.Batch.Call<T,R> callable)\n  throws com.google.protobuf.ServiceException, Throwable\n```\n\nExisting CPEPs will have made reference to core HBase protobufs\nspecifying ServerNames or carrying Mutations.\nSo as to continue being able to service CPEPs and their references\nto `com.google.protobuf.*` across the upgrade to hbase-2.0.0 and beyond,\nHBase needs to be able to deal with both\n`com.google.protobuf.*` references and its internal offset\n`org.apache.hadoop.hbase.shaded.com.google.protobuf.*` protobufs.\n\nThe `hbase-protocol-shaded` module hosts all\nprotobufs used by HBase core.\n\nBut for the vestigial CPEP references to the (non-shaded) content of\n`hbase-protocol`, we keep around most of this module going forward\njust so it is available to CPEPs. Retaining the most of `hbase-protocol`\nmakes for overlapping, 'duplicated' proto instances where some exist as\nnon-shaded/non-relocated here in their old module\nlocation but also in the new location, shaded under\n`hbase-protocol-shaded`. In other words, there is an instance\nof the generated protobuf class\n`org.apache.hadoop.hbase.protobuf.generated.ServerName`\nin hbase-protocol and another generated instance that is the same in all\nregards except its protobuf references are to the internal shaded\nversion at `org.apache.hadoop.hbase.shaded.protobuf.generated.ServerName`\n(note the 'shaded' addition in the middle of the package name).\n\nIf you extend a proto in `hbase-protocol-shaded` for internal use,\nconsider extending it also in\n`hbase-protocol` (and regenerating).\n\nGoing forward, we will provide a new module of common types for use\nby CPEPs that will have the same guarantees against change as does our\npublic API. TODO.\n\n### protobuf changes for hbase-3.0.0 (HBASE-23797)\n\nSince hadoop(start from 3.3.x) also shades protobuf and bumps the version to\n3.x, there is no reason for us to stay on protobuf 2.5.0 any more.\n\nIn HBase 3.0.0, the hbase-protocol module has been purged, the CPEP\nimplementation should use the protos in hbase-protocol-shaded module, and also\nmake use of the shaded protobuf in hbase-thirdparty. In general, we will keep\nthe protobuf version compatible for a whole major release, unless there are\ncritical problems, for example, a critical CVE on protobuf.\n\nAdd this dependency to your pom:\n\n```xml\n<dependency>\n  <groupId>org.apache.hbase.thirdparty</groupId>\n  <artifactId>hbase-shaded-protobuf</artifactId>\n  <!-- use the version that your target hbase cluster uses -->\n  <version>${hbase-thirdparty.version}</version>\n  <scope>provided</scope>\n</dependency>\n```\n\nAnd typically you also need to add this plugin to your pom to make your\ngenerated protobuf code also use the shaded and relocated protobuf version\nin hbase-thirdparty.\n\n```xml\n<plugin>\n  <groupId>com.google.code.maven-replacer-plugin</groupId>\n  <artifactId>replacer</artifactId>\n  <version>1.5.3</version>\n  <executions>\n    <execution>\n      <phase>process-sources</phase>\n      <goals>\n        <goal>replace</goal>\n      </goals>\n    </execution>\n  </executions>\n  <configuration>\n    <basedir>${basedir}/target/generated-sources/</basedir>\n      <includes>\n        <include>**/*.java</include>\n      </includes>\n      <!-- Ignore errors when missing files, because it means this build\n           was run with -Dprotoc.skip and there is no -Dreplacer.skip -->\n      <ignoreErrors>true</ignoreErrors>\n      <replacements>\n        <replacement>\n          <token>([^\\.])com.google.protobuf</token>\n          <value>$1org.apache.hbase.thirdparty.com.google.protobuf</value>\n        </replacement>\n        <replacement>\n          <token>(public)(\\W+static)?(\\W+final)?(\\W+class)</token>\n          <value>@javax.annotation.Generated(\"proto\") $1$2$3$4</value>\n        </replacement>\n        <!-- replacer doesn't support anchoring or negative lookbehind -->\n        <replacement>\n          <token>(@javax.annotation.Generated\\(\"proto\"\\) ){2}</token>\n          <value>$1</value>\n        </replacement>\n      </replacements>\n  </configuration>\n</plugin>\n```\n\nIn hbase-examples module, we have some examples under the\n`org.apache.hadoop.hbase.coprocessor.example` package. You can see\n`BulkDeleteEndpoint` and `BulkDelete.proto` for more details, and you can also\ncheck the `pom.xml` of hbase-examples module to see how to make use of the above\nplugin.\n\n\n# Procedure Framework (PV2) (/docs/pv2)\nSee [HBASE-12439](https://issues.apache.org/jira/browse/HBASE-12439) for the original implementation.\n\nWith Pv2 you can build and run state machines. It was built by Matteo to make distributed state transitions in HBase resilient in the face of process failures. Previous to Pv2, state transition handling was spread about the codebase with implementation varying by transition-type and context. Pv2 was inspired by [FATE](https://accumulo.apache.org/1.8/accumulo_user_manual.html#_fault_tolerant_executor_fate), of Apache Accumulo.\n\nEarly Pv2 aspects have been shipping in HBase with a good while now but it has continued to evolve as it takes on more involved scenarios. What we have now is powerful but intricate in operation and incomplete, in need of cleanup and hardening. In this doc we have given overview on the system so you can make use of it (and help with its polishing).\n\nThis system has the awkward name of Pv2 because HBase already had the notion of a Procedure used in snapshots (see hbase-server *org.apache.hadoop.hbase.procedure* as opposed to hbase-procedure *org.apache.hadoop.hbase.procedure2*). Pv2 supercedes and is to replace Procedure.\n\n## Procedures\n\nA Procedure is a transform made on an HBase entity. Examples of HBase entities would be Regions and Tables.\nProcedures are run by a ProcedureExecutor instance. Procedure current state is kept in the ProcedureStore.\nThe ProcedureExecutor has but a primitive view on what goes on inside a Procedure. From its PoV, Procedures are submitted and then the ProcedureExecutor keeps calling *#execute(Object)* until the Procedure is done. Execute may be called multiple times in the case of failure or restart, so Procedure code must be idempotent yielding the same result each time it run. Procedure code can also implement *rollback* so steps can be undone if failure. A call to *execute()* can result in one of following possibilities:\n\n* *execute()* returns\n  * *null*: indicates we are done.\n  * *this*: indicates there is more to do so, persist current procedure state and re-*execute()*.\n  * *Array* of sub-procedures: indicates a set of procedures needed to be run to completion before we can proceed (after which we expect the framework to call our execute again).\n* *execute()* throws exception\n  * *suspend*: indicates execution of procedure is suspended and can be resumed due to some external event. The procedure state is persisted.\n  * *yield*: procedure is added back to scheduler. The procedure state is not persisted.\n  * *interrupted*: currently same as *yield*.\n  * Any *exception* not listed above: Procedure *state* is changed to *FAILED* (after which we expect the framework will attempt rollback).\n\nThe ProcedureExecutor stamps the frameworks notions of Procedure State into the Procedure itself; e.g. it marks Procedures as INITIALIZING on submit. It moves the state to RUNNABLE when it goes to execute. When done, a Procedure gets marked FAILED or SUCCESS depending. Here is the list of all states as of this writing:\n\n* ***INITIALIZING*** Procedure in construction, not yet added to the executor\n* ***RUNNABLE*** Procedure added to the executor, and ready to be executed.\n* ***WAITING*** The procedure is waiting on children (subprocedures) to be completed\n* ***WAITING\\_TIMEOUT*** The procedure is waiting a timeout or an external event\n* ***ROLLEDBACK*** The procedure failed and was rolledback.\n* ***SUCCESS*** The procedure execution completed successfully.\n* ***FAILED*** The procedure execution failed, may need to rollback.\n\nAfter each execute, the Procedure state is persisted to the ProcedureStore. Hooks are invoked on Procedures so they can preserve custom state. Post-fault, the ProcedureExecutor re-hydrates its pre-crash state by replaying the content of the ProcedureStore. This makes the Procedure Framework resilient against process failure.\n\n### Implementation\n\nIn implementation, Procedures tend to divide transforms into finer-grained tasks and while some of these work items are handed off to sub-procedures,\nthe bulk are done as processing *steps* in-Procedure; each invocation of the execute is used to perform a single step, and then the Procedure relinquishes returning to the framework. The Procedure does its own tracking of where it is in the processing.\n\nWhat comprises a sub-task, or *step* in the execution is up to the Procedure author but generally it is a small piece of work that cannot be further decomposed and that moves the processing forward toward its end state. Having procedures made of many small steps rather than a few large ones allows the Procedure framework give out insight on where we are in the processing. It also allows the framework be more fair in its execution. As stated per above, each step may be called multiple times (failure/restart) so steps must be implemented idempotent.\nIt is easy to confuse the state that the Procedure itself is keeping with that of the Framework itself. Try to keep them distinct.\n\n### Rollback\n\nRollback is called when the procedure or one of the sub-procedures has failed. The rollback step is supposed to cleanup the resources created during the execute() step. In case of failure and restart, rollback() may be called multiple times, so again the code must be idempotent.\n\n### Metrics\n\nThere are hooks for collecting metrics on submit of the procedure and on finish.\n\n* updateMetricsOnSubmit()\n* updateMetricsOnFinish()\n\nIndividual procedures can override these methods to collect procedure specific metrics. The default implementations of these methods try to get an object implementing an interface ProcedureMetrics which encapsulates following set of generic metrics:\n\n* SubmittedCount (Counter): Total number of procedure instances submitted of a type.\n* Time (Histogram): Histogram of runtime for procedure instances.\n* FailedCount (Counter): Total number of failed procedure instances.\n\nIndividual procedures can implement this object and define these generic set of metrics.\n\n### Baggage\n\nProcedures can carry baggage. One example is the *step* the procedure last attained (see previous section); procedures persist the enum that marks where they are currently. Other examples might be the Region or Server name the Procedure is currently working. After each call to execute, the Procedure#serializeStateData is called. Procedures can persist whatever.\n\n### Result/State and Queries\n\n(From Matteo's [ProcedureV2 and Notification Bus](https://issues.apache.org/jira/secure/attachment/12693273/Procedurev2Notification-Bus.pdf) doc)\\\nIn the case of asynchronous operations, the result must be kept around until the client asks for it. Once we receive a \"get\" of the result we can schedule the delete of the record. For some operations the result may be \"unnecessary\" especially in case of failure (e.g. if the create table fail, we can query the operation result or we can just do a list table to see if it was created) so in some cases we can schedule the delete after a timeout. On the client side the operation will return a \"Procedure ID\", this ID can be used to wait until the procedure is completed and get the result/exception.\n\n```\nAdmin.doOperation() { longprocId=master.doOperation(); master.waitCompletion(procId); }\n```\n\nIf the master goes down while performing the operation the backup master will pickup the half in­progress operation and complete it. The client will not notice the failure.\n\n## Subprocedures\n\nSubprocedures are *Procedure* instances created and returned by *#execute(Object)* method of a procedure instance (parent procedure). As subprocedures are of type *Procedure*, they can instantiate their own subprocedures. As its a recursive, procedure stack is maintained by the framework. The framework makes sure that the parent procedure does not proceed till all sub-procedures and their subprocedures in a procedure stack are successfully finished.\n\n## ProcedureExecutor\n\n*ProcedureExecutor* uses *ProcedureStore* and *ProcedureScheduler* and executes procedures submitted to it. Some of the basic operations supported are:\n\n* *abort(procId)*: aborts specified procedure if its not finished\n* *submit(Procedure)*: submits procedure for execution\n* *retrieve:* list of get methods to get *Procedure* instances and results\n* *register/ unregister* listeners: for listening on Procedure related notifications\n\nWhen *ProcedureExecutor* starts it loads procedure instances persisted in *ProcedureStore* from previous run. All unfinished procedures are resumed from the last stored state.\n\n## Nonces\n\nYou can pass the nonce that came in with the RPC to the Procedure on submit at the executor. This nonce will then be serialized along w/ the Procedure on persist. If a crash, on reload, the nonce will be put back into a map of nonces to pid in case a client tries to run same procedure for a second time (it will be rejected). See the base Procedure and how nonce is a base data member.\n\n## Wait/Wake/Suspend/Yield\n\n'suspend' means stop processing a procedure because we can make no more progress until a condition changes; i.e. we sent RPC and need to wait on response. The way this works is that a Procedure throws a suspend exception from down in its guts as a GOTO the end-of-the-current-processing step. Suspend also puts the Procedure back on the scheduler. Problematic is we do some accounting on our way out even on suspend making it so it can take time exiting (We have to update state in the WAL).\n\nRegionTransitionProcedure#reportTransition is called on receipt of a report from a RS. For Assign and Unassign, this event response from the server we sent an RPC wakes up suspended Assign/Unassigns.\n\n## Locking\n\nProcedure Locks are not about concurrency! They are about giving a Procedure read/write access to an HBase Entity such as a Table or Region so that is possible to shut out other Procedures from making modifications to an HBase Entity state while the current one is running.\n\nLocking is optional, up to the Procedure implementor but if an entity is being operated on by a Procedure, all transforms need to be done via Procedures using the same locking scheme else havoc.\n\nTwo ProcedureExecutor Worker threads can actually end up both processing the same Procedure instance. If it happens, the threads are meant to be running different parts of the one Procedure — changes that do not stamp on each other (This gets awkward around the procedure frameworks notion of ‘suspend'. More on this below).\n\nLocks optionally may be held for the life of a Procedure. For example, if moving a Region, you probably want to have exclusive access to the HBase Region until the Region completes (or fails). This is used in conjunction with \\{@link #holdLock(Object)}. If \\{@link #holdLock(Object)} returns true, the procedure executor will call acquireLock() once and thereafter not call \\{@link #releaseLock(Object)} until the Procedure is done (Normally, it calls release/acquire around each invocation of \\{@link #execute(Object)}.\n\nLocks also may live the life of a procedure; i.e. once an Assign Procedure starts, we do not want another procedure meddling w/ the region under assignment. Procedures that hold the lock for the life of the procedure set Procedure#holdLock to true. AssignProcedure does this as do Split and Move (If in the middle of a Region move, you do not want it Splitting).\n\nLocking can be for life of Procedure.\n\nSome locks have a hierarchy. For example, taking a region lock also takes (read) lock on its containing table and namespace to prevent another Procedure obtaining an exclusive lock on the hosting table (or namespace).\n\n## Procedure Types\n\n### StateMachineProcedure\n\nOne can consider each call to *#execute(Object)* method as transitioning from one state to another in a state machine. Abstract class *StateMachineProcedure* is wrapper around base *Procedure* class which provides constructs for implementing a state machine as a *Procedure*. After each state transition current state is persisted so that, in case of crash/ restart, the state transition can be resumed from the previous state of a procedure before crash/ restart. Individual procedures need to define initial and terminus states and hooks *executeFromState()* and *setNextState()* are provided for state transitions.\n\n### RemoteProcedureDispatcher\n\nA new RemoteProcedureDispatcher (+ subclass RSProcedureDispatcher) primitive takes care of running the Procedure-based Assignments 'remote' component. This dispatcher knows about 'servers'. It does aggregation of assignments by time on a time/count basis so can send procedures in batches rather than one per RPC. Procedure status comes back on the back of the RegionServer heartbeat reporting online/offline regions (No more notifications via ZK). The response is passed to the AMv2 to 'process'. It will check against the in-memory state. If there is a mismatch, it fences out the RegionServer on the assumption that something went wrong on the RS side. Timeouts trigger retries (Not Yet Implemented!). The Procedure machine ensures only one operation at a time on any one Region/Table using entity *locking* and smarts about what is serial and what can be run concurrently (Locking was zk-based — you'd put a znode in zk for a table — but now has been converted to be procedure-based as part of this project).\n\n## References\n\n* Matteo had a slide deck on what it the Procedure Framework would look like and the problems it addresses initially [attached to the Pv2 issue.](https://issues.apache.org/jira/secure/attachment/12845124/ProcedureV2b.pdf)\n* [A good doc by Matteo](https://issues.apache.org/jira/secure/attachment/12693273/Procedurev2Notification-Bus.pdf) on problem and how Pv2 addresses it w/ roadmap (from the Pv2 JIRA). We should go back to the roadmap to do the Notification Bus, convertion of log splitting to Pv2, etc.\n\n\n# RegionServer Sizing Rules of Thumb (/docs/regionserver-sizing)\nLars Hofhansl wrote a great [blog post](http://hadoop-hbase.blogspot.com/2013/01/hbase-region-server-memory-sizing.html) about RegionServer memory sizing. The upshot is that you probably need more memory than you think you need. He goes into the impact of region size, memstore size, HDFS replication factor, and other things to check.\n\n> Personally I would place the maximum disk space per machine that can be served exclusively with HBase around 6T, unless you have a very read-heavy workload. In that case the Java heap should be 32GB (20G regions, 128M memstores, the rest defaults).\n>\n> — Lars Hofhansl [http://hadoop-hbase.blogspot.com/2013/01/hbase-region-server-memory-sizing.html](http://hadoop-hbase.blogspot.com/2013/01/hbase-region-server-memory-sizing.html)\n\n## On the number of column families\n\nHBase currently does not do well with anything above two or three column families so keep the number of column families in your schema low. Currently, flushing is done on a per Region basis so if one column family is carrying the bulk of the data bringing on flushes, the adjacent families will also be flushed even though the amount of data they carry is small. When many column families exist the flushing interaction can make for a bunch of needless i/o (To be addressed by changing flushing to work on a per column family basis). In addition, compactions triggered at table/region level will happen per store too.\n\nTry to make do with one column family if you can in your schemas. Only introduce a second and third column family in the case where data access is usually column scoped; i.e. you query one column family or the other but usually not both at the one time.\n\n### Cardinality of ColumnFamilies\n\nWhere multiple ColumnFamilies exist in a single table, be aware of the cardinality (i.e., number of rows). If ColumnFamilyA has 1 million rows and ColumnFamilyB has 1 billion rows, ColumnFamilyA's data will likely be spread across many, many regions (and RegionServers). This makes mass scans for ColumnFamilyA less efficient.\n\n## Rowkey Design\n\n### Hotspotting\n\nRows in HBase are sorted lexicographically by row key. This design optimizes for scans, allowing you to store related rows, or rows that will be read together, near each other. However, poorly designed row keys are a common source of **hotspotting**. Hotspotting occurs when a large amount of client traffic is directed at one node, or only a few nodes, of a cluster. This traffic may represent reads, writes, or other operations. The traffic overwhelms the single machine responsible for hosting that region, causing performance degradation and potentially leading to region unavailability. This can also have adverse effects on other regions hosted by the same region server as that host is unable to service the requested load. It is important to design data access patterns such that the cluster is fully and evenly utilized.\n\nTo prevent hotspotting on writes, design your row keys such that rows that truly do need to be in the same region are, but in the bigger picture, data is being written to multiple regions across the cluster, rather than one at a time. Some common techniques for avoiding hotspotting are described below, along with some of their advantages and drawbacks.\n\n#### Salting \\[!toc]\n\nSalting in this sense has nothing to do with cryptography, but refers to adding random data to the start of a row key. In this case, salting refers to adding a randomly-assigned prefix to the row key to cause it to sort differently than it otherwise would. The number of possible prefixes correspond to the number of regions you want to spread the data across. Salting can be helpful if you have a few \"hot\" row key patterns which come up over and over amongst other more evenly-distributed rows. Consider the following example, which shows that salting can spread write load across multiple RegionServers, and illustrates some of the negative implications for reads.\n\n#### Salting Example: \\[!toc]\n\nSuppose you have the following list of row keys, and your table is split such that there is one region for each letter of the alphabet. Prefix 'a' is one region, prefix 'b' is another. In this table, all rows starting with 'f' are in the same region. This example focuses on rows with keys like the following:\n\n```text\nfoo0001\nfoo0002\nfoo0003\nfoo0004\n```\n\nNow, imagine that you would like to spread these across four different regions. You decide to use four different salts: `a`, `b`, `c`, and `d`. In this scenario, each of these letter prefixes will be on a different region. After applying the salts, you have the following rowkeys instead. Since you can now write to four separate regions, you theoretically have four times the throughput when writing that you would have if all the writes were going to the same region.\n\n```text\na-foo0003\nb-foo0001\nc-foo0004\nd-foo0002\n```\n\nThen, if you add another row, it will randomly be assigned one of the four possible salt values and end up near one of the existing rows.\n\n```text\na-foo0003\nb-foo0001\nc-foo0003\nc-foo0004\nd-foo0002\n```\n\nSince this assignment will be random, you will need to do more work if you want to retrieve the rows in lexicographic order. In this way, salting attempts to increase throughput on writes, but has a cost during reads.\n\n#### Hashing \\[!toc]\n\nInstead of a random assignment, you could use a one-way **hash** that would cause a given row to always be \"salted\" with the same prefix, in a way that would spread the load across the RegionServers, but allow for predictability during reads. Using a deterministic hash allows the client to reconstruct the complete rowkey and use a Get operation to retrieve that row as normal.\n\n#### Hashing Example: \\[!toc]\n\nGiven the same situation in the salting example above, you could instead apply a one-way hash that would cause the row with key `foo0003` to always, and predictably, receive the `a` prefix. Then, to retrieve that row, you would already know the key. You could also optimize things so that certain pairs of keys were always in the same region, for instance.\n\n#### Reversing the Key \\[!toc]\n\nA third common trick for preventing hotspotting is to reverse a fixed-width or numeric row key so that the part that changes the most often (the least significant digit) is first. This effectively randomizes row keys, but sacrifices row ordering properties.\n\nSee [https://communities.intel.com/community/itpeernetwork/datastack/blog/2013/11/10/discussion-on-designing-hbase-tables](https://communities.intel.com/community/itpeernetwork/datastack/blog/2013/11/10/discussion-on-designing-hbase-tables), and [article on Salted Tables](https://phoenix.apache.org/salted.html) from the Phoenix project, and the discussion in the comments of [HBASE-11682](https://issues.apache.org/jira/browse/HBASE-11682) for more information about avoiding hotspotting.\n\n### Monotonically Increasing Row Keys/Timeseries Data\n\nIn the HBase chapter of Tom White's book [Hadoop: The Definitive Guide](http://oreilly.com/catalog/9780596521981) (O'Reilly) there is a an optimization note on watching out for a phenomenon where an import process walks in lock-step with all clients in concert pounding one of the table's regions (and thus, a single node), then moving onto the next region, etc. With monotonically increasing row-keys (i.e., using a timestamp), this will happen. See this comic by IKai Lan on why monotonically increasing row keys are problematic in BigTable-like datastores: [monotonically increasing values are bad](http://ikaisays.com/2011/01/25/app-engine-datastore-tip-monotonically-increasing-values-are-bad/). The pile-up on a single region brought on by monotonically increasing keys can be mitigated by randomizing the input records to not be in sorted order, but in general it's best to avoid using a timestamp or a sequence (e.g. 1, 2, 3) as the row-key.\n\nIf you do need to upload time series data into HBase, you should study [OpenTSDB](http://opentsdb.net/) as a successful example. It has a page describing the [schema](http://opentsdb.net/schema.html) it uses in HBase. The key format in OpenTSDB is effectively \\[metric\\_type]\\[event\\_timestamp], which would appear at first glance to contradict the previous advice about not using a timestamp as the key. However, the difference is that the timestamp is not in the *lead* position of the key, and the design assumption is that there are dozens or hundreds (or more) of different metric types. Thus, even with a continual stream of input data with a mix of metric types, the Puts are distributed across various points of regions in the table.\n\nSee [schema.casestudies](/docs/regionserver-sizing#schema-design-case-studies) for some rowkey design examples.\n\n### Try to minimize row and column sizes\n\nIn HBase, values are always freighted with their coordinates; as a cell value passes through the system, it'll be accompanied by its row, column name, and timestamp - always. If your rows and column names are large, especially compared to the size of the cell value, then you may run up against some interesting scenarios. One such is the case described by Marc Limotte at the tail of [HBASE-3551](https://issues.apache.org/jira/browse/HBASE-3551?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel\\&focusedCommentId=13005272#comment-13005272) (recommended!). Therein, the indices that are kept on HBase storefiles (see [HFile Format](/docs/hfile-format)) to facilitate random access may end up occupying large chunks of the HBase allotted RAM because the cell value coordinates are large. Mark in the above cited comment suggests upping the block size so entries in the store file index happen at a larger interval or modify the table schema so it makes for smaller rows and column names. Compression will also make for larger indices. See the thread [a question storefileIndexSize](https://lists.apache.org/thread.html/b158eae5d8888d3530be378298bca90c17f80982fdcdfa01d0844c3d%401306240189%40%3Cuser.hbase.apache.org%3E) up on the user mailing list.\n\nMost of the time small inefficiencies don't matter all that much. Unfortunately, this is a case where they do. Whatever patterns are selected for ColumnFamilies, attributes, and rowkeys they could be repeated several billion times in your data.\n\nSee [keyvalue](/docs/architecture/regions#keyvalue) for more information on HBase stores data internally to see why this is important.\n\n#### Column Families\n\nTry to keep the ColumnFamily names as small as possible, preferably one character (e.g. \"d\" for data/default).\n\nSee [KeyValue](/docs/architecture/regions#keyvalue) for more information on how HBase stores data internally.\n\n#### Attributes\n\nAlthough verbose attribute names (e.g., \"myVeryImportantAttribute\") are easier to read, prefer shorter attribute names (e.g., \"via\") to store in HBase.\n\nSee [keyvalue](/docs/architecture/regions#keyvalue) for more information on HBase stores data internally to see why this is important.\n\n#### Rowkey Length\n\nKeep them as short as is reasonable such that they can still be useful for required data access (e.g. Get vs. Scan). A short key that is useless for data access is not better than a longer key with better get/scan properties. Expect tradeoffs when designing rowkeys.\n\n#### Byte Patterns\n\nA long is 8 bytes. You can store an unsigned number up to 18,446,744,073,709,551,615 in those eight bytes. If you stored this number as a String — presuming a byte per character — you need nearly 3x the bytes.\n\nNot convinced? Below is some sample code that you can run on your own.\n\n```java\n// long\n//\nlong l = 1234567890L;\nbyte[] lb = Bytes.toBytes(l);\nSystem.out.println(\"long bytes length: \" + lb.length);   // returns 8\n\nString s = String.valueOf(l);\nbyte[] sb = Bytes.toBytes(s);\nSystem.out.println(\"long as string length: \" + sb.length);    // returns 10\n\n// hash\n//\nMessageDigest md = MessageDigest.getInstance(\"MD5\");\nbyte[] digest = md.digest(Bytes.toBytes(s));\nSystem.out.println(\"md5 digest bytes length: \" + digest.length);    // returns 16\n\nString sDigest = new String(digest);\nbyte[] sbDigest = Bytes.toBytes(sDigest);\nSystem.out.println(\"md5 digest as string length: \" + sbDigest.length);    // returns 26\n```\n\nUnfortunately, using a binary representation of a type will make your data harder to read outside of your code. For example, this is what you will see in the shell when you increment a value:\n\n```bash\nhbase(main):001:0> incr 't', 'r', 'f:q', 1\nCOUNTER VALUE = 1\n\nhbase(main):002:0> get 't', 'r'\nCOLUMN                                        CELL\n f:q                                          timestamp=1369163040570, value=\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\n1 row(s) in 0.0310 seconds\n```\n\nThe shell makes a best effort to print a string, and it this case it decided to just print the hex. The same will happen to your row keys inside the region names. It can be okay if you know what's being stored, but it might also be unreadable if arbitrary data can be put in the same cells. This is the main trade-off.\n\n### Reverse Timestamps\n\n<Callout type=\"info\">\n  [HBASE-4811](https://issues.apache.org/jira/browse/HBASE-4811) implements an API to scan a table\n  or a range within a table in reverse, reducing the need to optimize your schema for forward or\n  reverse scanning. This feature is available in HBase 0.98 and later. See\n  [Scan.setReversed()](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html#setReversed\\(boolean\\))\n  for more information.\n</Callout>\n\nA common problem in database processing is quickly finding the most recent version of a value. A technique using reverse timestamps as a part of the key can help greatly with a special case of this problem. Also found in the HBase chapter of Tom White's book Hadoop: The Definitive Guide (O'Reilly), the technique involves appending (`Long.MAX_VALUE - timestamp`) to the end of any key, e.g. \\[key]\\[reverse\\_timestamp].\n\nThe most recent value for \\[key] in a table can be found by performing a Scan for \\[key] and obtaining the first record. Since HBase keys are in sorted order, this key sorts before any older row-keys for \\[key] and thus is first.\n\nThis technique would be used instead of using [Number of Versions](/docs/regionserver-sizing#number-of-versions) where the intent is to hold onto all versions \"forever\" (or a very long time) and at the same time quickly obtain access to any other version by using the same Scan technique.\n\n### Rowkeys and ColumnFamilies\n\nRowkeys are scoped to ColumnFamilies. Thus, the same rowkey could exist in each ColumnFamily that exists in a table without collision.\n\n### Immutability of Rowkeys\n\nRowkeys cannot be changed. The only way they can be \"changed\" in a table is if the row is deleted and then re-inserted. This is a fairly common question on the HBase dist-list so it pays to get the rowkeys right the first time (and/or before you've inserted a lot of data).\n\n### Relationship Between RowKeys and Region Splits\n\nIf you pre-split your table, it is *critical* to understand how your rowkey will be distributed across the region boundaries. As an example of why this is important, consider the example of using displayable hex characters as the lead position of the key (e.g., \"0000000000000000\" to \"ffffffffffffffff\"). Running those key ranges through `Bytes.split` (which is the split strategy used when creating regions in `Admin.createTable(byte[] startKey, byte[] endKey, numRegions)` for 10 regions will generate the following splits...\n\n```text\n48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48                                // 0\n54 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10                 // 6\n61 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -68                 // =\n68 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -126  // D\n75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 72                                // K\n82 18 18 18 18 18 18 18 18 18 18 18 18 18 18 14                                // R\n88 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -44                 // X\n95 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -102                // _\n102 102 102 102 102 102 102 102 102 102 102 102 102 102 102 102                // f\n```\n\n(note: the lead byte is listed to the right as a comment.) Given that the first split is a '0' and the last split is an 'f', everything is great, right? Not so fast.\n\nThe problem is that all the data is going to pile up in the first 2 regions and the last region thus creating a \"lumpy\" (and possibly \"hot\") region problem. To understand why, refer to an [ASCII Table](http://www.asciitable.com). '0' is byte 48, and 'f' is byte 102, but there is a huge gap in byte values (bytes 58 to 96) that will *never appear in this keyspace* because the only values are \\[0-9] and \\[a-f]. Thus, the middle regions will never be used. To make pre-splitting work with this example keyspace, a custom definition of splits (i.e., and not relying on the built-in split method) is required.\n\nLesson #1: Pre-splitting tables is generally a best practice, but you need to pre-split them in such a way that all the regions are accessible in the keyspace. While this example demonstrated the problem with a hex-key keyspace, the same problem can happen with *any* keyspace. Know your data.\n\nLesson #2: While generally not advisable, using hex-keys (and more generally, displayable data) can still work with pre-split tables as long as all the created regions are accessible in the keyspace.\n\nTo conclude this example, the following is an example of how appropriate splits can be pre-created for hex-keys:\n\n```java\npublic static boolean createTable(Admin admin, HTableDescriptor table, byte[][] splits)\nthrows IOException {\n  try {\n    admin.createTable( table, splits );\n    return true;\n  } catch (TableExistsException e) {\n    logger.info(\"table \" + table.getNameAsString() + \" already exists\");\n    // the table already exists...\n    return false;\n  }\n}\n\npublic static byte[][] getHexSplits(String startKey, String endKey, int numRegions) {\n  byte[][] splits = new byte[numRegions-1][];\n  BigInteger lowestKey = new BigInteger(startKey, 16);\n  BigInteger highestKey = new BigInteger(endKey, 16);\n  BigInteger range = highestKey.subtract(lowestKey);\n  BigInteger regionIncrement = range.divide(BigInteger.valueOf(numRegions));\n  lowestKey = lowestKey.add(regionIncrement);\n  for(int i=0; i < numRegions-1;i++) {\n    BigInteger key = lowestKey.add(regionIncrement.multiply(BigInteger.valueOf(i)));\n    byte[] b = String.format(\"%016x\", key).getBytes();\n    splits[i] = b;\n  }\n  return splits;\n}\n```\n\n## Number of Versions\n\n### Maximum Number of Versions\n\nThe maximum number of row versions to store is configured per column family via [HColumnDescriptor](https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html). The default for max versions is 1. This is an important parameter because as described in [Data Model](/docs/datamodel) section HBase does *not* overwrite row values, but rather stores different values per row by time (and qualifier). Excess versions are removed during major compactions. The number of max versions may need to be increased or decreased depending on application needs.\n\nIt is not recommended setting the number of max versions to an exceedingly high level (e.g., hundreds or more) unless those old values are very dear to you because this will greatly increase StoreFile size.\n\n### Minimum Number of Versions\n\nLike maximum number of row versions, the minimum number of row versions to keep is configured per column family via [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html). The default for min versions is 0, which means the feature is disabled. The minimum number of row versions parameter is used together with the time-to-live parameter and can be combined with the number of row versions parameter to allow configurations such as \"keep the last T minutes worth of data, at most N versions, *but keep at least M versions around*\" (where M is the value for minimum number of row versions, M\\<N). This parameter should only be set when time-to-live is enabled for a column family and must be less than the number of row versions.\n\n## Supported Datatypes\n\nHBase supports a \"bytes-in/bytes-out\" interface via [Put](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Put.html) and [Result](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Result.html), so anything that can be converted to an array of bytes can be stored as a value. Input could be strings, numbers, complex objects, or even images as long as they can rendered as bytes.\n\nThere are practical limits to the size of values (e.g., storing 10-50MB objects in HBase would probably be too much to ask); search the mailing list for conversations on this topic. All rows in HBase conform to the [Data Model](/docs/datamodel), and that includes versioning. Take that into consideration when making your design, as well as block size for the ColumnFamily.\n\n### Counters\n\nOne supported datatype that deserves special mention are \"counters\" (i.e., the ability to do atomic increments of numbers). See [Increment](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#increment\\(org.apache.hadoop.hbase.client.Increment\\)) in `Table`.\n\nSynchronization on counters are done on the RegionServer, not in the client.\n\n## Joins\n\nIf you have multiple tables, don't forget to factor in the potential for [Joins](/docs/datamodel#datamodel-joins) into the schema design.\n\n## Time To Live (TTL)\n\nColumnFamilies can set a TTL length in seconds, and HBase will automatically delete rows once the expiration time is reached. This applies to *all* versions of a row - even the current one. The TTL time encoded in the HBase for the row is specified in UTC.\n\nStore files which contains only expired rows are deleted on minor compaction. Setting `hbase.store.delete.expired.storefile` to `false` disables this feature. Setting minimum number of versions to other than 0 also disables this.\n\nSee [HColumnDescriptor](https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html) for more information.\n\nRecent versions of HBase also support setting time to live on a per cell basis. See [HBASE-10560](https://issues.apache.org/jira/browse/HBASE-10560) for more information. Cell TTLs are submitted as an attribute on mutation requests (Appends, Increments, Puts, etc.) using Mutation#setTTL. If the TTL attribute is set, it will be applied to all cells updated on the server by the operation. There are two notable differences between cell TTL handling and ColumnFamily TTLs:\n\n* Cell TTLs are expressed in units of milliseconds instead of seconds.\n\n* A cell TTLs cannot extend the effective lifetime of a cell beyond a ColumnFamily level TTL setting.\n\n## Keeping Deleted Cells\n\nBy default, delete markers extend back to the beginning of time. Therefore, [Get](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html) or [Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) operations will not see a deleted cell (row or column), even when the Get or Scan operation indicates a time range before the delete marker was placed.\n\nColumnFamilies can optionally keep deleted cells. In this case, deleted cells can still be retrieved, as long as these operations specify a time range that ends before the timestamp of any delete that would affect the cells. This allows for point-in-time queries even in the presence of deletes.\n\nDeleted cells are still subject to TTL and there will never be more than \"maximum number of versions\" deleted cells. A new \"raw\" scan options returns all deleted rows and the delete markers.\n\n#### Change the Value of `KEEP_DELETED_CELLS` Using HBase Shell: \\[!toc]\n\n```bash\nhbase> hbase> alter 't1', NAME => 'f1', KEEP_DELETED_CELLS => true\n```\n\n#### Change the Value of `KEEP_DELETED_CELLS` Using the API: \\[!toc]\n\n```java\n...\nHColumnDescriptor.setKeepDeletedCells(true);\n...\n```\n\nLet us illustrate the basic effect of setting the `KEEP_DELETED_CELLS` attribute on a table.\n\nFirst, without:\n\n```bash\ncreate 'test', {NAME=>'e', VERSIONS=>2147483647}\nput 'test', 'r1', 'e:c1', 'value', 10\nput 'test', 'r1', 'e:c1', 'value', 12\nput 'test', 'r1', 'e:c1', 'value', 14\ndelete 'test', 'r1', 'e:c1',  11\n\nhbase(main):017:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                              COLUMN+CELL\n r1                                              column=e:c1, timestamp=14, value=value\n r1                                              column=e:c1, timestamp=12, value=value\n r1                                              column=e:c1, timestamp=11, type=DeleteColumn\n r1                                              column=e:c1, timestamp=10, value=value\n1 row(s) in 0.0120 seconds\n\nhbase(main):018:0> flush 'test'\n0 row(s) in 0.0350 seconds\n\nhbase(main):019:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                              COLUMN+CELL\n r1                                              column=e:c1, timestamp=14, value=value\n r1                                              column=e:c1, timestamp=12, value=value\n r1                                              column=e:c1, timestamp=11, type=DeleteColumn\n1 row(s) in 0.0120 seconds\n\nhbase(main):020:0> major_compact 'test'\n0 row(s) in 0.0260 seconds\n\nhbase(main):021:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                              COLUMN+CELL\n r1                                              column=e:c1, timestamp=14, value=value\n r1                                              column=e:c1, timestamp=12, value=value\n1 row(s) in 0.0120 seconds\n```\n\nNotice how delete cells are let go.\n\nNow let's run the same test only with `KEEP_DELETED_CELLS` set on the table (you can do table or per-column-family):\n\n```bash\nhbase(main):005:0> create 'test', {NAME=>'e', VERSIONS=>2147483647, KEEP_DELETED_CELLS => true}\n0 row(s) in 0.2160 seconds\n\n=> Hbase::Table - test\nhbase(main):006:0> put 'test', 'r1', 'e:c1', 'value', 10\n0 row(s) in 0.1070 seconds\n\nhbase(main):007:0> put 'test', 'r1', 'e:c1', 'value', 12\n0 row(s) in 0.0140 seconds\n\nhbase(main):008:0> put 'test', 'r1', 'e:c1', 'value', 14\n0 row(s) in 0.0160 seconds\n\nhbase(main):009:0> delete 'test', 'r1', 'e:c1',  11\n0 row(s) in 0.0290 seconds\n\nhbase(main):010:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                                                                          COLUMN+CELL\n r1                                                                                          column=e:c1, timestamp=14, value=value\n r1                                                                                          column=e:c1, timestamp=12, value=value\n r1                                                                                          column=e:c1, timestamp=11, type=DeleteColumn\n r1                                                                                          column=e:c1, timestamp=10, value=value\n1 row(s) in 0.0550 seconds\n\nhbase(main):011:0> flush 'test'\n0 row(s) in 0.2780 seconds\n\nhbase(main):012:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                                                                          COLUMN+CELL\n r1                                                                                          column=e:c1, timestamp=14, value=value\n r1                                                                                          column=e:c1, timestamp=12, value=value\n r1                                                                                          column=e:c1, timestamp=11, type=DeleteColumn\n r1                                                                                          column=e:c1, timestamp=10, value=value\n1 row(s) in 0.0620 seconds\n\nhbase(main):013:0> major_compact 'test'\n0 row(s) in 0.0530 seconds\n\nhbase(main):014:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                                                                          COLUMN+CELL\n r1                                                                                          column=e:c1, timestamp=14, value=value\n r1                                                                                          column=e:c1, timestamp=12, value=value\n r1                                                                                          column=e:c1, timestamp=11, type=DeleteColumn\n r1                                                                                          column=e:c1, timestamp=10, value=value\n1 row(s) in 0.0650 seconds\n```\n\nKEEP*DELETED\\_CELLS is to avoid removing Cells from HBase when the \\_only* reason to remove them is the delete marker. So with KEEP\\_DELETED\\_CELLS enabled deleted cells would get removed if either you write more versions than the configured max, or you have a TTL and Cells are in excess of the configured timeout, etc.\n\n## Secondary Indexes and Alternate Query Paths\n\nThis section could also be titled \"what if my table rowkey looks like *this* but I also want to query my table like *that*.\" A common example on the dist-list is where a row-key is of the format \"user-timestamp\" but there are reporting requirements on activity across users for certain time ranges. Thus, selecting by user is easy because it is in the lead position of the key, but time is not.\n\nThere is no single answer on the best way to handle this because it depends on...\n\n* Number of users\n* Data size and data arrival rate\n* Flexibility of reporting requirements (e.g., completely ad-hoc date selection vs. pre-configured ranges)\n* Desired execution speed of query (e.g., 90 seconds may be reasonable to some for an ad-hoc report, whereas it may be too long for others)\n\nand solutions are also influenced by the size of the cluster and how much processing power you have to throw at the solution. Common techniques are in sub-sections below. This is a comprehensive, but not exhaustive, list of approaches.\n\nIt should not be a surprise that secondary indexes require additional cluster space and processing. This is precisely what happens in an RDBMS because the act of creating an alternate index requires both space and processing cycles to update. RDBMS products are more advanced in this regard to handle alternative index management out of the box. However, HBase scales better at larger data volumes, so this is a feature trade-off.\n\nPay attention to [Apache HBase Performance Tuning](/docs/performance) when implementing any of these approaches.\n\nAdditionally, see the David Butler response in this dist-list thread [HBase, mail # user - Stargate+hbase](https://lists.apache.org/thread.html/b0ca33407f010d5b1be67a20d1708e8d8bb1e147770f2cb7182a2e37%401300972712%40%3Cuser.hbase.apache.org%3E)\n\n### Filter Query\n\nDepending on the case, it may be appropriate to use [Client Request Filters](/docs/architecture/client-request-filters). In this case, no secondary index is created. However, don't try a full-scan on a large table like this from an application (i.e., single-threaded client).\n\n### Periodic-Update Secondary Index\n\nA secondary index could be created in another table which is periodically updated via a MapReduce job. The job could be executed intra-day, but depending on load-strategy it could still potentially be out of sync with the main data table.\n\nSee [mapreduce.example.readwrite](/docs/mapreduce#hbase-mapreduce-read-example) for more information.\n\n### Dual-Write Secondary Index\n\nAnother strategy is to build the secondary index while publishing data to the cluster (e.g., write to data table, write to index table). If this is approach is taken after a data table already exists, then bootstrapping will be needed for the secondary index with a MapReduce job (see [secondary.indexes.periodic](/docs/regionserver-sizing#periodic-update-secondary-index)).\n\n### Summary Tables\n\nWhere time-ranges are very wide (e.g., year-long report) and where the data is voluminous, summary tables are a common approach. These would be generated with MapReduce jobs into another table.\n\nSee [mapreduce.example.summary](/docs/mapreduce#hbase-mapreduce-summary-to-hbase-example) for more information.\n\n### Coprocessor Secondary Index\n\nCoprocessors act like RDBMS triggers. These were added in 0.92. For more information, see [coprocessors](/docs/cp)\n\n## Constraints\n\nHBase currently supports 'constraints' in traditional (SQL) database parlance. The advised usage for Constraints is in enforcing business rules for attributes in the table (e.g. make sure values are in the range 1-10). Constraints could also be used to enforce referential integrity, but this is strongly discouraged as it will dramatically decrease the write throughput of the tables where integrity checking is enabled. Extensive documentation on using Constraints can be found at [Constraint](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/constraint/Constraint.html) since version 0.94.\n\n## Schema Design Case Studies\n\nThe following will describe some typical data ingestion use-cases with HBase, and how the rowkey design and construction can be approached. Note: this is just an illustration of potential approaches, not an exhaustive list. Know your data, and know your processing requirements.\n\nIt is highly recommended that you read the rest of the [HBase and Schema Design](/docs/schema-design) first, before reading these case studies.\n\nThe following case studies are described:\n\n* Log Data / Timeseries Data\n* Log Data / Timeseries on Steroids\n* Customer/Order\n* Tall/Wide/Middle Schema Design\n* List Data\n\n### Case Study - Log Data and Timeseries Data\n\nAssume that the following data elements are being collected.\n\n* Hostname\n* Timestamp\n* Log event\n* Value/message\n\nWe can store them in an HBase table called LOG\\_DATA, but what will the rowkey be? From these attributes the rowkey will be some combination of hostname, timestamp, and log-event - but what specifically?\n\n#### Timestamp In The Rowkey Lead Position\n\nThe rowkey `[timestamp][hostname][log-event]` suffers from the monotonically increasing rowkey problem described in [Monotonically Increasing Row Keys/Timeseries Data](/docs/regionserver-sizing#monotonically-increasing-row-keystimeseries-data).\n\nThere is another pattern frequently mentioned in the dist-lists about \"bucketing\" timestamps, by performing a mod operation on the timestamp. If time-oriented scans are important, this could be a useful approach. Attention must be paid to the number of buckets, because this will require the same number of scans to return results.\n\n```java\nlong bucket = timestamp % numBuckets;\n```\n\nto construct:\n\n```text\n[bucket][timestamp][hostname][log-event]\n```\n\nAs stated above, to select data for a particular timerange, a Scan will need to be performed for each bucket. 100 buckets, for example, will provide a wide distribution in the keyspace but it will require 100 Scans to obtain data for a single timestamp, so there are trade-offs.\n\n#### Host In The Rowkey Lead Position\n\nThe rowkey `[hostname][log-event][timestamp]` is a candidate if there is a large-ish number of hosts to spread the writes and reads across the keyspace. This approach would be useful if scanning by hostname was a priority.\n\n#### Timestamp, or Reverse Timestamp?\n\nIf the most important access path is to pull most recent events, then storing the timestamps as reverse-timestamps (e.g., `timestamp = Long.MAX_VALUE – timestamp`) will create the property of being able to do a Scan on `[hostname][log-event]` to obtain the most recently captured events.\n\nNeither approach is wrong, it just depends on what is most appropriate for the situation.\n\n<Callout type=\"info\">\n  [HBASE-4811](https://issues.apache.org/jira/browse/HBASE-4811) implements an API to scan a table\n  or a range within a table in reverse, reducing the need to optimize your schema for forward or\n  reverse scanning. This feature is available in HBase 0.98 and later. See\n  [Scan.setReversed()](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html#setReversed\\(boolean\\))\n  for more information.\n</Callout>\n\n#### Variable Length or Fixed Length Rowkeys?\n\nIt is critical to remember that rowkeys are stamped on every column in HBase. If the hostname is `a` and the event type is `e1` then the resulting rowkey would be quite small. However, what if the ingested hostname is `myserver1.mycompany.com` and the event type is `com.package1.subpackage2.subsubpackage3.ImportantService`?\n\nIt might make sense to use some substitution in the rowkey. There are at least two approaches: hashed and numeric. In the Hostname In The Rowkey Lead Position example, it might look like this:\n\nComposite Rowkey With Hashes:\n\n* \\[MD5 hash of hostname] = 16 bytes\n* \\[MD5 hash of event-type] = 16 bytes\n* \\[timestamp] = 8 bytes\n\nComposite Rowkey With Numeric Substitution:\n\nFor this approach another lookup table would be needed in addition to LOG\\_DATA, called LOG\\_TYPES. The rowkey of LOG\\_TYPES would be:\n\n* `[type]` (e.g., byte indicating hostname vs. event-type)\n* `[bytes]` variable length bytes for raw hostname or event-type.\n\nA column for this rowkey could be a long with an assigned number, which could be obtained by using an [HBase counter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#incrementColumnValue\\(byte%5B%5D,byte%5B%5D,byte%5B%5D,long\\))\n\nSo the resulting composite rowkey would be:\n\n* \\[substituted long for hostname] = 8 bytes\n* \\[substituted long for event type] = 8 bytes\n* \\[timestamp] = 8 bytes\n\nIn either the Hash or Numeric substitution approach, the raw values for hostname and event-type can be stored as columns.\n\n### Case Study - Log Data and Timeseries Data on Steroids\n\nThis effectively is the OpenTSDB approach. What OpenTSDB does is re-write data and pack rows into columns for certain time-periods. For a detailed explanation, see: [http://opentsdb.net/schema.html](http://opentsdb.net/schema.html), and [Lessons Learned from OpenTSDB](https://www.slideshare.net/cloudera/4-opentsdb-hbasecon) from HBaseCon2012.\n\nBut this is how the general concept works: data is ingested, for example, in this manner...\n\n```text\n[hostname][log-event][timestamp1]\n[hostname][log-event][timestamp2]\n[hostname][log-event][timestamp3]\n```\n\nwith separate rowkeys for each detailed event, but is re-written like this...\n\n```text\n[hostname][log-event][timerange]\n```\n\nand each of the above events are converted into columns stored with a time-offset relative to the beginning timerange (e.g., every 5 minutes). This is obviously a very advanced processing technique, but HBase makes this possible.\n\n### Case Study - Customer/Order\n\nAssume that HBase is used to store customer and order information. There are two core record-types being ingested: a Customer record type, and Order record type.\n\nThe Customer record type would include all the things that you'd typically expect:\n\n* Customer number\n* Customer name\n* Address (e.g., city, state, zip)\n* Phone numbers, etc.\n\nThe Order record type would include things like:\n\n* Customer number\n* Order number\n* Sales date\n* A series of nested objects for shipping locations and line-items (see [Order Object Design](/docs/regionserver-sizing#order-object-design) for details)\n\nAssuming that the combination of customer number and sales order uniquely identify an order, these two attributes will compose the rowkey, and specifically a composite key such as:\n\n```text\n[customer number][order number]\n```\n\nfor an ORDER table. However, there are more design decisions to make: are the *raw* values the best choices for rowkeys?\n\nThe same design questions in the Log Data use-case confront us here. What is the keyspace of the customer number, and what is the format (e.g., numeric? alphanumeric?) As it is advantageous to use fixed-length keys in HBase, as well as keys that can support a reasonable spread in the keyspace, similar options appear:\n\nComposite Rowkey With Hashes:\n\n* \\[MD5 of customer number] = 16 bytes\n* \\[MD5 of order number] = 16 bytes\n\nComposite Numeric/Hash Combo Rowkey:\n\n* \\[substituted long for customer number] = 8 bytes\n* \\[MD5 of order number] = 16 bytes\n\n#### Single Table? Multiple Tables?\n\nA traditional design approach would have separate tables for CUSTOMER and SALES. Another option is to pack multiple record types into a single table (e.g., CUSTOMER++).\n\nCustomer Record Type Rowkey:\n\n* \\[customer-id]\n* \\[type] = type indicating `1` for customer record type\n\nOrder Record Type Rowkey:\n\n* \\[customer-id]\n* \\[type] = type indicating `2` for order record type\n* \\[order]\n\nThe advantage of this particular CUSTOMER++ approach is that organizes many different record-types by customer-id (e.g., a single scan could get you everything about that customer). The disadvantage is that it's not as easy to scan for a particular record-type.\n\n#### Order Object Design\n\nNow we need to address how to model the Order object. Assume that the class structure is as follows:\n\n#### Order \\[!toc]\n\nan Order can have multiple ShippingLocations\n\n#### LineItem \\[!toc]\n\na ShippingLocation can have multiple LineItems\n\nthere are multiple options on storing this data.\n\n##### Completely Normalized\n\nWith this approach, there would be separate tables for ORDER, SHIPPING\\_LOCATION, and LINE\\_ITEM.\n\nThe ORDER table's rowkey was described above: [schema.casestudies.custorder](/docs/regionserver-sizing#case-study---customerorder)\n\nThe SHIPPING\\_LOCATION's composite rowkey would be something like this:\n\n* `[order-rowkey]`\n* `[shipping location number]` (e.g., 1st location, 2nd, etc.)\n\nThe LINE\\_ITEM table's composite rowkey would be something like this:\n\n* `[order-rowkey]`\n* `[shipping location number]` (e.g., 1st location, 2nd, etc.)\n* `[line item number]` (e.g., 1st lineitem, 2nd, etc.)\n\nSuch a normalized model is likely to be the approach with an RDBMS, but that's not your only option with HBase. The cons of such an approach is that to retrieve information about any Order, you will need:\n\n* Get on the ORDER table for the Order\n* Scan on the SHIPPING\\_LOCATION table for that order to get the ShippingLocation instances\n* Scan on the LINE\\_ITEM for each ShippingLocation\n\ngranted, this is what an RDBMS would do under the covers anyway, but since there are no joins in HBase you're just more aware of this fact.\n\n#### Single Table With Record Types\n\nWith this approach, there would exist a single table ORDER that would contain\n\nThe Order rowkey was described above: [schema.casestudies.custorder](/docs/regionserver-sizing#case-study---customerorder)\n\n* `[order-rowkey]`\n* `[ORDER record type]`\n\nThe ShippingLocation composite rowkey would be something like this:\n\n* `[order-rowkey]`\n* `[SHIPPING record type]`\n* `[shipping location number]` (e.g., 1st location, 2nd, etc.)\n\nThe LineItem composite rowkey would be something like this:\n\n* `[order-rowkey]`\n* `[LINE record type]`\n* `[shipping location number]` (e.g., 1st location, 2nd, etc.)\n* `[line item number]` (e.g., 1st lineitem, 2nd, etc.)\n\n#### Denormalized\n\nA variant of the Single Table With Record Types approach is to denormalize and flatten some of the object hierarchy, such as collapsing the ShippingLocation attributes onto each LineItem instance.\n\nThe LineItem composite rowkey would be something like this:\n\n* `[order-rowkey]`\n* `[LINE record type]`\n* `[line item number]` (e.g., 1st lineitem, 2nd, etc., care must be taken that there are unique across the entire order)\n\nand the LineItem columns would be something like this:\n\n* itemNumber\n* quantity\n* price\n* shipToLine1 (denormalized from ShippingLocation)\n* shipToLine2 (denormalized from ShippingLocation)\n* shipToCity (denormalized from ShippingLocation)\n* shipToState (denormalized from ShippingLocation)\n* shipToZip (denormalized from ShippingLocation)\n\nThe pros of this approach include a less complex object hierarchy, but one of the cons is that updating gets more complicated in case any of this information changes.\n\n#### Object BLOB\n\nWith this approach, the entire Order object graph is treated, in one way or another, as a BLOB. For example, the ORDER table's rowkey was described above: [schema.casestudies.custorder](/docs/regionserver-sizing#case-study---customerorder), and a single column called \"order\" would contain an object that could be deserialized that contained a container Order, ShippingLocations, and LineItems.\n\nThere are many options here: JSON, XML, Java Serialization, Avro, Hadoop Writables, etc. All of them are variants of the same approach: encode the object graph to a byte-array. Care should be taken with this approach to ensure backward compatibility in case the object model changes such that older persisted structures can still be read back out of HBase.\n\nPros are being able to manage complex object graphs with minimal I/O (e.g., a single HBase Get per Order in this example), but the cons include the aforementioned warning about backward compatibility of serialization, language dependencies of serialization (e.g., Java Serialization only works with Java clients), the fact that you have to deserialize the entire object to get any piece of information inside the BLOB, and the difficulty in getting frameworks like Hive to work with custom objects like this.\n\n### Case Study - \"Tall/Wide/Middle\" Schema Design Smackdown\n\nThis section will describe additional schema design questions that appear on the dist-list, specifically about tall and wide tables. These are general guidelines and not laws - each application must consider its own needs.\n\n#### Rows vs. Versions\n\nA common question is whether one should prefer rows or HBase's built-in-versioning. The context is typically where there are \"a lot\" of versions of a row to be retained (e.g., where it is significantly above the HBase default of 1 max versions). The rows-approach would require storing a timestamp in some portion of the rowkey so that they would not overwrite with each successive update.\n\nPreference: Rows (generally speaking).\n\n#### Rows vs. Columns\n\nAnother common question is whether one should prefer rows or columns. The context is typically in extreme cases of wide tables, such as having 1 row with 1 million attributes, or 1 million rows with 1 columns apiece.\n\nPreference: Rows (generally speaking). To be clear, this guideline is in the context is in extremely wide cases, not in the standard use-case where one needs to store a few dozen or hundred columns. But there is also a middle path between these two options, and that is \"Rows as Columns.\"\n\n#### Rows as Columns\n\nThe middle path between Rows vs. Columns is packing data that would be a separate row into columns, for certain rows. OpenTSDB is the best example of this case where a single row represents a defined time-range, and then discrete events are treated as columns. This approach is often more complex, and may require the additional complexity of re-writing your data, but has the advantage of being I/O efficient. For an overview of this approach, see [schema.casestudies.log-steroids](#schema.casestudies.log_steroids).\n\n### Case Study - List Data\n\nThe following is an exchange from the user dist-list regarding a fairly common question: how to handle per-user list data in Apache HBase.\n\n* QUESTION \\*\n\nWe're looking at how to store a large amount of (per-user) list data in HBase, and we were trying to figure out what kind of access pattern made the most sense. One option is store the majority of the data in a key, so we could have something like:\n\n```text\n<FixedWidthUserName><FixedWidthValueId1>:\"\" (no value)\n<FixedWidthUserName><FixedWidthValueId2>:\"\" (no value)\n<FixedWidthUserName><FixedWidthValueId3>:\"\" (no value)\n```\n\nThe other option we had was to do this entirely using:\n\n```text\n<FixedWidthUserName><FixedWidthPageNum0>:<FixedWidthLength><FixedIdNextPageNum><ValueId1><ValueId2><ValueId3>...\n<FixedWidthUserName><FixedWidthPageNum1>:<FixedWidthLength><FixedIdNextPageNum><ValueId1><ValueId2><ValueId3>...\n```\n\nwhere each row would contain multiple values. So in one case reading the first thirty values would be:\n\n```bash\nscan { STARTROW => 'FixedWidthUsername' LIMIT => 30}\n```\n\nAnd in the second case it would be\n\n```bash\nget 'FixedWidthUserName\\x00\\x00\\x00\\x00'\n```\n\nThe general usage pattern would be to read only the first 30 values of these lists, with infrequent access reading deeper into the lists. Some users would have ⇐ 30 total values in these lists, and some users would have millions (i.e. power-law distribution)\n\nThe single-value format seems like it would take up more space on HBase, but would offer some improved retrieval / pagination flexibility. Would there be any significant performance advantages to be able to paginate via gets vs paginating with scans?\n\nMy initial understanding was that doing a scan should be faster if our paging size is unknown (and caching is set appropriately), but that gets should be faster if we'll always need the same page size. I've ended up hearing different people tell me opposite things about performance. I assume the page sizes would be relatively consistent, so for most use cases we could guarantee that we only wanted one page of data in the fixed-page-length case. I would also assume that we would have infrequent updates, but may have inserts into the middle of these lists (meaning we'd need to update all subsequent rows).\n\nThanks for help / suggestions / follow-up questions.\n\n* ANSWER \\*\n\nIf I understand you correctly, you're ultimately trying to store triples in the form \"user, valueid, value\", right? E.g., something like:\n\n```text\n\"user123, firstname, Paul\",\n\"user234, lastname, Smith\"\n```\n\n(But the usernames are fixed width, and the valueids are fixed width).\n\nAnd, your access pattern is along the lines of: \"for user X, list the next 30 values, starting with valueid Y\". Is that right? And these values should be returned sorted by valueid?\n\nThe tl;dr version is that you should probably go with one row per user+value, and not build a complicated intra-row pagination scheme on your own unless you're really sure it is needed.\n\nYour two options mirror a common question people have when designing HBase schemas: should I go \"tall\" or \"wide\"? Your first schema is \"tall\": each row represents one value for one user, and so there are many rows in the table for each user; the row key is user + valueid, and there would be (presumably) a single column qualifier that means \"the value\". This is great if you want to scan over rows in sorted order by row key (thus my question above, about whether these ids are sorted correctly). You can start a scan at any user+valueid, read the next 30, and be done. What you're giving up is the ability to have transactional guarantees around all the rows for one user, but it doesn't sound like you need that. Doing it this way is generally recommended (see [here](/docs/regionserver-sizing#case-study---tallwidemiddle-schema-design-smackdown)).\n\nYour second option is \"wide\": you store a bunch of values in one row, using different qualifiers (where the qualifier is the valueid). The simple way to do that would be to just store ALL values for one user in a single row. I'm guessing you jumped to the \"paginated\" version because you're assuming that storing millions of columns in a single row would be bad for performance, which may or may not be true; as long as you're not trying to do too much in a single request, or do things like scanning over and returning all of the cells in the row, it shouldn't be fundamentally worse. The client has methods that allow you to get specific slices of columns.\n\nNote that neither case fundamentally uses more disk space than the other; you're just \"shifting\" part of the identifying information for a value either to the left (into the row key, in option one) or to the right (into the column qualifiers in option 2). Under the covers, every key/value still stores the whole row key, and column family name. (If this is a bit confusing, take an hour and watch Lars George's excellent video about understanding HBase schema design: [http://www.youtube.com/watch?v=\\_HLoH\\_PgrLk](http://www.youtube.com/watch?v=_HLoH_PgrLk)).\n\nA manually paginated version has lots more complexities, as you note, like having to keep track of how many things are in each page, re-shuffling if new values are inserted, etc. That seems significantly more complex. It might have some slight speed advantages (or disadvantages!) at extremely high throughput, and the only way to really know that would be to try it out. If you don't have time to build it both ways and compare, my advice would be to start with the simplest option (one row per user+value). Start simple and iterate! :)\n\n## Operational and Performance Configuration Options\n\n### Tune HBase Server RPC Handling\n\n* Set `hbase.regionserver.handler.count` (in `hbase-site.xml`) to cores x spindles for concurrency.\n* Optionally, split the call queues into separate read and write queues for differentiated service. The parameter `hbase.ipc.server.callqueue.handler.factor` specifies the number of call queues:\n  * `0` means a single shared queue\n  * `1` means one queue for each handler.\n  * A value between `0` and `1` allocates the number of queues proportionally to the number of handlers. For instance, a value of `.5` shares one queue between each two handlers.\n* Use `hbase.ipc.server.callqueue.read.ratio` (`hbase.ipc.server.callqueue.read.share` in 0.98) to split the call queues into read and write queues:\n  * `0.5` means there will be the same number of read and write queues\n  * `< 0.5` for more write than read\n  * `> 0.5` for more read than write\n* Set `hbase.ipc.server.callqueue.scan.ratio` (HBase 1.0+) to split read call queues into small-read and long-read queues:\n  * 0.5 means that there will be the same number of short-read and long-read queues\n  * `< 0.5` for more short-read\n  * `> 0.5` for more long-read\n\n### Disable Nagle for RPC\n\nDisable Nagle's algorithm. Delayed ACKs can add up to \\~200ms to RPC round trip time. Set the following parameters:\n\n* In Hadoop's `core-site.xml`:\n  * `ipc.server.tcpnodelay = true`\n  * `ipc.client.tcpnodelay = true`\n* In HBase's `hbase-site.xml`:\n  * `hbase.ipc.client.tcpnodelay = true`\n  * `hbase.ipc.server.tcpnodelay = true`\n\n### Limit Server Failure Impact\n\nDetect regionserver failure as fast as reasonable. Set the following parameters:\n\n* In `hbase-site.xml`, set `zookeeper.session.timeout` to 30 seconds or less to bound failure detection (20-30 seconds is a good start).\n  * Note: Zookeeper clients negotiate a session timeout with the server during client init. Server enforces this timeout to be in the range \\[`minSessionTimeout`, `maxSessionTimeout`] and both these timeouts (measured in milliseconds) are configurable in Zookeeper service configuration. If not configured, these default to 2 \\* `tickTime` and 20 \\* `tickTime` respectively (`tickTime` is the basic time unit used by ZooKeeper, as measured in milliseconds. It is used to regulate heartbeats, timeouts etc.). Refer to Zookeeper documentation for additional details.\n* Detect and avoid unhealthy or failed HDFS DataNodes: in `hdfs-site.xml` and `hbase-site.xml`, set the following parameters:\n  * `dfs.namenode.avoid.read.stale.datanode = true`\n  * `dfs.namenode.avoid.write.stale.datanode = true`\n\n### Optimize on the Server Side for Low Latency\n\nSkip the network for local blocks when the RegionServer goes to read from HDFS by exploiting HDFS's [Short-Circuit Local Reads](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/ShortCircuitLocalReads.html) facility. Note how setup must be done both at the datanode and on the dfsclient ends of the conneciton — i.e. at the RegionServer and how both ends need to have loaded the hadoop native `.so` library. After configuring your hadoop setting *dfs.client.read.shortcircuit* to *true* and configuring the *dfs.domain.socket.path* path for the datanode and dfsclient to share and restarting, next configure the regionserver/dfsclient side.\n\n* In `hbase-site.xml`, set the following parameters:\n  * `dfs.client.read.shortcircuit = true`\n  * `dfs.client.read.shortcircuit.skip.checksum = true` so we don't double checksum (HBase does its own checksumming to save on i/os).\n  * `dfs.domain.socket.path` to match what was set for the datanodes.\n  * `dfs.client.read.shortcircuit.buffer.size = 131072` Important to avoid OOME — hbase has a default it uses if unset, see `hbase.dfs.client.read.shortcircuit.buffer.size`; its default is 131072.\n* Ensure data locality. In `hbase-site.xml`, set `hbase.hstore.min.locality.to.skip.major.compact = 0.7` (Meaning that 0.7 \\<= n \\<= 1)\n* Make sure DataNodes have enough handlers for block transfers. In `hdfs-site.xml`, set the following parameters:\n  * `dfs.datanode.max.xcievers >= 8192`\n  * `dfs.datanode.handler.count =` number of spindles\n\nCheck the RegionServer logs after restart. You should only see complaint if misconfiguration. Otherwise, shortcircuit read operates quietly in background. It does not provide metrics so no optics on how effective it is but read latencies should show a marked improvement, especially if good data locality, lots of random reads, and dataset is larger than available cache.\n\nOther advanced configurations that you might play with, especially if shortcircuit functionality is complaining in the logs, include `dfs.client.read.shortcircuit.streams.cache.size` and `dfs.client.socketcache.capacity`. Documentation is sparse on these options. You'll have to read source code.\n\nRegionServer metric system exposes HDFS short circuit read metrics `shortCircuitBytesRead`. Other HDFS read metrics, including `totalBytesRead` (The total number of bytes read from HDFS), `localBytesRead` (The number of bytes read from the local HDFS DataNode), `zeroCopyBytesRead` (The number of bytes read through HDFS zero copy) are available and can be used to troubleshoot short-circuit read issues.\n\nFor more on short-circuit reads, see Colin's old blog on rollout, [How Improved Short-Circuit Local Reads Bring Better Performance and Security to Hadoop](http://blog.cloudera.com/blog/2013/08/how-improved-short-circuit-local-reads-bring-better-performance-and-security-to-hadoop/). The [HDFS-347](https://issues.apache.org/jira/browse/HDFS-347) issue also makes for an interesting read showing the HDFS community at its best (caveat a few comments).\n\n### JVM Tuning\n\n#### Tune JVM GC for low collection latencies\n\n* Use the CMS collector: `-XX:+UseConcMarkSweepGC`\n* Keep eden space as small as possible to minimize average collection time. Example:\n  ```text\n  -XX:CMSInitiatingOccupancyFraction=70\n  ```\n* Optimize for low collection latency rather than throughput: `-Xmn512m`\n* Collect eden in parallel: `-XX:+UseParNewGC`\n* Avoid collection under pressure: `-XX:+UseCMSInitiatingOccupancyOnly`\n* Limit per request scanner result sizing so everything fits into survivor space but doesn't tenure. In `hbase-site.xml`, set `hbase.client.scanner.max.result.size` to 1/8th of eden space (with -`Xmn512m` this is \\~51MB )\n* Set `max.result.size` x `handler.count` less than survivor space\n\n#### OS-Level Tuning\n\n* Turn transparent huge pages (THP) off:\n  ```bash\n  echo never > /sys/kernel/mm/transparent_hugepage/enabled\n  echo never > /sys/kernel/mm/transparent_hugepage/defrag\n  ```\n* Set `vm.swappiness = 0`\n* Set `vm.min_free_kbytes` to at least 1GB (8GB on larger memory systems)\n* Disable NUMA zone reclaim with `vm.zone_reclaim_mode = 0`\n\n## Special Cases\n\n### For applications where failing quickly is better than waiting\n\n* In `hbase-site.xml` on the client side, set the following parameters:\n  * Set `hbase.client.pause = 1000`\n  * Set `hbase.client.retries.number = 3`\n  * If you want to ride over splits and region moves, increase `hbase.client.retries.number` substantially (>= 20)\n  * Set the RecoverableZookeeper retry count: `zookeeper.recovery.retry = 1` (no retry)\n* In `hbase-site.xml` on the server side, set the Zookeeper session timeout for detecting server failures: `zookeeper.session.timeout` ⇐ 30 seconds (20-30 is good).\n\n### For applications that can tolerate slightly out of date information\n\n**HBase timeline consistency (HBASE-10070)** With read replicas enabled, read-only copies of regions (replicas) are distributed over the cluster. One RegionServer services the default or primary replica, which is the only replica that can service writes. Other RegionServers serve the secondary replicas, follow the primary RegionServer, and only see committed updates. The secondary replicas are read-only, but can serve reads immediately while the primary is failing over, cutting read availability blips from seconds to milliseconds. Phoenix supports timeline consistency as of 4.4.0 Tips:\n\n* Deploy HBase 1.0.0 or later.\n* Enable timeline consistent replicas on the server side.\n* Use one of the following methods to set timeline consistency:\n  * Use `ALTER SESSION SET CONSISTENCY = 'TIMELINE'`\n  * Set the connection property `Consistency` to `timeline` in the JDBC connect string\n\n### More Information\n\nSee the Performance section [perf.schema](/docs/case-studies#case-studies-schema-design) for more information about operational and performance schema design options, such as Bloom Filters, Table-configured regionsizes, compression, and blocksizes.\n\n\n# 0.95 RPC Specification (/docs/rpc)\nIn 0.95, all client/server communication is done with [protobuf'ed](https://developers.google.com/protocol-buffers/) Messages rather than with [Hadoop Writables](https://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/Writable.html).\nOur RPC wire format therefore changes.\nThis document describes the client/server request/response protocol and our new RPC wire-format.\n\nFor what RPC is like in 0.94 and previous, see Benoît/Tsuna's [Unofficial Hadoop / HBase RPC protocol documentation](https://github.com/OpenTSDB/asynchbase/blob/master/src/HBaseRpc.java#L164).\nFor more background on how we arrived at this spec., see [HBase RPC: WIP](https://docs.google.com/document/d/1WCKwgaLDqBw2vpux0jPsAu2WPTRISob7HGCO8YhfDTA/edit#)\n\n## Goals\n\n1. A wire-format we can evolve\n2. A format that does not require our rewriting server core or radically changing its current architecture (for later).\n\n## TODO\n\n1. List of problems with currently specified format and where we would like to go in a version2, etc.\n   For example, what would we have to change if anything to move server async or to support streaming/chunking?\n2. Diagram on how it works\n3. A grammar that succinctly describes the wire-format.\n   Currently we have these words and the content of the rpc protobuf idl but a grammar for the back and forth would help with groking rpc.\n   Also, a little state machine on client/server interactions would help with understanding (and ensuring correct implementation).\n\n## RPC\n\nThe client will send setup information on connection establish.\nThereafter, the client invokes methods against the remote server sending a protobuf Message and receiving a protobuf Message in response.\nCommunication is synchronous.\nAll back and forth is preceded by an int that has the total length of the request/response.\nOptionally, Cells(KeyValues) can be passed outside of protobufs in follow-behind Cell blocks\n(because [we can't protobuf megabytes of KeyValues](https://docs.google.com/document/d/1WEtrq-JTIUhlnlnvA0oYRLp0F8MKpEBeBSCFcQiacdw/edit#) or Cells). These CellBlocks are encoded and optionally compressed.\n\nFor more detail on the protobufs involved, see the\n[RPC.proto](https://github.com/apache/hbase/blob/master/hbase-protocol-shaded/src/main/protobuf/rpc/RPC.proto) file in master.\n\n### Connection Setup\n\nClient initiates connection.\n\n#### Client\n\nOn connection setup, client sends a preamble followed by a connection header.\n\n`<preamble>`\n\n```text\n<MAGIC 4 byte integer> <1 byte RPC Format Version> <1 byte auth type>\n```\n\nWe need the auth method spec.\nhere so the connection header is encoded if auth enabled.\\\nE.g.: HBas0x000x50 — 4 bytes of MAGIC — \\`HBas' — plus one-byte of version, 0 in this case, and one byte, 0x50 (SIMPLE). of an auth type.\n\n`<Protobuf ConnectionHeader Message>`\\\nHas user info, and \"protocol\", as well as the encoders and compression the client will use sending CellBlocks.\nCellBlock encoders and compressors are for the life of the connection.\nCellBlock encoders implement org.apache.hadoop.hbase.codec.Codec.\nCellBlocks may then also be compressed.\nCompressors implement org.apache.hadoop.io.compress.CompressionCodec.\nThis protobuf is written using writeDelimited so is prefaced by a pb varint with its serialized length\n\n#### Server\n\nAfter client sends preamble and connection header, server does NOT respond if successful connection setup.\nNo response means server is READY to accept requests and to give out response.\nIf the version or authentication in the preamble is not agreeable or the server has trouble parsing the preamble, it will throw a org.apache.hadoop.hbase.ipc.FatalConnectionException explaining the error and will then disconnect.\nIf the client in the connection header — i.e.\nthe protobuf'd Message that comes after the connection preamble — asks for a Service the server does not support or a codec the server does not have, again we throw a FatalConnectionException with explanation.\n\n### Request\n\nAfter a Connection has been set up, client makes requests.\nServer responds.\n\nA request is made up of a protobuf RequestHeader followed by a protobuf Message parameter.\nThe header includes the method name and optionally, metadata on the optional CellBlock that may be following.\nThe parameter type suits the method being invoked: i.e.\nif we are doing a getRegionInfo request, the protobuf Message param will be an instance of GetRegionInfoRequest.\nThe response will be a GetRegionInfoResponse.\nThe CellBlock is optionally used ferrying the bulk of the RPC data: i.e. Cells/KeyValues.\n\n#### Request Parts\n\n`<Total Length>`\\\nThe request is prefaced by an int that holds the total length of what follows.\n\n`<Protobuf RequestHeader Message>`\\\nWill have call.id, trace.id, and method name, etc.\nincluding optional Metadata on the Cell block IFF one is following.\nData is protobuf'd inline in this pb Message or optionally comes in the following CellBlock\n\n`<Protobuf Param Message>`\\\nIf the method being invoked is getRegionInfo, if you study the Service descriptor for the client to regionserver protocol, you will find that the request sends a GetRegionInfoRequest protobuf Message param in this position.\n\n`<CellBlock>`\\\nAn encoded and optionally compressed Cell block.\n\n### Response\n\nSame as Request, it is a protobuf ResponseHeader followed by a protobuf Message response where the Message response type suits the method invoked.\nBulk of the data may come in a following CellBlock.\n\n#### Response Parts\n\n`<Total Length>`\\\nThe response is prefaced by an int that holds the total length of what follows.\n\n`<Protobuf ResponseHeader Message>`\\\nWill have call.id, etc.\nWill include exception if failed processing.\nOptionally includes metadata on optional, IFF there is a CellBlock following.\n\n`<Protobuf Response Message>`\\\nReturn or may be nothing if exception.\nIf the method being invoked is getRegionInfo, if you study the Service descriptor for the client to regionserver protocol, you will find that the response sends a GetRegionInfoResponse protobuf Message param in this position.\n\n`<CellBlock>`\\\nAn encoded and optionally compressed Cell block.\n\n### Exceptions\n\nThere are two distinct types.\nThere is the request failed which is encapsulated inside the response header for the response.\nThe connection stays open to receive new requests.\nThe second type, the FatalConnectionException, kills the connection.\n\nExceptions can carry extra information.\nSee the ExceptionResponse protobuf type.\nIt has a flag to indicate do-no-retry as well as other miscellaneous payload to help improve client responsiveness.\n\n### CellBlocks\n\nThese are not versioned.\nServer can do the codec or it cannot.\nIf new version of a codec with say, tighter encoding, then give it a new class name.\nCodecs will live on the server for all time so old clients can connect.\n\n## Notes\n\n### Constraints\n\nIn some part, current wire-format — i.e.\nall requests and responses preceded by a length — has been dictated by current server non-async architecture.\n\n### One fat pb request or header+param\n\nWe went with pb header followed by pb param making a request and a pb header followed by pb response for now.\nDoing header+param rather than a single protobuf Message with both header and param content:\n\n1. Is closer to what we currently have\n2. Having a single fat pb requires extra copying putting the already pb'd param into the body of the fat request pb (and same making result)\n3. We can decide whether to accept the request or not before we read the param; for example, the request might be low priority.\n   As is, we read header+param in one go as server is currently implemented so this is a TODO.\n\nThe advantages are minor.\nIf later, fat request has clear advantage, can roll out a v2 later.\n\n### RPC Configurations\n\n#### CellBlock Codecs\n\nTo enable a codec other than the default `KeyValueCodec`, set `hbase.client.rpc.codec` to the name of the Codec class to use.\nCodec must implement hbase's `Codec` Interface.\nAfter connection setup, all passed cellblocks will be sent with this codec.\nThe server will return cellblocks using this same codec as long as the codec is on the servers' CLASSPATH (else you will get `UnsupportedCellCodecException`).\n\nTo change the default codec, set `hbase.client.default.rpc.codec`.\n\nTo disable cellblocks completely and to go pure protobuf, set the default to the empty String and do not specify a codec in your Configuration.\nSo, set `hbase.client.default.rpc.codec` to the empty string and do not set `hbase.client.rpc.codec`.\nThis will cause the client to connect to the server with no codec specified.\nIf a server sees no codec, it will return all responses in pure protobuf.\nRunning pure protobuf all the time will be slower than running with cellblocks.\n\n#### Compression\n\nUses hadoop's compression codecs.\nTo enable compressing of passed CellBlocks, set `hbase.client.rpc.compressor` to the name of the Compressor to use.\nCompressor must implement Hadoop's CompressionCodec Interface.\nAfter connection setup, all passed cellblocks will be sent compressed.\nThe server will return cellblocks compressed using this same compressor as long as the compressor is on its CLASSPATH (else you will get `UnsupportedCompressionCodecException`).\n\n\n# HBase and Schema Design (/docs/schema-design)\nA good introduction on the strength and weaknesses modelling on the various non-rdbms datastores is to be found in Ian Varley's Master thesis, [No Relation: The Mixed Blessings of Non-Relational Databases](http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf). It is a little dated now but a good background read if you have a moment on how HBase schema modeling differs from how it is done in an RDBMS. Also, read [keyvalue](/docs/architecture/regions#keyvalue) for how HBase stores data internally, and the section on [schema.casestudies](/docs/regionserver-sizing#schema-design-case-studies).\n\nThe documentation on the Cloud Bigtable website, [Designing Your Schema](https://cloud.google.com/bigtable/docs/schema-design), is pertinent and nicely done and lessons learned there equally apply here in HBase land; just divide any quoted values by \\~10 to get what works for HBase: e.g. where it says individual values can be \\~10MBs in size, HBase can do similar — perhaps best to go smaller if you can — and where it says a maximum of 100 column families in Cloud Bigtable, think \\~10 when modeling on HBase.\n\nSee also Robert Yokota's [HBase Application Archetypes](https://blogs.apache.org/hbase/entry/hbase-application-archetypes-redux) (an update on work done by other HBasers), for a helpful categorization of use cases that do well on top of the HBase model.\n\n## Schema Creation\n\nHBase schemas can be created or updated using the [Apache HBase Shell](/docs/shell) or by using [Admin](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Admin.html) in the Java API.\n\nTables must be disabled when making ColumnFamily modifications, for example:\n\n```java\nConfiguration config = HBaseConfiguration.create();\nAdmin admin = new Admin(conf);\nTableName table = TableName.valueOf(\"myTable\");\n\nadmin.disableTable(table);\n\nHColumnDescriptor cf1 = ...;\nadmin.addColumn(table, cf1);      // adding new ColumnFamily\nHColumnDescriptor cf2 = ...;\nadmin.modifyColumn(table, cf2);    // modifying existing ColumnFamily\n\nadmin.enableTable(table);\n```\n\nSee [client dependencies](/docs/configuration/default#client-configuration-and-dependencies-connecting-to-an-hbase-cluster) for more information about configuring client connections.\n\n<Callout type=\"info\">\n  Online schema changes are supported in the 0.92.x codebase, but the 0.90.x codebase requires the\n  table to be disabled.\n</Callout>\n\n### Schema Updates\n\nWhen changes are made to either Tables or ColumnFamilies (e.g. region size, block size), these changes take effect the next time there is a major compaction and the StoreFiles get re-written.\n\nSee [store](/docs/architecture/regions#store) for more information on StoreFiles.\n\n## Table Schema Rules Of Thumb\n\nThere are many different data sets, with different access patterns and service-level expectations. Therefore, these rules of thumb are only an overview. Read the rest of this chapter to get more details after you have gone through this list.\n\n* Aim to have regions sized between 10 and 50 GB.\n* Aim to have cells no larger than 10 MB, or 50 MB if you use [mob](/docs/architecture/hbase-mob). Otherwise, consider storing your cell data in HDFS and store a pointer to the data in HBase.\n* A typical schema has between 1 and 3 column families per table. HBase tables should not be designed to mimic RDBMS tables.\n* Around 50-100 regions is a good number for a table with 1 or 2 column families. Remember that a region is a contiguous segment of a column family.\n* Keep your column family names as short as possible. The column family names are stored for every value (ignoring prefix encoding). They should not be self-documenting and descriptive like in a typical RDBMS.\n* If you are storing time-based machine data or logging information, and the row key is based on device ID or service ID plus time, you can end up with a pattern where older data regions never have additional writes beyond a certain age. In this type of situation, you end up with a small number of active regions and a large number of older regions which have no new writes. For these situations, you can tolerate a larger number of regions because your resource consumption is driven by the active regions only.\n* If only one column family is busy with writes, only that column family accomulates memory. Be aware of write patterns when allocating resources.\n\n\n# Secure Client Access to Apache HBase (/docs/security/client-access)\nNewer releases of Apache HBase (>= 0.92) support optional SASL authentication of clients. See also Matteo Bertozzi's article on [Understanding User Authentication and Authorization in Apache HBase](https://blog.cloudera.com/blog/2012/09/understanding-user-authentication-and-authorization-in-apache-hbase/).\n\nThis describes how to set up Apache HBase and clients for connection to secure HBase resources.\n\n## Prerequisites\n\n#### Hadoop Authentication Configuration \\[!toc]\n\nTo run HBase RPC with strong authentication, you must set `hbase.security.authentication` to `kerberos`. In this case, you must also set `hadoop.security.authentication` to `kerberos` in core-site.xml. Otherwise, you would be using strong authentication for HBase but not for the underlying HDFS, which would cancel out any benefit.\n\n#### Kerberos KDC \\[!toc]\n\nYou need to have a working Kerberos KDC.\n\n## Server-side Configuration for Secure Operation\n\nFirst, refer to [security.prerequisites](/docs/security/client-access#security-client-access-prerequisites) and ensure that your underlying HDFS configuration is secure.\n\nAdd the following to the `hbase-site.xml` file on every server machine in the cluster:\n\n```xml\n<property>\n  <name>hbase.security.authentication</name>\n  <value>kerberos</value>\n</property>\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n<name>hbase.coprocessor.region.classes</name>\n  <value>org.apache.hadoop.hbase.security.token.TokenProvider</value>\n</property>\n```\n\nA full shutdown and restart of HBase service is required when deploying these configuration changes.\n\n## Client-side Configuration for Secure Operation\n\nFirst, refer to [Prerequisites](/docs/security/client-access#security-client-access-prerequisites) and ensure that your underlying HDFS configuration is secure.\n\nAdd the following to the `hbase-site.xml` file on every client:\n\n```xml\n<property>\n  <name>hbase.security.authentication</name>\n  <value>kerberos</value>\n</property>\n```\n\nBefore 2.2.0 version, the client environment must be logged in to Kerberos from KDC or keytab via the `kinit` command before communication with the HBase cluster will be possible.\n\nSince 2.2.0, client can specify the following configurations in `hbase-site.xml`:\n\n```xml\n<property>\n  <name>hbase.client.keytab.file</name>\n  <value>/local/path/to/client/keytab</value>\n</property>\n\n<property>\n  <name>hbase.client.keytab.principal</name>\n  <value>foo@EXAMPLE.COM</value>\n</property>\n```\n\nThen application can automatically do the login and credential renewal jobs without client interference.\n\nIt's optional feature, client, who upgrades to 2.2.0, can still keep their login and credential renewal logic already did in older version, as long as keeping `hbase.client.keytab.file` and `hbase.client.keytab.principal` are unset.\n\nBe advised that if the `hbase.security.authentication` in the client- and server-side site files do not match, the client will not be able to communicate with the cluster.\n\nOnce HBase is configured for secure RPC it is possible to optionally configure encrypted communication. To do so, add the following to the `hbase-site.xml` file on every client:\n\n```xml\n<property>\n  <name>hbase.rpc.protection</name>\n  <value>privacy</value>\n</property>\n```\n\nThis configuration property can also be set on a per-connection basis. Set it in the `Configuration` supplied to `Table`:\n\n```java\nConfiguration conf = HBaseConfiguration.create();\nConnection connection = ConnectionFactory.createConnection(conf);\nconf.set(\"hbase.rpc.protection\", \"privacy\");\ntry (Connection connection = ConnectionFactory.createConnection(conf);\n     Table table = connection.getTable(TableName.valueOf(tablename))) {\n  .... do your stuff\n}\n```\n\nExpect a \\~10% performance penalty for encrypted communication.\n\n## Client-side Configuration for Secure Operation - Thrift Gateway\n\nAdd the following to the `hbase-site.xml` file for every Thrift gateway:\n\n```xml\n<property>\n  <name>hbase.thrift.keytab.file</name>\n  <value>/etc/hbase/conf/hbase.keytab</value>\n</property>\n<property>\n  <name>hbase.thrift.kerberos.principal</name>\n  <value>$USER/_HOST@HADOOP.LOCALDOMAIN</value>\n  <!-- TODO: This may need to be  HTTP/_HOST@<REALM> and _HOST may not work.\n   You may have  to put the concrete full hostname.\n   -->\n</property>\n<!-- Add these if you need to configure a different DNS interface from the default -->\n<property>\n  <name>hbase.thrift.dns.interface</name>\n  <value>default</value>\n</property>\n<property>\n  <name>hbase.thrift.dns.nameserver</name>\n  <value>default</value>\n</property>\n```\n\nSubstitute the appropriate credential and keytab for *\\$USER* and *\\$KEYTAB* respectively.\n\nIn order to use the Thrift API principal to interact with HBase, it is also necessary to add the `hbase.thrift.kerberos.principal` to the `acl` table. For example, to give the Thrift API principal, `thrift_server`, administrative access, a command such as this one will suffice:\n\n```sql\ngrant 'thrift_server', 'RWCA'\n```\n\nFor more information about ACLs, please see the [Access Control Labels (ACLs)](/docs/security/data-access#access-control-labels-acls) section\n\nThe Thrift gateway will authenticate with HBase using the supplied credential. No authentication will be performed by the Thrift gateway itself. All client access via the Thrift gateway will use the Thrift gateway's credential and have its privilege.\n\n## Configure the Thrift Gateway to Authenticate on Behalf of the Client\n\n[Client-side Configuration for Secure Operation - Thrift Gateway](/docs/security/client-access#client-side-configuration-for-secure-operation---thrift-gateway) describes how to authenticate a Thrift client to HBase using a fixed user. As an alternative, you can configure the Thrift gateway to authenticate to HBase on the client's behalf, and to access HBase using a proxy user. This was implemented in [HBASE-11349](https://issues.apache.org/jira/browse/HBASE-11349) for Thrift 1, and [HBASE-11474](https://issues.apache.org/jira/browse/HBASE-11474) for Thrift 2.\n\n<Callout type=\"info\">\n  If you use framed transport, you cannot yet take advantage of this feature, because SASL does not\n  work with Thrift framed transport at this time.\n</Callout>\n\nTo enable it, do the following.\n\n1. Be sure Thrift is running in secure mode, by following the procedure described in [Client-side Configuration for Secure Operation - Thrift Gateway](/docs/security/client-access#client-side-configuration-for-secure-operation---thrift-gateway).\n2. Be sure that HBase is configured to allow proxy users, as described in [REST Gateway Impersonation Configuration](/docs/security/client-access#rest-gateway-impersonation-configuration).\n3. In *hbase-site.xml* for each cluster node running a Thrift gateway, set the property `hbase.thrift.security.qop` to one of the following three values:\n   * `privacy` - authentication, integrity, and confidentiality checking.\n   * `integrity` - authentication and integrity checking\n   * `authentication` - authentication checking only\n4. Restart the Thrift gateway processes for the changes to take effect. If a node is running Thrift, the output of the `jps` command will list a `ThriftServer` process. To stop Thrift on a node, run the command `bin/hbase-daemon.sh stop thrift`. To start Thrift on a node, run the command `bin/hbase-daemon.sh start thrift`.\n\n## Configure the Thrift Gateway to Use the `doAs` Feature\n\n[Configure the Thrift Gateway to Authenticate on Behalf of the Client](/docs/security/client-access#configure-the-thrift-gateway-to-authenticate-on-behalf-of-the-client) describes how to configure the Thrift gateway to authenticate to HBase on the client's behalf, and to access HBase using a proxy user. The limitation of this approach is that after the client is initialized with a particular set of credentials, it cannot change these credentials during the session. The `doAs` feature provides a flexible way to impersonate multiple principals using the same client. This feature was implemented in [HBASE-12640](https://issues.apache.org/jira/browse/HBASE-12640) for Thrift 1, but is currently not available for Thrift 2.\n\n**To enable the `doAs` feature**, add the following to the *hbase-site.xml* file for every Thrift gateway:\n\n```xml\n<property>\n  <name>hbase.regionserver.thrift.http</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.thrift.support.proxyuser</name>\n  <value>true</value>\n</property>\n```\n\n**To allow proxy users** when using `doAs` impersonation, add the following to the *hbase-site.xml* file for every HBase node:\n\n```xml\n<property>\n  <name>hadoop.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hadoop.proxyuser.$USER.groups</name>\n  <value>$GROUPS</value>\n</property>\n<property>\n  <name>hadoop.proxyuser.$USER.hosts</name>\n  <value>$GROUPS</value>\n</property>\n```\n\nTake a look at the [demo client](https://github.com/apache/hbase/blob/master/hbase-examples/src/main/java/org/apache/hadoop/hbase/thrift/HttpDoAsClient.java) to get an overall idea of how to use this feature in your client.\n\n## Client-side Configuration for Secure Operation - REST Gateway\n\nAdd the following to the `hbase-site.xml` file for every REST gateway:\n\n```xml\n<property>\n  <name>hbase.rest.keytab.file</name>\n  <value>$KEYTAB</value>\n</property>\n<property>\n  <name>hbase.rest.kerberos.principal</name>\n  <value>$USER/_HOST@HADOOP.LOCALDOMAIN</value>\n</property>\n```\n\nSubstitute the appropriate credential and keytab for *\\$USER* and *\\$KEYTAB* respectively.\n\nThe REST gateway will authenticate with HBase using the supplied credential.\n\nIn order to use the REST API principal to interact with HBase, it is also necessary to add the `hbase.rest.kerberos.principal` to the `acl` table. For example, to give the REST API principal, `rest_server`, administrative access, a command such as this one will suffice:\n\n```sql\ngrant 'rest_server', 'RWCA'\n```\n\nFor more information about ACLs, please see the [Access Control Labels (ACLs)](/docs/security/data-access#access-control-labels-acls) section\n\nHBase REST gateway supports [SPNEGO HTTP authentication](https://hadoop.apache.org/docs/stable/hadoop-auth/index.html) for client access to the gateway. To enable REST gateway Kerberos authentication for client access, add the following to the `hbase-site.xml` file for every REST gateway.\n\n```xml\n<property>\n  <name>hbase.rest.support.proxyuser</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.rest.authentication.type</name>\n  <value>kerberos</value>\n</property>\n<property>\n  <name>hbase.rest.authentication.kerberos.principal</name>\n  <value>HTTP/_HOST@HADOOP.LOCALDOMAIN</value>\n</property>\n<property>\n  <name>hbase.rest.authentication.kerberos.keytab</name>\n  <value>$KEYTAB</value>\n</property>\n<!-- Add these if you need to configure a different DNS interface from the default -->\n<property>\n  <name>hbase.rest.dns.interface</name>\n  <value>default</value>\n</property>\n<property>\n  <name>hbase.rest.dns.nameserver</name>\n  <value>default</value>\n</property>\n```\n\nSubstitute the keytab for HTTP for *\\$KEYTAB*.\n\nHBase REST gateway supports different 'hbase.rest.authentication.type': simple, kerberos. You can also implement a custom authentication by implementing Hadoop AuthenticationHandler, then specify the full class name as 'hbase.rest.authentication.type' value. For more information, refer to [SPNEGO HTTP authentication](https://hadoop.apache.org/docs/stable/hadoop-auth/index.html).\n\n## REST Gateway Impersonation Configuration\n\nBy default, the REST gateway doesn't support impersonation. It accesses the HBase on behalf of clients as the user configured as in the previous section. To the HBase server, all requests are from the REST gateway user. The actual users are unknown. You can turn on the impersonation support. With impersonation, the REST gateway user is a proxy user. The HBase server knows the actual/real user of each request. So it can apply proper authorizations.\n\nTo turn on REST gateway impersonation, we need to configure HBase servers (masters and region servers) to allow proxy users; configure REST gateway to enable impersonation.\n\nTo allow proxy users, add the following to the `hbase-site.xml` file for every HBase server:\n\n```xml\n<property>\n  <name>hadoop.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hadoop.proxyuser.$USER.groups</name>\n  <value>$GROUPS</value>\n</property>\n<property>\n  <name>hadoop.proxyuser.$USER.hosts</name>\n  <value>$GROUPS</value>\n</property>\n```\n\nSubstitute the REST gateway proxy user for *\\$USER*, and the allowed group list for *\\$GROUPS*.\n\nTo enable REST gateway impersonation, add the following to the `hbase-site.xml` file for every REST gateway.\n\n```xml\n<property>\n  <name>hbase.rest.authentication.type</name>\n  <value>kerberos</value>\n</property>\n<property>\n  <name>hbase.rest.authentication.kerberos.principal</name>\n  <value>HTTP/_HOST@HADOOP.LOCALDOMAIN</value>\n</property>\n<property>\n  <name>hbase.rest.authentication.kerberos.keytab</name>\n  <value>$KEYTAB</value>\n</property>\n```\n\nSubstitute the keytab for HTTP for *\\$KEYTAB*.\n\n\n# Securing Access To Your Data (/docs/security/data-access)\nAfter you have configured secure authentication between HBase client and server processes and gateways, you need to consider the security of your data itself. HBase provides several strategies for securing your data:\n\n* Role-based Access Control (RBAC) controls which users or groups can read and write to a given HBase resource or execute a coprocessor endpoint, using the familiar paradigm of roles.\n* Visibility Labels which allow you to label cells and control access to labelled cells, to further restrict who can read or write to certain subsets of your data. Visibility labels are stored as tags. See [hbase.tags](/docs/security/data-access#tags) for more information.\n* Transparent encryption of data at rest on the underlying filesystem, both in HFiles and in the WAL. This protects your data at rest from an attacker who has access to the underlying filesystem, without the need to change the implementation of the client. It can also protect against data leakage from improperly disposed disks, which can be important for legal and regulatory compliance.\n\nServer-side configuration, administration, and implementation details of each of these features are discussed below, along with any performance trade-offs. An example security configuration is given at the end, to show these features all used together, as they might be in a real-world scenario.\n\n<Callout type=\"error\">\n  All aspects of security in HBase are in active development and evolving rapidly. Any strategy you\n  employ for security of your data should be thoroughly tested. In addition, some of these features\n  are still in the experimental stage of development. To take advantage of many of these features,\n  you must be running HBase 0.98+ and using the HFile v3 file format.\n</Callout>\n\n<Callout type=\"warn\">\n  Several procedures in this section require you to copy files between cluster nodes. When copying\n  keys, configuration files, or other files containing sensitive strings, use a secure method, such\n  as `ssh`, to avoid leaking sensitive data.\n</Callout>\n\n#### Procedure: Basic Server-Side Configuration\n\n<Steps>\n  <Step>\n    Enable HFile v3, by setting `hfile.format.version` to 3 in *hbase-site.xml*. This is the default for HBase 1.0 and newer.\n\n    ```xml\n    <property>\n      <name>hfile.format.version</name>\n      <value>3</value>\n    </property>\n    ```\n  </Step>\n\n  <Step>\n    Enable SASL and Kerberos authentication for RPC and ZooKeeper, as described in [security.prerequisites](/docs/security/client-access#security-client-access-prerequisites) and [ZooKeeper](/docs/zookeeper).\n  </Step>\n</Steps>\n\n## Tags\n\n*Tags* are a feature of HFile v3. A tag is a piece of metadata which is part of a cell, separate from the key, value, and version. Tags are an implementation detail which provides a foundation for other security-related features such as cell-level ACLs and visibility labels. Tags are stored in the HFiles themselves. It is possible that in the future, tags will be used to implement other HBase features. You don't need to know a lot about tags in order to use the security features they enable.\n\n### Implementation Details\n\nEvery cell can have zero or more tags. Every tag has a type and the actual tag byte array.\n\nJust as row keys, column families, qualifiers and values can be encoded (see [data.block.encoding.types](/docs/compression#data-block-encoding-types)), tags can also be encoded as well. You can enable or disable tag encoding at the level of the column family, and it is enabled by default. Use the `HColumnDescriptor#setCompressionTags(boolean compressTags)` method to manage encoding settings on a column family. You also need to enable the DataBlockEncoder for the column family, for encoding of tags to take effect.\n\nYou can enable compression of each tag in the WAL, if WAL compression is also enabled, by setting the value of `hbase.regionserver.wal.tags.enablecompression` to `true` in *hbase-site.xml*. Tag compression uses dictionary encoding.\n\nCoprocessors that run server-side on RegionServers can perform get and set operations on cell Tags. Tags are stripped out at the RPC layer before the read response is sent back, so clients do not see these tags. Tag compression is not supported when using WAL encryption.\n\n## Access Control Labels (ACLs)\n\n### How It Works\n\nACLs in HBase are based upon a user's membership in or exclusion from groups, and a given group's permissions to access a given resource. ACLs are implemented as a coprocessor called AccessController.\n\nHBase does not maintain a private group mapping, but relies on a ***Hadoop group mapper***, which maps between entities in a directory such as LDAP or Active Directory, and HBase users. Any supported Hadoop group mapper will work. Users are then granted specific permissions (Read, Write, Execute, Create, Admin) against resources (global, namespaces, tables, cells, or endpoints).\n\n<Callout type=\"info\">\n  With Kerberos and Access Control enabled, client access to HBase is authenticated and user data is\n  private unless access has been explicitly granted.\n</Callout>\n\nHBase has a simpler security model than relational databases, especially in terms of client operations. No distinction is made between an insert (new record) and update (of existing record), for example, as both collapse down into a Put.\n\n#### Understanding Access Levels\n\nHBase access levels are granted independently of each other and allow for different types of operations at a given scope.\n\n* *Read (R)* - can read data at the given scope\n* *Write (W)* - can write data at the given scope\n* *Execute (X)* - can execute coprocessor endpoints at the given scope\n* *Create (C)* - can create tables or drop tables (even those they did not create) at the given scope\n* *Admin (A)* - can perform cluster operations such as balancing the cluster or assigning regions at the given scope\n\nThe possible scopes are:\n\n* *Superuser* - superusers can perform any operation available in HBase, to any resource. The user who runs HBase on your cluster is a superuser, as are any principals assigned to the configuration property `hbase.superuser` in *hbase-site.xml* on the HMaster.\n* *Global* - permissions granted at *global* scope allow the admin to operate on all tables of the cluster.\n* *Namespace* - permissions granted at *namespace* scope apply to all tables within a given namespace.\n* *Table* - permissions granted at *table* scope apply to data or metadata within a given table.\n* *ColumnFamily* - permissions granted at *ColumnFamily* scope apply to cells within that ColumnFamily.\n* *Cell* - permissions granted at *cell* scope apply to that exact cell coordinate (key, value, timestamp). This allows for policy evolution along with data.\n  To change an ACL on a specific cell, write an updated cell with new ACL to the precise coordinates of the original.\\\n  If you have a multi-versioned schema and want to update ACLs on all visible versions, you need to write new cells for all visible versions. The application has complete control over policy evolution.\\\n  The exception to the above rule is `append` and `increment` processing. Appends and increments can carry an ACL in the operation. If one is included in the operation, then it will be applied to the result of the `append` or `increment`. Otherwise, the ACL of the existing cell you are appending to or incrementing is preserved.\n\nThe combination of access levels and scopes creates a matrix of possible access levels that can be granted to a user. In a production environment, it is useful to think of access levels in terms of what is needed to do a specific job. The following list describes appropriate access levels for some common types of HBase users. It is important not to grant more access than is required for a given user to perform their required tasks.\n\n* *Superusers* - In a production system, only the HBase user should have superuser access. In a development environment, an administrator may need superuser access in order to quickly control and manage the cluster. However, this type of administrator should usually be a Global Admin rather than a superuser.\n* *Global Admins* - A global admin can perform tasks and access every table in HBase. In a typical production environment, an admin should not have Read or Write permissions to data within tables.\n* A global admin with Admin permissions can perform cluster-wide operations on the cluster, such as balancing, assigning or unassigning regions, or calling an explicit major compaction. This is an operations role.\n* A global admin with Create permissions can create or drop any table within HBase. This is more of a DBA-type role.\n  In a production environment, it is likely that different users will have only one of Admin and Create permissions.\n  <Callout type=\"warn\">\n    In the current implementation, a Global Admin with `Admin` permission can grant himself `Read`\n    and `Write` permissions on a table and gain access to that table's data. For this reason, only\n    grant `Global Admin` permissions to trusted user who actually need them. Also be aware that a\n    `Global Admin` with `Create` permission can perform a `Put` operation on the ACL table,\n    simulating a `grant` or `revoke` and circumventing the authorization check for `Global Admin`\n    permissions. Due to these issues, be cautious with granting `Global Admin` privileges.\n  </Callout>\n* *Namespace Admins* - a namespace admin with `Create` permissions can create or drop tables within that namespace, and take and restore snapshots. A namespace admin with `Admin` permissions can perform operations such as splits or major compactions on tables within that namespace.\n* *Table Admins* - A table admin can perform administrative operations only on that table. A table admin with `Create` permissions can create snapshots from that table or restore that table from a snapshot. A table admin with `Admin` permissions can perform operations such as splits or major compactions on that table.\n* *Users* - Users can read or write data, or both. Users can also execute coprocessor endpoints, if given `Executable` permissions.\n\n#### Real-World Example of Access Levels \\[!toc]\n\n| Job Title            | Scope  | Permissions    | Description                                                     |\n| -------------------- | ------ | -------------- | --------------------------------------------------------------- |\n| Senior Administrator | Global | Access, Create | Manages the cluster and gives access to Junior Administrators.  |\n| Junior Administrator | Global | Create         | Creates tables and gives access to Table Administrators.        |\n| Table Administrator  | Table  | Access         | Maintains a table from an operations point of view.             |\n| Data Analyst         | Table  | Read           | Creates reports from HBase data.                                |\n| Web Application      | Table  | Read, Write    | Puts data into HBase and uses HBase data to perform operations. |\n\n#### ACL Matrix \\[!toc]\n\nFor more details on how ACLs map to specific HBase operations and tasks, see [appendix acl matrix](/docs/acl-matrix).\n\n#### Implementation Details\n\nCell-level ACLs are implemented using tags (see [Tags](/docs/security/data-access#tags)). In order to use cell-level ACLs, you must be using HFile v3 and HBase 0.98 or newer.\n\n1. Files created by HBase are owned by the operating system user running the HBase process. To interact with HBase files, you should use the API or bulk load facility.\n2. HBase does not model \"roles\" internally in HBase. Instead, group names can be granted permissions. This allows external modeling of roles via group membership. Groups are created and manipulated externally to HBase, via the Hadoop group mapping service.\n\n#### Server-Side Configuration\n\n<Steps>\n  <Step>\n    As a prerequisite, perform the steps in [Procedure: Basic Server-Side Configuration](/docs/security/data-access#procedure-basic-server-side-configuration).\n  </Step>\n\n  <Step>\n    Install and configure the AccessController coprocessor, by setting the following properties in *hbase-site.xml*. These properties take a list of classes.\n\n    <Callout type=\"info\">\n      If you use the AccessController along with the VisibilityController, the AccessController must\n      come first in the list, because with both components active, the VisibilityController will\n      delegate access control on its system tables to the AccessController. For an example of using both\n      together, see [Security Configuration Example](/docs/security/example).\n    </Callout>\n\n    ```xml\n    <property>\n      <name>hbase.security.authorization</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.region.classes</name>\n      <value>\n        org.apache.hadoop.hbase.security.access.AccessController,\n        org.apache.hadoop.hbase.security.token.TokenProvider\n      </value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.master.classes</name>\n      <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.regionserver.classes</name>\n      <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n    </property>\n    <property>\n      <name>hbase.security.exec.permission.checks</name>\n      <value>true</value>\n    </property>\n    ```\n\n    Optionally, you can enable transport security, by setting `hbase.rpc.protection` to\n    `privacy`. This requires HBase 0.98.4 or newer.\n  </Step>\n\n  <Step>\n    Set up the Hadoop group mapper in the Hadoop namenode's *core-site.xml*. This is a Hadoop file, not an HBase file. Customize it to your site's needs. Following is an example.\n\n    ```xml\n    <property>\n      <name>hadoop.security.group.mapping</name>\n      <value>org.apache.hadoop.security.LdapGroupsMapping</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.url</name>\n      <value>ldap://server</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.bind.user</name>\n      <value>Administrator@example-ad.local</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.bind.password</name>\n      <value>****</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.base</name>\n      <value>dc=example-ad,dc=local</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.filter.user</name>\n      <value>(&amp;(objectClass=user)(sAMAccountName={0}))</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.filter.group</name>\n      <value>(objectClass=group)</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.attr.member</name>\n      <value>member</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.attr.group.name</name>\n      <value>cn</value>\n    </property>\n    ```\n  </Step>\n\n  <Step>\n    Optionally, enable the early-out evaluation strategy. Prior to HBase 0.98.0, if a user was not granted access to a column family, or at least a column qualifier, an AccessDeniedException would be thrown. HBase 0.98.0 removed this exception in order to allow cell-level exceptional grants. To restore the old behavior in HBase 0.98.0-0.98.6, set `hbase.security.access.early_out` to `true` in *hbase-site.xml*. In HBase 0.98.6, the default has been returned to `true`.\n  </Step>\n\n  <Step>\n    Distribute your configuration and restart your cluster for changes to take effect.\n  </Step>\n\n  <Step>\n    To test your configuration, log into HBase Shell as a given user and use the `whoami` command to report the groups your user is part of. In this example, the user is reported as being a member of the `services` group.\n\n    ```ruby\n    hbase> whoami\n    service (auth:KERBEROS)\n        groups: services\n    ```\n  </Step>\n</Steps>\n\n#### Administration\n\nAdministration tasks can be performed from HBase Shell or via an API.\n\n<Callout type=\"error\">\n  Many of the API examples below are taken from source files *hbase-server/src/test/java/org/apache/hadoop/hbase/security/access/TestAccessController.java* and *hbase-server/src/test/java/org/apache/hadoop/hbase/security/access/SecureTestUtil.java*.\n\n  Neither the examples, nor the source files they are taken from, are part of the public HBase API, and are provided for illustration only. Refer to the official API for usage instructions.\n</Callout>\n\n<Steps>\n  <Step>\n    As a prerequisite, perform the steps in [Procedure: Basic Server-Side Configuration.](/docs/security/data-access#procedure-basic-server-side-configuration).\n  </Step>\n\n  <Step>\n    Install and configure the AccessController coprocessor, by setting the following properties in *hbase-site.xml*. These properties take a list of classes.\n\n    <Callout type=\"info\">\n      If you use the AccessController along with the VisibilityController, the AccessController must\n      come first in the list, because with both components active, the VisibilityController will\n      delegate access control on its system tables to the AccessController. For an example of using both\n      together, see [Security Configuration Example](/docs/security/example).\n    </Callout>\n\n    ```xml\n    <property>\n      <name>hbase.security.authorization</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.region.classes</name>\n      <value>\n        org.apache.hadoop.hbase.security.access.AccessController,\n        org.apache.hadoop.hbase.security.token.TokenProvider\n      </value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.master.classes</name>\n      <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.regionserver.classes</name>\n      <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n    </property>\n    <property>\n      <name>hbase.security.exec.permission.checks</name>\n      <value>true</value>\n    </property>\n    ```\n\n    Optionally, you can enable transport security, by setting `hbase.rpc.protection` to\n    `privacy`. This requires HBase 0.98.4 or newer.\n  </Step>\n\n  <Step>\n    Set up the Hadoop group mapper in the Hadoop namenode's *core-site.xml*. This is a Hadoop file, not an HBase file. Customize it to your site's needs. Following is an example.\n\n    ```xml\n    <property>\n      <name>hadoop.security.group.mapping</name>\n      <value>org.apache.hadoop.security.LdapGroupsMapping</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.url</name>\n      <value>ldap://server</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.bind.user</name>\n      <value>Administrator@example-ad.local</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.bind.password</name>\n      <value>****</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.base</name>\n      <value>dc=example-ad,dc=local</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.filter.user</name>\n      <value>(&amp;(objectClass=user)(sAMAccountName={0}))</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.filter.group</name>\n      <value>(objectClass=group)</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.attr.member</name>\n      <value>member</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.attr.group.name</name>\n      <value>cn</value>\n    </property>\n    ```\n  </Step>\n\n  <Step>\n    Optionally, enable the early-out evaluation strategy. Prior to HBase 0.98.0, if a user was not granted access to a column family, or at least a column qualifier, an AccessDeniedException would be thrown. HBase 0.98.0 removed this exception in order to allow cell-level exceptional grants. To restore the old behavior in HBase 0.98.0-0.98.6, set `hbase.security.access.early_out` to `true` in *hbase-site.xml*. In HBase 0.98.6, the default has been returned to `true`.\n  </Step>\n\n  <Step>\n    Distribute your configuration and restart your cluster for changes to take effect.\n  </Step>\n\n  <Step>\n    To test your configuration, log into HBase Shell as a given user and use the `whoami` command to report the groups your user is part of. In this example, the user is reported as being a member of the `services` group.\n\n    ```ruby\n    hbase> whoami\n    service (auth:KERBEROS)\n        groups: services\n    ```\n  </Step>\n</Steps>\n\n#### API example:\n\n```java\npublic static void verifyAllowed(User user, AccessTestAction action, int count) throws Exception {\n  try {\n    Object obj = user.runAs(action);\n    if (obj != null && obj instanceof List<?>) {\n      List<?> results = (List<?>) obj;\n      if (results != null && results.isEmpty()) {\n        fail(\"Empty non null results from action for user '\" + user.getShortName() + \"'\");\n      }\n      assertEquals(count, results.size());\n    }\n  } catch (AccessDeniedException ade) {\n    fail(\"Expected action to pass for user '\" + user.getShortName() + \"' but was denied\");\n  }\n}\n```\n\n## Visibility Labels\n\nVisibility labels control can be used to only permit users or principals associated with a given label to read or access cells with that label. For instance, you might label a cell `top-secret`, and only grant access to that label to the `managers` group. Visibility labels are implemented using Tags, which are a feature of HFile v3, and allow you to store metadata on a per-cell basis. A label is a string, and labels can be combined into expressions by using logical operators (&, |, or !), and using parentheses for grouping. HBase does not do any kind of validation of expressions beyond basic well-formedness. Visibility labels have no meaning on their own, and may be used to denote sensitivity level, privilege level, or any other arbitrary semantic meaning.\n\nIf a user's labels do not match a cell's label or expression, the user is denied access to the cell.\n\nIn HBase 0.98.6 and newer, UTF-8 encoding is supported for visibility labels and expressions. When creating labels using the `addLabels(conf, labels)` method provided by the `org.apache.hadoop.hbase.security.visibility.VisibilityClient` class and passing labels in Authorizations via Scan or Get, labels can contain UTF-8 characters, as well as the logical operators normally used in visibility labels, with normal Java notations, without needing any escaping method. However, when you pass a CellVisibility expression via a Mutation, you must enclose the expression with the `CellVisibility.quote()` method if you use UTF-8 characters or logical operators. See `TestExpressionParser` and the source file *hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestScan.java*.\n\nA user adds visibility expressions to a cell during a Put operation. In the default configuration, the user does not need to have access to a label in order to label cells with it. This behavior is controlled by the configuration option `hbase.security.visibility.mutations.checkauths`. If you set this option to `true`, the labels the user is modifying as part of the mutation must be associated with the user, or the mutation will fail. Whether a user is authorized to read a labelled cell is determined during a Get or Scan, and results which the user is not allowed to read are filtered out. This incurs the same I/O penalty as if the results were returned, but reduces load on the network.\n\nVisibility labels can also be specified during Delete operations. For details about visibility labels and Deletes, see [HBASE-10885](https://issues.apache.org/jira/browse/HBASE-10885).\n\nThe user's effective label set is built in the RPC context when a request is first received by the RegionServer. The way that users are associated with labels is pluggable. The default plugin passes through labels specified in Authorizations added to the Get or Scan and checks those against the calling user's authenticated labels list. When the client passes labels for which the user is not authenticated, the default plugin drops them. You can pass a subset of user authenticated labels via the `Get#setAuthorizations(Authorizations(String,...))` and `Scan#setAuthorizations(Authorizations(String,...));` methods.\n\nGroups can be granted visibility labels the same way as users. Groups are prefixed with an @ symbol. When checking visibility labels of a user, the server will include the visibility labels of the groups of which the user is a member, together with the user's own labels. When the visibility labels are retrieved using API `VisibilityClient#getAuths` or Shell command `get_auths` for a user, we will return labels added specifically for that user alone, not the group level labels.\n\nVisibility label access checking is performed by the VisibilityController coprocessor. You can use interface `VisibilityLabelService` to provide a custom implementation and/or control the way that visibility labels are stored with cells. See the source file *hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsWithCustomVisLabService.java* for one example.\n\nVisibility labels can be used in conjunction with ACLs.\n\n<Callout type=\"info\">\n  The labels have to be explicitly defined before they can be used in visibility labels. See below\n  for an example of how this can be done.\n</Callout>\n\n<Callout type=\"info\">\n  There is currently no way to determine which labels have been applied to a cell. See\n  [HBASE-12470](https://issues.apache.org/jira/browse/HBASE-12470) for details.\n</Callout>\n\n<Callout type=\"info\">\n  Visibility labels are not currently applied for superusers.\n</Callout>\n\n### Examples of Visibility Expressions\n\n| Expression                                | Interpretation                                                                                                             |\n| ----------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| `fulltime`                                | Allow access to users associated with the fulltime label.                                                                  |\n| `!public`                                 | Allow access to users not associated with the public label.                                                                |\n| `( secret \\| topsecret ) & !probationary` | Allow access to users associated with either the secret or topsecret label and not associated with the probationary label. |\n\n### Server-Side Configuration\n\n<Steps>\n  <Step>\n    As a prerequisite, perform the steps in [Procedure: Basic Server-Side Configuration.](/docs/security/data-access#procedure-basic-server-side-configuration).\n  </Step>\n\n  <Step>\n    Install and configure the VisibilityController coprocessor by setting the following properties in *hbase-site.xml*. These properties take a list of class names.\n\n    ```xml\n    <property>\n      <name>hbase.security.authorization</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.region.classes</name>\n      <value>org.apache.hadoop.hbase.security.visibility.VisibilityController</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.master.classes</name>\n      <value>org.apache.hadoop.hbase.security.visibility.VisibilityController</value>\n    </property>\n    ```\n\n    <Callout type=\"info\">\n      If you use the AccessController and VisibilityController coprocessors together, the\n      AccessController must come first in the list, because with both components active, the\n      VisibilityController will delegate access control on its system tables to the AccessController.\n    </Callout>\n  </Step>\n\n  <Step>\n    Adjust Configuration\n\n    By default, users can label cells with any label, including labels they are not associated with, which means that a user can Put data that he cannot read. For example, a user could label a cell with the (hypothetical) 'topsecret' label even if the user is not associated with that label. If you only want users to be able to label cells with labels they are associated with, set `hbase.security.visibility.mutations.checkauths` to `true`. In that case, the mutation will fail if it makes use of labels the user is not associated with.\n  </Step>\n\n  <Step>\n    Distribute your configuration and restart your cluster for changes to take effect.\n  </Step>\n</Steps>\n\n### Administration\n\nAdministration tasks can be performed using the HBase Shell or the Java API. For defining the list of visibility labels and associating labels with users, the HBase Shell is probably simpler.\n\n<Callout type=\"error\">\n  Many of the Java API examples in this section are taken from the source file *hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabels.java*. Refer to that file or the API documentation for more context.\n\n  Neither these examples, nor the source file they were taken from, are part of the public HBase API, and are provided for illustration only. Refer to the official API for usage instructions.\n</Callout>\n\n<Steps>\n  <Step>\n    Define the List of Visibility Labels\n\n    **HBase Shell:**\n\n    ```ruby\n    hbase> add_labels [ 'admin', 'service', 'developer', 'test' ]\n    ```\n\n    **Java API:**\n\n    ```java\n    public static void addLabels() throws Exception {\n      PrivilegedExceptionAction<VisibilityLabelsResponse> action = new PrivilegedExceptionAction<VisibilityLabelsResponse>() {\n        public VisibilityLabelsResponse run() throws Exception {\n          String[] labels = { SECRET, TOPSECRET, CONFIDENTIAL, PUBLIC, PRIVATE, COPYRIGHT, ACCENT,\n              UNICODE_VIS_TAG, UC1, UC2 };\n          try {\n            VisibilityClient.addLabels(conf, labels);\n          } catch (Throwable t) {\n            throw new IOException(t);\n          }\n          return null;\n        }\n      };\n      SUPERUSER.runAs(action);\n    }\n    ```\n  </Step>\n\n  <Step>\n    Associate Labels with Users\n\n    **HBase Shell:**\n\n    ```ruby\n    hbase> set_auths 'service', [ 'service' ]\n    hbase> set_auths 'testuser', [ 'test' ]\n    hbase> set_auths 'qa', [ 'test', 'developer' ]\n    hbase> set_auths '@qagroup', [ 'test' ]\n    ```\n\n    **Java API:**\n\n    ```java\n    public void testSetAndGetUserAuths() throws Throwable {\n      final String user = \"user1\";\n      PrivilegedExceptionAction<Void> action = new PrivilegedExceptionAction<Void>() {\n        public Void run() throws Exception {\n          String[] auths = { SECRET, CONFIDENTIAL };\n          try {\n            VisibilityClient.setAuths(conf, auths, user);\n          } catch (Throwable e) {\n          }\n          return null;\n        }\n        ...\n    ```\n  </Step>\n\n  <Step>\n    Clear Labels From Users\n\n    **HBase Shell:**\n\n    ```ruby\n    hbase> clear_auths 'service', [ 'service' ]\n    hbase> clear_auths 'testuser', [ 'test' ]\n    hbase> clear_auths 'qa', [ 'test', 'developer' ]\n    hbase> clear_auths '@qagroup', [ 'test', 'developer' ]\n    ```\n\n    **Java API:**\n\n    ```java\n    ...\n    auths = new String[] { SECRET, PUBLIC, CONFIDENTIAL };\n    VisibilityLabelsResponse response = null;\n    try {\n      response = VisibilityClient.clearAuths(conf, auths, user);\n    } catch (Throwable e) {\n      fail(\"Should not have failed\");\n      ...\n    }\n    ```\n  </Step>\n\n  <Step>\n    Apply a Label or Expression to a Cell\n\n    The label is only applied when data is written. The label is associated with a given version of the cell.\n\n    **HBase Shell:**\n\n    ```ruby\n    hbase> set_visibility 'user', 'admin|service|developer', { COLUMNS => 'i' }\n    hbase> set_visibility 'user', 'admin|service', { COLUMNS => 'pii' }\n    hbase> set_visibility 'user', 'test', { COLUMNS => [ 'i', 'pii' ], FILTER => \"(PrefixFilter ('test'))\" }\n    ```\n\n    <Callout type=\"info\">\n      HBase Shell support for applying labels or permissions to cells is for testing and verification\n      support, and should not be employed for production use because it won't apply the labels to cells\n      that don't exist yet. The correct way to apply cell level labels is to do so in the application\n      code when storing the values.\n    </Callout>\n\n    **Java API example:**\n\n    ```java\n    static Table createTableAndWriteDataWithLabels(TableName tableName, String... labelExps)\n        throws Exception {\n      Configuration conf = HBaseConfiguration.create();\n      Connection connection = ConnectionFactory.createConnection(conf);\n      Table table = NULL;\n          try {\n            table = TEST_UTIL.createTable(tableName, fam);\n            int i = 1;\n            List<Put> puts = new ArrayList<Put>();\n            for (String labelExp : labelExps) {\n              Put put = new Put(Bytes.toBytes(\"row\" + i));\n              put.add(fam, qual, HConstants.LATEST_TIMESTAMP, value);\n              put.setCellVisibility(new CellVisibility(labelExp));\n              puts.add(put);\n              i++;\n            }\n            table.put(puts);\n          } finally {\n            if (table != null) {\n              table.flushCommits();\n            }\n          }\n        }\n    ```\n  </Step>\n</Steps>\n\n### Reading Cells with Labels\n\nWhen you issue a Scan or Get, HBase uses your default set of authorizations to filter out cells that you do not have access to. A superuser can set the default set of authorizations for a given user by using the `set_auths` HBase Shell command or the [VisibilityClient.setAuths()](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/security/visibility/VisibilityClient.html#setAuths\\(org.apache.hadoop.hbase.client.Connection,java.lang.String%5B%5D,java.lang.String\\)) method.\n\nYou can specify a different authorization during the Scan or Get, by passing the AUTHORIZATIONS option in HBase Shell, or the [Scan.setAuthorizations()](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html#setAuthorizations\\(org.apache.hadoop.hbase.security.visibility.Authorizations\\)) method if you use the API. This authorization will be combined with your default set as an additional filter. It will further filter your results, rather than giving you additional authorization.\n\n#### HBase Shell: \\[!toc]\n\n```ruby\nhbase> get_auths 'myUser'\nhbase> scan 'table1', AUTHORIZATIONS => ['private']\n```\n\n#### Java API: \\[!toc]\n\n```java\n...\npublic Void run() throws Exception {\n  String[] auths1 = { SECRET, CONFIDENTIAL };\n  GetAuthsResponse authsResponse = null;\n  try {\n    VisibilityClient.setAuths(conf, auths1, user);\n    try {\n      authsResponse = VisibilityClient.getAuths(conf, user);\n    } catch (Throwable e) {\n      fail(\"Should not have failed\");\n    }\n  } catch (Throwable e) {\n  }\n  List<String> authsList = new ArrayList<String>();\n  for (ByteString authBS : authsResponse.getAuthList()) {\n    authsList.add(Bytes.toString(authBS.toByteArray()));\n  }\n  assertEquals(2, authsList.size());\n  assertTrue(authsList.contains(SECRET));\n  assertTrue(authsList.contains(CONFIDENTIAL));\n  return null;\n}\n...\n```\n\n### Implementing Your Own Visibility Label Algorithm\n\nInterpreting the labels authenticated for a given get/scan request is a pluggable algorithm.\n\nYou can specify a custom plugin or plugins by using the property `hbase.regionserver.scan.visibility.label.generator.class`. The output for the first `ScanLabelGenerator` will be the input for the next one, until the end of the list.\n\nThe default implementation, which was implemented in [HBASE-12466](https://issues.apache.org/jira/browse/HBASE-12466), loads two plugins, `FeedUserAuthScanLabelGenerator` and `DefinedSetFilterScanLabelGenerator`. See [Reading Cells with Labels](/docs/security/data-access#reading-cells-with-labels).\n\n### Replicating Visibility Tags as Strings\n\nAs mentioned in the above sections, the interface `VisibilityLabelService` could be used to implement a different way of storing the visibility expressions in the cells. Clusters with replication enabled also must replicate the visibility expressions to the peer cluster. If `DefaultVisibilityLabelServiceImpl` is used as the implementation for `VisibilityLabelService`, all the visibility expression are converted to the corresponding expression based on the ordinals for each visibility label stored in the labels table. During replication, visible cells are also replicated with the ordinal-based expression intact. The peer cluster may not have the same `labels` table with the same ordinal mapping for the visibility labels. In that case, replicating the ordinals makes no sense. It would be better if the replication occurred with the visibility expressions transmitted as strings. To replicate the visibility expression as strings to the peer cluster, create a `RegionServerObserver` configuration which works based on the implementation of the `VisibilityLabelService` interface. The configuration below enables replication of visibility expressions to peer clusters as strings. See [HBASE-11639](https://issues.apache.org/jira/browse/HBASE-11639) for more details.\n\n```xml\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.coprocessor.regionserver.classes</name>\n  <value>org.apache.hadoop.hbase.security.visibility.VisibilityController$VisibilityReplication</value>\n</property>\n```\n\n## Transparent Encryption of Data At Rest\n\nHBase provides a mechanism for protecting your data at rest, in HFiles and the WAL, which reside within HDFS or another distributed filesystem. A two-tier architecture is used for flexible and non-intrusive key rotation. \"Transparent\" means that no implementation changes are needed on the client side. When data is written, it is encrypted. When it is read, it is decrypted on demand.\n\n### How It Works\n\nThe administrator provisions a master key for the cluster, which is stored in a key provider accessible to every trusted HBase process, including the HMaster, RegionServers, and clients (such as HBase Shell) on administrative workstations. The default key provider is integrated with the Java KeyStore API and any key management systems with support for it. Other custom key provider implementations are possible. The key retrieval mechanism is configured in the *hbase-site.xml* configuration file. The master key may be stored on the cluster servers, protected by a secure KeyStore file, or on an external keyserver, or in a hardware security module. This master key is resolved as needed by HBase processes through the configured key provider.\n\nNext, encryption use can be specified in the schema, per column family, by creating or modifying a column descriptor to include two additional attributes: the name of the encryption algorithm to use (currently only \"AES\" is supported), and optionally, a data key wrapped (encrypted) with the cluster master key. If a data key is not explicitly configured for a ColumnFamily, HBase will create a random data key per HFile. This provides an incremental improvement in security over the alternative. Unless you need to supply an explicit data key, such as in a case where you are generating encrypted HFiles for bulk import with a given data key, only specify the encryption algorithm in the ColumnFamily schema metadata and let HBase create data keys on demand. Per Column Family keys facilitate low impact incremental key rotation and reduce the scope of any external leak of key material. The wrapped data key is stored in the ColumnFamily schema metadata, and in each HFile for the Column Family, encrypted with the cluster master key. After the Column Family is configured for encryption, any new HFiles will be written encrypted. To ensure encryption of all HFiles, trigger a major compaction after enabling this feature.\n\nWhen the HFile is opened, the data key is extracted from the HFile, decrypted with the cluster master key, and used for decryption of the remainder of the HFile. The HFile will be unreadable if the master key is not available. If a remote user somehow acquires access to the HFile data because of some lapse in HDFS permissions, or from inappropriately discarded media, it will not be possible to decrypt either the data key or the file data.\n\nIt is also possible to encrypt the WAL. Even though WALs are transient, it is necessary to encrypt the WALEdits to avoid circumventing HFile protections for encrypted column families, in the event that the underlying filesystem is compromised. When WAL encryption is enabled, all WALs are encrypted, regardless of whether the relevant HFiles are encrypted.\n\n### Enable or disable the feature.\n\nThe \"Transparent Encryption of Data At Rest\" feature is enabled by default, meaning the users can define tables with column families where the HFiles and WAL files will be encrypted by HBase, assuming the feature is properly configured (see [Server-Side Configuration](/docs/security/data-access#security-data-access-transparent-encryption-of-data-at-test-server-side-configuration)).\n\nIn some cases (e.g. due to custom security policies), the operator of the HBase cluster might wish to only rely on an encryption at rest mechanism outside of HBase (e.g. those offered by HDFS) and wants to ensure that HBase's encryption at rest system is inactive. Since [HBASE-25181](https://issues.apache.org/jira/browse/HBASE-25181) it is possible to explicitly disable HBase's own encryption by setting `hbase.crypto.enabled` to `false`. This configuration is `true` by default. If it is set to `false`, the users won't be able to create any table (column family) with HFile and WAL file encryption and the related create table shell (or API) commands will fail if they try.\n\n### Server-Side Configuration\n\nThis procedure assumes you are using the default Java keystore implementation. If you are using a custom implementation, check its documentation and adjust accordingly.\n\n<Steps>\n  <Step>\n    Create a secret key of appropriate length for AES encryption, using the `keytool` utility.\n\n    ```bash\n    $ keytool -keystore /path/to/hbase/conf/hbase.jks \\\n      -storetype jceks -storepass **** \\\n      -genseckey -keyalg AES -keysize 128 \\\n      -alias <alias>\n    ```\n\n    Replace \\*\\*\\*\\* with the password for the keystore file and \\<alias> with the username of the HBase service account, or an arbitrary string. If you use an arbitrary string, you will need to configure HBase to use it, and that is covered below. Specify a keysize that is appropriate. Do not specify a separate password for the key, but press `Return` when prompted.\n  </Step>\n\n  <Step>\n    Set appropriate permissions on the keyfile and distribute it to all the HBase servers.\n\n    The previous command created a file called *hbase.jks* in the HBase *conf/* directory. Set the permissions and ownership on this file such that only the HBase service account user can read the file, and securely distribute the key to all HBase servers.\n  </Step>\n\n  <Step>\n    Configure the HBase daemons.\n\n    Set the following properties in *hbase-site.xml* on the region servers, to configure HBase daemons to use a key provider backed by the KeyStore file or retrieving the cluster master key. In the example below, replace \\*\\*\\*\\* with the password.\n\n    ```xml\n    <property>\n      <name>hbase.crypto.keyprovider</name>\n      <value>org.apache.hadoop.hbase.io.crypto.KeyStoreKeyProvider</value>\n    </property>\n    <property>\n      <name>hbase.crypto.keyprovider.parameters</name>\n      <value>jceks:///path/to/hbase/conf/hbase.jks?password=****</value>\n    </property>\n    ```\n\n    By default, the HBase service account name will be used to resolve the cluster master key. However, you can store it with an arbitrary alias (in the `keytool` command). In that case, set the following property to the alias you used.\n\n    ```xml\n    <property>\n      <name>hbase.crypto.master.key.name</name>\n      <value>my-alias</value>\n    </property>\n    ```\n\n    You also need to be sure your HFiles use HFile v3, in order to use transparent encryption. This is the default configuration for HBase 1.0 onward. For previous versions, set the following property in your *hbase-site.xml* file.\n\n    ```xml\n    <property>\n      <name>hfile.format.version</name>\n      <value>3</value>\n    </property>\n    ```\n\n    Optionally, you can use a different cipher provider, either a Java Cryptography Encryption (JCE) algorithm provider or a custom HBase cipher implementation.\n\n    * JCE:\n      * Install a signed JCE provider (supporting `AES/CTR/NoPadding` mode with 128 bit keys)\n      * Add it with highest preference to the JCE site configuration file *\\$JAVA\\_HOME/lib/security/java.security*.\n      * Update `hbase.crypto.algorithm.aes.provider` and `hbase.crypto.algorithm.rng.provider` options in *hbase-site.xml*.\n    * Custom HBase Cipher:\n      * Implement `org.apache.hadoop.hbase.io.crypto.CipherProvider`.\n      * Add the implementation to the server classpath.\n      * Update `hbase.crypto.cipherprovider` in *hbase-site.xml*.\n  </Step>\n\n  <Step>\n    Configure WAL encryption.\n\n    Configure WAL encryption in every RegionServer's *hbase-site.xml*, by setting the following properties. You can include these in the HMaster's *hbase-site.xml* as well, but the HMaster does not have a WAL and will not use them.\n\n    ```xml\n    <property>\n      <name>hbase.regionserver.hlog.reader.impl</name>\n      <value>org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogReader</value>\n    </property>\n    <property>\n      <name>hbase.regionserver.hlog.writer.impl</name>\n      <value>org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogWriter</value>\n    </property>\n    <property>\n      <name>hbase.regionserver.wal.encryption</name>\n      <value>true</value>\n    </property>\n    ```\n\n    <Callout type=\"info\">\n      Starting from 2.6.0, the hbase.regionserver.hlog.reader.impl and\n      hbase.regionserver.hlog.writer.impl configurations are removed, you do not need to specify them\n      any more. Just set hbase.regionserver.wal.encryption to true is enough to enable WAL encryption.\n    </Callout>\n  </Step>\n\n  <Step>\n    (Optional) Configure encryption key hash algorithm.\n\n    Since [HBASE-25181](https://issues.apache.org/jira/browse/HBASE-25181) it is possible to use custom encryption key hash algorithm instead of the default MD5 algorithm. This hash is needed to verify the secret key during decryption. The MD5 algorithm is considered weak, and can not be used in some (e.g. FIPS compliant) clusters.\n\n    The hash is set via the configuration option `hbase.crypto.key.hash.algorithm`. It should be set to a JDK `MessageDigest` algorithm like \"MD5\", \"SHA-384\" or \"SHA-512\". The default is \"MD5\" for backward compatibility. An example of this configuration parameter on a FIPS-compliant cluster:\n\n    ```xml\n    <property>\n      <name>hbase.crypto.key.hash.algorithm</name>\n      <value>SHA-384</value>\n    </property>\n    ```\n  </Step>\n\n  <Step>\n    Configure permissions on the *hbase-site.xml* file.\n\n    Because the keystore password is stored in the hbase-site.xml, you need to ensure that only the HBase user can read the *hbase-site.xml* file, using file ownership and permissions.\n  </Step>\n\n  <Step>\n    Restart your cluster.\n\n    Distribute the new configuration file to all nodes and restart your cluster.\n  </Step>\n</Steps>\n\n### Administration\n\nAdministrative tasks can be performed in HBase Shell or the Java API.\n\n<Callout type=\"error\">\n  Java API examples in this section are taken from the source file *hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestHBaseFsckEncryption.java*. .\n\n  Neither these examples, nor the source files they are taken from, are part of the public HBase API, and are provided for illustration only. Refer to the official API for usage instructions.\n</Callout>\n\n#### Enable Encryption on a Column Family\n\nTo enable encryption on a column family, you can either use HBase Shell or the Java API. After enabling encryption, trigger a major compaction. When the major compaction completes, the compacted new HFiles will be encrypted. However, depending on the compaction settings, it is possible that not all the HFiles will be rewritten during a major compaction and there still might remain some old unencrypted HFiles. Also please note, that the snapshots are immutable. So the snapshots taken before you enabled the encryption will still contain the unencrypted HFiles.\n\n#### Rotate the Data Key\n\nTo rotate the data key, first change the ColumnFamily key in the column descriptor, then trigger a major compaction. Until the compaction completes, the old HFiles will still be readable using the old key. During compaction, the compacted HFiles will be re-encrypted using the new data key. However, depending on the compaction settings, it is possible that not all the HFiles will be rewritten during a major compaction and there still might remain some old HFiles encrypted with the old key. Also please note, that the snapshots are immutable. So the snapshots taken before the changing of the encryption key will still contain the HFiles written using the old key.\n\n#### Switching Between Using a Random Data Key and Specifying A Key\n\nIf you configured a column family to use a specific key and you want to return to the default behavior of using a randomly-generated key for that column family, use the Java API to alter the `HColumnDescriptor` so that no value is sent with the key `ENCRYPTION_KEY`.\n\n#### Rotate the Master Key\n\nTo rotate the master key, first generate and distribute the new key. Then update the KeyStore to contain a new master key, and keep the old master key in the KeyStore using a different alias. Next, configure fallback to the old master key in the *hbase-site.xml* file.\n\n## Secure Enable\n\nAfter hbase-2.x, the default 'hbase.security.authorization' changed. Before hbase-2.x, it defaulted to true, in later HBase versions, the default became false. So to enable hbase authorization, the following propertie must be configured in *hbase-site.xml*. See [HBASE-19483](https://issues.apache.org/jira/browse/HBASE-19483);\n\n```xml\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n</property>\n```\n\n\n# Security Configuration Example (/docs/security/example)\n#### Example Security Settings in *hbase-site.xml*\n\n```xml\n<!-- HFile v3 Support -->\n<property>\n  <name>hfile.format.version</name>\n  <value>3</value>\n</property>\n<!-- HBase Superuser -->\n<property>\n  <name>hbase.superuser</name>\n  <value>hbase,admin,@superuser-group</value>\n</property>\n<!-- Coprocessors for ACLs and Visibility Tags -->\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.coprocessor.region.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController,\n  org.apache.hadoop.hbase.security.visibility.VisibilityController,\n  org.apache.hadoop.hbase.security.token.TokenProvider</value>\n</property>\n<property>\n  <name>hbase.coprocessor.master.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController,\n  org.apache.hadoop.hbase.security.visibility.VisibilityController</value>\n</property>\n<property>\n  <name>hbase.coprocessor.regionserver.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n<!-- Executable ACL for Coprocessor Endpoints -->\n<property>\n  <name>hbase.security.exec.permission.checks</name>\n  <value>true</value>\n</property>\n<!-- Whether a user needs authorization for a visibility tag to set it on a cell -->\n<property>\n  <name>hbase.security.visibility.mutations.checkauth</name>\n  <value>false</value>\n</property>\n<!-- Secure RPC Transport -->\n<property>\n  <name>hbase.rpc.protection</name>\n  <value>privacy</value>\n </property>\n <!-- Transparent Encryption -->\n<property>\n  <name>hbase.crypto.keyprovider</name>\n  <value>org.apache.hadoop.hbase.io.crypto.KeyStoreKeyProvider</value>\n</property>\n<property>\n  <name>hbase.crypto.keyprovider.parameters</name>\n  <value>jceks:///path/to/hbase/conf/hbase.jks?password=***</value>\n</property>\n<property>\n  <name>hbase.crypto.master.key.name</name>\n  <value>hbase</value>\n</property>\n<!-- WAL Encryption -->\n<property>\n  <name>hbase.regionserver.hlog.reader.impl</name>\n  <value>org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogReader</value>\n</property>\n<property>\n  <name>hbase.regionserver.hlog.writer.impl</name>\n  <value>org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogWriter</value>\n</property>\n<property>\n  <name>hbase.regionserver.wal.encryption</name>\n  <value>true</value>\n</property>\n<!-- For key rotation -->\n<property>\n  <name>hbase.crypto.master.alternate.key.name</name>\n  <value>hbase.old</value>\n</property>\n```\n\n<Callout type=\"info\">\n  Starting from 2.6.0, the hbase.regionserver.hlog.reader.impl and\n  hbase.regionserver.hlog.writer.impl configurations are removed, you do not need to specify them\n  any more. Just set hbase.regionserver.wal.encryption to true is enough to enable WAL encryption.\n</Callout>\n\n#### Example Group Mapper in Hadoop *core-site.xml*\n\nAdjust these settings to suit your environment.\n\n```xml\n<property>\n  <name>hadoop.security.group.mapping</name>\n  <value>org.apache.hadoop.security.LdapGroupsMapping</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.url</name>\n  <value>ldap://server</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.bind.user</name>\n  <value>Administrator@example-ad.local</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.bind.password</name>\n  <value>****</value> <!-- Replace with the actual password -->\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.base</name>\n  <value>dc=example-ad,dc=local</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.search.filter.user</name>\n  <value>(&amp;(objectClass=user)(sAMAccountName={0}))</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.search.filter.group</name>\n  <value>(objectClass=group)</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.search.attr.member</name>\n  <value>member</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.search.attr.group.name</name>\n  <value>cn</value>\n</property>\n```\n\n\n# Securing Access to HDFS and ZooKeeper (/docs/security/hdfs-and-zookeeper-access)\n## Securing ZooKeeper Data\n\nZooKeeper has a pluggable authentication mechanism to enable access from clients using different methods. ZooKeeper even allows authenticated and un-authenticated clients at the same time. The access to znodes can be restricted by providing Access Control Lists (ACLs) per znode. An ACL contains two components, the authentication method and the principal. ACLs are NOT enforced hierarchically. See [ZooKeeper Programmers Guide](https://zookeeper.apache.org/doc/r3.3.6/zookeeperProgrammers.html#sc_ZooKeeperPluggableAuthentication) for details.\n\nHBase daemons authenticate to ZooKeeper via SASL and kerberos (See [ZooKeeper](/docs/zookeeper)). HBase sets up the znode ACLs so that only the HBase user and the configured hbase superuser (`hbase.superuser`) can access and modify the data. In cases where ZooKeeper is used for service discovery or sharing state with the client, the znodes created by HBase will also allow anyone (regardless of authentication) to read these znodes (clusterId, master address, meta location, etc), but only the HBase user can modify them.\n\n## Securing File System (HDFS) Data\n\nAll of the data under management is kept under the root directory in the file system (`hbase.rootdir`). Access to the data and WAL files in the filesystem should be restricted so that users cannot bypass the HBase layer, and peek at the underlying data files from the file system. HBase assumes the filesystem used (HDFS or other) enforces permissions hierarchically. If sufficient protection from the file system (both authorization and authentication) is not provided, HBase level authorization control (ACLs, visibility labels, etc) is meaningless since the user can always access the data from the file system.\n\nHBase enforces the posix-like permissions 700 (`rwx------`) to its root directory. It means that only the HBase user can read or write the files in FS. The default setting can be changed by configuring `hbase.rootdir.perms` in hbase-site.xml. A restart of the active master is needed so that it changes the used permissions. For versions before 1.2.0, you can check whether HBASE-13780 is committed, and if not, you can manually set the permissions for the root directory if needed. Using HDFS, the command would be:\n\n```bash\nsudo -u hdfs hadoop fs -chmod 700 /hbase\n```\n\nYou should change `/hbase` if you are using a different `hbase.rootdir`.\n\n\n# Security (/docs/security)\n<Callout type=\"error\">\n  **Reporting Security Bugs**\n\n  HBase adheres to the Apache Software Foundation's policy on reported vulnerabilities, available at [http://apache.org/security/](http://apache.org/security/).\n\n  If you wish to send an encrypted report, you can use the GPG details provided for the general ASF security list. This will likely increase the response time to your report.\n</Callout>\n\n<Callout type=\"info\">\n  To protect existing HBase installations from exploitation, please **do not** use JIRA to report\n  security-related bugs. Instead, send your report to the mailing list `private@hbase.apache.org`,\n  which allows anyone to send messages, but restricts who can read them. Someone on that list will\n  contact you to follow up on your report.\n</Callout>\n\n\n# Transport Level Security (TLS) in HBase RPC communication (/docs/security/tls)\nSince version `2.6.0` HBase supports TLS encryption in server-client and Master-RegionServer communication. [Transport Layer Security (TLS)](https://en.wikipedia.org/wiki/Transport_Layer_Security) is a standard cryptographic protocol designed to provide communications security over a computer network. HBase TLS implementation works exactly how secure websites are accessed via **https** prefix in a web browser: once established all communication on the channel will be securely hidden from malicious access.\n\nThe encryption works at the transport level which means it's independent of the configured authentication method. Secure client access mentioned in the previous section requires Kerberos to be configured and used in HBase authentication, while TLS can be configured with any other SASL mechanism or even with simple client access methods, effectively preventing attackers from eavesdropping the communication. No Kerberos KDC or other complicated infrastructure required.\n\nHBase TLS is based on the Netty library therefore it only works with Netty client and server RPC implementations. Netty's powerful SSL implementation is a great foundation for highly secure and performant communication providing the latest and greatest cryptographic solution at all times.\n\nSince Region Servers effectively work as clients from Master's perspective, TLS supports encrypted communication between cluster members too.\n\n<Callout type=\"info\">\n  From version 2.6.0 HBase supports the [Hadoop CredentialProvider API](https://hadoop.apache.org/docs/r3.3.4/hadoop-project-dist/hadoop-common/CredentialProviderAPI.html) to avoid storing sensitive information in HBase configuration files. The recommended way of storing keystore / truststore passwords is to use one of the supported credential providers e.g. the local jceks file provider. You can find more information about how to setup credential providers in the Hadoop documentation.\n\n  The CLI interface for accessing the Hadoop Credential Shell is also available in HBase CLI. Type `hbase credential` to get help.\n</Callout>\n\n## Server side configuration\n\nWe need to set up Java key store for the server. Key store is the list of private keys that a server can use to configure TLS encryption. See [TLS wikipedia page](https://en.wikipedia.org/wiki/Transport_Layer_Security) for further details of the protocol. Add the following configuration to `hbase-site.xml` on Master, Region Servers and HBase clients:\n\n```xml\n<property>\n  <name>hbase.server.netty.tls.enabled</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.rpc.tls.keystore.location</name>\n  <value>/path/to/keystore.jks</value>\n</property>\n```\n\nUse `hbase.rpc.tls.keystore.password` alias to retrieve key store password from Hadoop credential provider.\n\n<Callout type=\"info\">\n  The supported storefile formats are based on the registered security providers and the loader can\n  be autodetected from the file extension. If needed, the file format can be explicitly specified\n  with the `hbase.rpc.tls.keystore.type` property.\n</Callout>\n\n## Client side configuration\n\nWe need to configure trust store for the client. Trust store contains the list of certificates that the client should trust when doing the handshake with the server. Add the following to `hbase-site.xml`.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.enabled</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.rpc.tls.truststore.location</name>\n  <value>/path/to/truststore.jks</value>\n</property>\n```\n\nUse `hbase.rpc.tls.truststore.password` alias to retrieve trust store password from Hadoop credential provider.\n\n<Callout type=\"info\">\n  The supported storefile formats are based on the registered security providers and the loader can\n  be autodetected from the file extension. If needed, the file format can be explicitly specified\n  with the `hbase.rpc.tls.truststore.type` property.\n</Callout>\n\nHowever, specifying a trust store is not always required. Standard JDK implementations are shipped with a standard list of trusted certificates (the certificates of Certificate Authorities) and if your private key is provided by one of them, you don't need to configure your clients to trust it. Similarly to an internet browser, you don't need to set up the certificates of every single website you're planning to visit. Later in this documentation we'll walk through the steps of creating self-signed certificates which requires a trust store setup.\n\nYou can check the list of public certificate authorities shipped with your JDK implementation:\n\n```bash\nkeytool -keystore $JAVA_HOME/jre/lib/security/cacerts -list\n```\n\nPassword is empty by default.\n\n## Creating self-signed certificates\n\nWhile obtaining globally trusted certificates from Certificate Authorities is convenient, it's perfectly valid to generate your own private/public keypairs and set them up specifically for the HBase cluster. Especially if you don't want to enable public access to the cluster, paying money for a certificate doesn't make sense.\n\nFollow the following steps to generate self-signed certificates.\n\n1. Create SSL key store JKS to store local credentials\n\n   Please note that the alias (-alias) and the distinguished name (-dname) must match the hostname of the machine that is associated with, otherwise hostname verification won't work.\n\n   ```bash\n   keytool -genkeypair -alias $(hostname -f) -keyalg RSA -keysize 2048 -dname \"cn=$(hostname -f)\" -keypass password -keystore keystore.jks -storepass password\n   ```\n\n   At the end of this operation you'll have as many key store files as many servers you have in your cluster. Each cluster member will have its own key store.\n\n2. Extract the signed public key (certificate) from each key store\n\n   ```bash\n   keytool -exportcert -alias $(hostname -f) -keystore keystore.jks -file $(hostname -f).cer -rfc\n   ```\n\n3. Create SSL trust store JKS containing certificates for the clients\n\n   The same truststore (storing all accepted certs) should be shared on participants of the cluster. You need to use different aliases to store multiple certificates in the same truststore. Name of the aliases doesn't matter.\n\n   ```bash\n   keytool -importcert -alias [host1..3] -file [host1..3].cer -keystore truststore.jks -storepass password\n   ```\n\n## Upgrading existing non-TLS cluster with no downtime\n\nHere are the steps needed to upgrade an already running HBase cluster to TLS without downtime by taking advantage of port unification functionality. There's a property on server side called `hbase.server.netty.tls.supportplaintext` which makes possible to accept TLS and plaintext connections on the same socket port.\n\n<Steps>\n  <Step>\n    Create the necessary key stores and trust stores for all server participants as described in the previous section.\n  </Step>\n\n  <Step>\n    Enable secure communication on the Master node in *server-only* mode with plaintext support\n\n    ```xml\n    <property>\n      <name>hbase.client.netty.tls.enabled</name>\n      <value>false</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.supportplaintext</name>\n      <value>true</value>\n    </property>\n    ...keystore / truststore setup ...\n    ```\n\n    Restart the Master. Master now accepts both TLS/non-TLS connections and works with non-TLS in client mode.\n  </Step>\n\n  <Step>\n    Enable secure communication on the Region Servers in both *server and client* mode with plaintext support\n\n    Client mode here will ensure that RegionServer's communication to Master is encrypted.\n\n    <Callout type=\"warn\">\n      **Replication**\n\n      If you have read replicas enabled in your cluster or replication between two different clusters, you have to break this into two steps. Secure communication has to be enabled on the *server side* first with plaintext support and once all Region Servers are upgraded you can repeat the upgrade by enabling *client side* as well.\n\n      You have to prepare all Region Servers for secure communication before upgrading the client side.\n    </Callout>\n\n    ```xml\n    <property>\n      <name>hbase.client.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.supportplaintext</name>\n      <value>true</value>\n    </property>\n    ...keystore / truststore setup ...\n    ```\n\n    Restart Region Servers in rolling restart fashion. They send requests with TLS and accept both TLS and non-TLS communication.\n  </Step>\n\n  <Step>\n    Enable secure communication on the clients\n\n    ```xml\n    <property>\n      <name>hbase.client.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    ...truststore setup ...\n    ```\n  </Step>\n\n  <Step>\n    Enable client-mode TLS on master and disable plaintext mode\n\n    ```xml\n    <property>\n      <name>hbase.client.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.supportplaintext</name>\n      <value>false</value>\n    </property>\n    ```\n\n    Restart Master.\n  </Step>\n\n  <Step>\n    Disable plaintext communication on the Region Servers\n\n    Disable plaintext communication on the Region Servers by removing `supportplaintext` property. Restart RSs in rolling restart fashion.\n\n    <Callout type=\"warn\">\n      Once `hbase.client.netty.tls.enabled` is enabled on the server side, the cluster will only be able\n      to communicate with other clusters which have TLS enabled. For example, this would impact\n      inter-cluster replication.\n    </Callout>\n  </Step>\n</Steps>\n\n## Enable automatic certificate reloading\n\nCertificates usually expire after some time to improve security. In this case we need to replace them by modifying Keystore / Truststore files and HBase processes have to be restarted. In order to avoid that you can enable automatic file change detection and certificate reloading with the following option. Default: false.\n\n```xml\n<property>\n  <name>hbase.rpc.tls.certReload</name>\n  <value>true</value>\n</property>\n```\n\n## Additional configuration\n\n### Enabled protocols\n\nComma-separated list of TLS protocol versions to enable. Default is empty.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.enabledProtocols</name>\n  <value>TLSv1.2,TLSv1.3</value>\n</property>\n```\n\n### Default protocol\n\nSet the default TLS protocol version to use. Default is TLSv1.2. Use this protocol if enabled protocols is not defined.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.protocol</name>\n  <value>TLSv1.2</value>\n</property>\n```\n\n### Enabled cipher suites\n\nList of enabled cipher suites in TLS protocol. Useful when you want to disable certain cipher suites due to recent security concerns. Default value is a mix of CBC and GCM ciphers. Due to performance reasons we prefer CBC ciphers for Java 8 and GCM ciphers for Java 9+.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.ciphersuites</name>\n  <value>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</value>\n</property>\n```\n\n### Certificate Revocation Checking\n\nThere's a built-in mechanism in JDK's TrustManager which automatically checks certificates for revocation. See [Managing Server Certificates](https://docs.oracle.com/cd/E19263-01/817-5215/ssl.html#wp19807). Disabled by default.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.clr</name>\n  <value>false</value>\n</property>\n```\n\n### Online Certificate Status Protocol\n\nEnables [OCSP](https://en.wikipedia.org/wiki/OCSP_stapling) stapling. Please note that not all `SSLProvider` implementations support OCSP stapling and an exception will be thrown upon. Disabled by default.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.ocsp</name>\n  <value>false</value>\n</property>\n```\n\n### Client handshake timeout\n\nSet the TLS client handshake timeout is milliseconds. Default is 5 seconds.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.handshaketimeout</name>\n  <value>5000</value>\n</property>\n```\n\n\n# Simple User Access to Apache HBase (/docs/security/user-access)\nNewer releases of Apache HBase (>= 0.92) support optional SASL authentication of clients. See also Matteo Bertozzi's article on [Understanding User Authentication and Authorization in Apache HBase](https://blog.cloudera.com/blog/2012/09/understanding-user-authentication-and-authorization-in-apache-hbase/).\n\nThis describes how to set up Apache HBase and clients for simple user access to HBase resources.\n\n## Simple versus Secure Access\n\nThe following section shows how to set up simple user access. Simple user access is not a secure method of operating HBase. This method is used to prevent users from making mistakes. It can be used to mimic the Access Control using on a development system without having to set up Kerberos.\n\nThis method is not used to prevent malicious or hacking attempts. To make HBase secure against these types of attacks, you must configure HBase for secure operation. Refer to the section [Secure Client Access to Apache HBase](/docs/security/client-access) and complete all of the steps described there.\n\n## Prerequisites\n\nNone\n\n## Server-side Configuration for Simple User Access Operation\n\nAdd the following to the `hbase-site.xml` file on every server machine in the cluster:\n\n```xml\n<property>\n  <name>hbase.security.authentication</name>\n  <value>simple</value>\n</property>\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.coprocessor.master.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n<property>\n  <name>hbase.coprocessor.region.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n<property>\n  <name>hbase.coprocessor.regionserver.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n```\n\nFor 0.94, add the following to the `hbase-site.xml` file on every server machine in the cluster:\n\n```xml\n<property>\n  <name>hbase.rpc.engine</name>\n  <value>org.apache.hadoop.hbase.ipc.SecureRpcEngine</value>\n</property>\n<property>\n  <name>hbase.coprocessor.master.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n<property>\n  <name>hbase.coprocessor.region.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n```\n\nA full shutdown and restart of HBase service is required when deploying these configuration changes.\n\n## Client-side Configuration for Simple User Access Operation\n\nAdd the following to the `hbase-site.xml` file on every client:\n\n```xml\n<property>\n  <name>hbase.security.authentication</name>\n  <value>simple</value>\n</property>\n```\n\nFor 0.94, add the following to the `hbase-site.xml` file on every server machine in the cluster:\n\n```xml\n<property>\n  <name>hbase.rpc.engine</name>\n  <value>org.apache.hadoop.hbase.ipc.SecureRpcEngine</value>\n</property>\n```\n\nBe advised that if the `hbase.security.authentication` in the client- and server-side site files do not match, the client will not be able to communicate with the cluster.\n\n### Client-side Configuration for Simple User Access Operation - Thrift Gateway\n\nThe Thrift gateway user will need access. For example, to give the Thrift API user, `thrift_server`, administrative access, a command such as this one will suffice:\n\n```sql\ngrant 'thrift_server', 'RWCA'\n```\n\nFor more information about ACLs, please see the [Access Control Labels (ACLs)](/docs/security/data-access#access-control-labels-acls) section\n\nThe Thrift gateway will authenticate with HBase using the supplied credential. No authentication will be performed by the Thrift gateway itself. All client access via the Thrift gateway will use the Thrift gateway's credential and have its privilege.\n\n### Client-side Configuration for Simple User Access Operation - REST Gateway\n\nThe REST gateway will authenticate with HBase using the supplied credential. No authentication will be performed by the REST gateway itself. All client access via the REST gateway will use the REST gateway's credential and have its privilege.\n\nThe REST gateway user will need access. For example, to give the REST API user, `rest_server`, administrative access, a command such as this one will suffice:\n\n```sql\ngrant 'rest_server', 'RWCA'\n```\n\nFor more information about ACLs, please see the [Access Control Labels (ACLs)](/docs/security/data-access#access-control-labels-acls) section\n\nIt should be possible for clients to authenticate with the HBase cluster through the REST gateway in a pass-through manner via SPNEGO HTTP authentication. This is future work.\n\n\n# Web UI Security (/docs/security/web-ui)\n## Using Secure HTTP (HTTPS) for the Web UI\n\nA default HBase install uses insecure HTTP connections for Web UIs for the master and region servers. To enable secure HTTP (HTTPS) connections instead, set `hbase.ssl.enabled` to `true` in *hbase-site.xml*(Please prepare SSL certificate and ssl configuration file in advance). This does not change the port used by the Web UI. To change the port for the web UI for a given HBase component, configure that port's setting in hbase-site.xml. These settings are:\n\n* `hbase.master.info.port`\n* `hbase.regionserver.info.port`\n\n<Callout type=\"info\">\n  If you enable secure HTTP, clients should connect to HBase using the `https://` URL. Clients using the `http://` URL will receive an HTTP response of `200`, but will not receive any data. The following exception is logged:\n\n  ```text\n  javax.net.ssl.SSLException: Unrecognized SSL message, plaintext connection?\n  ```\n\n  This is because the same port is used for HTTP and HTTPS.\n\n  HBase uses Jetty for the Web UI. Without modifying Jetty itself, it does not seem possible to configure Jetty to redirect one port to another on the same host. See Nick Dimiduk's contribution on this [Stack Overflow](http://stackoverflow.com/questions/20611815/redirect-from-http-to-https-in-jetty) thread for more information. If you know how to fix this without opening a second port for HTTPS, patches are appreciated.\n</Callout>\n\n## Disable cache in HBase UI\n\nSet the following configuration in hbase-site to set max age to zero and disable cache for the web UI:\n\n```xml\n<property>\n  <name>hbase.http.filter.no-store.enable</name>\n  <value>true</value>\n</property>\n```\n\n## Using SPNEGO for Kerberos authentication with Web UIs\n\nKerberos-authentication to HBase Web UIs can be enabled via configuring SPNEGO with the `hbase.security.authentication.ui` property in *hbase-site.xml*. Enabling this authentication requires that HBase is also configured to use Kerberos authentication for RPCs (e.g `hbase.security.authentication` = `kerberos`).\n\n```xml\n<property>\n  <name>hbase.security.authentication.ui</name>\n  <value>kerberos</value>\n  <description>Controls what kind of authentication should be used for the HBase web UIs.</description>\n</property>\n<property>\n  <name>hbase.security.authentication</name>\n  <value>kerberos</value>\n  <description>The Kerberos keytab file to use for SPNEGO authentication by the web server.</description>\n</property>\n```\n\nA number of properties exist to configure SPNEGO authentication for the web server:\n\n```xml\n<property>\n  <name>hbase.security.authentication.spnego.kerberos.principal</name>\n  <value>HTTP/_HOST@EXAMPLE.COM</value>\n  <description>Required for SPNEGO, the Kerberos principal to use for SPNEGO authentication by the\n  web server. The _HOST keyword will be automatically substituted with the node's\n  hostname.</description>\n</property>\n<property>\n  <name>hbase.security.authentication.spnego.kerberos.keytab</name>\n  <value>/etc/security/keytabs/spnego.service.keytab</value>\n  <description>Required for SPNEGO, the Kerberos keytab file to use for SPNEGO authentication by the\n  web server.</description>\n</property>\n<property>\n  <name>hbase.security.authentication.spnego.kerberos.name.rules</name>\n  <value></value>\n  <description>Optional, Hadoop-style `auth_to_local` rules which will be parsed and used in the\n  handling of Kerberos principals</description>\n</property>\n<property>\n  <name>hbase.security.authentication.signature.secret.file</name>\n  <value></value>\n  <description>Optional, a file whose contents will be used as a secret to sign the HTTP cookies\n  as a part of the SPNEGO authentication handshake. If this is not provided, Java's `Random` library\n  will be used for the secret.</description>\n</property>\n```\n\n## Defining administrators of the Web UI with SPNEGO\n\nIn the previous section, we cover how to enable authentication for the Web UI via SPNEGO. However, some portions of the Web UI could be used to impact the availability and performance of an HBase cluster. As such, it is desirable to ensure that only those with proper authority can interact with these sensitive endpoints.\n\nHBase allows the adminstrators to be defined via a list of usernames or groups in hbase-site.xml\n\n```xml\n<property>\n  <name>hbase.security.authentication.spnego.admin.users</name>\n  <value></value>\n</property>\n<property>\n  <name>hbase.security.authentication.spnego.admin.groups</name>\n  <value></value>\n</property>\n```\n\nThe usernames are those which the Kerberos identity maps to, given the Hadoop `auth_to_local` rules in core-site.xml. The groups here are the Unix groups associated with the mapped usernames.\n\nConsider the following scenario to describe how the configuration properties operate. Consider three users which are defined in the Kerberos KDC:\n\n* `alice@COMPANY.COM`\n* `bob@COMPANY.COM`\n* `charlie@COMPANY.COM`\n\nThe default Hadoop `auth_to_local` rules map these principals to the \"shortname\":\n\n* `alice`\n* `bob`\n* `charlie`\n\nUnix groups membership define that `alice` is a member of the group `admins`. `bob` and `charlie` are not members of the `admins` group.\n\n```xml\n<property>\n  <name>hbase.security.authentication.spnego.admin.users</name>\n  <value>charlie</value>\n</property>\n<property>\n  <name>hbase.security.authentication.spnego.admin.groups</name>\n  <value>admins</value>\n</property>\n```\n\nGiven the above configuration, `alice` is allowed to access sensitive endpoints in the Web UI as she is a member of the `admins` group. `charlie` is also allowed to access sensitive endpoints because he is explicitly listed as an admin in the configuration. `bob` is not allowed to access sensitive endpoints because he is not a member of the `admins` group nor is listed as an explicit admin user via `hbase.security.authentication.spnego.admin.users`, but can still use any non-sensitive endpoints in the Web UI.\n\nIf it doesn't go without saying: non-authenticated users cannot access any part of the Web UI.\n\n## Using LDAP authentication with Web UIs\n\nLDAP authentication to HBase Web UIs can be enabled via configuring LDAP with the `hbase.security.authentication.ui` property in *hbase-site.xml*. The `hbase.http.filter.initializers` property also needs to have the `AuthenticationFilterInitializer` class.\n\n**IMPORTANT:** A LDAP server must be configured and running. When TLS is enabled for communication with LDAP server (either via ldaps scheme or ‘start TLS' extension), configure the public certificate of the LDAP server in the local truststore. The LDAP authentication mechanism uses HTTP Basic authentication scheme to verify user specified credentials against a configured LDAP (or Active Directory) server. The authentication filter must be configured with the following init parameters:\n\n```xml\n<property>\n  <name>hbase.security.authentication.ui</name>\n  <value>ldap</value>\n  <description>Controls what kind of authentication should be used for the HBase web UIs.</description>\n</property>\n<property>\n  <name>hbase.http.filter.initializers</name>\n  <value>org.apache.hadoop.hbase.http.lib.AuthenticationFilterInitializer</value>\n  <description>Comma separated class names corresponding to the Filters that will be initialized.\n  Then, the Filters will be applied to all user facing jsp and servlet web pages.</description>\n</property>\n<property>\n  <name>hadoop.http.authentication.type</name>\n  <value>ldap</value>\n  <description>Defines authentication used for the HTTP web-consoles in Hadoop ecosystem.</description>\n</property>\n```\n\nA number of properties exist to configure LDAP authentication for the web server:\n\n```xml\n<property>\n  <name>hadoop.http.authentication.ldap.binddomain</name>\n  <value>EXAMPLE.COM</value>\n  <description>The LDAP bind domain value to be used with the LDAP server. This property is optional\n   and useful only in case of Active Directory server (e.g. example.com).</description>\n</property>\n<property>\n  <name>hadoop.http.authentication.ldap.providerurl</name>\n  <value>ldap://ldap-server-host:8920</value>\n  <description>The url of the LDAP server.</description>\n</property>\n<property>\n  <name>hadoop.http.authentication.ldap.enablestarttls</name>\n  <value>false</value>\n  <description>A boolean value used to define if the LDAP server supports ‘StartTLS' extension.</description>\n</property>\n<property>\n  <name>hadoop.http.authentication.ldap.basedn</name>\n  <value>ou=users,dc=example,dc=com</value>\n  <description>The base distinguished name (DN) to be used with the LDAP server. This value is\n  appended to the provided user id for authentication purpose. This property is not useful in case\n  of Active Directory server.</description>\n</property>\n```\n\n## Defining Administrators of the Web UI with LDAP\n\nIn the previous section, we discussed enabling authentication for the Web UI via LDAP. Certain portions of the Web UI can impact the availability and performance of an HBase cluster. To safeguard these sensitive endpoints, it is essential to restrict access to authorized administrators only.\n\nHBase provides a mechanism to define administrators for the Web UI through a list of usernames in the `hbase-site.xml` configuration file.\n\nTo specify the administrators, use the following property in `hbase-site.xml`:\n\n```xml\n<property>\n  <name>hbase.security.authentication.ldap.admin.users</name>\n  <value>admin1,admin2,admin3</value>\n</property>\n```\n\nThe usernames listed in the above property should correspond to the LDAP usernames of the administrators.\n\n### Notes\n\n* This feature is supported by only versions of HBase having [HBASE-29244](https://issues.apache.org/jira/browse/HBASE-29244)\n* Ensure that the LDAP server is properly configured and running. See the previous section for details.\n* Only users explicitly listed in the `hbase.security.authentication.ldap.admin.users` property will have access to sensitive endpoints.\n* Non-administrative users can still access non-sensitive endpoints, provided they are authenticated.\n\nBy defining administrators in this way, you can ensure that only authorized personnel can interact with critical Web UI functionalities, thereby enhancing the security and stability of your HBase cluster.\n\n## Other UI security-related configuration\n\nWhile it is a clear anti-pattern for HBase developers, the developers acknowledge that the HBase configuration (including Hadoop configuration files) may contain sensitive information. As such, a user may find that they do not want to expose the HBase service-level configuration to all authenticated users. They may configure HBase to require a user must be an admin to access the service-level configuration via the HBase UI. This configuration is **false** by default (any authenticated user may access the configuration).\n\nUsers who wish to change this would set the following in their hbase-site.xml:\n\n```xml\n<property>\n  <name>hbase.security.authentication.ui.config.protected</name>\n  <value>true</value>\n</property>\n```\n\nTo disable showing stack traces in HBase UI for hiding sensitive information, set the following in hbase-site:\n\n```xml\n<property>\n  <name>hbase.ui.show-stack-traces</name>\n  <value>false</value>\n</property>\n```\n\n\n# The Apache HBase Shell (/docs/shell)\nThe Apache HBase Shell is [(J)Ruby](http://jruby.org)'s IRB with some HBase particular commands added.\nAnything you can do in IRB, you should be able to do in the HBase Shell.\n\nTo run the HBase shell, do as follows:\n\n```bash\n$ ./bin/hbase shell\n```\n\nType `help` and then `<RETURN>` to see a listing of shell commands and options.\nBrowse at least the paragraphs at the end of the help output for the gist of how variables and command arguments are entered into the HBase shell; in particular note how table names, rows, and columns, etc., must be quoted.\n\nSee [shell exercises](/docs/getting-started#procedure-use-hbase-for-the-first-time) for example basic shell operation.\n\nHere is a nicely formatted listing of [all shell commands](http://learnhbase.wordpress.com/2013/03/02/hbase-shell-commands/) by Rajeshbabu Chintaguntla.\n\n## Scripting with Ruby\n\nFor examples scripting Apache HBase, look in the HBase *bin* directory.\nLook at the files that end in *\\*.rb*.\nTo run one of these files, do as follows:\n\n```bash\n$ ./bin/hbase org.jruby.Main PATH_TO_SCRIPT\n```\n\n## Running the Shell in Non-Interactive Mode\n\nA new non-interactive mode has been added to the HBase Shell ([HBASE-11658](https://issues.apache.org/jira/browse/HBASE-11658)).\nNon-interactive mode captures the exit status (success or failure) of HBase Shell commands and passes that status back to the command interpreter.\nIf you use the normal interactive mode, the HBase Shell will only ever return its own exit status, which will nearly always be `0` for success.\n\nTo invoke non-interactive mode, pass the `-n` or `--non-interactive` option to HBase Shell.\n\n## HBase Shell in OS Scripts\n\nYou can use the HBase shell from within operating system script interpreters like the Bash shell which is the default command interpreter for most Linux and UNIX distributions.\nThe following guidelines use Bash syntax, but could be adjusted to work with C-style shells such as csh or tcsh, and could probably be modified to work with the Microsoft Windows script interpreter as well. Submissions are welcome.\n\n<Callout type=\"info\">\n  Spawning HBase Shell commands in this way is slow, so keep that in mind when you are deciding when\n  combining HBase operations with the operating system command line is appropriate.\n</Callout>\n\n### Passing Commands to the HBase Shell\n\nYou can pass commands to the HBase Shell in non-interactive mode (see [hbase.shell.noninteractive](/docs/shell#hbase-shell-in-os-scripts)) using the `echo` command and the `|` (pipe) operator.\nBe sure to escape characters in the HBase commands which would otherwise be interpreted by the shell.\nSome debug-level output has been truncated from the example below.\n\n```bash\n$ echo \"describe 'test1'\" | ./hbase shell -n\n\nVersion 0.98.3-hadoop2, rd5e65a9144e315bb0a964e7730871af32f5018d5, Sat May 31 19:56:09 PDT 2014\n\ndescribe 'test1'\n\nDESCRIPTION                                          ENABLED\n 'test1', {NAME => 'cf', DATA_BLOCK_ENCODING => 'NON true\n E', BLOOMFILTER => 'ROW', REPLICATION_SCOPE => '0',\n  VERSIONS => '1', COMPRESSION => 'NONE', MIN_VERSIO\n NS => '0', TTL => 'FOREVER', KEEP_DELETED_CELLS =>\n 'false', BLOCKSIZE => '65536', IN_MEMORY => 'false'\n , BLOCKCACHE => 'true'}\n1 row(s) in 3.2410 seconds\n```\n\nTo suppress all output, echo it to */dev/null:*\n\n```bash\n$ echo \"describe 'test'\" | ./hbase shell -n > /dev/null 2>&1\n```\n\n### Checking the Result of a Scripted Command\n\nSince scripts are not designed to be run interactively, you need a way to check whether your command failed or succeeded.\nThe HBase shell uses the standard convention of returning a value of `0` for successful commands, and some non-zero value for failed commands.\nBash stores a command's return value in a special environment variable called `$?`.\nBecause that variable is overwritten each time the shell runs any command, you should store the result in a different, script-defined variable.\n\nThis is a naive script that shows one way to store the return value and make a decision based upon it.\n\n```bash\n#!/bin/bash\n\necho \"describe 'test'\" | ./hbase shell -n > /dev/null 2>&1\nstatus=$?\necho \"The status was \" $status\nif ($status == 0); then\n  echo \"The command succeeded\"\nelse\n  echo \"The command may have failed.\"\nfi\nreturn $status\n```\n\n### Checking for Success or Failure In Scripts\n\nGetting an exit code of `0` means that the command you scripted definitely succeeded.\nHowever, getting a non-zero exit code does not necessarily mean the command failed.\nThe command could have succeeded, but the client lost connectivity, or some other event obscured its success.\nThis is because RPC commands are stateless.\nThe only way to be sure of the status of an operation is to check.\nFor instance, if your script creates a table, but returns a non-zero exit value, you should check whether the table was actually created before trying again to create it.\n\n## Read HBase Shell Commands from a Command File\n\nYou can enter HBase Shell commands into a text file, one command per line, and pass that file to the HBase Shell.\n\n### Example Command File\n\n```ruby\ncreate 'test', 'cf'\nlist 'test'\nput 'test', 'row1', 'cf:a', 'value1'\nput 'test', 'row2', 'cf:b', 'value2'\nput 'test', 'row3', 'cf:c', 'value3'\nput 'test', 'row4', 'cf:d', 'value4'\nscan 'test'\nget 'test', 'row1'\ndisable 'test'\nenable 'test'\n```\n\n### Directing HBase Shell to Execute the Commands\n\nPass the path to the command file as the only argument to the `hbase shell` command.\nEach command is executed and its output is shown.\nIf you do not include the `exit` command in your script, you are returned to the HBase shell prompt.\nThere is no way to programmatically check each individual command for success or failure.\nAlso, though you see the output for each command, the commands themselves are not echoed to the screen so it can be difficult to line up the command with its output.\n\n```bash\n$ ./hbase shell ./sample_commands.txt\n0 row(s) in 3.4170 seconds\n\nTABLE\ntest\n1 row(s) in 0.0590 seconds\n\n0 row(s) in 0.1540 seconds\n\n0 row(s) in 0.0080 seconds\n\n0 row(s) in 0.0060 seconds\n\n0 row(s) in 0.0060 seconds\n\nROW                   COLUMN+CELL\n row1                 column=cf:a, timestamp=1407130286968, value=value1\n row2                 column=cf:b, timestamp=1407130286997, value=value2\n row3                 column=cf:c, timestamp=1407130287007, value=value3\n row4                 column=cf:d, timestamp=1407130287015, value=value4\n4 row(s) in 0.0420 seconds\n\nCOLUMN                CELL\n cf:a                 timestamp=1407130286968, value=value1\n1 row(s) in 0.0110 seconds\n\n0 row(s) in 1.5630 seconds\n\n0 row(s) in 0.4360 seconds\n```\n\n## Passing VM Options to the Shell\n\nYou can pass VM options to the HBase Shell using the `HBASE_SHELL_OPTS` environment variable.\nYou can set this in your environment, for instance by editing *\\~/.bashrc*, or set it as part of the command to launch HBase Shell.\nThe following example sets several garbage-collection-related variables, just for the lifetime of the VM running the HBase Shell.\nThe command should be run all on a single line, but is broken by the `\\` character, for readability.\n\n```bash\n$ HBASE_SHELL_OPTS=\"-verbose:gc -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps \\\n  -XX:+PrintGCDetails -Xloggc:$HBASE_HOME/logs/gc-hbase.log\" ./bin/hbase shell\n```\n\n## Overriding configuration starting the HBase Shell\n\nAs of hbase-2.0.5/hbase-2.1.3/hbase-2.2.0/hbase-1.4.10/hbase-1.5.0, you can\npass or override hbase configuration as specified in `hbase-*.xml` by passing\nyour key/values prefixed with `-D` on the command-line as follows:\n\n```bash\n$ ./bin/hbase shell -Dhbase.zookeeper.quorum=ZK0.remote.cluster.example.org,ZK1.remote.cluster.example.org,ZK2.remote.cluster.example.org -Draining=false\n...\nhbase(main):001:0> @shell.hbase.configuration.get(\"hbase.zookeeper.quorum\")\n=> \"ZK0.remote.cluster.example.org,ZK1.remote.cluster.example.org,ZK2.remote.cluster.example.org\"\nhbase(main):002:0> @shell.hbase.configuration.get(\"raining\")\n=> \"false\"\n```\n\n## Shell Tricks\n\n### Table variables\n\nHBase 0.95 adds shell commands that provides jruby-style object-oriented references for tables.\nPreviously all of the shell commands that act upon a table have a procedural style that always took the name of the table as an argument.\nHBase 0.95 introduces the ability to assign a table to a jruby variable.\nThe table reference can be used to perform data read write operations such as puts, scans, and gets well as admin functionality such as disabling, dropping, describing tables.\n\nFor example, previously you would always specify a table name:\n\n```ruby\nhbase(main):000:0> create 't', 'f'\n0 row(s) in 1.0970 seconds\nhbase(main):001:0> put 't', 'rold', 'f', 'v'\n0 row(s) in 0.0080 seconds\n\nhbase(main):002:0> scan 't'\nROW                                COLUMN+CELL\n rold                              column=f:, timestamp=1378473207660, value=v\n1 row(s) in 0.0130 seconds\n\nhbase(main):003:0> describe 't'\nDESCRIPTION                                                                           ENABLED\n 't', {NAME => 'f', DATA_BLOCK_ENCODING => 'NONE', BLOOMFILTER => 'ROW', REPLICATION_ true\n SCOPE => '0', VERSIONS => '1', COMPRESSION => 'NONE', MIN_VERSIONS => '0', TTL => '2\n 147483647', KEEP_DELETED_CELLS => 'false', BLOCKSIZE => '65536', IN_MEMORY => 'false\n ', BLOCKCACHE => 'true'}\n1 row(s) in 1.4430 seconds\n\nhbase(main):004:0> disable 't'\n0 row(s) in 14.8700 seconds\n\nhbase(main):005:0> drop 't'\n0 row(s) in 23.1670 seconds\n\nhbase(main):006:0>\n```\n\nNow you can assign the table to a variable and use the results in jruby shell code.\n\n```ruby\nhbase(main):007 > t = create 't', 'f'\n0 row(s) in 1.0970 seconds\n\n=> Hbase::Table - t\nhbase(main):008 > t.put 'r', 'f', 'v'\n0 row(s) in 0.0640 seconds\nhbase(main):009 > t.scan\nROW                           COLUMN+CELL\n r                            column=f:, timestamp=1331865816290, value=v\n1 row(s) in 0.0110 seconds\nhbase(main):010:0> t.describe\nDESCRIPTION                                                                           ENABLED\n 't', {NAME => 'f', DATA_BLOCK_ENCODING => 'NONE', BLOOMFILTER => 'ROW', REPLICATION_ true\n SCOPE => '0', VERSIONS => '1', COMPRESSION => 'NONE', MIN_VERSIONS => '0', TTL => '2\n 147483647', KEEP_DELETED_CELLS => 'false', BLOCKSIZE => '65536', IN_MEMORY => 'false\n ', BLOCKCACHE => 'true'}\n1 row(s) in 0.0210 seconds\nhbase(main):038:0> t.disable\n0 row(s) in 6.2350 seconds\nhbase(main):039:0> t.drop\n0 row(s) in 0.2340 seconds\n```\n\nIf the table has already been created, you can assign a Table to a variable by using the get\\_table method:\n\n```ruby\nhbase(main):011 > create 't','f'\n0 row(s) in 1.2500 seconds\n\n=> Hbase::Table - t\nhbase(main):012:0> tab = get_table 't'\n0 row(s) in 0.0010 seconds\n\n=> Hbase::Table - t\nhbase(main):013:0> tab.put 'r1' ,'f', 'v'\n0 row(s) in 0.0100 seconds\nhbase(main):014:0> tab.scan\nROW                                COLUMN+CELL\n r1                                column=f:, timestamp=1378473876949, value=v\n1 row(s) in 0.0240 seconds\nhbase(main):015:0>\n```\n\nThe list functionality has also been extended so that it returns a list of table names as strings.\nYou can then use jruby to script table operations based on these names.\nThe list\\_snapshots command also acts similarly.\n\n```ruby\nhbase(main):016 > tables = list('t.*')\nTABLE\nt\n1 row(s) in 0.1040 seconds\n\n=> [\"t\"]\nhbase(main):017:0> tables.map { |t| disable t ; drop  t}\n0 row(s) in 2.2510 seconds\n\n=> [nil]\nhbase(main):018:0>\n```\n\n### *irbrc*\n\nCreate an *.irbrc* file for yourself in your home directory.\nAdd customizations.\nA useful one is command history so commands are save across Shell invocations:\n\n```bash\n$ more .irbrc\nrequire 'irb/ext/save-history'\nIRB.conf[:SAVE_HISTORY] = 100\nIRB.conf[:HISTORY_FILE] = \"#{ENV['HOME']}/.irb-save-history\"\n```\n\nIf you'd like to avoid printing the result of evaluting each expression to stderr, for example the array of tables returned from the \"list\" command:\n\n```bash\n$ echo \"IRB.conf[:ECHO] = false\" >>~/.irbrc\n```\n\nSee the `ruby` documentation of *.irbrc* to learn about other possible configurations.\n\n### LOG data to timestamp\n\nTo convert the date '08/08/16 20:56:29' from an hbase log into a timestamp, do:\n\n```ruby\nhbase(main):021:0> import java.text.SimpleDateFormat\nhbase(main):022:0> import java.text.ParsePosition\nhbase(main):023:0> SimpleDateFormat.new(\"yy/MM/dd HH:mm:ss\").parse(\"08/08/16 20:56:29\", ParsePosition.new(0)).getTime() => 1218920189000\n```\n\nTo go the other direction:\n\n```ruby\nhbase(main):021:0> import java.util.Date\nhbase(main):022:0> Date.new(1218920189000).toString() => \"Sat Aug 16 20:56:29 UTC 2008\"\n```\n\nTo output in a format that is exactly like that of the HBase log format will take a little messing with [SimpleDateFormat](http://download.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html).\n\n### Query Shell Configuration\n\n```ruby\nhbase(main):001:0> @shell.hbase.configuration.get(\"hbase.rpc.timeout\")\n=> \"60000\"\n```\n\nTo set a config in the shell:\n\n```ruby\nhbase(main):005:0> @shell.hbase.configuration.setInt(\"hbase.rpc.timeout\", 61010)\nhbase(main):006:0> @shell.hbase.configuration.get(\"hbase.rpc.timeout\")\n=> \"61010\"\n```\n\n### Pre-splitting tables with the HBase Shell\n\nYou can use a variety of options to pre-split tables when creating them via the HBase Shell `create` command.\n\nThe simplest approach is to specify an array of split points when creating the table. Note that when specifying string literals as split points, these will create split points based on the underlying byte representation of the string. So when specifying a split point of '10', we are actually specifying the byte split point '\\x31\\30'.\n\nThe split points will define `n+1` regions where `n` is the number of split points. The lowest region will contain all keys from the lowest possible key up to but not including the first split point key.\nThe next region will contain keys from the first split point up to, but not including the next split point key.\nThis will continue for all split points up to the last. The last region will be defined from the last split point up to the maximum possible key.\n\n```ruby\nhbase>create 't1','f',SPLITS => ['10','20','30']\n```\n\nIn the above example, the table 't1' will be created with column family 'f', pre-split to four regions. Note the first region will contain all keys from '\\x00' up to '\\x30' (as '\\x31' is the ASCII code for '1').\n\nYou can pass the split points in a file using following variation. In this example, the splits are read from a file corresponding to the local path on the local filesystem. Each line in the file specifies a split point key.\n\n```ruby\nhbase>create 't14','f',SPLITS_FILE=>'splits.txt'\n```\n\nThe other options are to automatically compute splits based on a desired number of regions and a splitting algorithm.\nHBase supplies algorithms for splitting the key range based on uniform splits or based on hexadecimal keys, but you can provide your own splitting algorithm to subdivide the key range.\n\n```ruby\n# create table with four regions based on random bytes keys\nhbase>create 't2','f1', { NUMREGIONS => 4 , SPLITALGO => 'UniformSplit' }\n\n# create table with five regions based on hex keys\nhbase>create 't3','f1', { NUMREGIONS => 5, SPLITALGO => 'HexStringSplit' }\n```\n\nAs the HBase Shell is effectively a Ruby environment, you can use simple Ruby scripts to compute splits algorithmically.\n\n```ruby\n# generate splits for long (Ruby fixnum) key range from start to end key\nhbase(main):070:0> def gen_splits(start_key,end_key,num_regions)\nhbase(main):071:1>   results=[]\nhbase(main):072:1>   range=end_key-start_key\nhbase(main):073:1>   incr=(range/num_regions).floor\nhbase(main):074:1>   for i in 1 .. num_regions-1\nhbase(main):075:2>     results.push([i*incr+start_key].pack(\"N\"))\nhbase(main):076:2>   end\nhbase(main):077:1>   return results\nhbase(main):078:1> end\nhbase(main):079:0>\nhbase(main):080:0> splits=gen_splits(1,2000000,10)\n=> [\"\\000\\003\\r@\", \"\\000\\006\\032\\177\", \"\\000\\t'\\276\", \"\\000\\f4\\375\", \"\\000\\017B<\", \"\\000\\022O{\", \"\\000\\025\\\\\\272\", \"\\000\\030i\\371\", \"\\000\\ew8\"]\nhbase(main):081:0> create 'test_splits','f',SPLITS=>splits\n0 row(s) in 0.2670 seconds\n\n=> Hbase::Table - test_splits\n```\n\nNote that the HBase Shell command `truncate` effectively drops and recreates the table with default options which will discard any pre-splitting.\nIf you need to truncate a pre-split table, you must drop and recreate the table explicitly to re-specify custom split options.\n\n### Debug\n\n#### Shell debug switch\n\nYou can set a debug switch in the shell to see more output — e.g.\nmore of the stack trace on exception — when you run a command:\n\n```\nhbase> debug <RETURN>\n```\n\n#### DEBUG log level\n\nTo enable DEBUG level logging in the shell, launch it with the `-d` option.\n\n```bash\n$ ./bin/hbase shell -d\n```\n\n### Commands\n\n#### count\n\nCount command returns the number of rows in a table.\nIt's quite fast when configured with the right CACHE\n\n```ruby\nhbase> count '<tablename>', CACHE => 1000\n```\n\nThe above count fetches 1000 rows at a time.\nSet CACHE lower if your rows are big.\nDefault is to fetch one row at a time.\n\n\n# HBase and Spark (/docs/spark)\n[Spark](https://spark.apache.org/) itself is out of scope of this document, please refer to the Spark site for\nmore information on the Spark project and subprojects. This document will focus\non 4 main interaction points between Spark and HBase. Those interaction points are:\n\n**Basic Spark**\\\nThe ability to have an HBase Connection at any point in your Spark DAG.\n\n**Spark Streaming**\\\nThe ability to have an HBase Connection at any point in your Spark Streaming\napplication.\n\n**Spark Bulk Load**\\\nThe ability to write directly to HBase HFiles for bulk insertion into HBase\n\n**SparkSQL/DataFrames**\\\nThe ability to write SparkSQL that draws on tables that are represented in HBase.\n\nThe following sections will walk through examples of all these interaction points.\n\n## Basic Spark\n\nThis section discusses Spark HBase integration at the lowest and simplest levels.\nAll the other interaction points are built upon the concepts that will be described\nhere.\n\nAt the root of all Spark and HBase integration is the HBaseContext. The HBaseContext\ntakes in HBase configurations and pushes them to the Spark executors. This allows\nus to have an HBase Connection per Spark Executor in a static location.\n\nFor reference, Spark Executors can be on the same nodes as the Region Servers or\non different nodes, there is no dependence on co-location. Think of every Spark\nExecutor as a multi-threaded client application. This allows any Spark Tasks\nrunning on the executors to access the shared Connection object.\n\n### HBaseContext Usage Example\n\nThis example shows how HBaseContext can be used to do a `foreachPartition` on a RDD\nin Scala:\n\n```scala\nval sc = new SparkContext(\"local\", \"test\")\nval config = new HBaseConfiguration()\n\n...\n\nval hbaseContext = new HBaseContext(sc, config)\n\nrdd.hbaseForeachPartition(hbaseContext, (it, conn) => {\n val bufferedMutator = conn.getBufferedMutator(TableName.valueOf(\"t1\"))\n it.foreach((putRecord) => {\n. val put = new Put(putRecord._1)\n. putRecord._2.foreach((putValue) => put.addColumn(putValue._1, putValue._2, putValue._3))\n. bufferedMutator.mutate(put)\n })\n bufferedMutator.flush()\n bufferedMutator.close()\n})\n```\n\nHere is the same example implemented in Java:\n\n```java\nJavaSparkContext jsc = new JavaSparkContext(sparkConf);\n\ntry {\n  List<byte[]> list = new ArrayList<>();\n  list.add(Bytes.toBytes(\"1\"));\n  ...\n  list.add(Bytes.toBytes(\"5\"));\n\n  JavaRDD<byte[]> rdd = jsc.parallelize(list);\n  Configuration conf = HBaseConfiguration.create();\n\n  JavaHBaseContext hbaseContext = new JavaHBaseContext(jsc, conf);\n\n  hbaseContext.foreachPartition(rdd,\n      new VoidFunction<Tuple2<Iterator<byte[]>, Connection>>() {\n   public void call(Tuple2<Iterator<byte[]>, Connection> t)\n        throws Exception {\n    Table table = t._2().getTable(TableName.valueOf(tableName));\n    BufferedMutator mutator = t._2().getBufferedMutator(TableName.valueOf(tableName));\n    while (t._1().hasNext()) {\n      byte[] b = t._1().next();\n      Result r = table.get(new Get(b));\n      if (r.getExists()) {\n       mutator.mutate(new Put(b));\n      }\n    }\n\n    mutator.flush();\n    mutator.close();\n    table.close();\n   }\n  });\n} finally {\n  jsc.stop();\n}\n```\n\nAll functionality between Spark and HBase will be supported both in Scala and in\nJava, with the exception of SparkSQL which will support any language that is\nsupported by Spark. For the remaining of this documentation we will focus on\nScala examples.\n\nThe examples above illustrate how to do a foreachPartition with a connection. A\nnumber of other Spark base functions are supported out of the box:\n\n**`bulkPut`**\\\nFor massively parallel sending of puts to HBase\n\n**`bulkDelete`**\\\nFor massively parallel sending of deletes to HBase\n\n**`bulkGet`**\\\nFor massively parallel sending of gets to HBase to create a new RDD\n\n**`mapPartition`**\\\nTo do a Spark Map function with a Connection object to allow full\naccess to HBase\n\n**`hbaseRDD`**\\\nTo simplify a distributed scan to create a RDD\n\nFor examples of all these functionalities, see the\n[hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\nin the [hbase-connectors](https://github.com/apache/hbase-connectors) repository\n(the hbase-spark connectors live outside hbase core in a related,\nApache HBase project maintained, associated repo).\n\n## Spark Streaming\n\n[Spark Streaming](https://spark.apache.org/streaming/) is a micro batching stream\nprocessing framework built on top of Spark. HBase and Spark Streaming make great\ncompanions in that HBase can help serve the following benefits alongside Spark\nStreaming.\n\n* A place to grab reference data or profile data on the fly\n* A place to store counts or aggregates in a way that supports Spark Streaming's\n  promise of *only once processing*.\n\nThe [hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\nwith Spark Streaming is similar to its normal Spark integration points, in that the following\ncommands are possible straight off a Spark Streaming DStream.\n\n**`bulkPut`**\\\nFor massively parallel sending of puts to HBase\n\n**`bulkDelete`**\\\nFor massively parallel sending of deletes to HBase\n\n**`bulkGet`**\\\nFor massively parallel sending of gets to HBase to create a new RDD\n\n**`mapPartition`**\\\nTo do a Spark Map function with a Connection object to allow full\naccess to HBase\n\n**`hbaseRDD`**\\\nTo simplify a distributed scan to create a RDD\n\n### `bulkPut` Example with DStreams\n\nBelow is an example of bulkPut with DStreams. It is very close in feel to the RDD\nbulk put.\n\n```scala\nval sc = new SparkContext(\"local\", \"test\")\nval config = new HBaseConfiguration()\n\nval hbaseContext = new HBaseContext(sc, config)\nval ssc = new StreamingContext(sc, Milliseconds(200))\n\nval rdd1 = ...\nval rdd2 = ...\n\nval queue = mutable.Queue[RDD[(Array[Byte], Array[(Array[Byte],\n    Array[Byte], Array[Byte])])]]()\n\nqueue += rdd1\nqueue += rdd2\n\nval dStream = ssc.queueStream(queue)\n\ndStream.hbaseBulkPut(\n  hbaseContext,\n  TableName.valueOf(tableName),\n  (putRecord) => {\n   val put = new Put(putRecord._1)\n   putRecord._2.foreach((putValue) => put.addColumn(putValue._1, putValue._2, putValue._3))\n   put\n  })\n```\n\nThere are three inputs to the `hbaseBulkPut` function.\nThe hbaseContext that carries the configuration broadcast information link\nto the HBase Connections in the executor, the table name of the table we are\nputting data into, and a function that will convert a record in the DStream\ninto an HBase Put object.\n\n## Bulk Load\n\nThere are two options for bulk loading data into HBase with Spark. There is the\nbasic bulk load functionality that will work for cases where your rows have\nmillions of columns and cases where your columns are not consolidated and\npartitioned before the map side of the Spark bulk load process.\n\nThere is also a thin record bulk load option with Spark. This second option is\ndesigned for tables that have less then 10k columns per row. The advantage\nof this second option is higher throughput and less over-all load on the Spark\nshuffle operation.\n\nBoth implementations work more or less like the MapReduce bulk load process in\nthat a partitioner partitions the rowkeys based on region splits and\nthe row keys are sent to the reducers in order, so that HFiles can be written\nout directly from the reduce phase.\n\nIn Spark terms, the bulk load will be implemented around a Spark\n`repartitionAndSortWithinPartitions` followed by a Spark `foreachPartition`.\n\nFirst lets look at an example of using the basic bulk load functionality\n\n### Bulk Loading Example\n\nThe following example shows bulk loading with Spark.\n\n```scala\nval sc = new SparkContext(\"local\", \"test\")\nval config = new HBaseConfiguration()\n\nval hbaseContext = new HBaseContext(sc, config)\n\nval stagingFolder = ...\nval rdd = sc.parallelize(Array(\n      (Bytes.toBytes(\"1\"),\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"a\"), Bytes.toBytes(\"foo1\"))),\n      (Bytes.toBytes(\"3\"),\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"b\"), Bytes.toBytes(\"foo2.b\"))), ...\n\nrdd.hbaseBulkLoad(TableName.valueOf(tableName),\n  t => {\n   val rowKey = t._1\n   val family:Array[Byte] = t._2(0)._1\n   val qualifier = t._2(0)._2\n   val value = t._2(0)._3\n\n   val keyFamilyQualifier= new KeyFamilyQualifier(rowKey, family, qualifier)\n\n   Seq((keyFamilyQualifier, value)).iterator\n  },\n  stagingFolder.getPath)\n\nval load = new LoadIncrementalHFiles(config)\nload.doBulkLoad(new Path(stagingFolder.getPath),\n  conn.getAdmin, table, conn.getRegionLocator(TableName.valueOf(tableName)))\n```\n\nThe `hbaseBulkLoad` function takes three required parameters:\n\n1. The table name of the table we intend to bulk load too\n2. A function that will convert a record in the RDD to a tuple key value par. With\n   the tuple key being a KeyFamilyQualifer object and the value being the cell value.\n   The KeyFamilyQualifer object will hold the RowKey, Column Family, and Column Qualifier.\n   The shuffle will partition on the RowKey but will sort by all three values.\n3. The temporary path for the HFile to be written out too\n\nFollowing the Spark bulk load command, use the HBase's LoadIncrementalHFiles object\nto load the newly created HFiles into HBase.\n\n### Additional Parameters for Bulk Loading with Spark\n\nYou can set the following attributes with additional parameter options on hbaseBulkLoad.\n\n* Max file size of the HFiles\n* A flag to exclude HFiles from compactions\n* Column Family settings for compression, bloomType, blockSize, and dataBlockEncoding\n\n### Using Additional Parameters\n\n```scala\nval sc = new SparkContext(\"local\", \"test\")\nval config = new HBaseConfiguration()\n\nval hbaseContext = new HBaseContext(sc, config)\n\nval stagingFolder = ...\nval rdd = sc.parallelize(Array(\n      (Bytes.toBytes(\"1\"),\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"a\"), Bytes.toBytes(\"foo1\"))),\n      (Bytes.toBytes(\"3\"),\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"b\"), Bytes.toBytes(\"foo2.b\"))), ...\n\nval familyHBaseWriterOptions = new java.util.HashMap[Array[Byte], FamilyHFileWriteOptions]\nval f1Options = new FamilyHFileWriteOptions(\"GZ\", \"ROW\", 128, \"PREFIX\")\n\nfamilyHBaseWriterOptions.put(Bytes.toBytes(\"columnFamily1\"), f1Options)\n\nrdd.hbaseBulkLoad(TableName.valueOf(tableName),\n  t => {\n   val rowKey = t._1\n   val family:Array[Byte] = t._2(0)._1\n   val qualifier = t._2(0)._2\n   val value = t._2(0)._3\n\n   val keyFamilyQualifier= new KeyFamilyQualifier(rowKey, family, qualifier)\n\n   Seq((keyFamilyQualifier, value)).iterator\n  },\n  stagingFolder.getPath,\n  familyHBaseWriterOptions,\n  compactionExclude = false,\n  HConstants.DEFAULT_MAX_FILE_SIZE)\n\nval load = new LoadIncrementalHFiles(config)\nload.doBulkLoad(new Path(stagingFolder.getPath),\n  conn.getAdmin, table, conn.getRegionLocator(TableName.valueOf(tableName)))\n```\n\nNow lets look at how you would call the thin record bulk load implementation\n\n### Using thin record bulk load\n\n```scala\nval sc = new SparkContext(\"local\", \"test\")\nval config = new HBaseConfiguration()\n\nval hbaseContext = new HBaseContext(sc, config)\n\nval stagingFolder = ...\nval rdd = sc.parallelize(Array(\n      (\"1\",\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"a\"), Bytes.toBytes(\"foo1\"))),\n      (\"3\",\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"b\"), Bytes.toBytes(\"foo2.b\"))), ...\n\nrdd.hbaseBulkLoadThinRows(hbaseContext,\n      TableName.valueOf(tableName),\n      t => {\n        val rowKey = t._1\n\n        val familyQualifiersValues = new FamiliesQualifiersValues\n        t._2.foreach(f => {\n          val family:Array[Byte] = f._1\n          val qualifier = f._2\n          val value:Array[Byte] = f._3\n\n          familyQualifiersValues +=(family, qualifier, value)\n        })\n        (new ByteArrayWrapper(Bytes.toBytes(rowKey)), familyQualifiersValues)\n      },\n      stagingFolder.getPath,\n      new java.util.HashMap[Array[Byte], FamilyHFileWriteOptions],\n      compactionExclude = false,\n      20)\n\nval load = new LoadIncrementalHFiles(config)\nload.doBulkLoad(new Path(stagingFolder.getPath),\n  conn.getAdmin, table, conn.getRegionLocator(TableName.valueOf(tableName)))\n```\n\nNote that the big difference in using bulk load for thin rows is the function\nreturns a tuple with the first value being the row key and the second value\nbeing an object of FamiliesQualifiersValues, which will contain all the\nvalues for this row for all column families.\n\n## SparkSQL/DataFrames\n\nThe [hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\nleverages\n[DataSource API](https://databricks.com/blog/2015/01/09/spark-sql-data-sources-api-unified-data-access-for-the-spark-platform.html)\n([SPARK-3247](https://issues.apache.org/jira/browse/SPARK-3247))\nintroduced in Spark-1.2.0, which bridges the gap between simple HBase KV store and complex\nrelational SQL queries and enables users to perform complex data analytical work\non top of HBase using Spark. HBase Dataframe is a standard Spark Dataframe, and is able to\ninteract with any other data sources such as Hive, Orc, Parquet, JSON, etc.\nThe [hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\napplies critical techniques such as partition pruning, column pruning,\npredicate pushdown and data locality.\n\nTo use the\n[hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\nconnector, users need to define the Catalog for the schema mapping\nbetween HBase and Spark tables, prepare the data and populate the HBase table,\nthen load the HBase DataFrame. After that, users can do integrated query and access records\nin HBase tables with SQL query. The following illustrates the basic procedure.\n\n### Define catalog\n\n```scala\ndef catalog = s\"\"\"{\n       |\"table\":{\"namespace\":\"default\", \"name\":\"table1\"},\n       |\"rowkey\":\"key\",\n       |\"columns\":{\n         |\"col0\":{\"cf\":\"rowkey\", \"col\":\"key\", \"type\":\"string\"},\n         |\"col1\":{\"cf\":\"cf1\", \"col\":\"col1\", \"type\":\"boolean\"},\n         |\"col2\":{\"cf\":\"cf2\", \"col\":\"col2\", \"type\":\"double\"},\n         |\"col3\":{\"cf\":\"cf3\", \"col\":\"col3\", \"type\":\"float\"},\n         |\"col4\":{\"cf\":\"cf4\", \"col\":\"col4\", \"type\":\"int\"},\n         |\"col5\":{\"cf\":\"cf5\", \"col\":\"col5\", \"type\":\"bigint\"},\n         |\"col6\":{\"cf\":\"cf6\", \"col\":\"col6\", \"type\":\"smallint\"},\n         |\"col7\":{\"cf\":\"cf7\", \"col\":\"col7\", \"type\":\"string\"},\n         |\"col8\":{\"cf\":\"cf8\", \"col\":\"col8\", \"type\":\"tinyint\"}\n       |}\n     |}\"\"\".stripMargin\n```\n\nCatalog defines a mapping between HBase and Spark tables. There are two critical parts of this catalog.\nOne is the rowkey definition and the other is the mapping between table column in Spark and\nthe column family and column qualifier in HBase. The above defines a schema for a HBase table\nwith name as table1, row key as key and a number of columns (col1 `-` col8). Note that the rowkey\nalso has to be defined in details as a column (col0), which has a specific cf (rowkey).\n\n### Save the DataFrame\n\n```scala\ncase class HBaseRecord(\n   col0: String,\n   col1: Boolean,\n   col2: Double,\n   col3: Float,\n   col4: Int,\n   col5: Long,\n   col6: Short,\n   col7: String,\n   col8: Byte)\n\nobject HBaseRecord\n{\n   def apply(i: Int, t: String): HBaseRecord = {\n      val s = s\"\"\"row${\"%03d\".format(i)}\"\"\"\n      HBaseRecord(s,\n      i % 2 == 0,\n      i.toDouble,\n      i.toFloat,\n      i,\n      i.toLong,\n      i.toShort,\n      s\"String$i: $t\",\n      i.toByte)\n  }\n}\n\nval data = (0 to 255).map { i =>  HBaseRecord(i, \"extra\")}\n\nsc.parallelize(data).toDF.write.options(\n Map(HBaseTableCatalog.tableCatalog -> catalog, HBaseTableCatalog.newTable -> \"5\"))\n .format(\"org.apache.hadoop.hbase.spark \")\n .save()\n```\n\n`data` prepared by the user is a local Scala collection which has 256 HBaseRecord objects.\n`sc.parallelize(data)` function distributes `data` to form an RDD. `toDF` returns a DataFrame.\n`write` function returns a DataFrameWriter used to write the DataFrame to external storage\nsystems (e.g. HBase here). Given a DataFrame with specified schema `catalog`, `save` function\nwill create an HBase table with 5 regions and save the DataFrame inside.\n\n### Load the DataFrame\n\n```scala\ndef withCatalog(cat: String): DataFrame = {\n  sqlContext\n  .read\n  .options(Map(HBaseTableCatalog.tableCatalog->cat))\n  .format(\"org.apache.hadoop.hbase.spark\")\n  .load()\n}\nval df = withCatalog(catalog)\n```\n\nIn 'withCatalog' function, sqlContext is a variable of SQLContext, which is the entry point\nfor working with structured data (rows and columns) in Spark.\n`read` returns a DataFrameReader that can be used to read data in as a DataFrame.\n`option` function adds input options for the underlying data source to the DataFrameReader,\nand `format` function specifies the input data source format for the DataFrameReader.\nThe `load()` function loads input in as a DataFrame. The date frame `df` returned\nby `withCatalog` function could be used to access HBase table, such as 4.4 and 4.5.\n\n### Language Integrated Query\n\n```scala\nval s = df.filter(($\"col0\" <= \"row050\" && $\"col0\" > \"row040\") ||\n  $\"col0\" === \"row005\" ||\n  $\"col0\" <= \"row005\")\n  .select(\"col0\", \"col1\", \"col4\")\ns.show\n```\n\nDataFrame can do various operations, such as join, sort, select, filter, orderBy and so on.\n`df.filter` above filters rows using the given SQL expression. `select` selects a set of columns:\n`col0`, `col1` and `col4`.\n\n### SQL Query\n\n```scala\ndf.registerTempTable(\"table1\")\nsqlContext.sql(\"select count(col1) from table1\").show\n```\n\n`registerTempTable` registers `df` DataFrame as a temporary table using the table name `table1`.\nThe lifetime of this temporary table is tied to the SQLContext that was used to create `df`.\n`sqlContext.sql` function allows the user to execute SQL queries.\n\n### Others\n\n#### Query with different timestamps\n\nIn HBaseSparkConf, four parameters related to timestamp can be set. They are TIMESTAMP,\nMIN\\_TIMESTAMP, MAX\\_TIMESTAMP and MAX\\_VERSIONS respectively. Users can query records with\ndifferent timestamps or time ranges with MIN\\_TIMESTAMP and MAX\\_TIMESTAMP. In the meantime,\nuse concrete value instead of tsSpecified and oldMs in the examples below.\n\nThe example below shows how to load df DataFrame with different timestamps.\ntsSpecified is specified by the user.\nHBaseTableCatalog defines the HBase and Relation relation schema.\nwriteCatalog defines catalog for the schema mapping.\n\n```scala\nval df = sqlContext.read\n      .options(Map(HBaseTableCatalog.tableCatalog -> writeCatalog, HBaseSparkConf.TIMESTAMP -> tsSpecified.toString))\n      .format(\"org.apache.hadoop.hbase.spark\")\n      .load()\n```\n\nThe example below shows how to load df DataFrame with different time ranges.\noldMs is specified by the user.\n\n```scala\nval df = sqlContext.read\n      .options(Map(HBaseTableCatalog.tableCatalog -> writeCatalog, HBaseSparkConf.MIN_TIMESTAMP -> \"0\",\n        HBaseSparkConf.MAX_TIMESTAMP -> oldMs.toString))\n      .format(\"org.apache.hadoop.hbase.spark\")\n      .load()\n```\n\nAfter loading df DataFrame, users can query data.\n\n```scala\ndf.registerTempTable(\"table\")\nsqlContext.sql(\"select count(col1) from table\").show\n```\n\n#### Native Avro support\n\nThe [hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\nconnector supports different data formats like Avro, JSON, etc. The use case below\nshows how spark supports Avro. Users can persist the Avro record into HBase directly. Internally,\nthe Avro schema is converted to a native Spark Catalyst data type automatically.\nNote that both key-value parts in an HBase table can be defined in Avro format.\n\n1. Define catalog for the schema mapping:\n\n   ```scala\n   def catalog = s\"\"\"{\n                       |\"table\":{\"namespace\":\"default\", \"name\":\"Avrotable\"},\n                         |\"rowkey\":\"key\",\n                         |\"columns\":{\n                         |\"col0\":{\"cf\":\"rowkey\", \"col\":\"key\", \"type\":\"string\"},\n                         |\"col1\":{\"cf\":\"cf1\", \"col\":\"col1\", \"type\":\"binary\"}\n                         |}\n                         |}\"\"\".stripMargin\n   ```\n\n   `catalog` is a schema for a HBase table named `Avrotable`. row key as key and\n   one column col1. The rowkey also has to be defined in details as a column (col0),\n   which has a specific cf (rowkey).\n\n2. Prepare the Data:\n\n   ```scala\n   object AvroHBaseRecord {\n     val schemaString =\n       s\"\"\"{\"namespace\": \"example.avro\",\n           |   \"type\": \"record\",      \"name\": \"User\",\n           |    \"fields\": [\n           |        {\"name\": \"name\", \"type\": \"string\"},\n           |        {\"name\": \"favorite_number\",  \"type\": [\"int\", \"null\"]},\n           |        {\"name\": \"favorite_color\", \"type\": [\"string\", \"null\"]},\n           |        {\"name\": \"favorite_array\", \"type\": {\"type\": \"array\", \"items\": \"string\"}},\n           |        {\"name\": \"favorite_map\", \"type\": {\"type\": \"map\", \"values\": \"int\"}}\n           |      ]    }\"\"\".stripMargin\n\n     val avroSchema: Schema = {\n       val p = new Schema.Parser\n       p.parse(schemaString)\n     }\n\n     def apply(i: Int): AvroHBaseRecord = {\n       val user = new GenericData.Record(avroSchema);\n       user.put(\"name\", s\"name${\"%03d\".format(i)}\")\n       user.put(\"favorite_number\", i)\n       user.put(\"favorite_color\", s\"color${\"%03d\".format(i)}\")\n       val favoriteArray = new GenericData.Array[String](2, avroSchema.getField(\"favorite_array\").schema())\n       favoriteArray.add(s\"number${i}\")\n       favoriteArray.add(s\"number${i+1}\")\n       user.put(\"favorite_array\", favoriteArray)\n       import collection.JavaConverters._\n       val favoriteMap = Map[String, Int]((\"key1\" -> i), (\"key2\" -> (i+1))).asJava\n       user.put(\"favorite_map\", favoriteMap)\n       val avroByte = AvroSedes.serialize(user, avroSchema)\n       AvroHBaseRecord(s\"name${\"%03d\".format(i)}\", avroByte)\n     }\n   }\n\n   val data = (0 to 255).map { i =>\n       AvroHBaseRecord(i)\n   }\n   ```\n\n   `schemaString` is defined first, then it is parsed to get `avroSchema`. `avroSchema` is used to\n   generate `AvroHBaseRecord`. `data` prepared by users is a local Scala collection\n   which has 256 `AvroHBaseRecord` objects.\n\n3. Save DataFrame:\n\n   ```scala\n   sc.parallelize(data).toDF.write.options(\n       Map(HBaseTableCatalog.tableCatalog -> catalog, HBaseTableCatalog.newTable -> \"5\"))\n       .format(\"org.apache.spark.sql.execution.datasources.hbase\")\n       .save()\n   ```\n\n   Given a data frame with specified schema `catalog`, above will create an HBase table with 5\n   regions and save the data frame inside.\n\n4. Load the DataFrame\n\n   ```scala\n   def avroCatalog = s\"\"\"{\n               |\"table\":{\"namespace\":\"default\", \"name\":\"avrotable\"},\n               |\"rowkey\":\"key\",\n               |\"columns\":{\n                 |\"col0\":{\"cf\":\"rowkey\", \"col\":\"key\", \"type\":\"string\"},\n                 |\"col1\":{\"cf\":\"cf1\", \"col\":\"col1\", \"avro\":\"avroSchema\"}\n               |}\n             |}\"\"\".stripMargin\n\n   def withCatalog(cat: String): DataFrame = {\n       sqlContext\n           .read\n           .options(Map(\"avroSchema\" -> AvroHBaseRecord.schemaString, HBaseTableCatalog.tableCatalog -> avroCatalog))\n           .format(\"org.apache.spark.sql.execution.datasources.hbase\")\n           .load()\n   }\n   val df = withCatalog(catalog)\n   ```\n\n   In `withCatalog` function, `read` returns a DataFrameReader that can be used to read data in as a DataFrame.\n   The `option` function adds input options for the underlying data source to the DataFrameReader.\n   There are two options: one is to set `avroSchema` as `AvroHBaseRecord.schemaString`, and one is to\n   set `HBaseTableCatalog.tableCatalog` as `avroCatalog`. The `load()` function loads input in as a DataFrame.\n   The date frame `df` returned by `withCatalog` function could be used to access the HBase table.\n\n5. SQL Query\n\n   ```scala\n   df.registerTempTable(\"avrotable\")\n   val c = sqlContext.sql(\"select count(1) from avrotable\").\n   ```\n\n   After loading df DataFrame, users can query data. registerTempTable registers df DataFrame\n   as a temporary table using the table name avrotable. `sqlContext.sql` function allows the\n   user to execute SQL queries.\n\n\n# SQL over HBase (/docs/sql)\n[Apache Phoenix](https://phoenix.apache.org)\n\n[Trafodion: Transactional SQL-on-HBase](https://trafodion.incubator.apache.org/)\n\n\n# Store File Tracking (/docs/store-file-tracking)\n## Overview\n\nHistorically, HBase internals have relied on creating hfiles on temporary directories first, renaming\nthose files to the actual store directory at operation commit time. That's a simple and convenient\nway to separate transient from already finalised files that are ready to serve client reads with data.\nThis approach works well with strong consistent file systems, but with the popularity of less consistent\nfile systems, mainly Object Store which can be used like file systems, dependency on atomic rename operations starts to introduce performance penalties. The Amazon S3 Object Store, in particular, has been the most affected deployment,\ndue to its lack of atomic renames. The HBase community temporarily bypassed this problem by building a distributed locking layer called HBOSS, to guarantee atomicity of operations against S3.\n\nWith **Store File Tracking**, decision on where to originally create new hfiles and how to proceed upon\ncommit is delegated to the specific Store File Tracking implementation.\nThe implementation can be set at the HBase service leve in **hbase-site.xml** or at the\nTable or Column Family via the TableDescriptor configuration.\n\n<Callout type=\"info\">\n  When the store file tracking implementation is specified in **hbase\\_site.xml**, this configuration\n  is also propagated into a tables configuration at table creation time. This is to avoid dangerous\n  configuration mismatches between processes, which could potentially lead to data loss.\n</Callout>\n\n## Available Implementations\n\nStore File Tracking initial version provides three builtin implementations:\n\n* DEFAULT\n* FILE\n* MIGRATION\n\n### DEFAULT\n\nAs per the name, this is the Store File Tracking implementation used by default when no explicit\nconfiguration has been defined. The DEFAULT tracker implements the standard approach using temporary\ndirectories and renames. This is how all previous (implicit) implementation that HBase used to track store files.\n\n### FILE\n\nA file tracker implementation that creates new files straight in the store directory, avoiding the\nneed for rename operations. It keeps a list of committed hfiles in memory, backed by meta files, in\neach store directory. Whenever a new hfile is committed, the list of *tracked files* in the given\nstore is updated and a new meta file is written with this list contents, discarding the previous\nmeta file now containing an out dated list.\n\n### MIGRATION\n\nA special implementation to be used when swapping between Store File Tracking implementations on\npre-existing tables that already contain data, and therefore, files being tracked under an specific\nlogic.\n\n## Usage\n\nFor fresh deployments that don't yet contain any user data, **FILE** implementation can be just set as\nvalue for **hbase.store.file-tracker.impl** property in global **hbase-site.xml** configuration, prior\nto the first hbase start. Omitting this property sets the **DEFAULT** implementation.\n\nFor clusters with data that are upgraded to a version of HBase containing the store file tracking\nfeature, the Store File Tracking implementation can only be changed with the **MIGRATION**\nimplementation, so that the *new tracker* can safely build its list of tracked files based on the\nlist of the *current tracker*.\n\n<Callout type=\"info\">\n  MIGRATION tracker should NOT be set at global configuration. To use it, follow below section about\n  setting Store File Tacking at Table or Column Family configuration.\n</Callout>\n\n### Configuring for Table or Column Family\n\nSetting Store File Tracking configuration globally may not always be possible or desired, for example,\nin the case of upgraded clusters with pre-existing user data.\nStore File Tracking can be set at Table or Column Family level configuration.\nFor example, to specify **FILE** implementation in the table configuration at table creation time,\nthe following should be applied:\n\n```bash\ncreate 'my-table', 'f1', 'f2', {CONFIGURATION => {'hbase.store.file-tracker.impl' => 'FILE'}}\n```\n\nTo define **FILE** for an specific Column Family:\n\n```bash\ncreate 'my-table', {NAME=> '1', CONFIGURATION => {'hbase.store.file-tracker.impl' => 'FILE'}}\n```\n\n### Switching trackers at Table or Column Family\n\nA very common scenario is to set Store File Tracking on pre-existing HBase deployments that have\nbeen upgraded to a version that supports this feature. To apply the FILE tracker, tables effectively\nneed to be migrated from the DEFAULT tracker to the FILE tracker. As explained previously, such\nprocess requires the usage of the special MIGRATION tracker implementation, which can only be\nspecified at table or Column Family level.\n\nFor example, to switch *tracker* from **DEFAULT** to **FILE** in a table configuration:\n\n```bash\nalter 'my-table', CONFIGURATION => {'hbase.store.file-tracker.impl' => 'MIGRATION',\n'hbase.store.file-tracker.migration.src.impl' => 'DEFAULT',\n'hbase.store.file-tracker.migration.dst.impl' => 'FILE'}\n```\n\nTo apply similar switch at column family level configuration:\n\n```bash\nalter 'my-table', {NAME => 'f1', CONFIGURATION => {'hbase.store.file-tracker.impl' => 'MIGRATION',\n'hbase.store.file-tracker.migration.src.impl' => 'DEFAULT',\n'hbase.store.file-tracker.migration.dst.impl' => 'FILE'}}\n```\n\nOnce all table regions have been onlined again, don't forget to disable MIGRATION, by now setting\n**hbase.store.file-tracker.migration.dst.impl** value as the **hbase.store.file-tracker.impl**. In the above\nexample, that would be as follows:\n\n```bash\nalter 'my-table', CONFIGURATION => {'hbase.store.file-tracker.impl' => 'FILE'}\n```\n\n### Specifying trackers during snapshot recovery\n\nIt's also possible to specify a given store file tracking implementation when recovering a snapshot\nusing the *CLONE\\_SFT* option of *clone\\_snasphot* command. This is useful when recovering old\nsnapshots, taken prior to a change in the global configuration, or if the snapshot has been\nimported from a different cluster that had a different store file tracking setting.\nBecause snapshots preserve table and colum family descriptors, a simple restore would reload\nthe original configuration, requiring the additional steps described above to convert the\ntable/column family to the desired tracker implementation.\nAn example of how to use *clone\\_snapshot* to specify the **FILE** tracker implementation\nis shown below:\n\n```bash\nclone_snapshot 'snapshotName', 'namespace:tableName', {CLONE_SFT=>'FILE'}\n```\n\n<Callout type=\"info\">\n  The option to specify the tracker during snapshot recovery is only available for the\n  *clone\\_snapshot* command. The *restore\\_snapshot* command does not support this parameter.\n</Callout>\n\n\n# Synchronous Replication (/docs/sync-replication)\n## Background\n\nThe current [Cluster Replication](/docs/operational-management/cluster-replication) in HBase in asynchronous. So if the master cluster crashes, the slave cluster may not have the\nnewest data. If users want strong consistency then they can not switch to the slave cluster.\n\n## Design\n\nPlease see the design doc on [HBASE-19064](https://issues.apache.org/jira/browse/HBASE-19064)\n\n## Operation and maintenance\n\n### Case.1 Setup two synchronous replication clusters\n\n* Add a synchronous peer in both source cluster and peer cluster.\n\nFor source cluster:\n\n```ruby\nhbase> add_peer  '1', CLUSTER_KEY => 'lg-hadoop-tst-st01.bj:10010,lg-hadoop-tst-st02.bj:10010,lg-hadoop-tst-st03.bj:10010:/hbase/test-hbase-slave', REMOTE_WAL_DIR=>'hdfs://lg-hadoop-tst-st01.bj:20100/hbase/test-hbase-slave/remoteWALs', TABLE_CFS => {\"ycsb-test\"=>[]}\n```\n\nFor peer cluster:\n\n```ruby\nhbase> add_peer  '1', CLUSTER_KEY => 'lg-hadoop-tst-st01.bj:10010,lg-hadoop-tst-st02.bj:10010,lg-hadoop-tst-st03.bj:10010:/hbase/test-hbase', REMOTE_WAL_DIR=>'hdfs://lg-hadoop-tst-st01.bj:20100/hbase/test-hbase/remoteWALs', TABLE_CFS => {\"ycsb-test\"=>[]}\n```\n\n<Callout type=\"info\">\n  For synchronous replication, the current implementation require that we have the same peer id for\n  both source and peer cluster. Another thing that need attention is: the peer does not support\n  cluster-level, namespace-level, or cf-level replication, only support table-level replication now.\n</Callout>\n\n* Transit the peer cluster to be STANDBY state\n\n  ```ruby\n  hbase> transit_peer_sync_replication_state '1', 'STANDBY'\n  ```\n\n* Transit the source cluster to be ACTIVE state\n  ```ruby\n  hbase> transit_peer_sync_replication_state '1', 'ACTIVE'\n  ```\n\nNow, the synchronous replication has been set up successfully. the HBase client can only request to source cluster, if\nrequest to peer cluster, the peer cluster which is STANDBY state now will reject the read/write requests.\n\n### Case.2 How to operate when standby cluster crashed\n\nIf the standby cluster has been crashed, it will fail to write remote WAL for the active cluster. So we need to transit\nthe source cluster to DOWNGRANDE\\_ACTIVE state, which means source cluster won't write any remote WAL any more, but\nthe normal replication (asynchronous Replication) can still work fine, it queue the newly written WALs, but the\nreplication block until the peer cluster come back.\n\n```ruby\nhbase> transit_peer_sync_replication_state '1', 'DOWNGRADE_ACTIVE'\n```\n\nOnce the peer cluster come back, we can just transit the source cluster to ACTIVE, to ensure that the replication will be\nsynchronous.\n\n```ruby\nhbase> transit_peer_sync_replication_state '1', 'ACTIVE'\n```\n\n### Case.3 How to operate when active cluster crashed\n\nIf the active cluster has been crashed (it may be not reachable now), so let's just transit the standby cluster to\nDOWNGRADE\\_ACTIVE state, and after that, we should redirect all the requests from client to the DOWNGRADE\\_ACTIVE cluster.\n\n```ruby\nhbase> transit_peer_sync_replication_state '1', 'DOWNGRADE_ACTIVE'\n```\n\nIf the crashed cluster come back again, we just need to transit it to STANDBY directly. Otherwise if you transit the\ncluster to DOWNGRADE\\_ACTIVE, the original ACTIVE cluster may have redundant data compared to the current ACTIVE\ncluster. Because we designed to write source cluster WALs and remote cluster WALs concurrently, so it's possible that\nthe source cluster WALs has more data than the remote cluster, which result in data inconsistency. The procedure of\ntransiting ACTIVE to STANDBY has no problem, because we'll skip to replay the original WALs.\n\n```ruby\nhbase> transit_peer_sync_replication_state '1', 'STANDBY'\n```\n\nAfter that, we can promote the DOWNGRADE\\_ACTIVE cluster to ACTIVE now, to ensure that the replication will be synchronous.\n\n```ruby\nhbase> transit_peer_sync_replication_state '1', 'ACTIVE'\n```\n\n\n# Thrift API and Filter Language (/docs/thrift-filter-language)\nYou can configure [Thrift](https://thrift.apache.org/) for secure authentication at the server and client side, by following the procedures in [Client-side Configuration for Secure Operation - Thrift Gateway](/docs/security/client-access#client-side-configuration-for-secure-operation---thrift-gateway) and [Configure the Thrift Gateway to Authenticate on Behalf of the Client](/docs/security/client-access#configure-the-thrift-gateway-to-authenticate-on-behalf-of-the-client).\n\nThe rest of this chapter discusses the filter language provided by the Thrift API.\n\n## Filter Language\n\nThrift Filter Language was introduced in HBase 0.92.\nIt allows you to perform server-side filtering when accessing HBase over Thrift or in the HBase shell.\nYou can find out more about shell integration by using the `scan help` command in the shell.\n\nYou specify a filter as a string, which is parsed on the server to construct the filter.\n\n### General Filter String Syntax\n\nA simple filter expression is expressed as a string:\n\n```text\n\"FilterName (argument, argument,... , argument)\"\n```\n\nKeep the following syntax guidelines in mind.\n\n* Specify the name of the filter followed by the comma-separated argument list in parentheses.\n* If the argument represents a string, it should be enclosed in single quotes (`'`).\n* Arguments which represent a boolean, an integer, or a comparison operator (such as `<`, `>`, or `!=`), should not be enclosed in quotes\n* The filter name must be a single word.\n  All ASCII characters are allowed except for whitespace, single quotes and parentheses.\n* The filter's arguments can contain any ASCII character.\n  If single quotes are present in the argument, they must be escaped by an additional preceding single quote.\n\n### Compound Filters and Operators\n\n#### Binary Operators\n\n**`AND`**\\\nIf the `AND` operator is used, the key-value must satisfy both filters.\n\n**`OR`**\\\nIf the `OR` operator is used, the key-value must satisfy at least one of the filters.\n\n#### Unary Operators\n\n**`SKIP`**\\\nFor a particular row, if any of the key-values fail the filter condition, the entire row is skipped.\n\n**`WHILE`**\\\nFor a particular row, key-values will be emitted until a key-value is reached that fails the filter condition.\n\n#### Compound Operators\n\nYou can combine multiple operators to create a hierarchy of filters, such as the following example:\n\n```text\n(Filter1 AND Filter2) OR (Filter3 AND Filter4)\n```\n\n### Order of Evaluation\n\n1. Parentheses have the highest precedence.\n2. The unary operators `SKIP` and `WHILE` are next, and have the same precedence.\n3. The binary operators follow. `AND` has highest precedence, followed by `OR`.\n\n#### Precedence Example\n\n```text\nFilter1 AND Filter2 OR Filter\nis evaluated as\n(Filter1 AND Filter2) OR Filter3\n```\n\n```text\nFilter1 AND SKIP Filter2 OR Filter3\nis evaluated as\n(Filter1 AND (SKIP Filter2)) OR Filter3\n```\n\nYou can use parentheses to explicitly control the order of evaluation.\n\n### Compare Operator\n\nThe following compare operators are provided:\n\n1. LESS (`<`)\n2. LESS\\_OR\\_EQUAL (`<=`)\n3. EQUAL (`=`)\n4. NOT\\_EQUAL (`!=`)\n5. GREATER\\_OR\\_EQUAL (`>=`)\n6. GREATER (`>`)\n7. NO\\_OP (no operation)\n\nThe client should use the symbols (`<`, `<=`, `=`, `!=`, `>`, `>=`) to express compare operators.\n\n### Comparator\n\nA comparator can be any of the following:\n\n1. *BinaryComparator* - This lexicographically compares against the specified byte array using Bytes.compareTo(byte\\[], byte\\[])\n2. *BinaryPrefixComparator* - This lexicographically compares against a specified byte array.\n   It only compares up to the length of this byte array.\n3. *RegexStringComparator* - This compares against the specified byte array using the given regular expression.\n   Only EQUAL and NOT\\_EQUAL comparisons are valid with this comparator\n4. *SubStringComparator* - This tests if the given substring appears in a specified byte array.\n   The comparison is case insensitive.\n   Only EQUAL and NOT\\_EQUAL comparisons are valid with this comparator\n\nThe general syntax of a comparator is: `ComparatorType:ComparatorValue`\n\nThe ComparatorType for the various comparators is as follows:\n\n1. *BinaryComparator* - binary\n2. *BinaryPrefixComparator* - binaryprefix\n3. *RegexStringComparator* - regexstring\n4. *SubStringComparator* - substring\n\nThe ComparatorValue can be any value.\n\n#### Example ComparatorValues\n\n1. `binary:abc` will match everything that is lexicographically greater than \"abc\"\n2. `binaryprefix:abc` will match everything whose first 3 characters are lexicographically equal to \"abc\"\n3. `regexstring:ab*yz` will match everything that doesn't begin with \"ab\" and ends with \"yz\"\n4. `substring:abc123` will match everything that begins with the substring \"abc123\"\n\n### Example PHP Client Program that uses the Filter Language\n\n```php\n<?\n  $_SERVER['PHP_ROOT'] = realpath(dirname(__FILE__).'/..');\n  require_once $_SERVER['PHP_ROOT'].'/flib/__flib.php';\n  flib_init(FLIB_CONTEXT_SCRIPT);\n  require_module('storage/hbase');\n  $hbase = new HBase('<server_name_running_thrift_server>', <port on which thrift server is running>);\n  $hbase->open();\n  $client = $hbase->getClient();\n  $result = $client->scannerOpenWithFilterString('table_name', \"(PrefixFilter ('row2') AND (QualifierFilter (>=, 'binary:xyz'))) AND (TimestampsFilter ( 123, 456))\");\n  $to_print = $client->scannerGetList($result,1);\n  while ($to_print) {\n    print_r($to_print);\n    $to_print = $client->scannerGetList($result,1);\n  }\n  $client->scannerClose($result);\n?>\n```\n\n### Example Filter Strings\n\n* `\"PrefixFilter ('Row') AND PageFilter (1) AND FirstKeyOnlyFilter ()\"` will return all key-value pairs that match the following conditions:\n  1. The row containing the key-value should have prefix *Row*\n  2. The key-value must be located in the first row of the table\n  3. The key-value pair must be the first key-value in the row\n* `\"(RowFilter (=, 'binary:Row 1') AND TimeStampsFilter (74689, 89734)) OR ColumnRangeFilter ('abc', true, 'xyz', false))\"` will return all key-value pairs that match both the following conditions:\n  * The key-value is in a row having row key *Row 1*\n  * The key-value must have a timestamp of either 74689 or 89734.\n  * Or it must match the following condition:\n    * The key-value pair must be in a column that is lexicographically >= abc and \\< xyz\n* `\"SKIP ValueFilter (0)\"` will skip the entire row if any of the values in the row is not 0\n\n### Individual Filter Syntax\n\n**KeyOnlyFilter**\\\nThis filter doesn't take any arguments.\nIt returns only the key component of each key-value.\n\n**FirstKeyOnlyFilter**\\\nThis filter doesn't take any arguments.\nIt returns only the first key-value from each row.\n\n**PrefixFilter**\\\nThis filter takes one argument – a prefix of a row key.\nIt returns only those key-values present in a row that starts with the specified row prefix\n\n**ColumnPrefixFilter**\\\nThis filter takes one argument – a column prefix.\nIt returns only those key-values present in a column that starts with the specified column prefix.\nThe column prefix must be of the form: `\"qualifier\"`.\n\n**MultipleColumnPrefixFilter**\\\nThis filter takes a list of column prefixes.\nIt returns key-values that are present in a column that starts with any of the specified column prefixes.\nEach of the column prefixes must be of the form: `\"qualifier\"`.\n\n**ColumnCountGetFilter**\\\nThis filter takes one argument – a limit.\nIt returns the first limit number of columns in the table.\n\n**PageFilter**\\\nThis filter takes one argument – a page size.\nIt returns page size number of rows from the table.\n\n**ColumnPaginationFilter**\\\nThis filter takes two arguments – a limit and offset.\nIt returns limit number of columns after offset number of columns.\nIt does this for all the rows.\n\n**InclusiveStopFilter**\\\nThis filter takes one argument – a row key on which to stop scanning.\nIt returns all key-values present in rows up to and including the specified row.\n\n**TimeStampsFilter**\\\nThis filter takes a list of timestamps.\nIt returns those key-values whose timestamps matches any of the specified timestamps.\n\n**RowFilter**\\\nThis filter takes a compare operator and a comparator.\nIt compares each row key with the comparator using the compare operator and if the comparison returns true, it returns all the key-values in that row.\n\n**Family Filter**\\\nThis filter takes a compare operator and a comparator.\nIt compares each column family name with the comparator using the compare operator and if the comparison returns true, it returns all the Cells in that column family.\n\n**QualifierFilter**\\\nThis filter takes a compare operator and a comparator.\nIt compares each qualifier name with the comparator using the compare operator and if the comparison returns true, it returns all the key-values in that column.\n\n**ValueFilter**\\\nThis filter takes a compare operator and a comparator.\nIt compares each value with the comparator using the compare operator and if the comparison returns true, it returns that key-value.\n\n**DependentColumnFilter**\\\nThis filter takes two arguments – a family and a qualifier.\nIt tries to locate this column in each row and returns all key-values in that row that have the same timestamp.\nIf the row doesn't contain the specified column – none of the key-values in that row will be returned.\n\n**SingleColumnValueFilter**\\\nThis filter takes a column family, a qualifier, a compare operator and a comparator.\nIf the specified column is not found – all the columns of that row will be emitted.\nIf the column is found and the comparison with the comparator returns true, all the columns of the row will be emitted.\nIf the condition fails, the row will not be emitted.\n\n**SingleColumnValueExcludeFilter**\\\nThis filter takes the same arguments and behaves same as SingleColumnValueFilter – however, if the column is found and the condition passes, all the columns of the row will be emitted except for the tested column value.\n\n**ColumnRangeFilter**\\\nThis filter is used for selecting only those keys with columns that are between minColumn and maxColumn.\nIt also takes two boolean variables to indicate whether to include the minColumn and maxColumn or not.\n\n\n# Tracing (/docs/tracing)\n## Overview\n\nThe basic support for tracing has been done, where we added tracing for async client, rpc, region read/write/scan operation, and WAL. We use opentelemetry-api to implement the tracing support manually by code, as our code base is way too complicated to be instrumented through a java agent. But notice that you still need to attach the opentelemetry java agent to enable tracing. Please see the official site for [OpenTelemetry](https://opentelemetry.io/) and the documentation for [opentelemetry-java-instrumentation](https://github.com/open-telemetry/opentelemetry-java-instrumentation) for more details on how to properly configure opentelemetry instrumentation.\n\n## Usage\n\n### Enable Tracing\n\nSee this section in hbase-env.sh\n\n```\n# Uncomment to enable trace, you can change the options to use other exporters such as jaeger or\n# zipkin. See https://github.com/open-telemetry/opentelemetry-java-instrumentation on how to\n# configure exporters and other components through system properties.\n# export HBASE_TRACE_OPTS=\"-Dotel.resource.attributes=service.name=HBase -Dotel.traces.exporter=logging otel.metrics.exporter=none\"\n```\n\nUncomment this line to enable tracing. The default config is to output the tracing data to log. Please see the documentation for [opentelemetry-java-instrumentation](https://github.com/open-telemetry/opentelemetry-java-instrumentation) for more details on how to export tracing data to other tracing system such as OTel collector, jaeger or zipkin, what does the *service.name* mean, and how to change the sampling rate, etc.\n\n<Callout type=\"info\">\n  The\n  [LoggingSpanExporter](https://github.com/open-telemetry/opentelemetry-java/blob/v1.0.1/exporters/logging/src/main/java/io/opentelemetry/exporter/logging/LoggingSpanExporter.java)\n  uses java.util.logging(jul) for logging tracing data, and the logger is initialized in\n  opentelemetry java agent, which seems to be ahead of our jul to slf4j bridge initialization, so it\n  will always log the tracing data to console. We highly suggest that you use other tracing systems\n  to collect and view tracing data instead of logging.\n</Callout>\n\n### Performance Impact\n\nAccording to the result in [HBASE-25658](https://issues.apache.org/jira/browse/HBASE-25658), the performance impact is minimal. Of course the test cluster is not under heavy load, so if you find out that enabling tracing would impact the performance, try to lower the sampling rate. See documentation for configuring [sampler](https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk-extensions/autoconfigure/README.md#sampler) for more details.\n\n\n# Troubleshooting and Debugging Apache HBase (/docs/troubleshooting)\n## General Guidelines\n\nAlways start with the master log (TODO: Which lines?). Normally it's just printing the same lines over and over again. If not, then there's an issue. Google should return some hits for those exceptions you're seeing.\n\nAn error rarely comes alone in Apache HBase, usually when something gets screwed up what will follow may be hundreds of exceptions and stack traces coming from all over the place. The best way to approach this type of problem is to walk the log up to where it all began, for example one trick with RegionServers is that they will print some metrics when aborting so grepping for *Dump* should get you around the start of the problem.\n\nRegionServer suicides are 'normal', as this is what they do when something goes wrong. For example, if ulimit and max transfer threads (the two most important initial settings, see [\\[ulimit\\]](/docs/configuration/basic-prerequisites#limits-on-number-of-files-and-processes-ulimit) and [`dfs.datanode.max.transfer.threads`](/docs/configuration/basic-prerequisites#dfsdatanodemaxtransferthreads)) aren't changed, it will make it impossible at some point for DataNodes to create new threads that from the HBase point of view is seen as if HDFS was gone. Think about what would happen if your MySQL database was suddenly unable to access files on your local file system, well it's the same with HBase and HDFS. Another very common reason to see RegionServers committing seppuku is when they enter prolonged garbage collection pauses that last longer than the default ZooKeeper session timeout. For more information on GC pauses, see the [3 part blog post](https://blog.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/) by Todd Lipcon and [Long GC pauses](/docs/performance#long-gc-pauses) above.\n\n## Logs\n\nThe key process logs are as follows... (replace `<user>` with the user that started the service, and `<hostname>` for the machine name)\n\nNameNode: *\\$HADOOP\\_HOME/logs/hadoop-\\<user>-namenode-\\<hostname>.log*\n\nDataNode: *\\$HADOOP\\_HOME/logs/hadoop-\\<user>-datanode-\\<hostname>.log*\n\nJobTracker: *\\$HADOOP\\_HOME/logs/hadoop-\\<user>-jobtracker-\\<hostname>.log*\n\nTaskTracker: *\\$HADOOP\\_HOME/logs/hadoop-\\<user>-tasktracker-\\<hostname>.log*\n\nHMaster: *\\$HBASE\\_HOME/logs/hbase-\\<user>-master-\\<hostname>.log*\n\nRegionServer: *\\$HBASE\\_HOME/logs/hbase-\\<user>-regionserver-\\<hostname>.log*\n\nZooKeeper: *TODO*\n\n## Log Locations\n\nFor stand-alone deployments the logs are obviously going to be on a single machine, however this is a development configuration only. Production deployments need to run on a cluster.\n\n### NameNode\n\nThe NameNode log is on the NameNode server. The HBase Master is typically run on the NameNode server, and well as ZooKeeper.\n\nFor smaller clusters the JobTracker/ResourceManager is typically run on the NameNode server as well.\n\n### DataNode\n\nEach DataNode server will have a DataNode log for HDFS, as well as a RegionServer log for HBase.\n\nAdditionally, each DataNode server will also have a TaskTracker/NodeManager log for MapReduce task execution.\n\n## Log Levels\n\n### Enabling RPC-level logging\n\nEnabling the RPC-level logging on a RegionServer can often give insight on timings at the server. Once enabled, the amount of log spewed is voluminous. It is not recommended that you leave this logging on for more than short bursts of time. To enable RPC-level logging, browse to the RegionServer UI and click on *Log Level*. Set the log level to `TRACE` for the package `org.apache.hadoop.hbase.ipc`, then tail the RegionServers log. Analyze.\n\nTo disable, set the logging level back to `INFO` level.\n\nThe same log settings also work on Master and for the client.\n\n## JVM Garbage Collection Logs\n\n<Callout type=\"info\">\n  All example Garbage Collection logs in this section are based on Java 8 output. The introduction\n  of Unified Logging in Java 9 and newer will result in very different looking logs.\n</Callout>\n\nHBase is memory intensive, and using the default GC you can see long pauses in all threads including the *Juliet Pause* aka \"GC of Death\". To help debug this or confirm this is happening GC logging can be turned on in the Java virtual machine.\n\nTo enable, in *hbase-env.sh*, uncomment one of the below lines :\n\n```bash\n# This enables basic gc logging to the .out file.\n# export SERVER_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps\"\n\n# This enables basic gc logging to its own file.\n# export SERVER_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<FILE-PATH>\"\n\n# This enables basic GC logging to its own file with automatic log rolling. Only applies to jdk 1.6.0_34+ and 1.7.0_2+.\n# export SERVER_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<FILE-PATH> -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=1 -XX:GCLogFileSize=512M\"\n\n# If <FILE-PATH> is not replaced, the log file(.gc) would be generated in the HBASE_LOG_DIR.\n```\n\nAt this point you should see logs like so:\n\n```text\n64898.952: [GC [1 CMS-initial-mark: 2811538K(3055704K)] 2812179K(3061272K), 0.0007360 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n64898.953: [CMS-concurrent-mark-start]\n64898.971: [GC 64898.971: [ParNew: 5567K->576K(5568K), 0.0101110 secs] 2817105K->2812715K(3061272K), 0.0102200 secs] [Times: user=0.07 sys=0.00, real=0.01 secs]\n```\n\nIn this section, the first line indicates a 0.0007360 second pause for the CMS to initially mark. This pauses the entire VM, all threads for that period of time.\n\nThe third line indicates a \"minor GC\", which pauses the VM for 0.0101110 seconds - aka 10 milliseconds. It has reduced the \"ParNew\" from about 5.5m to 576k. Later on in this cycle we see:\n\n```text\n64901.445: [CMS-concurrent-mark: 1.542/2.492 secs] [Times: user=10.49 sys=0.33, real=2.49 secs]\n64901.445: [CMS-concurrent-preclean-start]\n64901.453: [GC 64901.453: [ParNew: 5505K->573K(5568K), 0.0062440 secs] 2868746K->2864292K(3061272K), 0.0063360 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]\n64901.476: [GC 64901.476: [ParNew: 5563K->575K(5568K), 0.0072510 secs] 2869283K->2864837K(3061272K), 0.0073320 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]\n64901.500: [GC 64901.500: [ParNew: 5517K->573K(5568K), 0.0120390 secs] 2869780K->2865267K(3061272K), 0.0121150 secs] [Times: user=0.09 sys=0.00, real=0.01 secs]\n64901.529: [GC 64901.529: [ParNew: 5507K->569K(5568K), 0.0086240 secs] 2870200K->2865742K(3061272K), 0.0087180 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]\n64901.554: [GC 64901.555: [ParNew: 5516K->575K(5568K), 0.0107130 secs] 2870689K->2866291K(3061272K), 0.0107820 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]\n64901.578: [CMS-concurrent-preclean: 0.070/0.133 secs] [Times: user=0.48 sys=0.01, real=0.14 secs]\n64901.578: [CMS-concurrent-abortable-preclean-start]\n64901.584: [GC 64901.584: [ParNew: 5504K->571K(5568K), 0.0087270 secs] 2871220K->2866830K(3061272K), 0.0088220 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]\n64901.609: [GC 64901.609: [ParNew: 5512K->569K(5568K), 0.0063370 secs] 2871771K->2867322K(3061272K), 0.0064230 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]\n64901.615: [CMS-concurrent-abortable-preclean: 0.007/0.037 secs] [Times: user=0.13 sys=0.00, real=0.03 secs]\n64901.616: [GC[YG occupancy: 645 K (5568 K)]64901.616: [Rescan (parallel) , 0.0020210 secs]64901.618: [weak refs processing, 0.0027950 secs] [1 CMS-remark: 2866753K(3055704K)] 2867399K(3061272K), 0.0049380 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]\n64901.621: [CMS-concurrent-sweep-start]\n```\n\nThe first line indicates that the CMS concurrent mark (finding garbage) has taken 2.4 seconds. But this is a *concurrent* 2.4 seconds, Java has not been paused at any point in time.\n\nThere are a few more minor GCs, then there is a pause at the 2nd last line:\n\n```text\n64901.616: [GC[YG occupancy: 645 K (5568 K)]64901.616: [Rescan (parallel) , 0.0020210 secs]64901.618: [weak refs processing, 0.0027950 secs] [1 CMS-remark: 2866753K(3055704K)] 2867399K(3061272K), 0.0049380 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]\n```\n\nThe pause here is 0.0049380 seconds (aka 4.9 milliseconds) to 'remark' the heap.\n\nAt this point the sweep starts, and you can watch the heap size go down:\n\n```text\n64901.637: [GC 64901.637: [ParNew: 5501K->569K(5568K), 0.0097350 secs] 2871958K->2867441K(3061272K), 0.0098370 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]\n...  lines removed ...\n64904.936: [GC 64904.936: [ParNew: 5532K->568K(5568K), 0.0070720 secs] 1365024K->1360689K(3061272K), 0.0071930 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]\n64904.953: [CMS-concurrent-sweep: 2.030/3.332 secs] [Times: user=9.57 sys=0.26, real=3.33 secs]\n```\n\nAt this point, the CMS sweep took 3.332 seconds, and heap went from about \\~ 2.8 GB to 1.3 GB (approximate).\n\nThe key points here is to keep all these pauses low. CMS pauses are always low, but if your ParNew starts growing, you can see minor GC pauses approach 100ms, exceed 100ms and hit as high at 400ms.\n\nThis can be due to the size of the ParNew, which should be relatively small. If your ParNew is very large after running HBase for a while, in one example a ParNew was about 150MB, then you might have to constrain the size of ParNew (The larger it is, the longer the collections take but if it's too small, objects are promoted to old gen too quickly). In the below we constrain new gen size to 64m.\n\nAdd the below line in *hbase-env.sh*:\n\n```bash\nexport SERVER_GC_OPTS=\"$SERVER_GC_OPTS -XX:NewSize=64m -XX:MaxNewSize=64m\"\n```\n\nSimilarly, to enable GC logging for client processes, uncomment one of the below lines in *hbase-env.sh*:\n\n```bash\n# This enables basic gc logging to the .out file.\n# export CLIENT_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps\"\n\n# This enables basic gc logging to its own file.\n# export CLIENT_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<FILE-PATH>\"\n\n# This enables basic GC logging to its own file with automatic log rolling. Only applies to jdk 1.6.0_34+ and 1.7.0_2+.\n# export CLIENT_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<FILE-PATH> -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=1 -XX:GCLogFileSize=512M\"\n\n# If <FILE-PATH> is not replaced, the log file(.gc) would be generated in the HBASE_LOG_DIR .\n```\n\nFor more information on GC pauses, see the [3 part blog post](https://blog.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/) by Todd Lipcon and [Long GC pauses](/docs/performance#long-gc-pauses) above.\n\n## Resources\n\n### Mailing Lists\n\nAsk a question on the [Apache HBase mailing lists](https://hbase.apache.org/mailing-lists.html). The 'dev' mailing list is aimed at the community of developers actually building Apache HBase and for features currently under development, and 'user' is generally used for questions on released versions of Apache HBase. Before going to the mailing list, make sure your question has not already been answered by searching the mailing list archives first. For those who prefer to communicate in Chinese, they can use the 'user-zh' mailing list instead of the 'user' list. Take some time crafting your question. See [Getting Answers](http://www.mikeash.com/getting_answers.html) for ideas on crafting good questions. A quality question that includes all context and exhibits evidence the author has tried to find answers in the manual and out on lists is more likely to get a prompt response.\n\n### Slack\n\n\\#hbase on [https://the-asf.slack.com/](https://the-asf.slack.com/)\n\n### IRC\n\n(You will probably get a more prompt response on the Slack channel)\n\n\\#hbase on irc.freenode.net\n\n### JIRA\n\n[JIRA](https://issues.apache.org/jira/browse/HBASE) is also really helpful when looking for Hadoop/HBase-specific issues.\n\n## Tools\n\n### Builtin Tools\n\n#### Master Web Interface\n\nThe Master starts a web-interface on port 16010 by default.\n\nThe Master web UI lists created tables and their definition (e.g., ColumnFamilies, blocksize, etc.). Additionally, the available RegionServers in the cluster are listed along with selected high-level metrics (requests, number of regions, usedHeap, maxHeap). The Master web UI allows navigation to each RegionServer's web UI.\n\n#### RegionServer Web Interface\n\nRegionServers starts a web-interface on port 16030 by default.\n\nThe RegionServer web UI lists online regions and their start/end keys, as well as point-in-time RegionServer metrics (requests, regions, storeFileIndexSize, compactionQueueSize, etc.).\n\nSee [HBase Metrics](/docs/operational-management/metrics-and-monitoring) for more information in metric definitions.\n\n#### zkcli\n\n`zkcli` is a very useful tool for investigating ZooKeeper-related issues. To invoke:\n\n```bash\n./hbase zkcli -server host:port <cmd> <args>\n```\n\nThe commands (and arguments) are:\n\n```text\n  connect host:port\n  get path [watch]\n  ls path [watch]\n  set path data [version]\n  delquota [-n|-b] path\n  quit\n  printwatches on|off\n  create [-s] [-e] path data acl\n  stat path [watch]\n  close\n  ls2 path [watch]\n  history\n  listquota path\n  setAcl path acl\n  getAcl path\n  sync path\n  redo cmdno\n  addauth scheme auth\n  delete path [version]\n  setquota -n|-b val path\n```\n\n#### Maintenance Mode\n\nIf the cluster has gotten stuck in some state and the standard techniques aren't making progress, it is possible to restart the cluster in \"maintenance mode.\" This mode features drastically reduced capabilities and surface area, making it easier to enact very low-level changes such as repairing/recovering the `hbase:meta` table.\n\nTo enter maintenance mode, set `hbase.master.maintenance_mode` to `true` either in your `hbase-site.xml` or via system propery when starting the master process (`-D...=true`). Entering and exiting this mode requires a service restart, however the typical use will be when HBase Master is already facing startup difficulties.\n\nWhen maintenance mode is enabled, the master will host all system tables - ensure that it has enough memory to do so. RegionServers will not be assigned any regions from user-space tables; in fact, they will go completely unused while in maintenance mode. Additionally, the master will not load any coprocessors, will not run any normalization or merge/split operations, and will not enforce quotas.\n\n### External Tools\n\n#### tail\n\n`tail` is the command line tool that lets you look at the end of a file. Add the `-f` option and it will refresh when new data is available. It's useful when you are wondering what's happening, for example, when a cluster is taking a long time to shutdown or startup as you can just fire a new terminal and tail the master log (and maybe a few RegionServers).\n\n#### top\n\n`top` is probably one of the most important tools when first trying to see what's running on a machine and how the resources are consumed. Here's an example from production system:\n\n```text\ntop - 14:46:59 up 39 days, 11:55,  1 user,  load average: 3.75, 3.57, 3.84\nTasks: 309 total,   1 running, 308 sleeping,   0 stopped,   0 zombie\nCpu(s):  4.5%us,  1.6%sy,  0.0%ni, 91.7%id,  1.4%wa,  0.1%hi,  0.6%si,  0.0%st\nMem:  24414432k total, 24296956k used,   117476k free,     7196k buffers\nSwap: 16008732k total,  14348k used, 15994384k free, 11106908k cached\n\n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM  TIME+  COMMAND\n15558 hadoop    18  -2 3292m 2.4g 3556 S   79 10.4   6523:52 java\n13268 hadoop    18  -2 8967m 8.2g 4104 S   21 35.1   5170:30 java\n 8895 hadoop    18  -2 1581m 497m 3420 S   11  2.1   4002:32 java\n...\n```\n\nHere we can see that the system load average during the last five minutes is 3.75, which very roughly means that on average 3.75 threads were waiting for CPU time during these 5 minutes. In general, the *perfect* utilization equals to the number of cores, under that number the machine is under utilized and over that the machine is over utilized. This is an important concept, see this article to understand it more: [http://www.linuxjournal.com/article/9001](http://www.linuxjournal.com/article/9001).\n\nApart from load, we can see that the system is using almost all its available RAM but most of it is used for the OS cache (which is good). The swap only has a few KBs in it and this is wanted, high numbers would indicate swapping activity which is the nemesis of performance of Java systems. Another way to detect swapping is when the load average goes through the roof (although this could also be caused by things like a dying disk, among others).\n\nThe list of processes isn't super useful by default, all we know is that 3 java processes are using about 111% of the CPUs. To know which is which, simply type `c` and each line will be expanded. Typing `1` will give you the detail of how each CPU is used instead of the average for all of them like shown here.\n\n#### jps\n\n`jps` is shipped with every JDK and gives the java process ids for the current user (if root, then it gives the ids for all users). Example:\n\n```bash\nhadoop@sv4borg12:~$ jps\n1322 TaskTracker\n17789 HRegionServer\n27862 Child\n1158 DataNode\n25115 HQuorumPeer\n2950 Jps\n19750 ThriftServer\n18776 jmx\n```\n\nIn order, we see a:\n\n* Hadoop TaskTracker, manages the local Childs\n* HBase RegionServer, serves regions\n* Child, its MapReduce task, cannot tell which type exactly\n* Hadoop TaskTracker, manages the local Childs\n* Hadoop DataNode, serves blocks\n* HQuorumPeer, a ZooKeeper ensemble member\n* Jps, well... it's the current process\n* ThriftServer, it's a special one will be running only if thrift was started\n* jmx, this is a local process that's part of our monitoring platform ( poorly named maybe). You probably don't have that.\n\nYou can then do stuff like checking out the full command line that started the process:\n\n```bash\nhadoop@sv4borg12:~$ ps aux | grep HRegionServer\nhadoop   17789  155 35.2 9067824 8604364 ?     S<l  Mar04 9855:48 /usr/java/jdk1.6.0_14/bin/java -Xmx8000m -XX:+DoEscapeAnalysis -XX:+AggressiveOpts -XX:+UseConcMarkSweepGC -XX:NewSize=64m -XX:MaxNewSize=64m -XX:CMSInitiatingOccupancyFraction=88 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/export1/hadoop/logs/gc-hbase.log -Dcom.sun.management.jmxremote.port=10102 -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.password.file=/home/hadoop/hbase/conf/jmxremote.password -Dcom.sun.management.jmxremote -Dhbase.log.dir=/export1/hadoop/logs -Dhbase.log.file=hbase-hadoop-regionserver-sv4borg12.log -Dhbase.home.dir=/home/hadoop/hbase -Dhbase.id.str=hadoop -Dhbase.root.logger=INFO,DRFA -Djava.library.path=/home/hadoop/hbase/lib/native/Linux-amd64-64 -classpath /home/hadoop/hbase/bin/../conf:[many jars]:/home/hadoop/hadoop/conf org.apache.hadoop.hbase.regionserver.HRegionServer start\n```\n\n#### jstack\n\n`jstack` is one of the most important tools when trying to figure out what a java process is doing apart from looking at the logs. It has to be used in conjunction with jps in order to give it a process id. It shows a list of threads, each one has a name, and they appear in the order that they were created (so the top ones are the most recent threads). Here are a few example:\n\nThe main thread of a RegionServer waiting for something to do from the master:\n\n```text\n\"regionserver60020\" prio=10 tid=0x0000000040ab4000 nid=0x45cf waiting on condition [0x00007f16b6a96000..0x00007f16b6a96a70]\njava.lang.Thread.State: TIMED_WAITING (parking)\n    at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00007f16cd5c2f30> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:1963)\n    at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:395)\n    at org.apache.hadoop.hbase.regionserver.HRegionServer.run(HRegionServer.java:647)\n    at java.lang.Thread.run(Thread.java:619)\n```\n\nThe MemStore flusher thread that is currently flushing to a file:\n\n```text\n\"regionserver60020.cacheFlusher\" daemon prio=10 tid=0x0000000040f4e000 nid=0x45eb in Object.wait() [0x00007f16b5b86000..0x00007f16b5b87af0]\njava.lang.Thread.State: WAITING (on object monitor)\n    at java.lang.Object.wait(Native Method)\n    at java.lang.Object.wait(Object.java:485)\n    at org.apache.hadoop.ipc.Client.call(Client.java:803)\n        - locked <0x00007f16cb14b3a8> (a org.apache.hadoop.ipc.Client$Call)\n    at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:221)\n    at $Proxy1.complete(Unknown Source)\n    at sun.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:82)\n    at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:59)\n    at $Proxy1.complete(Unknown Source)\n    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.closeInternal(DFSClient.java:3390)\n        - locked <0x00007f16cb14b470> (a org.apache.hadoop.hdfs.DFSClient$DFSOutputStream)\n    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.close(DFSClient.java:3304)\n    at org.apache.hadoop.fs.FSDataOutputStream$PositionCache.close(FSDataOutputStream.java:61)\n    at org.apache.hadoop.fs.FSDataOutputStream.close(FSDataOutputStream.java:86)\n    at org.apache.hadoop.hbase.io.hfile.HFile$Writer.close(HFile.java:650)\n    at org.apache.hadoop.hbase.regionserver.StoreFile$Writer.close(StoreFile.java:853)\n    at org.apache.hadoop.hbase.regionserver.Store.internalFlushCache(Store.java:467)\n        - locked <0x00007f16d00e6f08> (a java.lang.Object)\n    at org.apache.hadoop.hbase.regionserver.Store.flushCache(Store.java:427)\n    at org.apache.hadoop.hbase.regionserver.Store.access$100(Store.java:80)\n    at org.apache.hadoop.hbase.regionserver.Store$StoreFlusherImpl.flushCache(Store.java:1359)\n    at org.apache.hadoop.hbase.regionserver.HRegion.internalFlushcache(HRegion.java:907)\n    at org.apache.hadoop.hbase.regionserver.HRegion.internalFlushcache(HRegion.java:834)\n    at org.apache.hadoop.hbase.regionserver.HRegion.flushcache(HRegion.java:786)\n    at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.flushRegion(MemStoreFlusher.java:250)\n    at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.flushRegion(MemStoreFlusher.java:224)\n    at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.run(MemStoreFlusher.java:146)\n```\n\nA handler thread that's waiting for stuff to do (like put, delete, scan, etc.):\n\n```text\n\"IPC Server handler 16 on 60020\" daemon prio=10 tid=0x00007f16b011d800 nid=0x4a5e waiting on condition [0x00007f16afefd000..0x00007f16afefd9f0]\n   java.lang.Thread.State: WAITING (parking)\n          at sun.misc.Unsafe.park(Native Method)\n              - parking to wait for  <0x00007f16cd3f8dd8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n          at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158)\n          at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1925)\n          at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:358)\n          at org.apache.hadoop.hbase.ipc.HBaseServer$Handler.run(HBaseServer.java:1013)\n```\n\nAnd one that's busy doing an increment of a counter (it's in the phase where it's trying to create a scanner in order to read the last value):\n\n```text\n\"IPC Server handler 66 on 60020\" daemon prio=10 tid=0x00007f16b006e800 nid=0x4a90 runnable [0x00007f16acb77000..0x00007f16acb77cf0]\n   java.lang.Thread.State: RUNNABLE\n          at org.apache.hadoop.hbase.regionserver.KeyValueHeap.<init>(KeyValueHeap.java:56)\n          at org.apache.hadoop.hbase.regionserver.StoreScanner.<init>(StoreScanner.java:79)\n          at org.apache.hadoop.hbase.regionserver.Store.getScanner(Store.java:1202)\n          at org.apache.hadoop.hbase.regionserver.HRegion$RegionScanner.<init>(HRegion.java:2209)\n          at org.apache.hadoop.hbase.regionserver.HRegion.instantiateInternalScanner(HRegion.java:1063)\n          at org.apache.hadoop.hbase.regionserver.HRegion.getScanner(HRegion.java:1055)\n          at org.apache.hadoop.hbase.regionserver.HRegion.getScanner(HRegion.java:1039)\n          at org.apache.hadoop.hbase.regionserver.HRegion.getLastIncrement(HRegion.java:2875)\n          at org.apache.hadoop.hbase.regionserver.HRegion.incrementColumnValue(HRegion.java:2978)\n          at org.apache.hadoop.hbase.regionserver.HRegionServer.incrementColumnValue(HRegionServer.java:2433)\n          at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)\n          at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n          at java.lang.reflect.Method.invoke(Method.java:597)\n          at org.apache.hadoop.hbase.ipc.HBaseRPC$Server.call(HBaseRPC.java:560)\n          at org.apache.hadoop.hbase.ipc.HBaseServer$Handler.run(HBaseServer.java:1027)\n```\n\nA thread that receives data from HDFS:\n\n```text\n\"IPC Client (47) connection to sv4borg9/10.4.24.40:9000 from hadoop\" daemon prio=10 tid=0x00007f16a02d0000 nid=0x4fa3 runnable [0x00007f16b517d000..0x00007f16b517dbf0]\n   java.lang.Thread.State: RUNNABLE\n          at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)\n          at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:215)\n          at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:65)\n          at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:69)\n              - locked <0x00007f17d5b68c00> (a sun.nio.ch.Util$1)\n              - locked <0x00007f17d5b68be8> (a java.util.Collections$UnmodifiableSet)\n              - locked <0x00007f1877959b50> (a sun.nio.ch.EPollSelectorImpl)\n          at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:80)\n          at org.apache.hadoop.net.SocketIOWithTimeout$SelectorPool.select(SocketIOWithTimeout.java:332)\n          at org.apache.hadoop.net.SocketIOWithTimeout.doIO(SocketIOWithTimeout.java:157)\n          at org.apache.hadoop.net.SocketInputStream.read(SocketInputStream.java:155)\n          at org.apache.hadoop.net.SocketInputStream.read(SocketInputStream.java:128)\n          at java.io.FilterInputStream.read(FilterInputStream.java:116)\n          at org.apache.hadoop.ipc.Client$Connection$PingInputStream.read(Client.java:304)\n          at java.io.BufferedInputStream.fill(BufferedInputStream.java:218)\n          at java.io.BufferedInputStream.read(BufferedInputStream.java:237)\n              - locked <0x00007f1808539178> (a java.io.BufferedInputStream)\n          at java.io.DataInputStream.readInt(DataInputStream.java:370)\n          at org.apache.hadoop.ipc.Client$Connection.receiveResponse(Client.java:569)\n          at org.apache.hadoop.ipc.Client$Connection.run(Client.java:477)\n```\n\nAnd here is a master trying to recover a lease after a RegionServer died:\n\n```text\n\"LeaseChecker\" daemon prio=10 tid=0x00000000407ef800 nid=0x76cd waiting on condition [0x00007f6d0eae2000..0x00007f6d0eae2a70]\n--\n   java.lang.Thread.State: WAITING (on object monitor)\n          at java.lang.Object.wait(Native Method)\n          at java.lang.Object.wait(Object.java:485)\n          at org.apache.hadoop.ipc.Client.call(Client.java:726)\n          - locked <0x00007f6d1cd28f80> (a org.apache.hadoop.ipc.Client$Call)\n          at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:220)\n          at $Proxy1.recoverBlock(Unknown Source)\n          at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.processDatanodeError(DFSClient.java:2636)\n          at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.<init>(DFSClient.java:2832)\n          at org.apache.hadoop.hdfs.DFSClient.append(DFSClient.java:529)\n          at org.apache.hadoop.hdfs.DistributedFileSystem.append(DistributedFileSystem.java:186)\n          at org.apache.hadoop.fs.FileSystem.append(FileSystem.java:530)\n          at org.apache.hadoop.hbase.util.FSUtils.recoverFileLease(FSUtils.java:619)\n          at org.apache.hadoop.hbase.regionserver.wal.HLog.splitLog(HLog.java:1322)\n          at org.apache.hadoop.hbase.regionserver.wal.HLog.splitLog(HLog.java:1210)\n          at org.apache.hadoop.hbase.master.HMaster.splitLogAfterStartup(HMaster.java:648)\n          at org.apache.hadoop.hbase.master.HMaster.joinCluster(HMaster.java:572)\n          at org.apache.hadoop.hbase.master.HMaster.run(HMaster.java:503)\n```\n\n#### OpenTSDB\n\n[OpenTSDB](http://opentsdb.net) is an excellent alternative to Ganglia as it uses Apache HBase to store all the time series and doesn't have to downsample. Monitoring your own HBase cluster that hosts OpenTSDB is a good exercise.\n\nHere's an example of a cluster that's suffering from hundreds of compactions launched almost all around the same time, which severely affects the IO performance: (TODO: insert graph plotting compactionQueueSize)\n\nIt's a good practice to build dashboards with all the important graphs per machine and per cluster so that debugging issues can be done with a single quick look. For example, at StumbleUpon there's one dashboard per cluster with the most important metrics from both the OS and Apache HBase. You can then go down at the machine level and get even more detailed metrics.\n\n#### clusterssh+top\n\nclusterssh+top, it's like a poor man's monitoring system and it can be quite useful when you have only a few machines as it's very easy to setup. Starting clusterssh will give you one terminal per machine and another terminal in which whatever you type will be retyped in every window. This means that you can type `top` once and it will start it for all of your machines at the same time giving you full view of the current state of your cluster. You can also tail all the logs at the same time, edit files, etc.\n\n## Client\n\nFor more information on the HBase client, see [client](/docs/architecture/client).\n\n### ScannerTimeoutException or UnknownScannerException \\[!toc]\n\nThis is thrown if the time between RPC calls from the client to RegionServer exceeds the scan timeout. For example, if `Scan.setCaching` is set to 500, then there will be an RPC call to fetch the next batch of rows every 500 `.next()` calls on the ResultScanner because data is being transferred in blocks of 500 rows to the client. Reducing the setCaching value may be an option, but setting this value too low makes for inefficient processing on numbers of rows.\n\nSee [Scan Caching](/docs/performance#scan-caching).\n\n### Performance Differences in Thrift and Java APIs \\[!toc]\n\nPoor performance, or even `ScannerTimeoutExceptions`, can occur if `Scan.setCaching` is too high, as discussed in [ScannerTimeoutException or UnknownScannerException](/docs/troubleshooting#scannertimeoutexception-or-unknownscannerexception). If the Thrift client uses the wrong caching settings for a given workload, performance can suffer compared to the Java API. To set caching for a given scan in the Thrift client, use the `scannerGetList(scannerId, numRows)` method, where `numRows` is an integer representing the number of rows to cache. In one case, it was found that reducing the cache for Thrift scans from 1000 to 100 increased performance to near parity with the Java API given the same queries.\n\nSee also Jesse Andersen's [blog post](http://blog.cloudera.com/blog/2014/04/how-to-use-the-hbase-thrift-interface-part-3-using-scans/) about using Scans with Thrift.\n\n### `LeaseException` when calling `Scanner.next` \\[!toc]\n\nIn some situations clients that fetch data from a RegionServer get a LeaseException instead of the usual [ScannerTimeoutException or UnknownScannerException](/docs/troubleshooting#scannertimeoutexception-or-unknownscannerexception). Usually the source of the exception is `org.apache.hadoop.hbase.regionserver.Leases.removeLease(Leases.java:230)` (line number may vary). It tends to happen in the context of a slow/freezing `RegionServer#next` call. It can be prevented by having `hbase.rpc.timeout` > `hbase.client.scanner.timeout.period`. Harsh J investigated the issue as part of the mailing list thread [HBase, mail # user - Lease does not exist exceptions](https://mail-archives.apache.org/mod_mbox/hbase-user/201209.mbox/%3CCAOcnVr3R-LqtKhFsk8Bhrm-YW2i9O6J6Fhjz2h7q6_sxvwd2yw%40mail.gmail.com%3E)\n\n### Shell or client application throws lots of scary exceptions during normal operation \\[!toc]\n\nSince 0.20.0 the default log level for `org.apache.hadoop.hbase.*` is DEBUG.\n\nOn your clients, edit *\\$HBASE\\_HOME/conf/log4j.properties* and change this: `log4j.logger.org.apache.hadoop.hbase=DEBUG` to this: `log4j.logger.org.apache.hadoop.hbase=INFO`, or even `log4j.logger.org.apache.hadoop.hbase=WARN`.\n\n### Long Client Pauses With Compression \\[!toc]\n\nThis is a fairly frequent question on the Apache HBase dist-list. The scenario is that a client is typically inserting a lot of data into a relatively un-optimized HBase cluster. Compression can exacerbate the pauses, although it is not the source of the problem.\n\nSee [Table Creation: Pre-Creating Regions](/docs/performance#table-creation-pre-creating-regions) on the pattern for pre-creating regions and confirm that the table isn't starting with a single region.\n\nSee [HBase Configurations](/docs/performance#hbase-configurations) for cluster configuration, particularly `hbase.hstore.blockingStoreFiles`, `hbase.hregion.memstore.block.multiplier`, `MAX_FILESIZE` (region size), and `MEMSTORE_FLUSHSIZE.`\n\nA slightly longer explanation of why pauses can happen is as follows: Puts are sometimes blocked on the MemStores which are blocked by the flusher thread which is blocked because there are too many files to compact because the compactor is given too many small files to compact and has to compact the same data repeatedly. This situation can occur even with minor compactions. Compounding this situation, Apache HBase doesn't compress data in memory. Thus, the 64MB that lives in the MemStore could become a 6MB file after compression - which results in a smaller StoreFile. The upside is that more data is packed into the same region, but performance is achieved by being able to write larger files - which is why HBase waits until the flushsize before writing a new StoreFile. And smaller StoreFiles become targets for compaction. Without compression the files are much bigger and don't need as much compaction, however this is at the expense of I/O.\n\n### Secure Client Connect (\\[Caused by GSSException: No valid credentials provided...]) \\[!toc]\n\nYou may encounter the following error:\n\n```text\nSecure Client Connect ([Caused by GSSException: No valid credentials provided\n        (Mechanism level: Request is a replay (34) V PROCESS_TGS)])\n```\n\nThis issue is caused by bugs in the MIT Kerberos replay\\_cache component, [#1201](http://krbdev.mit.edu/rt/Ticket/Display.html?id=1201) and [#5924](http://krbdev.mit.edu/rt/Ticket/Display.html?id=5924). These bugs caused the old version of krb5-server to erroneously block subsequent requests sent from a Principal. This caused krb5-server to block the connections sent from one Client (one HTable instance with multi-threading connection instances for each RegionServer); Messages, such as `Request is a replay (34)`, are logged in the client log You can ignore the messages, because HTable will retry 5 \\* 10 (50) times for each failed connection by default. HTable will throw IOException if any connection to the RegionServer fails after the retries, so that the user client code for HTable instance can handle it further. NOTE: `HTable` is deprecated in HBase 1.0, in favor of `Table`.\n\nAlternatively, update krb5-server to a version which solves these issues, such as krb5-server-1.10.3. See JIRA [HBASE-10379](https://issues.apache.org/jira/browse/HBASE-10379) for more details.\n\n### ZooKeeper Client Connection Errors \\[!toc]\n\nErrors like this...\n\n```text\n11/07/05 11:26:41 WARN zookeeper.ClientCnxn: Session 0x0 for server null,\n unexpected error, closing socket connection and attempting reconnect\n java.net.ConnectException: Connection refused: no further information\n        at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)\n        at sun.nio.ch.SocketChannelImpl.finishConnect(Unknown Source)\n        at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1078)\n 11/07/05 11:26:43 INFO zookeeper.ClientCnxn: Opening socket connection to\n server localhost/127.0.0.1:2181\n 11/07/05 11:26:44 WARN zookeeper.ClientCnxn: Session 0x0 for server null,\n unexpected error, closing socket connection and attempting reconnect\n java.net.ConnectException: Connection refused: no further information\n        at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)\n        at sun.nio.ch.SocketChannelImpl.finishConnect(Unknown Source)\n        at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1078)\n 11/07/05 11:26:45 INFO zookeeper.ClientCnxn: Opening socket connection to\n server localhost/127.0.0.1:2181\n```\n\n...are either due to ZooKeeper being down, or unreachable due to network issues.\n\nThe utility [zkcli](/docs/troubleshooting#zkcli) may help investigate ZooKeeper issues.\n\n### Client running out of memory though heap size seems to be stable (but the off-heap/direct heap keeps growing) \\[!toc]\n\nYou are likely running into the issue that is described and worked through in the mail thread [HBase, mail # user - Suspected memory leak](https://lists.apache.org/thread.html/d12bbe56be95cf68478d1528263042730670ff39159a01eaf06d8bc8%401322622090%40%3Cuser.hbase.apache.org%3E) and continued over in [HBase, mail # dev - FeedbackRe: Suspected memory leak](https://lists.apache.org/thread.html/621dde35479215f0b07b23af93b8fac52ff4729949b5c9af18e3a85b%401322971078%40%3Cuser.hbase.apache.org%3E). A workaround is passing your client-side JVM a reasonable value for `-XX:MaxDirectMemorySize`. By default, the `MaxDirectMemorySize` is equal to your `-Xmx` max heapsize setting (if `-Xmx` is set). Try setting it to something smaller (for example, one user had success setting it to `1g` when they had a client-side heap of `12g`). If you set it too small, it will bring on `FullGCs` so keep it a bit hefty. You want to make this setting client-side only especially if you are running the new experimental server-side off-heap cache since this feature depends on being able to use big direct buffers (You may have to keep separate client-side and server-side config dirs).\n\n### Secure Client Cannot Connect (\\[Caused by GSSException: No valid credentials provided(Mechanism level: Failed to find any Kerberos tgt)]) \\[!toc]\n\nThere can be several causes that produce this symptom.\n\nFirst, check that you have a valid Kerberos ticket. One is required in order to set up communication with a secure Apache HBase cluster. Examine the ticket currently in the credential cache, if any, by running the `klist` command line utility. If no ticket is listed, you must obtain a ticket by running the `kinit` command with either a keytab specified, or by interactively entering a password for the desired principal.\n\nThen, consult the [Java Security Guide troubleshooting section](http://docs.oracle.com/javase/1.5.0/docs/guide/security/jgss/tutorials/Troubleshooting.html). The most common problem addressed there is resolved by setting `javax.security.auth.useSubjectCredsOnly` system property value to `false`.\n\nBecause of a change in the format in which MIT Kerberos writes its credentials cache, there is a bug in the Oracle JDK 6 Update 26 and earlier that causes Java to be unable to read the Kerberos credentials cache created by versions of MIT Kerberos 1.8.1 or higher. If you have this problematic combination of components in your environment, to work around this problem, first log in with `kinit` and then immediately refresh the credential cache with `kinit -R`. The refresh will rewrite the credential cache without the problematic formatting.\n\nPrior to JDK 1.4, the JCE was an unbundled product, and as such, the JCA and JCE were regularly referred to as separate, distinct components. As JCE is now bundled in the JDK 7.0, the distinction is becoming less apparent. Since the JCE uses the same architecture as the JCA, the JCE should be more properly thought of as a part of the JCA.\n\nYou may need to install the [Java Cryptography Extension](https://docs.oracle.com/javase/1.5.0/docs/guide/security/jce/JCERefGuide.html), or JCE because of JDK 1.5 or earlier version. Insure the JCE jars are on the classpath on both server and client systems.\n\nYou may also need to download the [unlimited strength JCE policy files](http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html). Uncompress and extract the downloaded file, and install the policy jars into *\\<java-home>/lib/security*.\n\n### Trouble shooting master registry issues \\[!toc]\n\n* For connectivity issues, usually an exception like \"MasterRegistryFetchException: Exception making rpc to masters...\" is logged in the client logs. The logging includes the list of master end points that were attempted by the client. The bottom part of the stack trace should include the underlying reason. If you suspect connectivity issues (ConnectionRefused?), make sure the master end points are accessible from client.\n* If there is a suspicion of higher load on the masters due to hedging of RPCs, it can be controlled by either reducing the hedging fan out (via *hbase.rpc.hedged.fanout*) or by restricting the set of masters that clients can access for the master registry purposes (via *hbase.masters*).\n\nRefer to [Master Registry (new as of 2.3.0)](/docs/architecture/client#masterregistry-rpc-hedging) and [Client configuration and dependencies connecting to an HBase cluster](/docs/configuration/default#client-configuration-and-dependencies-connecting-to-an-hbase-cluster) for more details.\n\n## MapReduce\n\n### You Think You're On The Cluster, But You're Actually Local \\[!toc]\n\nThis following stacktrace happened using `ImportTsv`, but things like this can happen on any job with a mis-configuration.\n\n```text\n    WARN mapred.LocalJobRunner: job_local_0001\njava.lang.IllegalArgumentException: Can't read partitions file\n       at org.apache.hadoop.hbase.mapreduce.hadoopbackport.TotalOrderPartitioner.setConf(TotalOrderPartitioner.java:111)\n       at org.apache.hadoop.util.ReflectionUtils.setConf(ReflectionUtils.java:62)\n       at org.apache.hadoop.util.ReflectionUtils.newInstance(ReflectionUtils.java:117)\n       at org.apache.hadoop.mapred.MapTask$NewOutputCollector.<init>(MapTask.java:560)\n       at org.apache.hadoop.mapred.MapTask.runNewMapper(MapTask.java:639)\n       at org.apache.hadoop.mapred.MapTask.run(MapTask.java:323)\n       at org.apache.hadoop.mapred.LocalJobRunner$Job.run(LocalJobRunner.java:210)\nCaused by: java.io.FileNotFoundException: File _partition.lst does not exist.\n       at org.apache.hadoop.fs.RawLocalFileSystem.getFileStatus(RawLocalFileSystem.java:383)\n       at org.apache.hadoop.fs.FilterFileSystem.getFileStatus(FilterFileSystem.java:251)\n       at org.apache.hadoop.fs.FileSystem.getLength(FileSystem.java:776)\n       at org.apache.hadoop.io.SequenceFile$Reader.<init>(SequenceFile.java:1424)\n       at org.apache.hadoop.io.SequenceFile$Reader.<init>(SequenceFile.java:1419)\n       at org.apache.hadoop.hbase.mapreduce.hadoopbackport.TotalOrderPartitioner.readPartitions(TotalOrderPartitioner.java:296)\n```\n\n...see the critical portion of the stack? It's...\n\n```text\nat org.apache.hadoop.mapred.LocalJobRunner$Job.run(LocalJobRunner.java:210)\n```\n\nLocalJobRunner means the job is running locally, not on the cluster.\n\nTo solve this problem, you should run your MR job with your `HADOOP_CLASSPATH` set to include the HBase dependencies. The \"hbase classpath\" utility can be used to do this easily. For example (substitute VERSION with your HBase version):\n\n```bash\nHADOOP_CLASSPATH=`hbase classpath` hadoop jar $HBASE_HOME/hbase-mapreduce-VERSION.jar rowcounter usertable\n```\n\nSee [HBase, MapReduce, and the CLASSPATH](/docs/mapreduce#hbase-mapreduce-and-the-classpath) for more information on HBase MapReduce jobs and classpaths.\n\n### Launching a job, you get java.lang.IllegalAccessError: com/google/protobuf/HBaseZeroCopyByteString or class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString \\[!toc]\n\nSee [HBASE-10304 Running an hbase job jar: IllegalAccessError: class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString](https://issues.apache.org/jira/browse/HBASE-10304) and [HBASE-11118 non environment variable solution for \"IllegalAccessError: class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString\"](https://issues.apache.org/jira/browse/HBASE-11118). The issue can also show up when trying to run spark jobs. See [HBASE-10877 HBase non-retriable exception list should be expanded](https://issues.apache.org/jira/browse/HBASE-10877).\n\n## NameNode\n\nFor more information on the NameNode, see [HDFS](/docs/architecture/hdfs).\n\n### HDFS Utilization of Tables and Regions\n\nTo determine how much space HBase is using on HDFS use the `hadoop` shell commands from the NameNode. For example...\n\n```bash\nhadoop fs -dus /hbase/\n```\n\n...returns the summarized disk utilization for all HBase objects.\n\n```bash\nhadoop fs -dus /hbase/myTable\n```\n\n...returns the summarized disk utilization for the HBase table 'myTable'.\n\n```bash\nhadoop fs -du /hbase/myTable\n```\n\n...returns a list of the regions under the HBase table 'myTable' and their disk utilization.\n\nFor more information on HDFS shell commands, see the [HDFS FileSystem Shell documentation](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/FileSystemShell.html).\n\n### Browsing HDFS for HBase Objects\n\nSometimes it will be necessary to explore the HBase objects that exist on HDFS. These objects could include the WALs (Write Ahead Logs), tables, regions, StoreFiles, etc. The easiest way to do this is with the NameNode web application that runs on port 50070. The NameNode web application will provide links to the all the DataNodes in the cluster so that they can be browsed seamlessly.\n\nThe HDFS directory structure of HBase tables in the cluster is...\n\n```text\n/hbase\n    /data\n        /<Namespace>                    (Namespaces in the cluster)\n            /<Table>                    (Tables in the cluster)\n                /<Region>               (Regions for the table)\n                    /<ColumnFamily>     (ColumnFamilies for the Region for the table)\n                        /<StoreFile>    (StoreFiles for the ColumnFamily for the Regions for the table)\n```\n\nThe HDFS directory structure of HBase WAL is..\n\n```text\n/hbase\n    /WALs\n        /<RegionServer>    (RegionServers)\n            /<WAL>         (WAL files for the RegionServer)\n```\n\nSee the [HDFS User Guide](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html) for other non-shell diagnostic utilities like `fsck`.\n\n#### Zero size WALs with data in them \\[!toc]\n\nProblem: when getting a listing of all the files in a RegionServer's *WALs* directory, one file has a size of 0 but it contains data.\n\nAnswer: It's an HDFS quirk. A file that's currently being written to will appear to have a size of 0 but once it's closed it will show its true size\n\n#### Use Cases \\[!toc]\n\nTwo common use-cases for querying HDFS for HBase objects is research the degree of uncompaction of a table. If there are a large number of StoreFiles for each ColumnFamily it could indicate the need for a major compaction. Additionally, after a major compaction if the resulting StoreFile is \"small\" it could indicate the need for a reduction of ColumnFamilies for the table.\n\n### Unexpected Filesystem Growth\n\nIf you see an unexpected spike in filesystem usage by HBase, two possible culprits are snapshots and WALs.\n\n**Snapshots**\\\nWhen you create a snapshot, HBase retains everything it needs to recreate the table's state at that time of the snapshot. This includes deleted cells or expired versions. For this reason, your snapshot usage pattern should be well-planned, and you should prune snapshots that you no longer need. Snapshots are stored in `/hbase/.hbase-snapshot`, and archives needed to restore snapshots are stored in `/hbase/archive/<tablename>/<region>/<column_family>/`.\n\n<Callout type=\"warn\">\n  **Do not** manage snapshots or archives manually via HDFS. HBase provides APIs and HBase Shell\n  commands for managing them. For more information, see\n  [ops.snapshots](/docs/operational-management/backup-and-snapshots#hbase-snapshots).\n</Callout>\n\n**WAL**\\\nWrite-ahead logs (WALs) are stored in subdirectories of the HBase root directory, typically `/hbase/`, depending on their status. Already-processed WALs are stored in `/hbase/oldWALs/` and corrupt WALs are stored in `/hbase/.corrupt/` for examination. If the size of one of these subdirectories is growing, examine the HBase server logs to find the root cause for why WALs are not being processed correctly.\\\nIf you use replication and `/hbase/oldWALs/` is using more space than you expect, remember that WALs are saved when replication is disabled, as long as there are peers.\n\n**Do not** manage WALs manually via HDFS.\n\n## Network\n\n### Network Spikes\n\nIf you are seeing periodic network spikes you might want to check the `compactionQueues` to see if major compactions are happening.\n\nSee [Managed Compactions](/docs/configuration/important#managed-compactions) for more information on managing compactions.\n\n### Loopback IP\n\nHBase expects the loopback IP Address to be 127.0.0.1.\n\n### Network Interfaces\n\nAre all the network interfaces functioning correctly? Are you sure? See the Troubleshooting Case Study in [Case Studies](/docs/troubleshooting#troubleshooting-case-studies).\n\n## RegionServer\n\nFor more information on the RegionServers, see [RegionServer](/docs/architecture/regionserver).\n\n### Startup Errors\n\n#### Master Starts, But RegionServers Do Not \\[!toc]\n\nThe Master believes the RegionServers have the IP of 127.0.0.1 - which is localhost and resolves to the master's own localhost.\n\nThe RegionServers are erroneously informing the Master that their IP addresses are 127.0.0.1.\n\nModify */etc/hosts* on the region servers, from...\n\n```text\n# Do not remove the following line, or various programs\n# that require network functionality will fail.\n127.0.0.1               fully.qualified.regionservername regionservername  localhost.localdomain localhost\n::1             localhost6.localdomain6 localhost6\n```\n\n... to (removing the master node's name from localhost)...\n\n```text\n# Do not remove the following line, or various programs\n# that require network functionality will fail.\n127.0.0.1               localhost.localdomain localhost\n::1             localhost6.localdomain6 localhost6\n```\n\n#### Compression Link Errors \\[!toc]\n\nSince compression algorithms such as LZO need to be installed and configured on each cluster this is a frequent source of startup error. If you see messages like this...\n\n```text\n11/02/20 01:32:15 ERROR lzo.GPLNativeCodeLoader: Could not load native gpl library\njava.lang.UnsatisfiedLinkError: no gplcompression in java.library.path\n        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1734)\n        at java.lang.Runtime.loadLibrary0(Runtime.java:823)\n        at java.lang.System.loadLibrary(System.java:1028)\n```\n\n... then there is a path issue with the compression libraries. See the Configuration section on [LZO compression configuration](/docs/compression#configure-hbase-for-compressors).\n\n#### RegionServer aborts due to lack of hsync for filesystem \\[!toc]\n\nIn order to provide data durability for writes to the cluster HBase relies on the ability to durably save state in a write ahead log. When using a version of Apache Hadoop Common's filesystem API that supports checking on the availability of needed calls, HBase will proactively abort the cluster if it finds it can't operate safely.\n\nFor RegionServer roles, the failure will show up in logs like this:\n\n```text\n2018-04-05 11:36:22,785 ERROR [regionserver/192.168.1.123:16020] wal.AsyncFSWALProvider: The RegionServer async write ahead log provider relies on the ability to call hflush and hsync for proper operation during component failures, but the current FileSystem does not support doing so. Please check the config value of 'hbase.wal.dir' and ensure it points to a FileSystem mount that has suitable capabilities for output streams.\n2018-04-05 11:36:22,799 ERROR [regionserver/192.168.1.123:16020] regionserver.HRegionServer: ***** ABORTING region server 192.168.1.123,16020,1522946074234: Unhandled: cannot get log writer *****\njava.io.IOException: cannot get log writer\n        at org.apache.hadoop.hbase.wal.AsyncFSWALProvider.createAsyncWriter(AsyncFSWALProvider.java:112)\n        at org.apache.hadoop.hbase.regionserver.wal.AsyncFSWAL.createWriterInstance(AsyncFSWAL.java:612)\n        at org.apache.hadoop.hbase.regionserver.wal.AsyncFSWAL.createWriterInstance(AsyncFSWAL.java:124)\n        at org.apache.hadoop.hbase.regionserver.wal.AbstractFSWAL.rollWriter(AbstractFSWAL.java:759)\n        at org.apache.hadoop.hbase.regionserver.wal.AbstractFSWAL.rollWriter(AbstractFSWAL.java:489)\n        at org.apache.hadoop.hbase.regionserver.wal.AsyncFSWAL.<init>(AsyncFSWAL.java:251)\n        at org.apache.hadoop.hbase.wal.AsyncFSWALProvider.createWAL(AsyncFSWALProvider.java:69)\n        at org.apache.hadoop.hbase.wal.AsyncFSWALProvider.createWAL(AsyncFSWALProvider.java:44)\n        at org.apache.hadoop.hbase.wal.AbstractFSWALProvider.getWAL(AbstractFSWALProvider.java:138)\n        at org.apache.hadoop.hbase.wal.AbstractFSWALProvider.getWAL(AbstractFSWALProvider.java:57)\n        at org.apache.hadoop.hbase.wal.WALFactory.getWAL(WALFactory.java:252)\n        at org.apache.hadoop.hbase.regionserver.HRegionServer.getWAL(HRegionServer.java:2105)\n        at org.apache.hadoop.hbase.regionserver.HRegionServer.buildServerLoad(HRegionServer.java:1326)\n        at org.apache.hadoop.hbase.regionserver.HRegionServer.tryRegionServerReport(HRegionServer.java:1191)\n        at org.apache.hadoop.hbase.regionserver.HRegionServer.run(HRegionServer.java:1007)\n        at java.lang.Thread.run(Thread.java:745)\nCaused by: org.apache.hadoop.hbase.util.CommonFSUtils$StreamLacksCapabilityException: hflush and hsync\n        at org.apache.hadoop.hbase.io.asyncfs.AsyncFSOutputHelper.createOutput(AsyncFSOutputHelper.java:69)\n        at org.apache.hadoop.hbase.regionserver.wal.AsyncProtobufLogWriter.initOutput(AsyncProtobufLogWriter.java:168)\n        at org.apache.hadoop.hbase.regionserver.wal.AbstractProtobufLogWriter.init(AbstractProtobufLogWriter.java:167)\n        at org.apache.hadoop.hbase.wal.AsyncFSWALProvider.createAsyncWriter(AsyncFSWALProvider.java:99)\n        ... 15 more\n```\n\nIf you are attempting to run in standalone mode and see this error, please walk back through the section [Quick Start - Standalone HBase](/docs/getting-started#quick-start---standalone-hbase) and ensure you have included **all** the given configuration settings.\n\n#### RegionServer aborts due to can not initialize access to HDFS \\[!toc]\n\nWe will try to use *AsyncFSWAL* for HBase-2.x as it has better performance while consuming less resources. But the problem for *AsyncFSWAL* is that it hacks into the internal of the DFSClient implementation, so it will easily be broken when upgrading hadoop, even for a simple patch release.\n\nIf you do not specify the wal provider, we will try to fall back to the old *FSHLog* if we fail to initialize *AsyncFSWAL*, but it may not always work. The failure will show up in logs like this:\n\n```text\n18/07/02 18:51:06 WARN concurrent.DefaultPromise: An exception was\nthrown by org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputHelper$13.operationComplete()\njava.lang.Error: Couldn't properly initialize access to HDFS\ninternals. Please update your WAL Provider to not make use of the\n'asyncfs' provider. See HBASE-16110 for more information.\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputSaslHelper.<clinit>(FanOutOneBlockAsyncDFSOutputSaslHelper.java:268)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputHelper.initialize(FanOutOneBlockAsyncDFSOutputHelper.java:661)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputHelper.access$300(FanOutOneBlockAsyncDFSOutputHelper.java:118)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputHelper$13.operationComplete(FanOutOneBlockAsyncDFSOutputHelper.java:720)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputHelper$13.operationComplete(FanOutOneBlockAsyncDFSOutputHelper.java:715)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:507)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:500)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:479)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:420)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\n     at org.apache.hbase.thirdparty.io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:82)\n     at org.apache.hbase.thirdparty.io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.fulfillConnectPromise(AbstractEpollChannel.java:638)\n     at org.apache.hbase.thirdparty.io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.finishConnect(AbstractEpollChannel.java:676)\n     at org.apache.hbase.thirdparty.io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.epollOutReady(AbstractEpollChannel.java:552)\n     at org.apache.hbase.thirdparty.io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:394)\n     at org.apache.hbase.thirdparty.io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:304)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)\n     at java.lang.Thread.run(Thread.java:748)\n Caused by: java.lang.NoSuchMethodException:\norg.apache.hadoop.hdfs.DFSClient.decryptEncryptedDataEncryptionKey(org.apache.hadoop.fs.FileEncryptionInfo)\n     at java.lang.Class.getDeclaredMethod(Class.java:2130)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputSaslHelper.createTransparentCryptoHelper(FanOutOneBlockAsyncDFSOutputSaslHelper.java:232)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputSaslHelper.<clinit>(FanOutOneBlockAsyncDFSOutputSaslHelper.java:262)\n     ... 18 more\n```\n\nIf you hit this error, please specify *FSHLog*, i.e, *filesystem*, explicitly in your config file.\n\n```xml\n<property>\n  <name>hbase.wal.provider</name>\n  <value>filesystem</value>\n</property>\n```\n\nAnd do not forget to send an email to the `user@hbase.apache.org` or `dev@hbase.apache.org` to report the failure and also your hadoop version, we will try to fix the problem ASAP in the next release.\n\n### Runtime Errors\n\n#### RegionServer Hanging \\[!toc]\n\nAre you running an old JVM (`< `1.6.0*u21?)? When you look at a thread dump, does it look like threads are BLOCKED but no one holds the lock all are blocked on? See [HBASE 3622 Deadlock in HBaseServer (JVM bug?)](https://issues.apache.org/jira/browse/HBASE-3622). Adding `-XX:+UseMembar` to the HBase `HBASE_OPTS` in \\_conf/hbase-env.sh* may fix it.\n\n#### java.io.IOException...(Too many open files) \\[!toc]\n\nIf you see log messages like this...\n\n```text\n2010-09-13 01:24:17,336 WARN org.apache.hadoop.hdfs.server.datanode.DataNode:\nDisk-related IOException in BlockReceiver constructor. Cause is java.io.IOException: Too many open files\n        at java.io.UnixFileSystem.createFileExclusively(Native Method)\n        at java.io.File.createNewFile(File.java:883)\n```\n\n... see the Getting Started section on [ulimit and nproc configuration](/docs/configuration/basic-prerequisites#example-ulimit-settings-on-ubuntu-toc).\n\n#### xceiverCount 258 exceeds the limit of concurrent xcievers 256 \\[!toc]\n\nThis typically shows up in the DataNode logs.\n\nTODO: add link.\nSee the Getting Started section on xceivers configuration.\n\n#### System instability, and the presence of \"java.lang.OutOfMemoryError: unable to createnew native thread in exceptions\" HDFS DataNode logs or that of any system daemon \\[!toc]\n\nSee the Getting Started section on ulimit and nproc configuration. The default on recent Linux distributions is 1024 - which is far too low for HBase.\n\n#### DFS instability and/or RegionServer lease timeouts \\[!toc]\n\nIf you see warning messages like this...\n\n```text\n2009-02-24 10:01:33,516 WARN org.apache.hadoop.hbase.util.Sleeper: We slept xxx ms, ten times longer than scheduled: 10000\n2009-02-24 10:01:33,516 WARN org.apache.hadoop.hbase.util.Sleeper: We slept xxx ms, ten times longer than scheduled: 15000\n2009-02-24 10:01:36,472 WARN org.apache.hadoop.hbase.regionserver.HRegionServer: unable to report to master for xxx milliseconds - retrying\n```\n\n... or see full GC compactions then you may be experiencing full GC's.\n\n#### \"No live nodes contain current block\" and/or YouAreDeadException \\[!toc]\n\nThese errors can happen either when running out of OS file handles or in periods of severe network problems where the nodes are unreachable.\n\nSee the Getting Started section on ulimit and nproc configuration and check your network.\n\n#### ZooKeeper SessionExpired events \\[!toc]\n\nMaster or RegionServers shutting down with messages like those in the logs:\n\n```text\nWARN org.apache.zookeeper.ClientCnxn: Exception\nclosing session 0x278bd16a96000f to sun.nio.ch.SelectionKeyImpl@355811ec\njava.io.IOException: TIMED OUT\n       at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:906)\nWARN org.apache.hadoop.hbase.util.Sleeper: We slept 79410ms, ten times longer than scheduled: 5000\nINFO org.apache.zookeeper.ClientCnxn: Attempting connection to server hostname/IP:PORT\nINFO org.apache.zookeeper.ClientCnxn: Priming connection to java.nio.channels.SocketChannel[connected local=/IP:PORT remote=hostname/IP:PORT]\nINFO org.apache.zookeeper.ClientCnxn: Server connection successful\nWARN org.apache.zookeeper.ClientCnxn: Exception closing session 0x278bd16a96000d to sun.nio.ch.SelectionKeyImpl@3544d65e\njava.io.IOException: Session Expired\n       at org.apache.zookeeper.ClientCnxn$SendThread.readConnectResult(ClientCnxn.java:589)\n       at org.apache.zookeeper.ClientCnxn$SendThread.doIO(ClientCnxn.java:709)\n       at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:945)\nERROR org.apache.hadoop.hbase.regionserver.HRegionServer: ZooKeeper session expired\n```\n\nThe JVM is doing a long running garbage collecting which is pausing every threads (aka \"stop the world\"). Since the RegionServer's local ZooKeeper client cannot send heartbeats, the session times out. By design, we shut down any node that isn't able to contact the ZooKeeper ensemble after getting a timeout so that it stops serving data that may already be assigned elsewhere.\n\n* Make sure you give plenty of RAM (in *hbase-env.sh*), the default of 1GB won't be able to sustain long running imports.\n* Make sure you don't swap, the JVM never behaves well under swapping.\n* Make sure you are not CPU starving the RegionServer thread. For example, if you are running a MapReduce job using 6 CPU-intensive tasks on a machine with 4 cores, you are probably starving the RegionServer enough to create longer garbage collection pauses.\n* Increase the ZooKeeper session timeout\n\nIf you wish to increase the session timeout, add the following to your *hbase-site.xml* to increase the timeout from the default of 60 seconds to 120 seconds.\n\n```xml\n<property>\n  <name>zookeeper.session.timeout</name>\n  <value>120000</value>\n</property>\n<property>\n  <name>hbase.zookeeper.property.tickTime</name>\n  <value>6000</value>\n</property>\n```\n\nBe aware that setting a higher timeout means that the regions served by a failed RegionServer will take at least that amount of time to be transferred to another RegionServer. For a production system serving live requests, we would instead recommend setting it lower than 1 minute and over-provision your cluster in order the lower the memory load on each machines (hence having less garbage to collect per machine).\n\nIf this is happening during an upload which only happens once (like initially loading all your data into HBase), consider bulk loading.\n\nSee [ZooKeeper, The Cluster Canary](/docs/troubleshooting#zookeeper-the-cluster-canary) for other general information about ZooKeeper troubleshooting.\n\n#### NotServingRegionException \\[!toc]\n\nThis exception is \"normal\" when found in the RegionServer logs at DEBUG level. This exception is returned back to the client and then the client goes back to `hbase:meta` to find the new location of the moved region.\n\nHowever, if the NotServingRegionException is logged ERROR, then the client ran out of retries and something probably wrong.\n\n#### Logs flooded with '2011-01-10 12:40:48,407 INFO org.apache.hadoop.io.compress.CodecPool: Gotbrand-new compressor' messages \\[!toc]\n\nWe are not using the native versions of compression libraries. See [HBASE-1900 Put back native support when hadoop 0.21 is released](https://issues.apache.org/jira/browse/HBASE-1900). Copy the native libs from hadoop under HBase lib dir or symlink them into place and the message should go away.\n\n#### Server handler X on 60020 caught: java.nio.channels.ClosedChannelException \\[!toc]\n\nIf you see this type of message it means that the region server was trying to read/send data from/to a client but it already went away. Typical causes for this are if the client was killed (you see a storm of messages like this when a MapReduce job is killed or fails) or if the client receives a SocketTimeoutException. It's harmless, but you should consider digging in a bit more if you aren't doing something to trigger them.\n\n### Snapshot Errors Due to Reverse DNS\n\nSeveral operations within HBase, including snapshots, rely on properly configured reverse DNS. Some environments, such as Amazon EC2, have trouble with reverse DNS. If you see errors like the following on your RegionServers, check your reverse DNS configuration:\n\n```text\n2013-05-01 00:04:56,356 DEBUG org.apache.hadoop.hbase.procedure.Subprocedure: Subprocedure 'backup1'\ncoordinator notified of 'acquire', waiting on 'reached' or 'abort' from coordinator.\n```\n\nIn general, the hostname reported by the RegionServer needs to be the same as the hostname the Master is trying to reach. You can see a hostname mismatch by looking for the following type of message in the RegionServer's logs at start-up.\n\n```text\n2013-05-01 00:03:00,614 INFO org.apache.hadoop.hbase.regionserver.HRegionServer: Master passed us hostname\nto use. Was=myhost-1234, Now=ip-10-55-88-99.ec2.internal\n```\n\n### Shutdown Errors\n\n## Master\n\nFor more information on the Master, see [master](/docs/architecture/master).\n\n### Startup Errors\n\n#### Master says that you need to run the HBase migrations script \\[!toc]\n\nUpon running that, the HBase migrations script says no files in root directory.\n\nHBase expects the root directory to either not exist, or to have already been initialized by HBase running a previous time. If you create a new directory for HBase using Hadoop DFS, this error will occur. Make sure the HBase root directory does not currently exist or has been initialized by a previous run of HBase. Sure fire solution is to just use Hadoop dfs to delete the HBase root and let HBase create and initialize the directory itself.\n\n#### Packet len6080218 is out of range! \\[!toc]\n\nIf you have many regions on your cluster and you see an error like that reported above in this sections title in your logs, see [HBASE-4246 Cluster with too many regions cannot withstand some master failover scenarios](https://issues.apache.org/jira/browse/HBASE-4246).\n\n#### Master fails to become active due to lack of hsync for filesystem \\[!toc]\n\nHBase's internal framework for cluster operations requires the ability to durably save state in a write ahead log. When using a version of Apache Hadoop Common's filesystem API that supports checking on the availability of needed calls, HBase will proactively abort the cluster if it finds it can't operate safely.\n\nFor Master roles, the failure will show up in logs like this:\n\n```text\n2018-04-05 11:18:44,653 ERROR [Thread-21] master.HMaster: Failed to become active master\njava.lang.IllegalStateException: The procedure WAL relies on the ability to hsync for proper operation during component failures, but the underlying filesystem does not support doing so. Please check the config value of 'hbase.procedure.store.wal.use.hsync' to set the desired level of robustness and ensure the config value of 'hbase.wal.dir' points to a FileSystem mount that can provide it.\n        at org.apache.hadoop.hbase.procedure2.store.wal.WALProcedureStore.rollWriter(WALProcedureStore.java:1034)\n        at org.apache.hadoop.hbase.procedure2.store.wal.WALProcedureStore.recoverLease(WALProcedureStore.java:374)\n        at org.apache.hadoop.hbase.procedure2.ProcedureExecutor.start(ProcedureExecutor.java:530)\n        at org.apache.hadoop.hbase.master.HMaster.startProcedureExecutor(HMaster.java:1267)\n        at org.apache.hadoop.hbase.master.HMaster.startServiceThreads(HMaster.java:1173)\n        at org.apache.hadoop.hbase.master.HMaster.finishActiveMasterInitialization(HMaster.java:881)\n        at org.apache.hadoop.hbase.master.HMaster.startActiveMasterManager(HMaster.java:2048)\n        at org.apache.hadoop.hbase.master.HMaster.lambda$run$0(HMaster.java:568)\n        at java.lang.Thread.run(Thread.java:745)\n```\n\nIf you are attempting to run in standalone mode and see this error, please walk back through the section [Quick Start - Standalone HBase](/docs/getting-started#quick-start---standalone-hbase) and ensure you have included **all** the given configuration settings.\n\n### Shutdown Errors\n\n## ZooKeeper\n\n### Startup Errors\n\n#### Could not find my address: xyz in list of ZooKeeper quorum servers \\[!toc]\n\nA ZooKeeper server wasn't able to start, throws that error. xyz is the name of your server.\n\nThis is a name lookup problem. HBase tries to start a ZooKeeper server on some machine but that machine isn't able to find itself in the `hbase.zookeeper.quorum` configuration.\n\nUse the hostname presented in the error message instead of the value you used. If you have a DNS server, you can set `hbase.zookeeper.dns.interface` and `hbase.zookeeper.dns.nameserver` in *hbase-site.xml* to make sure it resolves to the correct FQDN.\n\n### ZooKeeper, The Cluster Canary\n\nZooKeeper is the cluster's \"canary in the mineshaft\". It'll be the first to notice issues if any so making sure its happy is the short-cut to a humming cluster.\n\nSee the [ZooKeeper Operating Environment Troubleshooting](https://cwiki.apache.org/confluence/display/HADOOP2/ZooKeeper+Troubleshooting) page. It has suggestions and tools for checking disk and networking performance; i.e. the operating environment your ZooKeeper and HBase are running in.\n\nAdditionally, the utility [zkcli](/docs/troubleshooting#zkcli) may help investigate ZooKeeper issues.\n\n## Amazon EC2\n\n### ZooKeeper does not seem to work on Amazon EC2\n\nHBase does not start when deployed as Amazon EC2 instances. Exceptions like the below appear in the Master and/or RegionServer logs:\n\n```text\n  2009-10-19 11:52:27,030 INFO org.apache.zookeeper.ClientCnxn: Attempting\n  connection to server ec2-174-129-15-236.compute-1.amazonaws.com/10.244.9.171:2181\n  2009-10-19 11:52:27,032 WARN org.apache.zookeeper.ClientCnxn: Exception\n  closing session 0x0 to sun.nio.ch.SelectionKeyImpl@656dc861\n  java.net.ConnectException: Connection refused\n```\n\nSecurity group policy is blocking the ZooKeeper port on a public address. Use the internal EC2 host names when configuring the ZooKeeper quorum peer list.\n\n### Instability on Amazon EC2\n\nQuestions on HBase and Amazon EC2 come up frequently on the HBase dist-list.\n\n### Remote Java Connection into EC2 Cluster Not Working\n\nSee Andrew's answer here, up on the user list: [Remote Java client connection into EC2 instance](https://lists.apache.org/thread.html/666bfa863bc2eb2ec7bbe5ecfbee345e0cbf1d58aaa6c1636dfcb527%401269010842%40%3Cuser.hbase.apache.org%3E).\n\n## HBase and Hadoop version issues\n\n### ...cannot communicate with client version...\n\nIf you see something like the following in your logs ... 2012-09-24 10:20:52,168 FATAL org.apache.hadoop.hbase.master.HMaster: Unhandled exception. Starting shutdown. org.apache.hadoop.ipc.RemoteException: Server IPC version 7 cannot communicate with client version 4 ... ...are you trying to talk to an Hadoop 2.0.x from an HBase that has an Hadoop 1.0.x client? Use the HBase built against Hadoop 2.0 or rebuild your HBase passing the -Dhadoop.profile=2.0 attribute to Maven (See [Building against various Hadoop versions](/docs/building-and-developing/building#building-against-various-hadoop-versions) for more).\n\n## HBase and HDFS\n\nGeneral configuration guidance for Apache HDFS is out of the scope of this guide. Refer to the documentation available at [https://hadoop.apache.org/](https://hadoop.apache.org/) for extensive information about configuring HDFS. This section deals with HDFS in terms of HBase.\n\nIn most cases, HBase stores its data in Apache HDFS. This includes the HFiles containing the data, as well as the write-ahead logs (WALs) which store data before it is written to the HFiles and protect against RegionServer crashes. HDFS provides reliability and protection to data in HBase because it is distributed. To operate with the most efficiency, HBase needs data to be available locally. Therefore, it is a good practice to run an HDFS DataNode on each RegionServer.\n\n### Important Information and Guidelines for HBase and HDFS\n\n**HBase is a client of HDFS.**\\\nHBase is an HDFS client, using the HDFS `DFSClient` class, and references to this class appear in HBase logs with other HDFS client log messages.\n\n**Configuration is necessary in multiple places.**\\\nSome HDFS configurations relating to HBase need to be done at the HDFS (server) side. Others must be done within HBase (at the client side). Other settings need to be set at both the server and client side.\n\n**Write errors which affect HBase may be logged in the HDFS logs rather than HBase logs.**\\\nWhen writing, HDFS pipelines communications from one DataNode to another. HBase communicates to both the HDFS NameNode and DataNode, using the HDFS client classes. Communication problems between DataNodes are logged in the HDFS logs, not the HBase logs.\n\n**HBase communicates with HDFS using two different ports.**\\\nHBase communicates with DataNodes using the `ipc.Client` interface and the `DataNode` class. References to these will appear in HBase logs. Each of these communication channels use a different port (50010 and 50020 by default). The ports are configured in the HDFS configuration, via the `dfs.datanode.address` and `dfs.datanode.ipc.address` parameters.\n\n**Errors may be logged in HBase, HDFS, or both.**\\\nWhen troubleshooting HDFS issues in HBase, check logs in both places for errors.\n\n**HDFS takes a while to mark a node as dead. You can configure HDFS to avoid using stale DataNodes.**\\\nBy default, HDFS does not mark a node as dead until it is unreachable for 630 seconds. In Hadoop 1.1 and Hadoop 2.x, this can be alleviated by enabling checks for stale DataNodes, though this check is disabled by default. You can enable the check for reads and writes separately, via `dfs.namenode.avoid.read.stale.datanode` and `dfs.namenode.avoid.write.stale.datanode settings`. A stale DataNode is one that has not been reachable for `dfs.namenode.stale.datanode.interval` (default is 30 seconds). Stale datanodes are avoided, and marked as the last possible target for a read or write operation. For configuration details, see the HDFS documentation.\n\n**Settings for HDFS retries and timeouts are important to HBase.**\\\nYou can configure settings for various retries and timeouts. Always refer to the HDFS documentation for current recommendations and defaults. Some of the settings important to HBase are listed here. Defaults are current as of Hadoop 2.3. Check the Hadoop documentation for the most current values and recommendations.\n\n**The HBase Balancer and HDFS Balancer are incompatible**\\\nThe HDFS balancer attempts to spread HDFS blocks evenly among DataNodes. HBase relies on compactions to restore locality after a region split or failure. These two types of balancing do not work well together.\n\nIn the past, the generally accepted advice was to turn off the HDFS load balancer and rely on the HBase balancer, since the HDFS balancer would degrade locality. This advice is still valid if your HDFS version is lower than 2.7.1.\n\n[HDFS-6133](https://issues.apache.org/jira/browse/HDFS-6133) provides the ability to exclude favored-nodes (pinned) blocks from the HDFS load balancer, by setting the `dfs.datanode.block-pinning.enabled` property to `true` in the HDFS service configuration.\n\nHBase can be enabled to use the HDFS favored-nodes feature by switching the HBase balancer class (conf: `hbase.master.loadbalancer.class`) to `org.apache.hadoop.hbase.favored.FavoredNodeLoadBalancer` which is documented [here](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/favored/FavoredNodeLoadBalancer.html).\n\n<Callout type=\"info\">\n  HDFS-6133 is available in HDFS 2.7.0 and higher, but HBase does not support running on HDFS 2.7.0,\n  so you must be using HDFS 2.7.1 or higher to use this feature with HBase.\n</Callout>\n\n### Connection Timeouts\n\nConnection timeouts occur between the client (HBASE) and the HDFS DataNode. They may occur when establishing a connection, attempting to read, or attempting to write. The two settings below are used in combination, and affect connections between the DFSClient and the DataNode, the ipc.cClient and the DataNode, and communication between two DataNodes.\n\n`dfs.client.socket-timeout` (default: 60000)\\\nThe amount of time before a client connection times out when establishing a connection or reading. The value is expressed in milliseconds, so the default is 60 seconds.\n\n`dfs.datanode.socket.write.timeout` (default: 480000)\\\nThe amount of time before a write operation times out. The default is 8 minutes, expressed as milliseconds.\n\n### Typical Error Logs\n\nThe following types of errors are often seen in the logs.\n\n`INFO HDFS.DFSClient: Failed to connect to /xxx50010, add to deadNodes and continue java.net.SocketTimeoutException: 60000 millis timeout while waiting for channel to be ready for connect. ch : java.nio.channels.SocketChannel[connection-pending remote=/region-server-1:50010]`:: All DataNodes for a block are dead, and recovery is not possible. Here is the sequence of events that leads to this error:\n\n`INFO org.apache.hadoop.HDFS.DFSClient: Exception in createBlockOutputStream java.net.SocketTimeoutException: 69000 millis timeout while waiting for channel to be ready for connect. ch : java.nio.channels.SocketChannel[connection-pending remote=/ xxx:50010]`:: This type of error indicates a write issue. In this case, the master wants to split the log. It does not have a local DataNodes so it tries to connect to a remote DataNode, but the DataNode is dead.\n\n## Running unit or integration tests\n\n### Runtime exceptions from MiniDFSCluster when running tests\n\nIf you see something like the following\n\n```text\n...\njava.lang.NullPointerException: null\nat org.apache.hadoop.hdfs.MiniDFSCluster.startDataNodes\nat org.apache.hadoop.hdfs.MiniDFSCluster.<init>\nat org.apache.hadoop.hbase.MiniHBaseCluster.<init>\nat org.apache.hadoop.hbase.HBaseTestingUtility.startMiniDFSCluster\nat org.apache.hadoop.hbase.HBaseTestingUtility.startMiniCluster\n...\n```\n\nor\n\n```text\n...\njava.io.IOException: Shutting down\nat org.apache.hadoop.hbase.MiniHBaseCluster.init\nat org.apache.hadoop.hbase.MiniHBaseCluster.<init>\nat org.apache.hadoop.hbase.MiniHBaseCluster.<init>\nat org.apache.hadoop.hbase.HBaseTestingUtility.startMiniHBaseCluster\nat org.apache.hadoop.hbase.HBaseTestingUtility.startMiniCluster\n...\n```\n\n... then try issuing the command umask 022 before launching tests. This is a workaround for [HDFS-2556](https://issues.apache.org/jira/browse/HDFS-2556)\n\n## Case Studies\n\nFor Performance and Troubleshooting Case Studies, see [Apache HBase Case Studies](/docs/case-studies).\n\n## Cryptographic Features\n\n### sun.security.pkcs11.wrapper.PKCS11Exception: CKR\\_ARGUMENTS\\_BAD \\[!toc]\n\nThis problem manifests as exceptions ultimately caused by:\n\n```text\nCaused by: sun.security.pkcs11.wrapper.PKCS11Exception: CKR_ARGUMENTS_BAD\n  at sun.security.pkcs11.wrapper.PKCS11.C_DecryptUpdate(Native Method)\n  at sun.security.pkcs11.P11Cipher.implDoFinal(P11Cipher.java:795)\n```\n\nThis problem appears to affect some versions of OpenJDK 7 shipped by some Linux vendors. NSS is configured as the default provider. If the host has an x86\\_64 architecture, depending on if the vendor packages contain the defect, the NSS provider will not function correctly.\n\nTo work around this problem, find the JRE home directory and edit the file *lib/security/java.security*. Edit the file to comment out the line:\n\n```text\nsecurity.provider.1=sun.security.pkcs11.SunPKCS11 ${java.home}/lib/security/nss.cfg\n```\n\nThen renumber the remaining providers accordingly.\n\n## Operating System Specific Issues\n\n### Page Allocation Failure \\[!toc]\n\n<Callout type=\"info\">\n  This issue is known to affect CentOS 6.2 and possibly CentOS 6.5. It may also affect some versions\n  of Red Hat Enterprise Linux, according to\n  [https://bugzilla.redhat.com/show\\_bug.cgi?id=770545](https://bugzilla.redhat.com/show_bug.cgi?id=770545).\n</Callout>\n\nSome users have reported seeing the following error:\n\n```text\nkernel: java: page allocation failure. order:4, mode:0x20\n```\n\nRaising the value of `min_free_kbytes` was reported to fix this problem. This parameter is set to a percentage of the amount of RAM on your system, and is described in more detail at [https://docs.kernel.org/admin-guide/sysctl/vm.html#min-free-kbytes](https://docs.kernel.org/admin-guide/sysctl/vm.html#min-free-kbytes).\n\nTo find the current value on your system, run the following command:\n\n```bash\n[user@host]# cat /proc/sys/vm/min_free_kbytes\n```\n\nNext, raise the value. Try doubling, then quadrupling the value. Note that setting the value too low or too high could have detrimental effects on your system. Consult your operating system vendor for specific recommendations.\n\nUse the following command to modify the value of `min_free_kbytes`, substituting *VALUE* with your intended value:\n\n```bash\n[user@host]# echo <value> > /proc/sys/vm/min_free_kbytes\n```\n\n## JDK Issues\n\n### NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet \\[!toc]\n\nIf you see this in your logs:\n\n```text\nCaused by: java.lang.NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;\n  at org.apache.hadoop.hbase.master.ServerManager.findServerWithSameHostnamePortWithLock(ServerManager.java:393)\n  at org.apache.hadoop.hbase.master.ServerManager.checkAndRecordNewServer(ServerManager.java:307)\n  at org.apache.hadoop.hbase.master.ServerManager.regionServerStartup(ServerManager.java:244)\n  at org.apache.hadoop.hbase.master.MasterRpcServices.regionServerStartup(MasterRpcServices.java:304)\n  at org.apache.hadoop.hbase.protobuf.generated.RegionServerStatusProtos$RegionServerStatusService$2.callBlockingMethod(RegionServerStatusProtos.java:7910)\n  at org.apache.hadoop.hbase.ipc.RpcServer.call(RpcServer.java:2020)\n  ... 4 more\n```\n\nthen check if you compiled with jdk8 and tried to run it on jdk7. If so, this won't work. Run on jdk8 or recompile with jdk7. See [HBASE-10607 JDK8 NoSuchMethodError involving ConcurrentHashMap.keySet if running on JRE 7](https://issues.apache.org/jira/browse/HBASE-10607).\n\n### Full gc caused by mslab when using G1 \\[!toc]\n\nThe default size of chunk used by mslab is 2MB, when using G1, if heapRegionSize equals 4MB, these chunks are allocated as humongous objects, exclusively allocating one region, then the remaining 2MB become memory fragment.\n\nLots of memory fragment may lead to full gc even if the percent of used heap not high enough.\n\nThe G1HeapRegionSize calculated by initial\\_heap\\_size and max\\_heap\\_size, here are some cases for better understand:\n\n* xmx=10G -> region size 2M\n* xms=10G, xmx=10G -> region size 4M\n* xmx=20G -> region size 4M\n* xms=20G, xmx=20G -> region size 8M\n* xmx=30G -> region size 4M\n* xmx=32G -> region size 8M\n\nYou can avoid this problem by reducing the chunk size a bit to 2047KB as below.\n\n```properties\nhbase.hregion.memstore.mslab.chunksize 2096128\n```\n\n\n# Unit Testing HBase Applications (/docs/unit-testing)\nMuch of the information comes from [a community blog post about testing HBase applications](http://blog.cloudera.com/blog/2013/09/how-to-test-hbase-applications-using-popular-tools/).\nFor information on unit tests for HBase itself, see [hbase.tests](/docs/building-and-developing/tests).\n\nStarting from HBase 2.5.0, HBaseTestingUtility is deprecated and should only be used when writing UTs inside HBase.\nEnd users should use org.apache.hadoop.hbase.testing.TestingHBaseCluster instead.\n\n## JUnit\n\nHBase uses [JUnit](http://junit.org) for unit tests\n\nThis example will add unit tests to the following example class:\n\n```java\npublic class MyHBaseDAO {\n\n    public static void insertRecord(Table.getTable(table), HBaseTestObj obj)\n    throws Exception {\n        Put put = createPut(obj);\n        table.put(put);\n    }\n\n    private static Put createPut(HBaseTestObj obj) {\n        Put put = new Put(Bytes.toBytes(obj.getRowKey()));\n        put.add(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-1\"),\n                    Bytes.toBytes(obj.getData1()));\n        put.add(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-2\"),\n                    Bytes.toBytes(obj.getData2()));\n        return put;\n    }\n}\n```\n\nThe first step is to add JUnit dependencies to your Maven POM file:\n\n```xml\n<dependency>\n  <groupId>junit</groupId>\n  <artifactId>junit</artifactId>\n  <version>4.11</version>\n  <scope>test</scope>\n</dependency>\n```\n\nNext, add some unit tests to your code.\nTests are annotated with `@Test`.\nHere, the unit tests are in bold.\n\n```java\npublic class TestMyHbaseDAOData {\n  @Test\n  public void testCreatePut() throws Exception {\n  HBaseTestObj obj = new HBaseTestObj();\n  obj.setRowKey(\"ROWKEY-1\");\n  obj.setData1(\"DATA-1\");\n  obj.setData2(\"DATA-2\");\n  Put put = MyHBaseDAO.createPut(obj);\n  assertEquals(obj.getRowKey(), Bytes.toString(put.getRow()));\n  assertEquals(obj.getData1(), Bytes.toString(put.get(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-1\")).get(0).getValue()));\n  assertEquals(obj.getData2(), Bytes.toString(put.get(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-2\")).get(0).getValue()));\n  }\n}\n```\n\nThese tests ensure that your `createPut` method creates, populates, and returns a `Put` object with expected values.\nOf course, JUnit can do much more than this.\nFor an introduction to JUnit, see [https://github.com/junit-team/junit/wiki/Getting-started](https://github.com/junit-team/junit/wiki/Getting-started).\n\n## Mockito\n\nMockito is a mocking framework.\nIt goes further than JUnit by allowing you to test the interactions between objects without having to replicate the entire environment.\nYou can read more about Mockito at its project site, [https://code.google.com/p/mockito/](https://code.google.com/p/mockito/).\n\nYou can use Mockito to do unit testing on smaller units.\nFor instance, you can mock a `org.apache.hadoop.hbase.Server` instance or a `org.apache.hadoop.hbase.master.MasterServices` interface reference rather than a full-blown `org.apache.hadoop.hbase.master.HMaster`.\n\nThis example builds upon the example code in [unit.tests](/docs/unit-testing), to test the `insertRecord` method.\n\nFirst, add a dependency for Mockito to your Maven POM file.\n\n```xml\n<dependency>\n    <groupId>org.mockito</groupId>\n    <artifactId>mockito-core</artifactId>\n    <version>2.1.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\nNext, add a `@RunWith` annotation to your test class, to direct it to use Mockito.\n\n```java\n@RunWith(MockitoJUnitRunner.class)\npublic class TestMyHBaseDAO{\n  @Mock\n  Configuration config = HBaseConfiguration.create();\n  @Mock\n  Connection connection = ConnectionFactory.createConnection(config);\n  @Mock\n  private Table table;\n  @Captor\n  private ArgumentCaptor putCaptor;\n\n  @Test\n  public void testInsertRecord() throws Exception {\n    //return mock table when getTable is called\n    when(connection.getTable(TableName.valueOf(\"tablename\")).thenReturn(table);\n    //create test object and make a call to the DAO that needs testing\n    HBaseTestObj obj = new HBaseTestObj();\n    obj.setRowKey(\"ROWKEY-1\");\n    obj.setData1(\"DATA-1\");\n    obj.setData2(\"DATA-2\");\n    MyHBaseDAO.insertRecord(table, obj);\n    verify(table).put(putCaptor.capture());\n    Put put = putCaptor.getValue();\n\n    assertEquals(Bytes.toString(put.getRow()), obj.getRowKey());\n    assert(put.has(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-1\")));\n    assert(put.has(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-2\")));\n    assertEquals(Bytes.toString(put.get(Bytes.toBytes(\"CF\"),Bytes.toBytes(\"CQ-1\")).get(0).getValue()), \"DATA-1\");\n    assertEquals(Bytes.toString(put.get(Bytes.toBytes(\"CF\"),Bytes.toBytes(\"CQ-2\")).get(0).getValue()), \"DATA-2\");\n  }\n}\n```\n\nThis code populates `HBaseTestObj` with \"ROWKEY-1\", \"DATA-1\", \"DATA-2\" as values.\nIt then inserts the record into the mocked table.\nThe Put that the DAO would have inserted is captured, and values are tested to verify that they are what you expected them to be.\n\nThe key here is to manage Connection and Table instance creation outside the DAO.\nThis allows you to mock them cleanly and test Puts as shown above.\nSimilarly, you can now expand into other operations such as Get, Scan, or Delete.\n\n## MRUnit\n\n[Apache MRUnit](https://mrunit.apache.org/) is a library that allows you to unit-test MapReduce jobs.\nYou can use it to test HBase jobs in the same way as other MapReduce jobs.\n\nGiven a MapReduce job that writes to an HBase table called `MyTest`, which has one column family called `CF`, the reducer of such a job could look like the following:\n\n```java\npublic class MyReducer extends TableReducer<Text, Text, ImmutableBytesWritable> {\n   public static final byte[] CF = \"CF\".getBytes();\n   public static final byte[] QUALIFIER = \"CQ-1\".getBytes();\n   public void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n     //bunch of processing to extract data to be inserted, in our case, let's say we are simply\n     //appending all the records we receive from the mapper for this particular\n     //key and insert one record into HBase\n     StringBuffer data = new StringBuffer();\n     Put put = new Put(Bytes.toBytes(key.toString()));\n     for (Text val : values) {\n         data = data.append(val);\n     }\n     put.add(CF, QUALIFIER, Bytes.toBytes(data.toString()));\n     //write to HBase\n     context.write(new ImmutableBytesWritable(Bytes.toBytes(key.toString())), put);\n   }\n }\n```\n\nTo test this code, the first step is to add a dependency to MRUnit to your Maven POM file.\n\n```xml\n<dependency>\n   <groupId>org.apache.mrunit</groupId>\n   <artifactId>mrunit</artifactId>\n   <version>1.0.0 </version>\n   <scope>test</scope>\n</dependency>\n```\n\nNext, use the ReducerDriver provided by MRUnit, in your Reducer job.\n\n```java\npublic class MyReducerTest {\n    ReduceDriver<Text, Text, ImmutableBytesWritable, Writable> reduceDriver;\n    byte[] CF = \"CF\".getBytes();\n    byte[] QUALIFIER = \"CQ-1\".getBytes();\n\n    @Before\n    public void setUp() {\n      MyReducer reducer = new MyReducer();\n      reduceDriver = ReduceDriver.newReduceDriver(reducer);\n    }\n\n   @Test\n   public void testHBaseInsert() throws IOException {\n      String strKey = \"RowKey-1\", strValue = \"DATA\", strValue1 = \"DATA1\",\nstrValue2 = \"DATA2\";\n      List<Text> list = new ArrayList<Text>();\n      list.add(new Text(strValue));\n      list.add(new Text(strValue1));\n      list.add(new Text(strValue2));\n      //since in our case all that the reducer is doing is appending the records that the mapper\n      //sends it, we should get the following back\n      String expectedOutput = strValue + strValue1 + strValue2;\n     //Setup Input, mimic what mapper would have passed\n      //to the reducer and run test\n      reduceDriver.withInput(new Text(strKey), list);\n      //run the reducer and get its output\n      List<Pair<ImmutableBytesWritable, Writable>> result = reduceDriver.run();\n\n      //extract key from result and verify\n      assertEquals(Bytes.toString(result.get(0).getFirst().get()), strKey);\n\n      //extract value for CF/QUALIFIER and verify\n      Put a = (Put)result.get(0).getSecond();\n      String c = Bytes.toString(a.get(CF, QUALIFIER).get(0).getValue());\n      assertEquals(expectedOutput,c );\n   }\n}\n```\n\nYour MRUnit test verifies that the output is as expected, the Put that is inserted into HBase has the correct value, and the ColumnFamily and ColumnQualifier have the correct values.\n\nMRUnit includes a MapperDriver to test mapping jobs, and you can use MRUnit to test other operations, including reading from HBase, processing data, or writing to HDFS,\n\n## Integration Testing with an HBase Mini-Cluster\n\nHBase ships with HBaseTestingUtility, which makes it easy to write integration tests using a *mini-cluster*.\nThe first step is to add some dependencies to your Maven POM file.\nCheck the versions to be sure they are appropriate.\n\n```xml\n<properties>\n  <hbase.version>2.0.0-SNAPSHOT</hbase.version>\n</properties>\n\n<dependencies>\n  <dependency>\n    <groupId>org.apache.hbase</groupId>\n    <artifactId>hbase-testing-util</artifactId>\n    <version>${hbase.version}</version>\n    <scope>test</scope>\n  </dependency>\n</dependencies>\n```\n\nThis code represents an integration test for the MyDAO insert shown in [unit.tests](/docs/unit-testing).\n\n```java\npublic class MyHBaseIntegrationTest {\n    private static HBaseTestingUtility utility;\n    byte[] CF = \"CF\".getBytes();\n    byte[] CQ1 = \"CQ-1\".getBytes();\n    byte[] CQ2 = \"CQ-2\".getBytes();\n\n    @Before\n    public void setup() throws Exception {\n        utility = new HBaseTestingUtility();\n        utility.startMiniCluster();\n    }\n\n    @Test\n    public void testInsert() throws Exception {\n        Table table = utility.createTable(Bytes.toBytes(\"MyTest\"), CF);\n        HBaseTestObj obj = new HBaseTestObj();\n        obj.setRowKey(\"ROWKEY-1\");\n        obj.setData1(\"DATA-1\");\n        obj.setData2(\"DATA-2\");\n        MyHBaseDAO.insertRecord(table, obj);\n        Get get1 = new Get(Bytes.toBytes(obj.getRowKey()));\n        get1.addColumn(CF, CQ1);\n        Result result1 = table.get(get1);\n        assertEquals(Bytes.toString(result1.getRow()), obj.getRowKey());\n        assertEquals(Bytes.toString(result1.value()), obj.getData1());\n        Get get2 = new Get(Bytes.toBytes(obj.getRowKey()));\n        get2.addColumn(CF, CQ2);\n        Result result2 = table.get(get2);\n        assertEquals(Bytes.toString(result2.getRow()), obj.getRowKey());\n        assertEquals(Bytes.toString(result2.value()), obj.getData2());\n    }\n}\n```\n\nStarting from HBase 2.5.0, it is recommended to use TestingHBaseCluster instead.\n\n```java\npublic class MyHBaseIntegrationTest {\n\n  private TestingHBaseCluster cluster;\n\n  private Connection conn;\n\n  private Admin admin;\n\n  private TableName tableName = TableName.valueOf(\"MyTest\");\n\n  byte[] CF = \"CF\".getBytes();\n  byte[] CQ1 = \"CQ-1\".getBytes();\n  byte[] CQ2 = \"CQ-2\".getBytes();\n\n  @Before\n  public void setUp() throws Exception {\n    cluster = TestingHBaseCluster.create(TestingHBaseClusterOption.builder().build());\n    cluster.start();\n    conn = ConnectionFactory.createConnection(cluster.getConf());\n    admin = conn.getAdmin();\n    admin.createTable(TableDescriptorBuilder.newBuilder(tableName)\n      .setColumnFamily(ColumnFamilyDescriptorBuilder.of(CF)).build());\n  }\n\n  @After\n  public void tearDown() throws Exception {\n    admin.close();\n    conn.close();\n    cluster.stop();\n  }\n\n  @Test\n  public void testInsert() throws Exception {\n    try (Table table = conn.getTable(tableName)) {\n      HBaseTestObj obj = new HBaseTestObj();\n      obj.setRowKey(\"ROWKEY-1\");\n      obj.setData1(\"DATA-1\");\n      obj.setData2(\"DATA-2\");\n      MyHBaseDAO.insertRecord(table, obj);\n      Get get1 = new Get(Bytes.toBytes(obj.getRowKey()));\n      get1.addColumn(CF, CQ1);\n      Result result1 = table.get(get1);\n      assertEquals(Bytes.toString(result1.getRow()), obj.getRowKey());\n      assertEquals(Bytes.toString(result1.value()), obj.getData1());\n      Get get2 = new Get(Bytes.toBytes(obj.getRowKey()));\n      get2.addColumn(CF, CQ2);\n      Result result2 = table.get(get2);\n      assertEquals(Bytes.toString(result2.getRow()), obj.getRowKey());\n      assertEquals(Bytes.toString(result2.value()), obj.getData2());\n    }\n  }\n}\n```\n\nThis code creates an HBase mini-cluster and starts it.\nNext, it creates a table called `MyTest` with one column family, `CF`.\nA record is inserted, a Get is performed from the same table, and the insertion is verified.\n\n<Callout type=\"info\">\n  Starting the mini-cluster takes about 20-30 seconds, but that should be appropriate for\n  integration testing.\n</Callout>\n\nSee the paper at [HBase Case-Study: Using HBaseTestingUtility for Local Testing and Development](https://web.archive.org/web/20160214165147/http://blog.sematext.com/2010/08/30/hbase-case-study-using-hbasetestingutility-for-local-testing-development/) (2010) for more information about HBaseTestingUtility.\n\n\n# Upgrading (/docs/upgrading)\nYou cannot skip major versions when upgrading. If you are upgrading from version 0.98.x to 2.x, you must first go from 0.98.x to 1.2.x and then go from 1.2.x to 2.x.\n\nReview [Apache HBase Configuration](/docs/configuration), in particular [Hadoop](/docs/configuration/basic-prerequisites#hadoop). Familiarize yourself with [Support and Testing Expectations](/docs#support-and-testing-expectations).\n\n\n# Upgrade Paths (/docs/upgrading/paths)\n## Upgrade from 2.x to 3.x\n\nThe RegionServer Grouping feature has been reimplemented. See section [Migrating From Old Implementation](/docs/operational-management/region-and-capacity#migrating-from-old-implementation) in [Apache HBase Operational Management](/docs/operational-management) for more details.\n\nThe `hbase:namespace` table has been removed and fold into `hbase:meta`. See [Data Model](/docs/datamodel) for more details.\n\nThere is no special consideration upgrading to hbase-2.4.x from 2.3.x. And for earlier versions, just follow the [Upgrade from 2.0.x-2.2.x to 2.3+](/docs/upgrading/paths#upgrade-from-20x-22x-to-23) guide. In general, 2.2.x should be rolling upgradeable, for 2.1.x or 2.0.x, you will need to clear the [Upgrade from 2.0 or 2.1 to 2.2+](/docs/upgrading/paths#upgrade-from-20-or-21-to-22) hurdle first.\n\n## Upgrade from 2.0.x-2.2.x to 2.3+\n\nThere is no special consideration upgrading to hbase-2.3.x from earlier versions. From 2.2.x, it should be rolling upgradeable. From 2.1.x or 2.0.x, you will need to clear the [Upgrade from 2.0 or 2.1 to 2.2+](/docs/upgrading/paths#upgrade-from-20-or-21-to-22) hurdle first.\n\n### Upgraded ZooKeeper Dependency Version\n\nOur dependency on Apache ZooKeeper has been upgraded to 3.5.7 ([HBASE-24132](https://issues.apache.org/jira/browse/HBASE-24132)), as 3.4.x is EOL. The newer 3.5.x client is compatible with the older 3.4.x server. However, if you're using HBase in stand-alone mode and perform an in-place upgrade, there are some upgrade steps [documented by the ZooKeeper community](https://cwiki.apache.org/confluence/display/ZOOKEEPER/Upgrade+FAQ). This doesn't impact a production deployment, but would impact a developer's local environment.\n\n### New In-Master Procedure Store\n\nOf note, HBase 2.3.0 changes the in-Master Procedure Store implementation. It was a dedicated custom store to instead use a standard HBase Region ([HBASE-23326](https://issues.apache.org/jira/browse/HBASE-23326)). The migration from the old to new format is automatic run by the new 2.3.0 Master on startup. The old *MasterProcWALs* dir which hosted the old custom implementation files in *$\\{hbase.rootdir}* is deleted on successful migration. A new *MasterProc* sub-directory replaces it to host the Store files and WALs for the new Procedure Store in-Master Region. The in-Master Region is unusual in that it writes to an alternate location at *$\\{hbase.rootdir}/MasterProc* rather than under *$\\{hbase.rootdir}/data* in the filesystem and the special Procedure Store in-Master Region is hidden from all clients other than the active Master itself. Otherwise, it is like any other with the Master process running flushes and compactions, archiving WALs when over-flushed, and so on. Its files are readable by standard Region and Store file tooling for triage and analysis as long as they are pointed to the appropriate location in the filesystem.\n\nNotice that, after the migration, you should make sure to not start an active master with old code, as it can not recognize the new procedure store. So it is suggested to upgrade backup master(s) to new 2.3 first, and then upgrade the active master. And unless explicitly mentioned, this is the suggested way for all upgrading, i.e, upgrading backup master(s) first, then active master, and then region servers.\n\n## Upgrade from 2.0 or 2.1 to 2.2+\n\nHBase 2.2+ uses a new Procedure form assigning/unassigning/moving Regions. It does not process HBase 2.1 and 2.0's Unassign/Assign Procedure types. Upgrade requires that we first drain the Master Procedure Store of old style Procedures before starting the new 2.2 Master. So you need to make sure that before you kill the old version (2.0 or 2.1) Master, there is no region in transition. And once the new version (2.2+) Master is up, you can rolling upgrade RegionServers one by one.\n\nAnd there is a more safer way if you are running 2.1.1+ or 2.0.3+ cluster. It need four steps to upgrade Master.\n\n1. Shutdown both active and standby Masters (Your cluster will continue to server reads and writes without interruption).\n2. Set the property hbase.procedure.upgrade-to-2-2 to true in hbase-site.xml for the Master, and start only one Master, still using the 2.1.1+ (or 2.0.3+) version.\n3. Wait until the Master quits. Confirm that there is a 'UPGRADE OK: All existed procedures have been finished, quit...' message in the Master log as the cause of the shutdown. The Procedure Store is now empty.\n4. Start new Masters with the new 2.2+ version.\n\nThen you can rolling upgrade RegionServers one by one. See [HBASE-21075](https://issues.apache.org/jira/browse/HBASE-21075) for more details.\n\nIn case these steps are not done, on starting 2.2+ master, you would see the following exception in the master logs:\n\n`org.apache.hadoop.hbase.HBaseIOException: Unsupported procedure type class org.apache.hadoop.hbase.master.assignment.UnassignProcedure found`\n\n## Upgrading from 1.x to 2.x\n\nIn this section we will first call out significant changes compared to the prior stable HBase release and then go over the upgrade process. Be sure to read the former with care so you avoid surprises.\n\n### Changes of Note!\n\nFirst we'll cover deployment / operational changes that you might hit when upgrading to HBase 2.0+. After that we'll call out changes for downstream applications. Please note that Coprocessors are covered in the operational section. Also note that this section is not meant to convey information about new features that may be of interest to you. For a complete summary of changes, please see the CHANGES.txt file in the source release artifact for the version you are planning to upgrade to.\n\n#### Update to basic prerequisite minimums in HBase 2.0+ \\[!toc]\n\nAs noted in the [Basic Prerequisites](/docs/configuration/basic-prerequisites) section, HBase 2.0+ requires a minimum of Java 8 and Hadoop 2.6. The HBase community recommends ensuring you have already completed any needed upgrades in prerequisites prior to upgrading your HBase version.\n\n#### HBCK must match HBase server version \\[!toc]\n\nYou **must not** use an HBase 1.x version of HBCK against an HBase 2.0+ cluster. HBCK is strongly tied to the HBase server version. Using the HBCK tool from an earlier release against an HBase 2.0+ cluster will destructively alter said cluster in unrecoverable ways.\n\nAs of HBase 2.0, HBCK (A.K.A *HBCK1* or *hbck1*) is a read-only tool that can report the status of some non-public system internals but will often misread state because it does not understand the workings of hbase2.\n\nTo read about HBCK's replacement, see [Operations and Management](/docs/operational-management) documentation.\n\n<Callout type=\"warn\">\n  Related, before you upgrade, ensure that *hbck1* reports no `INCONSISTENCIES`. Fixing hbase1-type\n  inconsistencies post-upgrade is an involved process.\n</Callout>\n\n#### Configuration settings no longer in HBase 2.0+ \\[!toc]\n\nThe following configuration settings are no longer applicable or available. For details, please see the detailed release notes.\n\n* hbase.config.read.zookeeper.config (see [upgrade2.0.zkconfig](/docs/upgrading/paths#zookeeper-configs-no-longer-read-from-zoocfg-toc) for migration details)\n* hbase.zookeeper.useMulti (HBase now always uses ZK's multi functionality)\n* hbase.rpc.client.threads.max\n* hbase.rpc.client.nativetransport\n* hbase.fs.tmp.dir\n* hbase.bucketcache.combinedcache.enabled\n* hbase.bucketcache.ioengine no longer supports the 'heap' value.\n* hbase.bulkload.staging.dir\n* hbase.balancer.tablesOnMaster wasn't removed, strictly speaking, but its meaning has fundamentally changed and users should not set it. See the section [upgrade2.0.regions.on.master](/docs/upgrading/paths#master-hosting-regions-feature-broken-and-unsupported-toc) for details.\n* hbase.master.distributed.log.replay See the section [upgrade2.0.distributed.log.replay](/docs/upgrading/paths#distributed-log-replay-feature-broken-and-removed-toc) for details\n* hbase.regionserver.disallow\\.writes.when.recovering See the section [upgrade2.0.distributed.log.replay](/docs/upgrading/paths#distributed-log-replay-feature-broken-and-removed-toc) for details\n* hbase.regionserver.wal.logreplay.batch.size See the section [upgrade2.0.distributed.log.replay](/docs/upgrading/paths#distributed-log-replay-feature-broken-and-removed-toc) for details\n* hbase.master.catalog.timeout\n* hbase.regionserver.catalog.timeout\n* hbase.metrics.exposeOperationTimes\n* hbase.metrics.showTableName\n* hbase.online.schema.update.enable (HBase now always supports this)\n* hbase.thrift.htablepool.size.max\n\n#### Configuration properties that were renamed in HBase 2.0+ \\[!toc]\n\nThe following properties have been renamed. Attempts to set the old property will be ignored at run time.\n\n| Old name                                            | New name                                                |\n| --------------------------------------------------- | ------------------------------------------------------- |\n| hbase.rpc.server.nativetransport                    | hbase.netty.nativetransport                             |\n| hbase.netty.rpc.server.worker.count                 | hbase.netty.worker.count                                |\n| hbase.hfile.compactions.discharger.interval         | hbase.hfile.compaction.discharger.interval              |\n| hbase.hregion.percolumnfamilyflush.size.lower.bound | hbase.hregion.percolumnfamilyflush.size.lower.bound.min |\n\n#### Configuration settings with different defaults in HBase 2.0+ \\[!toc]\n\nThe following configuration settings changed their default value. Where applicable, the value to set to restore the behavior of HBase 1.2 is given.\n\n* hbase.security.authorization now defaults to false. set to true to restore same behavior as previous default.\n* hbase.client.retries.number is now set to 10. Previously it was 35. Downstream users are advised to use client timeouts as described in [Configuration](/docs/configuration/default#timeout-settings) instead.\n* hbase.client.serverside.retries.multiplier is now set to 3. Previously it was 10. Downstream users are advised to use client timeouts as described in [Configuration](/docs/configuration/default#timeout-settings) instead.\n* hbase.master.fileSplitTimeout is now set to 10 minutes. Previously it was 30 seconds.\n* hbase.regionserver.logroll.multiplier is now set to 0.5. Previously it was 0.95. This change is tied with the following doubling of block size. Combined, these two configuration changes should make for WALs of about the same size as those in hbase-1.x but there should be less incidence of small blocks because we fail to roll the WAL before we hit the blocksize threshold. See [HBASE-19148](https://issues.apache.org/jira/browse/HBASE-19148) for discussion.\n* hbase.regionserver.hlog.blocksize defaults to 2x the HDFS default block size for the WAL dir. Previously it was equal to the HDFS default block size for the WAL dir.\n* hbase.client.start.log.errors.counter changed to 5. Previously it was 9.\n* hbase.ipc.server.callqueue.type changed to 'fifo'. In HBase versions 1.0 - 1.2 it was 'deadline'. In prior and later 1.x versions it already defaults to 'fifo'.\n* hbase.hregion.memstore.chunkpool.maxsize is 1.0 by default. Previously it was 0.0. Effectively, this means previously we would not use a chunk pool when our memstore is onheap and now we will. See the section [Long GC pauses](/docs/performance#long-gc-pauses) for more information about the MSLAB chunk pool.\n* hbase.master.cleaner.interval is now set to 10 minutes. Previously it was 1 minute.\n* hbase.master.procedure.threads will now default to 1/4 of the number of available CPUs, but not less than 16 threads. Previously it would be number of threads equal to number of CPUs.\n* hbase.hstore.blockingStoreFiles is now 16. Previously it was 10.\n* hbase.http.max.threads is now 16. Previously it was 10.\n* hbase.client.max.perserver.tasks is now 2. Previously it was 5.\n* hbase.normalizer.period is now 5 minutes. Previously it was 30 minutes.\n* hbase.regionserver.region.split.policy is now SteppingSplitPolicy. Previously it was IncreasingToUpperBoundRegionSplitPolicy.\n* replication.source.ratio is now 0.5. Previously it was 0.1.\n\n#### \"Master hosting regions\" feature broken and unsupported \\[!toc]\n\nThe feature \"Master acts as region server\" and associated follow-on work available in HBase 1.y is non-functional in HBase 2.y and should not be used in a production setting due to deadlock on Master initialization. Downstream users are advised to treat related configuration settings as experimental and the feature as inappropriate for production settings.\n\nA brief summary of related changes:\n\n* Master no longer carries regions by default\n* hbase.balancer.tablesOnMaster is a boolean, default false (if it holds an HBase 1.x list of tables, will default to false)\n* hbase.balancer.tablesOnMaster.systemTablesOnly is boolean to keep user tables off master. default false\n* those wishing to replicate old list-of-servers config should deploy a stand-alone RegionServer process and then rely on Region Server Groups\n\n#### \"Distributed Log Replay\" feature broken and removed \\[!toc]\n\nThe Distributed Log Replay feature was broken and has been removed from HBase 2.y+. As a consequence all related configs, metrics, RPC fields, and logging have also been removed. Note that this feature was found to be unreliable in the run up to HBase 1.0, defaulted to being unused, and was effectively removed in HBase 1.2.0 when we started ignoring the config that turns it on ([HBASE-14465](https://issues.apache.org/jira/browse/HBASE-14465)). If you are currently using the feature, be sure to perform a clean shutdown, ensure all DLR work is complete, and disable the feature prior to upgrading.\n\n#### *prefix-tree* encoding removed \\[!toc]\n\nThe prefix-tree encoding was removed from HBase 2.0.0 ([HBASE-19179](https://issues.apache.org/jira/browse/HBASE-19179)). It was (late!) deprecated in hbase-1.2.7, hbase-1.4.0, and hbase-1.3.2.\n\nThis feature was removed because it as not being actively maintained. If interested in reviving this sweet facility which improved random read latencies at the expensive of slowed writes, write the HBase developers list at *dev at hbase dot apache dot org*.\n\nThe prefix-tree encoding needs to be removed from all tables before upgrading to HBase 2.0+. To do that first you need to change the encoding from PREFIX\\_TREE to something else that is supported in HBase 2.0. After that you have to major compact the tables that were using PREFIX\\_TREE encoding before. To check which column families are using incompatible data block encoding you can use [Pre-Upgrade Validator](/docs/operational-management/tools#pre-upgrade-validator).\n\n#### Changed metrics \\[!toc]\n\nThe following metrics have changed names:\n\n* Metrics previously published under the name \"AssignmentManger\" \\[sic] are now published under the name \"AssignmentManager\"\n\nThe following metrics have changed their meaning:\n\n* The metric 'blockCacheEvictionCount' published on a per-region server basis no longer includes blocks removed from the cache due to the invalidation of the hfiles they are from (e.g. via compaction).\n* The metric 'totalRequestCount' increments once per request; previously it incremented by the number of `Actions` carried in the request; e.g. if a request was a `multi` made of four Gets and two Puts, we'd increment 'totalRequestCount' by six; now we increment by one regardless. Expect to see lower values for this metric in hbase-2.0.0.\n* The 'readRequestCount' now counts reads that return a non-empty row where in older hbases, we'd increment 'readRequestCount' whether a Result or not. This change will flatten the profile of the read-requests graphs if requests for non-existent rows. A YCSB read-heavy workload can do this dependent on how the database was loaded.\n\nThe following metrics have been removed:\n\n* Metrics related to the Distributed Log Replay feature are no longer present. They were previously found in the region server context under the name 'replay'. See the section [\"Distributed Log Replay\" feature broken and removed](/docs/upgrading/paths#distributed-log-replay-feature-broken-and-removed-toc) for details.\n\nThe following metrics have been added:\n\n* 'totalRowActionRequestCount' is a count of region row actions summing reads and writes.\n\n#### Changed logging \\[!toc]\n\nHBase-2.0.0 now uses [slf4j](https://www.slf4j.org/) as its logging frontend. Previously, we used [log4j (1.2)](http://logging.apache.org/log4j/1.2/). For most the transition should be seamless; slf4j does a good job interpreting *log4j.properties* logging configuration files such that you should not notice any difference in your log system emissions.\n\nThat said, your *log4j.properties* may need freshening. See [HBASE-20351](https://issues.apache.org/jira/browse/HBASE-20351) for example, where a stale log configuration file manifest as netty configuration being dumped at DEBUG level as preamble on every shell command invocation.\n\n#### ZooKeeper configs no longer read from zoo.cfg \\[!toc]\n\nHBase no longer optionally reads the 'zoo.cfg' file for ZooKeeper related configuration settings. If you previously relied on the 'hbase.config.read.zookeeper.config' config for this functionality, you should migrate any needed settings to the hbase-site.xml file while adding the prefix 'hbase.zookeeper.property.' to each property name.\n\n#### Changes in permissions \\[!toc]\n\nThe following permission related changes either altered semantics or defaults:\n\n* Permissions granted to a user now merge with existing permissions for that user, rather than over-writing them. (see [the release note on HBASE-17472](https://issues.apache.org/jira/browse/HBASE-17472) for details)\n* Region Server Group commands (added in 1.4.0) now require admin privileges.\n\n#### Most Admin APIs don't work against an HBase 2.0+ cluster from pre-HBase 2.0 clients \\[!toc]\n\nA number of admin commands are known to not work when used from a pre-HBase 2.0 client. This includes an HBase Shell that has the library jars from pre-HBase 2.0. You will need to plan for an outage of use of admin APIs and commands until you can also update to the needed client version.\n\nThe following client operations do not work against HBase 2.0+ cluster when executed from a pre-HBase 2.0 client:\n\n* list\\_procedures\n* split\n* merge\\_region\n* list\\_quotas\n* enable\\_table\\_replication\n* disable\\_table\\_replication\n* Snapshot related commands\n\n#### Deprecated in 1.0 admin commands have been removed. \\[!toc]\n\nThe following commands that were deprecated in 1.0 have been removed. Where applicable the replacement command is listed.\n\n* The 'hlog' command has been removed. Downstream users should rely on the 'wal' command instead.\n\n#### Region Server memory consumption changes. \\[!toc]\n\nUsers upgrading from versions prior to HBase 1.4 should read the instructions in section [Region Server memory consumption changes.](/docs/upgrading/paths#region-server-memory-consumption-changes).\n\nAdditionally, HBase 2.0 has changed how memstore memory is tracked for flushing decisions. Previously, both the data size and overhead for storage were used to calculate utilization against the flush threshold. Now, only data size is used to make these per-region decisions. Globally the addition of the storage overhead is used to make decisions about forced flushes.\n\n#### Web UI for splitting and merging operate on row prefixes \\[!toc]\n\nPreviously, the Web UI included functionality on table status pages to merge or split based on an encoded region name. In HBase 2.0, instead this functionality works by taking a row prefix.\n\n#### Special upgrading for Replication users from pre-HBase 1.4 \\[!toc]\n\nUser running versions of HBase prior to the 1.4.0 release that make use of replication should be sure to read the instructions in the section [Replication peer's TableCFs config](/docs/upgrading/paths#replication-peers-tablecfs-config).\n\n#### HBase shell changes \\[!toc]\n\nThe HBase shell command relies on a bundled JRuby instance. This bundled JRuby been updated from version 1.6.8 to version 9.1.10.0. The represents a change from Ruby 1.8 to Ruby 2.3.3, which introduces non-compatible language changes for user scripts.\n\nThe HBase shell command now ignores the '--return-values' flag that was present in early HBase 1.4 releases. Instead the shell always behaves as though that flag were passed. If you wish to avoid having expression results printed in the console you should alter your IRB configuration.\n\n#### Coprocessor APIs have changed in HBase 2.0+ \\[!toc]\n\nAll Coprocessor APIs have been refactored to improve supportability around binary API compatibility for future versions of HBase. If you or applications you rely on have custom HBase coprocessors, you should read [the release notes for HBASE-18169](https://issues.apache.org/jira/browse/HBASE-18169) for details of changes you will need to make prior to upgrading to HBase 2.0+.\n\nFor example, if you had a BaseRegionObserver in HBase 1.2 then at a minimum you will need to update it to implement both RegionObserver and RegionCoprocessor and add the method\n\n```java\n...\n  @Override\n  public Optional<RegionObserver> getRegionObserver() {\n    return Optional.of(this);\n  }\n...\n```\n\nFor more information, see [Upgrading Coprocessors to 2.0](/docs/upgrading/paths#upgrading-coprocessors-to-20).\n\n#### HBase 2.0+ can no longer write HFile v2 files. \\[!toc]\n\nHBase has simplified our internal HFile handling. As a result, we can no longer write HFile versions earlier than the default of version 3. Upgrading users should ensure that hfile.format.version is not set to 2 in hbase-site.xml before upgrading. Failing to do so will cause Region Server failure. HBase can still read HFiles written in the older version 2 format.\n\n#### HBase 2.0+ can no longer read Sequence File based WAL file. \\[!toc]\n\nHBase can no longer read the deprecated WAL files written in the Apache Hadoop Sequence File format. The hbase.regionserver.hlog.reader.impl and hbase.regionserver.hlog.writer.impl configuration entries should be set to use the Protobuf based WAL reader / writer classes. This implementation has been the default since HBase 0.96, so legacy WAL files should not be a concern for most downstream users.\n\nStarting from 2.6.0, the hbase.regionserver.hlog.reader.impl and hbase.regionserver.hlog.writer.impl configuration entries are removed since the only valid values are protobuf based reader/writer. Setting them in *hbase-site.xml* will have no real effect.\n\nA clean cluster shutdown should ensure there are no WAL files. If you are unsure of a given WAL file's format you can use the `hbase wal` command to parse files while the HBase cluster is offline. In HBase 2.0+, this command will not be able to read a Sequence File based WAL.\n\n#### Change in behavior for filters \\[!toc]\n\nThe Filter ReturnCode NEXT\\_ROW has been redefined as skipping to next row in current family, not to next row in all family. it's more reasonable, because ReturnCode is a concept in store level, not in region level.\n\n#### Downstream HBase 2.0+ users should use the shaded client \\[!toc]\n\nDownstream users are strongly urged to rely on the Maven coordinates org.apache.hbase:hbase-shaded-client for their runtime use. This artifact contains all the needed implementation details for talking to an HBase cluster while minimizing the number of third party dependencies exposed.\n\nNote that this artifact exposes some classes in the org.apache.hadoop package space (e.g. o.a.h.configuration.Configuration) so that we can maintain source compatibility with our public API. Those classes are included so that they can be altered to use the same relocated third party dependencies as the rest of the HBase client code. In the event that you need to **also** use Hadoop in your code, you should ensure all Hadoop related jars precede the HBase client jar in your classpath.\n\n#### Downstream HBase 2.0+ users of MapReduce must switch to new artifact \\[!toc]\n\nDownstream users of HBase's integration for Apache Hadoop MapReduce must switch to relying on the org.apache.hbase:hbase-shaded-mapreduce module for their runtime use. Historically, downstream users relied on either the org.apache.hbase:hbase-server or org.apache.hbase:hbase-shaded-server artifacts for these classes. Both uses are no longer supported and in the vast majority of cases will fail at runtime.\n\nNote that this artifact exposes some classes in the org.apache.hadoop package space (e.g. o.a.h.configuration.Configuration) so that we can maintain source compatibility with our public API. Those classes are included so that they can be altered to use the same relocated third party dependencies as the rest of the HBase client code. In the event that you need to **also** use Hadoop in your code, you should ensure all Hadoop related jars precede the HBase client jar in your classpath.\n\n#### Significant changes to runtime classpath \\[!toc]\n\nA number of internal dependencies for HBase were updated or removed from the runtime classpath. Downstream client users who do not follow the guidance in [Downstream HBase 2.0+ users should use the shaded client](/docs/upgrading/paths#downstream-hbase-20-users-should-use-the-shaded-client-toc) will have to examine the set of dependencies Maven pulls in for impact. Downstream users of LimitedPrivate Coprocessor APIs will need to examine the runtime environment for impact.\n\n#### Multiple breaking changes to source and binary compatibility for client API \\[!toc]\n\nThe Java client API for HBase has a number of changes that break both source and binary compatibility for details see the Compatibility Check Report for the release you'll be upgrading to.\n\n#### Tracing implementation changes \\[!toc]\n\nThe backing implementation of HBase's tracing features was updated from Apache HTrace 3 to HTrace 4, which includes several breaking changes. While HTrace 3 and 4 can coexist in the same runtime, they will not integrate with each other, leading to disjoint trace information.\n\nThe internal changes to HBase during this upgrade were sufficient for compilation, but it has not been confirmed that there are no regressions in tracing functionality. Please consider this feature experimental for the immediate future.\n\nIf you previously relied on client side tracing integrated with HBase operations, it is recommended that you upgrade your usage to HTrace 4 as well.\n\nAfter the Apache HTrace project moved to the Attic/retired, the traces in HBase are left broken and unmaintained since HBase 2.0. A new project [HBASE-22120](https://issues.apache.org/jira/browse/HBASE-22120) will replace HTrace with OpenTelemetry. It will be shipped in 3.0.0 release. Please see the [Tracing](/docs/tracing) documentation for more details.\n\n#### HFile lose forward compatibility \\[!toc]\n\nHFiles generated by 2.0.0, 2.0.1, 2.1.0 are not forward compatible to 1.4.6-, 1.3.2.1-, 1.2.6.1-, and other inactive releases. Why HFile lose compatibility is hbase in new versions (2.0.0, 2.0.1, 2.1.0) use protobuf to serialize/deserialize TimeRangeTracker (TRT) while old versions use DataInput/DataOutput. To solve this, We have to put [HBASE-21012](https://issues.apache.org/jira/browse/HBASE-21012) to 2.x and put [HBASE-21013](https://issues.apache.org/jira/browse/HBASE-21013) in 1.x. For more information, please check [HBASE-21008](https://issues.apache.org/jira/browse/HBASE-21008).\n\n#### Performance \\[!toc]\n\nYou will likely see a change in the performance profile on upgrade to hbase-2.0.0 given read and write paths have undergone significant change. On release, writes may be slower with reads about the same or much better, dependent on context. Be prepared to spend time re-tuning (See [Performance](/docs/performance)). Performance is also an area that is now under active review so look forward to improvement in coming releases (See [HBASE-20188 TESTING Performance](https://issues.apache.org/jira/browse/HBASE-20188)).\n\n#### Integration Tests and Kerberos \\[!toc]\n\nIntegration Tests (`IntegrationTests*`) used to rely on the Kerberos credential cache for authentication against secured clusters. This used to lead to tests failing due to authentication failures when the tickets in the credential cache expired. As of hbase-2.0.0 (and hbase-1.3.0+), the integration test clients will make use of the configuration properties `hbase.client.keytab.file` and `hbase.client.kerberos.principal`. They are required. The clients will perform a login from the configured keytab file and automatically refresh the credentials in the background for the process lifetime (See [HBASE-16231](https://issues.apache.org/jira/browse/HBASE-16231)).\n\n#### Default Compaction Throughput \\[!toc]\n\nHBase 2.x comes with default limits to the speed at which compactions can execute. This limit is defined per RegionServer. In previous versions of HBase earlier than 1.5, there was no limit to the speed at which a compaction could run by default. Applying a limit to the throughput of a compaction should ensure more stable operations from RegionServers.\n\nTake care to notice that this limit is *per RegionServer*, not *per compaction*.\n\nThe throughput limit is defined as a range of bytes written per second, and is allowed to vary within the given lower and upper bound. RegionServers observe the current throughput of a compaction and apply a linear formula to adjust the allowed throughput, within the lower and upper bound, with respect to external pressure. For compactions, external pressure is defined as the number of store files with respect to the maximum number of allowed store files. The more store files, the higher the compaction pressure.\n\nConfiguration of this throughput is governed by the following properties.\n\n* The lower bound is defined by `hbase.hstore.compaction.throughput.lower.bound` and defaults to 50 MB/s (`52428800`).\n* The upper bound is defined by `hbase.hstore.compaction.throughput.higher.bound` and defaults to 100 MB/s (`104857600`).\n\nTo revert this behavior to the unlimited compaction throughput of earlier versions of HBase, please set the following property to the implementation that applies no limits to compactions.\n\n`hbase.regionserver.throughput.controller=org.apache.hadoop.hbase.regionserver.throttle.NoLimitThroughputController`\n\n### Upgrading Coprocessors to 2.0\n\nCoprocessors have changed substantially in 2.0 ranging from top level design changes in class hierarchies to changed/removed methods, interfaces, etc. (Parent jira: [HBASE-18169 Coprocessor fix and cleanup before 2.0.0 release](https://issues.apache.org/jira/browse/HBASE-18169)). Some of the reasons for such widespread changes:\n\n1. Pass Interfaces instead of Implementations; e.g. TableDescriptor instead of HTableDescriptor and Region instead of HRegion ([HBASE-18241](https://issues.apache.org/jira/browse/HBASE-18241) Change client.Table and client.Admin to not use HTableDescriptor).\n2. Design refactor so implementers need to fill out less boilerplate and so we can do more compile-time checking ([HBASE-17732](https://issues.apache.org/jira/browse/HBASE-17732))\n3. Purge Protocol Buffers from Coprocessor API ([HBASE-18859](https://issues.apache.org/jira/browse/HBASE-18859), [HBASE-16769](https://issues.apache.org/jira/browse/HBASE-16769), etc)\n4. Cut back on what we expose to Coprocessors removing hooks on internals that were too private to expose (for eg. [HBASE-18453](https://issues.apache.org/jira/browse/HBASE-18453) CompactionRequest should not be exposed to user directly; [HBASE-18298](https://issues.apache.org/jira/browse/HBASE-18298) RegionServerServices Interface cleanup for CP expose; etc)\n\nTo use coprocessors in 2.0, they should be rebuilt against new API otherwise they will fail to load and HBase processes will die.\n\nSuggested order of changes to upgrade the coprocessors:\n\n1. Directly implement observer interfaces instead of extending Base\\*Observer classes. Change `Foo extends BaseXXXObserver` to `Foo implements XXXObserver`. ([HBASE-17312](https://issues.apache.org/jira/browse/HBASE-17312)).\n2. Adapt to design change from Inheritence to Composition ([HBASE-17732](https://issues.apache.org/jira/browse/HBASE-17732)) by following [this example](https://github.com/apache/hbase/blob/master/dev-support/design-docs/Coprocessor_Design_Improvements-Use_composition_instead_of_inheritance-HBASE-17732.adoc#migrating-existing-cps-to-new-design).\n3. getTable() has been removed from the CoprocessorEnvrionment, coprocessors should self-manage Table instances.\n\nSome examples of writing coprocessors with new API can be found in hbase-example module [here](https://github.com/apache/hbase/tree/branch-2.0/hbase-examples/src/main/java/org/apache/hadoop/hbase/coprocessor/example).\n\nLastly, if an api has been changed/removed that breaks you in an irreparable way, and if there's a good justification to add it back, bring it our notice [dev@hbase.apache.org](mailto:dev@hbase.apache.org).\n\n### Rolling Upgrade from 1.x to 2.x\n\nRolling upgrades are currently an experimental feature. They have had limited testing. There are likely corner cases as yet uncovered in our limited experience so you should be careful if you go this route. The stop/upgrade/start described in the next section, [Upgrade process from 1.x to 2.x](/docs/upgrading/paths#upgrade-process-from-1x-to-2x), is the safest route.\n\nThat said, the below is a prescription for a rolling upgrade of a 1.4 cluster.\n\n#### Pre-Requirements\n\n* Upgrade to the latest 1.4.x release. Pre 1.4 releases may also work but are not tested, so please upgrade to 1.4.3+ before upgrading to 2.x, unless you are an expert and familiar with the region assignment and crash processing. See the section [Upgrading from pre-1.4 to 1.4+](/docs/upgrading/paths#upgrading-from-pre-14-to-14) on how to upgrade to 1.4.x.\n* Make sure that the zk-less assignment is enabled, i.e, set `hbase.assignment.usezk` to `false`. This is the most important thing. It allows the 1.x master to assign/unassign regions to/from 2.x region servers. See the release note section of [HBASE-11059](https://issues.apache.org/jira/browse/HBASE-11059) on how to migrate from zk based assignment to zk less assignment.\n* Before you upgrade, ensure that *hbck1* reports no `INCONSISTENCIES`. Fixing hbase1-type inconsistencies post-upgrade is an involved process.\n* We have tested rolling upgrading from 1.4.3 to 2.1.0, but it should also work if you want to upgrade to 2.0.x.\n\n#### Instructions\n\n1. Unload a region server and upgrade it to 2.1.0. With [HBASE-17931](https://issues.apache.org/jira/browse/HBASE-17931) in place, the meta region and regions for other system tables will be moved to this region server immediately. If not, please move them manually to the new region server. This is very important because\n   * The schema of meta region is hard coded, if meta is on an old region server, then the new region servers can not access it as it does not have some families, for example, table state.\n   * Client with lower version can communicate with server with higher version, but not vice versa. If the meta region is on an old region server, the new region server will use a client with higher version to communicate with a server with lower version, this may introduce strange problems.\n2. Rolling upgrade all other region servers.\n3. Upgrading masters.\n\nIt is OK that during the rolling upgrading there are region server crashes. The 1.x master can assign regions to both 1.x and 2.x region servers, and [HBASE-19166](https://issues.apache.org/jira/browse/HBASE-19166) fixed a problem so that 1.x region server can also read the WALs written by 2.x region server and split them.\n\n<Callout type=\"info\">\n  Please read the [Changes of Note!](/docs/upgrading/paths#changes-of-note) section carefully before\n  rolling upgrading. Make sure that you do not use the removed features in 2.0, for example, the\n  prefix-tree encoding, the old hfile format, etc. They could both fail the upgrading and leave the\n  cluster in an intermediate state and hard to recover.\n</Callout>\n\n<Callout type=\"info\">\n  If you have success running this prescription, please notify the dev list with a note on your\n  experience and/or update the above with any deviations you may have taken so others going this\n  route can benefit from your efforts.\n</Callout>\n\n### Upgrade process from 1.x to 2.x\n\nTo upgrade an existing HBase 1.x cluster, you should:\n\n* Ensure that *hbck1* reports no `INCONSISTENCIES`. Fixing hbase1-type inconsistencies post-upgrade is an involved process. Fix all *hbck1* complaints before proceeding.\n* Clean shutdown of existing 1.x cluster\n* Update coprocessors\n* Upgrade Master roles first\n* Upgrade RegionServers\n* (Eventually) Upgrade Clients\n\n## Upgrading to 1.7.1+\n\nHBase release 1.7.0 introduced an incompatible table metadata serialization format that broke the minor release compatibility guarantees. The issue was reported in [HBASE-26021](https://issues.apache.org/jira/browse/HBASE-26021) and the problematic serialization patch was reverted in HBase 1.7.1. Some important notes about 1.7.x upgrades below.\n\n* If you are considering an upgrade to 1.7.x version, skip 1.7.0 completely and upgrade to 1.7.1+ version. 1.7.0 was withdrawn and removed from the Apache sites.\n* If you already installed a 1.7.0 cluster from scratch and are looking to migrate to 1.7.1+, you cannot follow the regular rolling upgrade procedures due to broken compatibility contracts. Instead shutdown the cluster and reboot with 1.7.1+ binaries. Newer versions detect any existing tables with incompatible serialization and rewrite them using the correct format at bootstrap.\n* If you are already on 1.7.1+ version, everything is good and no additional steps need to be performed.\n\n## Upgrading from pre-1.4 to 1.4+\n\n### Region Server memory consumption changes.\n\nUsers upgrading from versions prior to HBase 1.4 should be aware that the estimates of heap usage by the memstore objects (KeyValue, object and array header sizes, etc) have been made more accurate for heap sizes up to 32G (using CompressedOops), resulting in them dropping by 10-50% in practice. This also results in less number of flushes and compactions due to \"fatter\" flushes. YMMV. As a result, the actual heap usage of the memstore before being flushed may increase by up to 100%. If configured memory limits for the region server had been tuned based on observed usage, this change could result in worse GC behavior or even OutOfMemory errors. Set the environment property (not hbase-site.xml) \"hbase.memorylayout.use.unsafe\" to false to disable.\n\n### Replication peer's TableCFs config\n\nBefore 1.4, the table name can't include namespace for replication peer's TableCFs config. It was fixed by add TableCFs to ReplicationPeerConfig which was stored on Zookeeper. So when upgrade to 1.4, you have to update the original ReplicationPeerConfig data on Zookeeper firstly. There are four steps to upgrade when your cluster have a replication peer with TableCFs config.\n\n* Disable the replication peer.\n* If master has permission to write replication peer znode, then rolling update master directly. If not, use TableCFsUpdater tool to update the replication peer's config.\n  ```bash\n  $ bin/hbase org.apache.hadoop.hbase.replication.master.TableCFsUpdater update\n  ```\n* Rolling update regionservers.\n* Enable the replication peer.\n\nNotes:\n\n* Can't use the old client(before 1.4) to change the replication peer's config. Because the client will write config to Zookeeper directly, the old client will miss TableCFs config. And the old client write TableCFs config to the old tablecfs znode, it will not work for new version regionserver.\n\n### Raw scan now ignores TTL\n\nDoing a raw scan will now return results that have expired according to TTL settings.\n\n## Upgrading from pre-1.3 to 1.3+\n\nIf running Integration Tests under Kerberos, see [upgrade2.0.it.kerberos](/docs/upgrading/paths#integration-tests-and-kerberos-toc).\n\n## Upgrading to 1.x\n\nPlease consult the documentation published specifically for the version of HBase that you are upgrading to for details on the upgrade process.\n\n\n# Rollback (/docs/upgrading/rollback)\nSometimes things don't go as planned when attempting an upgrade. This section explains how to perform a *rollback* to an earlier HBase release. Note that this should only be needed between Major and some Minor releases. You should always be able to *downgrade* between HBase Patch releases within the same Minor version. These instructions may require you to take steps before you start the upgrade process, so be sure to read through this section beforehand.\n\n## Caveats\n\n### Rollback vs Downgrade\n\nThis section describes how to perform a *rollback* on an upgrade between HBase minor and major versions. In this document, rollback refers to the process of taking an upgraded cluster and restoring it to the old version *while losing all changes that have occurred since upgrade*. By contrast, a cluster *downgrade* would restore an upgraded cluster to the old version while maintaining any data written since the upgrade. We currently only offer instructions to rollback HBase clusters. Further, rollback only works when these instructions are followed prior to performing the upgrade.\n\nWhen these instructions talk about rollback vs downgrade of prerequisite cluster services (i.e. HDFS), you should treat leaving the service version the same as a degenerate case of downgrade.\n\n### Replication\n\nUnless you are doing an all-service rollback, the HBase cluster will lose any configured peers for HBase replication. If your cluster is configured for HBase replication, then prior to following these instructions you should document all replication peers. After performing the rollback you should then add each documented peer back to the cluster. Note also that data written to the cluster since the upgrade may or may not have already been replicated to any peers. Determining which, if any, peers have seen replication data as well as rolling back the data in those peers is out of the scope of this guide.\n\n### Data Locality\n\nUnless you are doing an all-service rollback, going through a rollback procedure will likely destroy all locality for Region Servers. You should expect degraded performance until after the cluster has had time to go through compactions to restore data locality. Optionally, you can force a compaction to speed this process up at the cost of generating cluster load.\n\n### Configurable Locations\n\nThe instructions below assume default locations for the HBase data directory and the HBase znode. Both of these locations are configurable and you should verify the value used in your cluster before proceeding. In the event that you have a different value, just replace the default with the one found in your configuration \\* HBase data directory is configured via the key 'hbase.rootdir' and has a default value of '/hbase'. \\* HBase znode is configured via the key 'zookeeper.znode.parent' and has a default value of '/hbase'.\n\n## All service rollback\n\nIf you will be performing a rollback of both the HDFS and ZooKeeper services, then HBase's data will be rolled back in the process.\n\n### Requirements\n\n* Ability to rollback HDFS and ZooKeeper\n\n### Before upgrade\n\nNo additional steps are needed pre-upgrade. As an extra precautionary measure, you may wish to use distcp to back up the HBase data off of the cluster to be upgraded. To do so, follow the steps in the 'Before upgrade' section of 'Rollback after HDFS downgrade' but copy to another HDFS instance instead of within the same instance.\n\n### Performing a rollback\n\n<Steps>\n  <Step>\n    Stop HBase\n  </Step>\n\n  <Step>\n    Perform a rollback for HDFS and ZooKeeper (HBase should remain stopped)\n  </Step>\n\n  <Step>\n    Change the installed version of HBase to the previous version\n  </Step>\n\n  <Step>\n    Start HBase\n  </Step>\n\n  <Step>\n    Verify HBase contents — use the HBase shell to list tables and scan some known values.\n  </Step>\n</Steps>\n\n## Rollback after HDFS rollback and ZooKeeper downgrade\n\nIf you will be rolling back HDFS but going through a ZooKeeper downgrade, then HBase will be in an inconsistent state. You must ensure the cluster is not started until you complete this process.\n\n### Requirements\n\n* Ability to rollback HDFS\n* Ability to downgrade ZooKeeper\n\n### Before upgrade\n\nNo additional steps are needed pre-upgrade. As an extra precautionary measure, you may wish to use distcp to back up the HBase data off of the cluster to be upgraded. To do so, follow the steps in the 'Before upgrade' section of 'Rollback after HDFS downgrade' but copy to another HDFS instance instead of within the same instance.\n\n### Performing a rollback\n\n<Steps>\n  <Step>\n    Stop HBase\n  </Step>\n\n  <Step>\n    Perform a rollback for HDFS and a downgrade for ZooKeeper (HBase should remain stopped)\n  </Step>\n\n  <Step>\n    Change the installed version of HBase to the previous version\n  </Step>\n\n  <Step>\n    Clean out ZooKeeper information related to HBase. WARNING: This step will permanently destroy all replication peers. Please see the section on HBase Replication under Caveats for more information.\n\n    **Clean HBase information out of ZooKeeper:**\n\n    ```bash\n    [hpnewton@gateway_node.example.com ~]$ zookeeper-client -server zookeeper1.example.com:2181,zookeeper2.example.com:2181,zookeeper3.example.com:2181\n    Welcome to ZooKeeper!\n    JLine support is disabled\n    rmr /hbase\n    quit\n    Quitting...\n    ```\n  </Step>\n\n  <Step>\n    Start HBase\n  </Step>\n\n  <Step>\n    Verify HBase contents—use the HBase shell to list tables and scan some known values.\n  </Step>\n</Steps>\n\n## Rollback after HDFS downgrade\n\nIf you will be performing an HDFS downgrade, then you'll need to follow these instructions regardless of whether ZooKeeper goes through rollback, downgrade, or reinstallation.\n\n### Requirements\n\n* Ability to downgrade HDFS\n* Pre-upgrade cluster must be able to run MapReduce jobs\n* HDFS super user access\n* Sufficient space in HDFS for at least two copies of the HBase data directory\n\n### Before upgrade\n\nBefore beginning the upgrade process, you must take a complete backup of HBase's backing data. The following instructions cover backing up the data within the current HDFS instance. Alternatively, you can use the distcp command to copy the data to another HDFS cluster.\n\n<Steps>\n  <Step>\n    Stop the HBase cluster\n  </Step>\n\n  <Step>\n    Copy the HBase data directory to a backup location using the [distcp command](https://hadoop.apache.org/docs/current/hadoop-distcp/DistCp.html) as the HDFS super user (shown below on a security enabled cluster)\n\n    **Using distcp to backup the HBase data directory:**\n\n    ```bash\n    [hpnewton@gateway_node.example.com ~]$ kinit -k -t hdfs.keytab hdfs@EXAMPLE.COM\n    [hpnewton@gateway_node.example.com ~]$ hadoop distcp /hbase /hbase-pre-upgrade-backup\n    ```\n  </Step>\n\n  <Step>\n    Distcp will launch a mapreduce job to handle copying the files in a distributed fashion. Check the output of the distcp command to ensure this job completed successfully.\n  </Step>\n</Steps>\n\n### Performing a rollback\n\n<Steps>\n  <Step>\n    Stop HBase\n  </Step>\n\n  <Step>\n    Perform a downgrade for HDFS and a downgrade/rollback for ZooKeeper (HBase should remain stopped)\n  </Step>\n\n  <Step>\n    Change the installed version of HBase to the previous version\n  </Step>\n\n  <Step>\n    Restore the HBase data directory from prior to the upgrade. Restore the HBase data directory from prior to the upgrade as the HDFS super user (shown below on a security enabled cluster). If you backed up your data on another HDFS cluster instead of locally, you will need to use the distcp command to copy it back to the current HDFS cluster.\n\n    **Restore the HBase data directory:**\n\n    ```bash\n    [hpnewton@gateway_node.example.com ~]$ kinit -k -t hdfs.keytab hdfs@EXAMPLE.COM\n    [hpnewton@gateway_node.example.com ~]$ hdfs dfs -mv /hbase /hbase-upgrade-rollback\n    [hpnewton@gateway_node.example.com ~]$ hdfs dfs -mv /hbase-pre-upgrade-backup /hbase\n    ```\n  </Step>\n\n  <Step>\n    Clean out ZooKeeper information related to HBase. WARNING: This step will permanently destroy all replication peers. Please see the section on HBase Replication under Caveats for more information.\n\n    **Clean HBase information out of ZooKeeper:**\n\n    ```bash\n    [hpnewton@gateway_node.example.com ~]$ zookeeper-client -server zookeeper1.example.com:2181,zookeeper2.example.com:2181,zookeeper3.example.com:2181\n    Welcome to ZooKeeper!\n    JLine support is disabled\n    rmr /hbase\n    quit\n    Quitting...\n    ```\n  </Step>\n\n  <Step>\n    Start HBase\n  </Step>\n\n  <Step>\n    Verify HBase contents–use the HBase shell to list tables and scan some known values.\n  </Step>\n</Steps>\n\n\n# Rolling Upgrades (/docs/upgrading/rolling)\nA rolling upgrade is the process by which you update the servers in your cluster a server at a time. You can rolling upgrade across HBase versions if they are binary or wire compatible. See the \"Rolling Upgrade Between Versions that are Binary/Wire Compatible\" section below for more on what this means. Coarsely, a rolling upgrade is a graceful stop each server, update the software, and then restart. You do this for each server in the cluster. Usually you upgrade the Master first and then the RegionServers. See [Rolling Restart](/docs/operational-management/node#rolling-restart) for tools that can help use the rolling upgrade process.\n\nFor example, in the below, HBase was symlinked to the actual HBase install. On upgrade, before running a rolling restart over the cluster, we changed the symlink to point at the new HBase software version and then ran\n\n```bash\n$ HADOOP_HOME=~/hadoop-2.6.0-CRC-SNAPSHOT ~/hbase/bin/rolling-restart.sh --config ~/conf_hbase\n```\n\nThe rolling-restart script will first gracefully stop and restart the master, and then each of the RegionServers in turn. Because the symlink was changed, on restart the server will come up using the new HBase version. Check logs for errors as the rolling upgrade proceeds.\n\n#### Rolling Upgrade Between Versions that are Binary/Wire Compatible \\[!toc]\n\nUnless otherwise specified, HBase minor versions are binary compatible. You can do a rolling upgrades between HBase point versions. For example, you can go to 1.4.4 from 1.4.6 by doing a rolling upgrade across the cluster replacing the 1.4.4 binary with a 1.4.6 binary.\n\nIn the minor version-particular sections below, we call out where the versions are wire/protocol compatible and in this case, it is also possible to do a rolling upgrade.\n\n\n# HBase version number and compatibility (/docs/upgrading/version-number)\n## Aspirational Semantic Versioning\n\nStarting with the 1.0.0 release, HBase is working towards [Semantic Versioning](http://semver.org/) for its release versioning. In summary:\n\n#### Given a version number MAJOR.MINOR.PATCH, increment the: \\[!toc]\n\n* MAJOR version when you make incompatible API changes,\n* MINOR version when you add functionality in a backwards-compatible manner, and\n* PATCH version when you make backwards-compatible bug fixes.\n* Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\n\n#### Compatibility Dimensions \\[!toc]\n\nIn addition to the usual API versioning considerations HBase has other compatibility dimensions that we need to consider.\n\n#### Client-Server wire protocol compatibility \\[!toc]\n\n* Allows updating client and server out of sync.\n* We could only allow upgrading the server first. I.e. the server would be backward compatible to an old client, that way new APIs are OK.\n* Example: A user should be able to use an old client to connect to an upgraded cluster.\n\n#### Server-Server protocol compatibility \\[!toc]\n\n* Servers of different versions can co-exist in the same cluster.\n* The wire protocol between servers is compatible.\n* Workers for distributed tasks, such as replication and log splitting, can co-exist in the same cluster.\n* Dependent protocols (such as using ZK for coordination) will also not be changed.\n* Example: A user can perform a rolling upgrade.\n\n#### File format compatibility \\[!toc]\n\n* Support file formats backward and forward compatible\n* Example: File, ZK encoding, directory layout is upgraded automatically as part of an HBase upgrade. User can downgrade to the older version and everything will continue to work.\n\n#### Client API compatibility \\[!toc]\n\n* Allow changing or removing existing client APIs.\n* An API needs to be deprecated for a whole major version before we will change/remove it.\n  * An example: An API was deprecated in 2.0.1 and will be marked for deletion in 4.0.0. On the other hand, an API deprecated in 2.0.0 can be removed in 3.0.0.\n  * Occasionally mistakes are made and internal classes are marked with a higher access level than they should. In these rare circumstances, we will accelerate the deprecation schedule to the next major version (i.e., deprecated in 2.2.x, marked `IA.Private` 3.0.0). Such changes are communicated and explained via release note in Jira.\n* APIs available in a patch version will be available in all later patch versions. However, new APIs may be added which will not be available in earlier patch versions.\n* New APIs introduced in a patch version will only be added in a source compatible way: i.e. code that implements public APIs will continue to compile. [^1]\n  * Example: A user using a newly deprecated API does not need to modify application code with HBase API calls until the next major version. \\*\n\n#### Client Binary compatibility \\[!toc]\n\n* Client code written to APIs available in a given patch release can run unchanged (no recompilation needed) against the new jars of later patch versions.\n* Client code written to APIs available in a given patch release might not run against the old jars from an earlier patch version.\n  * Example: Old compiled client code will work unchanged with the new jars.\n* If a Client implements an HBase Interface, a recompile MAY be required upgrading to a newer minor version (See release notes for warning about incompatible changes). All effort will be made to provide a default implementation so this case should not arise.\n\n#### Server-Side Limited API compatibility (taken from Hadoop) \\[!toc]\n\n* Internal APIs are marked as Stable, Evolving, or Unstable\n* This implies binary compatibility for coprocessors and plugins (pluggable classes, including replication) as long as these are only using marked interfaces/classes.\n* Example: Old compiled Coprocessor, Filter, or Plugin code will work unchanged with the new jars.\n\n#### Dependency Compatibility \\[!toc]\n\n* An upgrade of HBase will not require an incompatible upgrade of a dependent project, except for Apache Hadoop.\n* An upgrade of HBase will not require an incompatible upgrade of the Java runtime.\n* Example: Upgrading HBase to a version that supports *Dependency Compatibility* won't require that you upgrade your Apache ZooKeeper service.\n* Example: If your current version of HBase supported running on JDK 8, then an upgrade to a version that supports *Dependency Compatibility* will also run on JDK 8.\n\n<Callout type=\"tip\">\n  Previously, we tried to maintain dependency compatibility for the underly Hadoop service but over\n  the last few years this has proven untenable. While the HBase project attempts to maintain support\n  for older versions of Hadoop, we drop the \"supported\" designator for minor versions that fail to\n  continue to see releases. Additionally, the Hadoop project has its own set of compatibility\n  guidelines, which means in some cases having to update to a newer supported minor release might\n  break some of our compatibility promises.\n</Callout>\n\n#### Operational Compatibility \\[!toc]\n\n* Metric changes\n* Behavioral changes of services\n* JMX APIs exposed via the `/jmx/` endpoint\n\n#### Summary \\[!toc]\n\n* A patch upgrade is a drop-in replacement. Any change that is not Java binary and source compatible would not be allowed. Downgrading versions within patch releases may not be compatible. [^2]\n* A minor upgrade requires no application/client code modification. Ideally it would be a drop-in replacement but client code, coprocessors, filters, etc might have to be recompiled if new jars are used.\n* A major upgrade allows the HBase community to make breaking changes.\n\n#### Compatibility Matrix: \\[!toc]\n\n|                                           |  Major | Minor | Patch |\n| ----------------------------------------- | :----: | :---: | :---: |\n| Client-Server wire Compatibility          |    N   |   Y   |   Y   |\n| Server-Server Compatibility               |    N   |   Y   |   Y   |\n| File Format Compatibility                 | N [^1] |   Y   |   Y   |\n| Client API Compatibility                  |    N   |   Y   |   Y   |\n| Client Binary Compatibility               |    N   |   N   |   Y   |\n| **Server-Side Limited API Compatibility** |        |       |       |\n| → Stable                                  |    N   |   Y   |   Y   |\n| → Evolving                                |    N   |   N   |   Y   |\n| → Unstable                                |    N   |   N   |   N   |\n| Dependency Compatibility                  |    N   |   Y   |   Y   |\n| Operational Compatibility                 |    N   |   N   |   Y   |\n\n<Callout type=\"warn\">\n  HBase 1.7.0 release violated client-server wire compatibility guarantees and was subsequently\n  withdrawn after the incompatibilities were reported and fixed in 1.7.1. If you are considering an\n  upgrade to 1.7.x line, see [Upgrading to 1.7.1+](/docs/upgrading/paths#upgrading-to-171).\n</Callout>\n\n## HBase API Surface\n\nHBase has a lot of API points, but for the compatibility matrix above, we differentiate between Client API, Limited Private API, and Private API. HBase uses [Apache Yetus Audience Annotations](https://yetus.apache.org/documentation/in-progress/interface-classification/) to guide downstream expectations for stability.\n\n* InterfaceAudience ([javadocs](https://yetus.apache.org/documentation/in-progress/javadocs/org/apache/yetus/audience/InterfaceAudience.html)): captures the intended audience, possible values include:\n  * Public: safe for end users and external projects\n  * LimitedPrivate: used for internals we expect to be pluggable, such as coprocessors\n  * Private: strictly for use within HBase itself Classes which are defined as `IA.Private` may be used as parameters or return values for interfaces which are declared `IA.LimitedPrivate`. Treat the `IA.Private` object as opaque; do not try to access its methods or fields directly.\n* InterfaceStability ([javadocs](https://yetus.apache.org/documentation/in-progress/javadocs/org/apache/yetus/audience/InterfaceStability.html)): describes what types of interface changes are permitted. Possible values include:\n  * Stable: the interface is fixed and is not expected to change\n  * Evolving: the interface may change in future minor versions\n  * Unstable: the interface may change at any time\n\nPlease keep in mind the following interactions between the `InterfaceAudience` and `InterfaceStability` annotations within the HBase project:\n\n* `IA.Public` classes are inherently stable and adhere to our stability guarantees relating to the type of upgrade (major, minor, or patch).\n* `IA.LimitedPrivate` classes should always be annotated with one of the given `InterfaceStability` values. If they are not, you should presume they are `IS.Unstable`.\n* `IA.Private` classes should be considered implicitly unstable, with no guarantee of stability between releases.\n\n### HBase Client API\n\nHBase Client API consists of all the classes or methods that are marked with InterfaceAudience.Public interface. All main classes in hbase-client and dependent modules have either InterfaceAudience.Public, InterfaceAudience.LimitedPrivate, or InterfaceAudience.Private marker. Not all classes in other modules (hbase-server, etc) have the marker. If a class is not annotated with one of these, it is assumed to be a InterfaceAudience.Private class.\n\n### HBase LimitedPrivate API\n\nLimitedPrivate annotation comes with a set of target consumers for the interfaces. Those consumers are coprocessors, phoenix, replication endpoint implementations or similar. At this point, HBase only guarantees source and binary compatibility for these interfaces between patch versions.\n\n### HBase Private API\n\nAll classes annotated with InterfaceAudience.Private or all classes that do not have the annotation are for HBase internal use only. The interfaces and method signatures can change at any point in time. If you are relying on a particular interface that is marked Private, you should open a jira to propose changing the interface to be Public or LimitedPrivate, or an interface exposed for this purpose.\n\n### Binary Compatibility\n\nWhen we say two HBase versions are compatible, we mean that the versions are wire and binary compatible. Compatible HBase versions means that clients can talk to compatible but differently versioned servers. It means too that you can just swap out the jars of one version and replace them with the jars of another, compatible version and all will just work. Unless otherwise specified, HBase point versions are (mostly) binary compatible. You can safely do rolling upgrades between binary compatible versions; i.e. across maintenance releases: e.g. from 1.4.4 to 1.4.6. See \"Does compatibility between versions also mean binary compatibility?\" discussion on the HBase dev mailing list.\n\n[^1]: Running an offline upgrade tool without downgrade might be needed. We will typically only support migrating data from major version X to major version X+1.\n\n[^2]: See [http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html](http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html).\n\n\n# YCSB (/docs/ycsb)\n[YCSB: The Yahoo! Cloud Serving Benchmark](https://github.com/brianfrankcooper/YCSB/) and HBase\n\nTODO: Describe how YCSB is poor for putting up a decent cluster load.\n\nTODO: Describe setup of YCSB for HBase. In particular, presplit your tables before you start a run. See [HBASE-4163 Create Split Strategy for YCSB Benchmark](https://issues.apache.org/jira/browse/HBASE-4163) for why and a little shell command for how to do it.\n\n\n# ZooKeeper (/docs/zookeeper)\nApache HBase by default manages a ZooKeeper \"cluster\" for you.\nIt will start and stop the ZooKeeper ensemble as part of the HBase start/stop process.\nYou can also manage the ZooKeeper ensemble independent of HBase and just point HBase at the cluster it should use.\nTo toggle HBase management of ZooKeeper, use the `HBASE_MANAGES_ZK` variable in *conf/hbase-env.sh*.\nThis variable, which defaults to `true`, tells HBase whether to start/stop the ZooKeeper ensemble servers as part of HBase start/stop.\n\nWhen HBase manages the ZooKeeper ensemble, you can specify ZooKeeper configuration directly in *conf/hbase-site.xml*.\nA ZooKeeper configuration option can be set as a property in the HBase *hbase-site.xml* XML configuration file by prefacing the ZooKeeper option name with `hbase.zookeeper.property`.\nFor example, the `clientPort` setting in ZooKeeper can be changed by setting the `hbase.zookeeper.property.clientPort` property.\nFor all default values used by HBase, including ZooKeeper configuration, see [hbase default configurations](/docs/configuration/default#configuration-default-hbase-default-configuration).\nLook for the `hbase.zookeeper.property` prefix.\nFor the full list of ZooKeeper configurations, see ZooKeeper's *zoo.cfg*.\nHBase does not ship with a *zoo.cfg* so you will need to browse the *conf* directory in an appropriate ZooKeeper download.\n\nYou must at least list the ensemble servers in *hbase-site.xml* using the `hbase.zookeeper.quorum` property.\nThis property defaults to a single ensemble member at `localhost` which is not suitable for a fully distributed HBase.\n(It binds to the local machine only and remote clients will not be able to connect).\n\n<Callout type=\"info\" title=\"How many ZooKeepers should I run?\">\n  You can run a ZooKeeper ensemble that comprises 1 node only but in production it is recommended that you run a ZooKeeper ensemble of 3, 5 or 7 machines; the more members an ensemble has, the more tolerant the ensemble is of host failures.\n  Also, run an odd number of machines.\n  In ZooKeeper, an even number of peers is supported, but it is normally not used because an even sized ensemble requires, proportionally, more peers to form a quorum than an odd sized ensemble requires.\n  For example, an ensemble with 4 peers requires 3 to form a quorum, while an ensemble with 5 also requires 3 to form a quorum.\n  Thus, an ensemble of 5 allows 2 peers to fail, and thus is more fault tolerant than the ensemble of 4, which allows only 1 down peer.\n\n  Give each ZooKeeper server around 1GB of RAM, and if possible, its own dedicated disk (A dedicated disk is the best thing you can do to ensure a performant ZooKeeper ensemble). For very heavily loaded clusters, run ZooKeeper servers on separate machines from RegionServers (DataNodes and TaskTrackers).\n</Callout>\n\nFor example, to have HBase manage a ZooKeeper quorum on nodes *rs\\{1,2,3,4,5}.example.com*, bound to port 2222 (the default is 2181) ensure `HBASE_MANAGE_ZK` is commented out or set to `true` in *conf/hbase-env.sh* and then edit *conf/hbase-site.xml* and set `hbase.zookeeper.property.clientPort` and `hbase.zookeeper.quorum`.\nYou should also set `hbase.zookeeper.property.dataDir` to other than the default as the default has ZooKeeper persist data under */tmp* which is often cleared on system restart.\nIn the example below we have ZooKeeper persist to */user/local/zookeeper*.\n\n```xml\n<configuration>\n  ...\n  <property>\n    <name>hbase.zookeeper.property.clientPort</name>\n    <value>2222</value>\n    <description>Property from ZooKeeper's config zoo.cfg.\n    The port at which the clients will connect.\n    </description>\n  </property>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>rs1.example.com,rs2.example.com,rs3.example.com,rs4.example.com,rs5.example.com</value>\n    <description>Comma separated list of servers in the ZooKeeper Quorum.\n    For example, \"host1.mydomain.com,host2.mydomain.com,host3.mydomain.com\".\n    By default this is set to localhost for local and pseudo-distributed modes\n    of operation. For a fully-distributed setup, this should be set to a full\n    list of ZooKeeper quorum servers. If HBASE_MANAGES_ZK is set in hbase-env.sh\n    this is the list of servers which we will start/stop ZooKeeper on.\n    </description>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.dataDir</name>\n    <value>/usr/local/zookeeper</value>\n    <description>Property from ZooKeeper's config zoo.cfg.\n    The directory where the snapshot is stored.\n    </description>\n  </property>\n  ...\n</configuration>\n```\n\n<Callout type=\"warn\" title=\"What version of ZooKeeper should I use?\">\n  The newer version, the better. ZooKeeper 3.4.x is required as of HBase 1.0.0\n</Callout>\n\n<Callout type=\"warn\" title=\"ZooKeeper Maintenance\">\n  Be sure to set up the data dir cleaner described under [ZooKeeper\n  Maintenance](https://zookeeper.apache.org/doc/r3.1.2/zookeeperAdmin.html#sc_maintenance) else you\n  could have 'interesting' problems a couple of months in; i.e. zookeeper could start dropping\n  sessions if it has to run through a directory of hundreds of thousands of logs which is wont to do\n  around leader reelection time — a process rare but run on occasion whether because a machine is\n  dropped or happens to hiccup.\n</Callout>\n\n## Using existing ZooKeeper ensemble\n\nTo point HBase at an existing ZooKeeper cluster, one that is not managed by HBase, set `HBASE_MANAGES_ZK` in *conf/hbase-env.sh* to false\n\n```bash\n  ...\n  # Tell HBase whether it should manage its own instance of ZooKeeper or not.\n  export HBASE_MANAGES_ZK=false\n```\n\nNext set ensemble locations and client port, if non-standard, in *hbase-site.xml*.\n\nWhen HBase manages ZooKeeper, it will start/stop the ZooKeeper servers as a part of the regular start/stop scripts.\nIf you would like to run ZooKeeper yourself, independent of HBase start/stop, you would do the following\n\n```bash\n${HBASE_HOME}/bin/hbase-daemons.sh {start,stop} zookeeper\n```\n\nNote that you can use HBase in this manner to spin up a ZooKeeper cluster, unrelated to HBase.\nJust make sure to set `HBASE_MANAGES_ZK` to `false` if you want it to stay up across HBase restarts so that when HBase shuts down, it doesn't take ZooKeeper down with it.\n\nFor more information about running a distinct ZooKeeper cluster, see the ZooKeeper [Getting Started Guide](https://zookeeper.apache.org/doc/current/zookeeperStarted.html).\nAdditionally, see the [ZooKeeper Wiki](https://cwiki.apache.org/confluence/display/HADOOP2/ZooKeeper+FAQ#ZooKeeperFAQ-7) or the [ZooKeeper documentation](https://zookeeper.apache.org/doc/r3.4.10/zookeeperAdmin.html#sc_zkMulitServerSetup) for more information on ZooKeeper sizing.\n\n## SASL Authentication with ZooKeeper\n\nNewer releases of Apache HBase (>= 0.92) will support connecting to a ZooKeeper Quorum that supports SASL authentication (which is available in ZooKeeper versions 3.4.0 or later).\n\nThis describes how to set up HBase to mutually authenticate with a ZooKeeper Quorum.\nZooKeeper/HBase mutual authentication ([HBASE-2418](https://issues.apache.org/jira/browse/HBASE-2418)) is required as part of a complete secure HBase configuration ([HBASE-3025](https://issues.apache.org/jira/browse/HBASE-3025)). For simplicity of explication, this section ignores additional configuration required (Secure HDFS and Coprocessor configuration). It's recommended to begin with an HBase-managed ZooKeeper configuration (as opposed to a standalone ZooKeeper quorum) for ease of learning.\n\n### Operating System Prerequisites\n\nYou need to have a working Kerberos KDC setup.\nFor each `$HOST` that will run a ZooKeeper server, you should have a principle `zookeeper/$HOST`.\nFor each such host, add a service key (using the `kadmin` or `kadmin.local` tool's `ktadd` command) for `zookeeper/$HOST` and copy this file to `$HOST`, and make it readable only to the user that will run zookeeper on `$HOST`.\nNote the location of this file, which we will use below as *\\$PATH\\_TO\\_ZOOKEEPER\\_KEYTAB*.\n\nSimilarly, for each `$HOST` that will run an HBase server (master or regionserver), you should have a principle: `hbase/$HOST`.\nFor each host, add a keytab file called *hbase.keytab* containing a service key for `hbase/$HOST`, copy this file to `$HOST`, and make it readable only to the user that will run an HBase service on `$HOST`.\nNote the location of this file, which we will use below as *\\$PATH\\_TO\\_HBASE\\_KEYTAB*.\n\nEach user who will be an HBase client should also be given a Kerberos principal.\nThis principal should usually have a password assigned to it (as opposed to, as with the HBase servers, a keytab file) which only this user knows.\nThe client's principal's `maxrenewlife` should be set so that it can be renewed enough so that the user can complete their HBase client processes.\nFor example, if a user runs a long-running HBase client process that takes at most 3 days, we might create this user's principal within `kadmin` with: `addprinc -maxrenewlife 3days`.\nThe ZooKeeper client and server libraries manage their own ticket refreshment by running threads that wake up periodically to do the refreshment.\n\nOn each host that will run an HBase client (e.g. `hbase shell`), add the following file to the HBase home directory's *conf* directory:\n\n```java\nClient {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useKeyTab=false\n  useTicketCache=true;\n};\n```\n\nWe'll refer to this JAAS configuration file as *\\$CLIENT\\_CONF* below.\n\n### HBase-managed ZooKeeper Configuration\n\nOn each node that will run a zookeeper, a master, or a regionserver, create a [JAAS](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jgss/tutorials/LoginConfigFile.html) configuration file in the conf directory of the node's *HBASE\\_HOME* directory that looks like the following:\n\n```java\nServer {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useKeyTab=true\n  keyTab=\"$PATH_TO_ZOOKEEPER_KEYTAB\"\n  storeKey=true\n  useTicketCache=false\n  principal=\"zookeeper/$HOST\";\n};\nClient {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useKeyTab=true\n  useTicketCache=false\n  keyTab=\"$PATH_TO_HBASE_KEYTAB\"\n  principal=\"hbase/$HOST\";\n};\n```\n\nwhere the *\\$PATH\\_TO\\_HBASE\\_KEYTAB* and *\\$PATH\\_TO\\_ZOOKEEPER\\_KEYTAB* files are what you created above, and `$HOST` is the hostname for that node.\n\nThe `Server` section will be used by the ZooKeeper quorum server, while the `Client` section will be used by the HBase master and regionservers.\nThe path to this file should be substituted for the text *\\$HBASE\\_SERVER\\_CONF* in the *hbase-env.sh* listing below.\n\nThe path to this file should be substituted for the text *\\$CLIENT\\_CONF* in the *hbase-env.sh* listing below.\n\nModify your *hbase-env.sh* to include the following:\n\n```bash\nexport HBASE_OPTS=\"-Djava.security.auth.login.config=$CLIENT_CONF\"\nexport HBASE_MANAGES_ZK=true\nexport HBASE_ZOOKEEPER_OPTS=\"-Djava.security.auth.login.config=$HBASE_SERVER_CONF\"\nexport HBASE_MASTER_OPTS=\"-Djava.security.auth.login.config=$HBASE_SERVER_CONF\"\nexport HBASE_REGIONSERVER_OPTS=\"-Djava.security.auth.login.config=$HBASE_SERVER_CONF\"\n```\n\nwhere *\\$HBASE\\_SERVER\\_CONF* and *\\$CLIENT\\_CONF* are the full paths to the JAAS configuration files created above.\n\nModify your *hbase-site.xml* on each node that will run zookeeper, master or regionserver to contain:\n\n```xml\n<configuration>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>$ZK_NODES</value>\n  </property>\n  <property>\n    <name>hbase.cluster.distributed</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.authProvider.1</name>\n    <value>org.apache.zookeeper.server.auth.SASLAuthenticationProvider</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.kerberos.removeHostFromPrincipal</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.kerberos.removeRealmFromPrincipal</name>\n    <value>true</value>\n  </property>\n</configuration>\n```\n\nwhere `$ZK_NODES` is the comma-separated list of hostnames of the ZooKeeper Quorum hosts.\n\nStart your hbase cluster by running one or more of the following set of commands on the appropriate hosts:\n\n```bash\nbin/hbase zookeeper start\nbin/hbase master start\nbin/hbase regionserver start\n```\n\n### External ZooKeeper Configuration\n\nAdd a JAAS configuration file that looks like:\n\n```java\nClient {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useKeyTab=true\n  useTicketCache=false\n  keyTab=\"$PATH_TO_HBASE_KEYTAB\"\n  principal=\"hbase/$HOST\";\n};\n```\n\nwhere the *\\$PATH\\_TO\\_HBASE\\_KEYTAB* is the keytab created above for HBase services to run on this host, and `$HOST` is the hostname for that node.\nPut this in the HBase home's configuration directory.\nWe'll refer to this file's full pathname as *\\$HBASE\\_SERVER\\_CONF* below.\n\nModify your hbase-env.sh to include the following:\n\n```bash\nexport HBASE_OPTS=\"-Djava.security.auth.login.config=$CLIENT_CONF\"\nexport HBASE_MANAGES_ZK=false\nexport HBASE_MASTER_OPTS=\"-Djava.security.auth.login.config=$HBASE_SERVER_CONF\"\nexport HBASE_REGIONSERVER_OPTS=\"-Djava.security.auth.login.config=$HBASE_SERVER_CONF\"\n```\n\nModify your *hbase-site.xml* on each node that will run a master or regionserver to contain:\n\n```xml\n<configuration>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>$ZK_NODES</value>\n  </property>\n  <property>\n    <name>hbase.cluster.distributed</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.authProvider.1</name>\n    <value>org.apache.zookeeper.server.auth.SASLAuthenticationProvider</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.kerberos.removeHostFromPrincipal</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.kerberos.removeRealmFromPrincipal</name>\n    <value>true</value>\n  </property>\n</configuration>\n```\n\nwhere `$ZK_NODES` is the comma-separated list of hostnames of the ZooKeeper Quorum hosts.\n\nAlso on each of these hosts, create a JAAS configuration file containing:\n\n```java\nServer {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useKeyTab=true\n  keyTab=\"$PATH_TO_ZOOKEEPER_KEYTAB\"\n  storeKey=true\n  useTicketCache=false\n  principal=\"zookeeper/$HOST\";\n};\n```\n\nwhere `$HOST` is the hostname of each Quorum host.\nWe will refer to the full pathname of this file as *\\$ZK\\_SERVER\\_CONF* below.\n\nStart your ZooKeepers on each ZooKeeper Quorum host with:\n\n```bash\nSERVER_JVMFLAGS=\"-Djava.security.auth.login.config=$ZK_SERVER_CONF\" bin/zkServer start\n```\n\nStart your HBase cluster by running one or more of the following set of commands on the appropriate nodes:\n\n```bash\nbin/hbase master start\nbin/hbase regionserver start\n```\n\n### ZooKeeper Server Authentication Log Output\n\nIf the configuration above is successful, you should see something similar to the following in your ZooKeeper server logs:\n\n```\n11/12/05 22:43:39 INFO zookeeper.Login: successfully logged in.\n11/12/05 22:43:39 INFO server.NIOServerCnxnFactory: binding to port 0.0.0.0/0.0.0.0:2181\n11/12/05 22:43:39 INFO zookeeper.Login: TGT refresh thread started.\n11/12/05 22:43:39 INFO zookeeper.Login: TGT valid starting at:        Mon Dec 05 22:43:39 UTC 2011\n11/12/05 22:43:39 INFO zookeeper.Login: TGT expires:                  Tue Dec 06 22:43:39 UTC 2011\n11/12/05 22:43:39 INFO zookeeper.Login: TGT refresh sleeping until: Tue Dec 06 18:36:42 UTC 2011\n..\n11/12/05 22:43:59 INFO auth.SaslServerCallbackHandler:\n  Successfully authenticated client: authenticationID=hbase/ip-10-166-175-249.us-west-1.compute.internal@HADOOP.LOCALDOMAIN;\n  authorizationID=hbase/ip-10-166-175-249.us-west-1.compute.internal@HADOOP.LOCALDOMAIN.\n11/12/05 22:43:59 INFO auth.SaslServerCallbackHandler: Setting authorizedID: hbase\n11/12/05 22:43:59 INFO server.ZooKeeperServer: adding SASL authorization for authorizationID: hbase\n```\n\n### ZooKeeper Client Authentication Log Output\n\nOn the ZooKeeper client side (HBase master or regionserver), you should see something similar to the following:\n\n```\n11/12/05 22:43:59 INFO zookeeper.ZooKeeper: Initiating client connection, connectString=ip-10-166-175-249.us-west-1.compute.internal:2181 sessionTimeout=180000 watcher=master:60000\n11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Opening socket connection to server /10.166.175.249:2181\n11/12/05 22:43:59 INFO zookeeper.RecoverableZooKeeper: The identifier of this process is 14851@ip-10-166-175-249\n11/12/05 22:43:59 INFO zookeeper.Login: successfully logged in.\n11/12/05 22:43:59 INFO client.ZooKeeperSaslClient: Client will use GSSAPI as SASL mechanism.\n11/12/05 22:43:59 INFO zookeeper.Login: TGT refresh thread started.\n11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Socket connection established to ip-10-166-175-249.us-west-1.compute.internal/10.166.175.249:2181, initiating session\n11/12/05 22:43:59 INFO zookeeper.Login: TGT valid starting at:        Mon Dec 05 22:43:59 UTC 2011\n11/12/05 22:43:59 INFO zookeeper.Login: TGT expires:                  Tue Dec 06 22:43:59 UTC 2011\n11/12/05 22:43:59 INFO zookeeper.Login: TGT refresh sleeping until: Tue Dec 06 18:30:37 UTC 2011\n11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Session establishment complete on server ip-10-166-175-249.us-west-1.compute.internal/10.166.175.249:2181, sessionid = 0x134106594320000, negotiated timeout = 180000\n```\n\n### Configuration from Scratch\n\nThis has been tested on the current standard Amazon Linux AMI.\nFirst setup KDC and principals as described above.\nNext checkout code and run a sanity check.\n\n```bash\ngit clone https://gitbox.apache.org/repos/asf/hbase.git\ncd hbase\nmvn clean test -Dtest=TestZooKeeperACL\n```\n\nThen configure HBase as described above.\nManually edit target/cached\\_classpath.txt (see below):\n\n```bash\nbin/hbase zookeeper &\nbin/hbase master &\nbin/hbase regionserver &\n```\n\n### Future improvements\n\n#### Fix target/cached\\_classpath.txt\n\nYou must override the standard hadoop-core jar file from the `target/cached_classpath.txt` file with the version containing the HADOOP-7070 fix.\nYou can use the following script to do this:\n\n```bash\necho `find ~/.m2 -name \"*hadoop-core*7070*SNAPSHOT.jar\"` ':' `cat target/cached_classpath.txt` | sed 's/ //g' > target/tmp.txt\nmv target/tmp.txt target/cached_classpath.txt\n```\n\n#### Set JAAS configuration programmatically\n\nThis would avoid the need for a separate Hadoop jar that fixes [HADOOP-7070](https://issues.apache.org/jira/browse/HADOOP-7070).\n\n#### Elimination of `kerberos.removeHostFromPrincipal` and`kerberos.removeRealmFromPrincipal`\n\n## TLS connection to ZooKeeper\n\nApache ZooKeeper also supports SSL/TLS client connections to encrypt the data in transmission. This is particularly\nuseful when the ZooKeeper ensemble is running on a host different from HBase and data has to be sent\nover the wire.\n\n### Java system properties\n\nThe ZooKeeper client supports the following Java system properties to set up TLS connection:\n\n```properties\nzookeeper.client.secure=true\nzookeeper.clientCnxnSocket=org.apache.zookeeper.ClientCnxnSocketNetty\nzookeeper.ssl.keyStore.location=\"/path/to/your/keystore\"\nzookeeper.ssl.keyStore.password=\"keystore_password\"\nzookeeper.ssl.trustStore.location=\"/path/to/your/truststore\"\nzookeeper.ssl.trustStore.password=\"truststore_password\"\n```\n\nSetting up KeyStore is optional and only required if ZooKeeper server requests for client certificate.\n\nFind more detailed information in the [ZooKeeper SSL User Guide](https://cwiki.apache.org/confluence/display/ZOOKEEPER/ZooKeeper+SSL+User+Guide).\n\n<Callout type=\"warn\">\n  These're standard Java properties which should be set in the HBase command line and are effective\n  in the entire Java process. All ZooKeeper clients running in the same process will pick them up\n  including co-processors.\n</Callout>\n\n<Callout type=\"info\">\n  Since ZooKeeper version 3.8 the following two properties are useful to store the keystore and\n  truststore passwords in protected text files rather than exposing them in the command line.\n</Callout>\n\n```properties\nzookeeper.ssl.keyStore.passwordPath=/path/to/secure/file\nzookeeper.ssl.trustStore.passwordPath=/path/to/secure/file\n```\n\n### HBase configuration\n\nBy adding [HBASE-28038](https://issues.apache.org/jira/browse/HBASE-28038), ZooKeeper client TLS\nsettings are also available in *hbase-site.xml* via `hbase.zookeeper.property` prefix. In contrast\nto Java system properties this could be more convenient under some circumstances.\n\n```xml\n<configuration>\n  <property>\n    <name>hbase.zookeeper.property.client.secure</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.clientCnxnSocket</name>\n    <value>org.apache.zookeeper.ClientCnxnSocketNetty</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.ssl.trustStore.location</name>\n    <value>/path/to/your/truststore</value>\n  </property>\n  ...\n</configuration>\n```\n\n<Callout type=\"info\">\n  These settings are eventually transformed into Java system properties, it's just a convenience\n  feature. So, the same rules that mentioned in the previous point, applies to them as well.\n</Callout>\n\n\n# Apache HBase Documentation (/docs/single-page)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Preface\n\nHerein you will find either the definitive documentation on an HBase topic as of its\nstanding when the referenced HBase version shipped, or it will point to the location\nin [Javadoc](https://hbase.apache.org/apidocs/index.html) or\n[JIRA](https://issues.apache.org/jira/browse/HBASE) where the pertinent information can be found.\n\n## About This Guide\n\nThis reference guide is a work in progress. The source for this guide can be found in the\n*hbase-website/app/pages/\\_docs/docs/\\_mdx/(multi-page)* directory of the HBase source. This reference guide is marked up\nusing [MDX](https://mdxjs.com/) (just extended markdown) powered by [Fumadocs](https://fumadocs.dev/) from which the finished guide is generated as part of the\n'site' build target. Run\n\n```bash\nmvn site\n```\n\nto generate this documentation.\nAmendments and improvements to the documentation are welcomed.\nClick\n[this link](https://issues.apache.org/jira/secure/CreateIssueDetails!init.jspa?pid=12310753\\&issuetype=1\\&components=12312132\\&summary=SHORT+DESCRIPTION)\nto file a new documentation bug against Apache HBase with some values pre-selected.\n\n## Contributing to the Documentation\n\nFor an overview and suggestions to get started contributing to the documentation,\nsee the [relevant section later in this documentation](/docs/contributing-to-documentation).\n\n## Heads-up if this is your first foray into the world of distributed computing...\n\nIf this is your first foray into the wonderful world of Distributed Computing, then you are in for some interesting times.\nFirst off, distributed systems are hard; making a distributed system hum requires a disparate skillset that spans systems (hardware and software) and networking.\n\nYour cluster's operation can hiccup because of any of a myriad set of reasons from bugs in HBase itself through misconfigurations — misconfiguration of HBase but also operating system misconfigurations — through to hardware problems whether it be a bug in your network card drivers or an underprovisioned RAM bus (to mention two recent examples of hardware issues that manifested as \"HBase is slow\"). You will also need to do a recalibration if up to this your computing has been bound to a single box.\nHere is one good starting point: [Fallacies of Distributed Computing](http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing).\n\nThat said, you are welcome.<br />\nIt's a fun place to be.<br />\nYours, the HBase Community.\n\n## Reporting Bugs\n\nPlease use [JIRA](https://issues.apache.org/jira/browse/hbase) to report non-security-related bugs.\n\nTo protect existing HBase installations from new vulnerabilities, please **do not** use JIRA to report security-related bugs. Instead, send your report to the mailing list [private@hbase.apache.org](mailto:private@hbase.apache.org), which allows anyone to send messages, but restricts who can read them. Someone on that list will contact you to follow up on your report.\n\n## Support and Testing Expectations\n\nThe phrases *supported*, *not supported*, *tested*, and *not tested* occur several\nplaces throughout this guide. In the interest of clarity, here is a brief explanation\nof what is generally meant by these phrases, in the context of HBase.\n\n<Callout type=\"info\">\n  Commercial technical support for Apache HBase is provided by many Hadoop vendors. This is not the\n  sense in which the term *support* is used in the context of the Apache HBase project. The Apache\n  HBase team assumes no responsibility for your HBase clusters, your configuration, or your data.\n</Callout>\n\n### Supported\n\nIn the context of Apache HBase, *supported* means that HBase is designed to work\nin the way described, and deviation from the defined behavior or functionality should\nbe reported as a bug.\n\n### Not Supported\n\nIn the context of Apache HBase, *not supported* means that a use case or use pattern\nis not expected to work and should be considered an antipattern. If you think this\ndesignation should be reconsidered for a given feature or use pattern, file a JIRA\nor start a discussion on one of the mailing lists.\n\n### Tested\n\nIn the context of Apache HBase, *tested* means that a feature is covered by unit\nor integration tests, and has been proven to work as expected.\n\n### Not Tested\n\nIn the context of Apache HBase, *not tested* means that a feature or use pattern\nmay or may not work in a given way, and may or may not corrupt your data or cause\noperational issues. It is an unknown, and there are no guarantees. If you can provide\nproof that a feature designated as *not tested* does work in a given way, please\nsubmit the tests and/or the metrics so that other users can gain certainty about\nsuch features or use patterns.\n\n***\n\n# Getting Started\n\n## Quick Start - Standalone HBase\n\nThis section describes the setup of a single-node standalone HBase. A *standalone* instance has all HBase daemons — the Master, RegionServers, and ZooKeeper — running in a single JVM persisting to the local filesystem. It is our most basic deploy profile. We will show you how to create a table in HBase using the `hbase shell` CLI, insert rows into the table, perform put and scan operations against the table, enable or disable the table, and start and stop HBase.\n\nApart from downloading HBase, this procedure should take less than 10 minutes.\n\n## JDK Version Requirements\n\nHBase requires that a JDK be installed. See [Java](/docs/configuration/basic-prerequisites#configuration-basic-prerequisites-java) for information about supported JDK versions.\n\n## Get Started with HBase\n\n### Procedure: Download, Configure, and Start HBase in Standalone Mode\n\n<Steps>\n  <Step>\n    Choose a download site from this list of [Apache Download Mirrors](https://www.apache.org/dyn/closer.lua/hbase/). Click on the suggested top link. This will take you to a mirror of *HBase Releases*. Click on the folder named *stable* and then download the binary file that ends in *.tar.gz* to your local filesystem. Do not download the file ending in *src.tar.gz* for now.\n  </Step>\n\n  <Step>\n    Extract the downloaded file, and change to the newly-created directory.\n\n    ```bash\n    tar xzvf <FILE_NAME>.tar.gz\n    cd <DIRECTORY_NAME>\n    ```\n  </Step>\n\n  <Step>\n    You must set the `JAVA_HOME` environment variable before starting HBase. To make this easier, HBase lets you set it within the *conf/hbase-env.sh* file. You must locate where Java is installed on your machine, and one way to find this is by using the *whereis java* command. Once you have the location, edit the *conf/hbase-env.sh* file and uncomment the line starting with *#export JAVA\\_HOME=*, and then set it to your Java installation path.\n\n    *Example extract from *hbase-env.sh* where *JAVA\\_HOME* is set*\n\n    ```bash\n    # Set environment variables here.\n    # The java implementation to use.\n    export JAVA_HOME=/usr/jdk64/jdk1.8.0_112\n    ```\n  </Step>\n\n  <Step>\n    The *bin/start-hbase.sh* script is provided as a convenient way to start HBase. Issue the command, and if all goes well, a message is logged to standard output showing that HBase started successfully. You can use the `jps` command to verify that you have one running process called `HMaster`. In standalone mode HBase runs all daemons within this single JVM, i.e. the HMaster, a single HRegionServer, and the ZooKeeper daemon. Go to *[http://localhost:16010](http://localhost:16010)* to view the HBase Web UI.\n  </Step>\n</Steps>\n\n### Procedure: Use HBase For the First Time\n\n<Steps>\n  <Step>\n    #### Connect to HBase\n\n    Connect to your running instance of HBase using the `hbase shell` command, located in the *bin/* directory of your HBase install. In this example, some usage and version information that is printed when you start HBase Shell has been omitted. The HBase Shell prompt ends with a `>` character.\n\n    ```bash\n    $ ./bin/hbase shell\n    hbase(main):001:0>\n    ```\n  </Step>\n\n  <Step>\n    #### Display HBase Shell Help Text\n\n    Type `help` and press Enter, to display some basic usage information for HBase Shell, as well as several example commands. Notice that table names, rows, columns all must be enclosed in quote characters.\n  </Step>\n\n  <Step>\n    #### Create a table\n\n    Use the `create` command to create a new table. You must specify the table name and the ColumnFamily name.\n\n    ```bash\n    hbase(main):001:0> create 'test', 'cf'\n    0 row(s) in 0.4170 seconds\n\n    => Hbase::Table - test\n    ```\n  </Step>\n\n  <Step>\n    #### List Information About your Table\n\n    Use the `list` command to confirm your table exists\n\n    ```bash\n    hbase(main):002:0> list 'test'\n    TABLE\n    test\n    1 row(s) in 0.0180 seconds\n\n    => [\"test\"]\n    ```\n\n    Now use the `describe` command to see details, including configuration defaults\n\n    ```bash\n    hbase(main):003:0> describe 'test'\n    Table test is ENABLED\n    test\n    COLUMN FAMILIES DESCRIPTION\n    {NAME => 'cf', VERSIONS => '1', EVICT_BLOCKS_ON_CLOSE => 'false', NEW_VERSION_BEHAVIOR => 'false', KEEP_DELETED_CELLS => 'FALSE', CACHE_DATA_ON_WRITE =>\n    'false', DATA_BLOCK_ENCODING => 'NONE', TTL => 'FOREVER', MIN_VERSIONS => '0', REPLICATION_SCOPE => '0', BLOOMFILTER => 'ROW', CACHE_INDEX_ON_WRITE => 'f\n    alse', IN_MEMORY => 'false', CACHE_BLOOMS_ON_WRITE => 'false', PREFETCH_BLOCKS_ON_OPEN => 'false', COMPRESSION => 'NONE', BLOCKCACHE => 'true', BLOCKSIZE\n     => '65536'}\n    1 row(s)\n    Took 0.9998 seconds\n    ```\n  </Step>\n\n  <Step>\n    #### Put data into your table\n\n    To put data into your table, use the `put` command.\n\n    ```bash\n    hbase(main):003:0> put 'test', 'row1', 'cf:a', 'value1'\n    0 row(s) in 0.0850 seconds\n\n    hbase(main):004:0> put 'test', 'row2', 'cf:b', 'value2'\n    0 row(s) in 0.0110 seconds\n\n    hbase(main):005:0> put 'test', 'row3', 'cf:c', 'value3'\n    0 row(s) in 0.0100 seconds\n    ```\n\n    Here, we insert three values, one at a time. The first insert is at `row1`, column `cf:a`, with a value of `value1`. Columns in HBase are comprised of a column family prefix, `cf` in this example, followed by a colon and then a column qualifier suffix, `a` in this case.\n  </Step>\n\n  <Step>\n    #### Scan the table for all data at once\n\n    One of the ways to get data from HBase is to scan. Use the `scan` command to scan the table for data. You can limit your scan, but for now, all data is fetched.\n\n    ```bash\n    hbase(main):006:0> scan 'test'\n    ROW                                      COLUMN+CELL\n     row1                                    column=cf:a, timestamp=1421762485768, value=value1\n     row2                                    column=cf:b, timestamp=1421762491785, value=value2\n     row3                                    column=cf:c, timestamp=1421762496210, value=value3\n    3 row(s) in 0.0230 seconds\n    ```\n  </Step>\n\n  <Step>\n    #### Get a single row of data\n\n    To get a single row of data at a time, use the `get` command.\n\n    ```bash\n    hbase(main):007:0> get 'test', 'row1'\n    COLUMN                                   CELL\n     cf:a                                    timestamp=1421762485768, value=value1\n    1 row(s) in 0.0350 seconds\n    ```\n  </Step>\n\n  <Step>\n    #### Disable a table\n\n    If you want to delete a table or change its settings, as well as in some other situations, you need to disable the table first, using the `disable` command. You can re-enable it using the `enable` command.\n\n    ```bash\n    hbase(main):008:0> disable 'test'\n    0 row(s) in 1.1820 seconds\n\n    hbase(main):009:0> enable 'test'\n    0 row(s) in 0.1770 seconds\n    ```\n\n    Disable the table again if you tested the `enable` command above:\n\n    ```bash\n    hbase(main):010:0> disable 'test'\n    0 row(s) in 1.1820 seconds\n    ```\n  </Step>\n\n  <Step>\n    #### Drop the table\n\n    To drop (delete) a table, use the `drop` command.\n\n    ```bash\n    hbase(main):011:0> drop 'test'\n    0 row(s) in 0.1370 seconds\n    ```\n  </Step>\n\n  <Step>\n    #### Exit the HBase Shell\n\n    To exit the HBase Shell and disconnect from your cluster, use the `quit` command. HBase is still running in the background.\n  </Step>\n</Steps>\n\n### Procedure: Stop HBase\n\n<Steps>\n  <Step>\n    In the same way that the *bin/start-hbase.sh* script is provided to conveniently start all HBase daemons, the *bin/stop-hbase.sh* script stops them.\n\n    ```bash\n    $ ./bin/stop-hbase.sh\n    stopping hbase....................\n    ```\n  </Step>\n\n  <Step>\n    After issuing the command, it can take several minutes for the processes to shut down. Use the `jps` to be sure that the HMaster and HRegionServer processes are shut down.\n  </Step>\n</Steps>\n\nThe above has shown you how to start and stop a standalone instance of HBase. In the next sections we give a quick overview of other modes of hbase deploy.\n\n## Pseudo-Distributed for Local Testing\n\nAfter working your way through [quickstart](/docs/getting-started#quick-start---standalone-hbase) standalone mode, you can re-configure HBase to run in pseudo-distributed mode. Pseudo-distributed mode means that HBase still runs completely on a single host, but each HBase daemon (HMaster, HRegionServer, and ZooKeeper) runs as a separate process: in standalone mode all daemons ran in one jvm process/instance. By default, unless you configure the `hbase.rootdir` property as described in [quickstart](/docs/getting-started#quick-start---standalone-hbase), your data is still stored in */tmp/*. In this walk-through, we store your data in HDFS instead, assuming you have HDFS available. You can skip the HDFS configuration to continue storing your data in the local filesystem.\n\n<Callout type=\"info\">\n  This procedure assumes that you have configured Hadoop and HDFS on your local system and/or a\n  remote system, and that they are running and available. It also assumes you are using Hadoop 2.\n  The guide on [Setting up a Single Node\n  Cluster](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html)\n  in the Hadoop documentation is a good starting point.\n</Callout>\n\n<Steps>\n  <Step>\n    #### Stop HBase if it is running\n\n    If you have just finished [quickstart](/docs/getting-started#quick-start---standalone-hbase) and HBase is still running, stop it. This procedure will create a totally new directory where HBase will store its data, so any databases you created before will be lost.\n  </Step>\n\n  <Step>\n    #### Configure HBase\n\n    Edit the *hbase-site.xml* configuration. First, add the following property which directs HBase to run in distributed mode, with one JVM instance per daemon.\n\n    ```xml\n    <property>\n      <name>hbase.cluster.distributed</name>\n      <value>true</value>\n    </property>\n    ```\n\n    Next, add a configuration for `hbase.rootdir`, pointing to the address of your HDFS instance, using the `hdfs:////` URI syntax. In this example, HDFS is running on the localhost at port 8020.\n\n    ```xml\n    <property>\n      <name>hbase.rootdir</name>\n      <value>hdfs://localhost:9000/hbase</value>\n    </property>\n    ```\n\n    You do not need to create the directory in HDFS. HBase will do this for you. If you create the directory, HBase will attempt to do a migration, which is not what you want.\n\n    Finally, remove existing configuration for `hbase.tmp.dir` and `hbase.unsafe.stream.capability.enforce`.\n  </Step>\n\n  <Step>\n    #### Start HBase\n\n    Use the *bin/start-hbase.sh* command to start HBase. If your system is configured correctly, the `jps` command should show the HMaster and HRegionServer processes running.\n  </Step>\n\n  <Step>\n    #### Check the HBase directory in HDFS\n\n    If everything worked correctly, HBase created its directory in HDFS. In the configuration above, it is stored in */hbase/* on HDFS. You can use the `hadoop fs` command in Hadoop's *bin/* directory to list this directory.\n\n    ```bash\n    $ ./bin/hadoop fs -ls /hbase\n    Found 7 items\n    drwxr-xr-x   - hbase users          0 2014-06-25 18:58 /hbase/.tmp\n    drwxr-xr-x   - hbase users          0 2014-06-25 21:49 /hbase/WALs\n    drwxr-xr-x   - hbase users          0 2014-06-25 18:48 /hbase/corrupt\n    drwxr-xr-x   - hbase users          0 2014-06-25 18:58 /hbase/data\n    -rw-r--r--   3 hbase users         42 2014-06-25 18:41 /hbase/hbase.id\n    -rw-r--r--   3 hbase users          7 2014-06-25 18:41 /hbase/hbase.version\n    drwxr-xr-x   - hbase users          0 2014-06-25 21:49 /hbase/oldWALs\n    ```\n  </Step>\n\n  <Step>\n    #### Create a table and populate it with data\n\n    You can use the HBase Shell to create a table, populate it with data, scan and get values from it, using the same procedure as in [shell exercises](/docs/getting-started#procedure-use-hbase-for-the-first-time).\n  </Step>\n\n  <Step>\n    #### Start and stop a backup HBase Master (HMaster) server\n\n    <Callout type=\"info\">\n      Running multiple HMaster instances on the same hardware does not make sense in a production\n      environment, in the same way that running a pseudo-distributed cluster does not make sense for\n      production. This step is offered for testing and learning purposes only.\n    </Callout>\n\n    The HMaster server controls the HBase cluster. You can start up to 9 backup HMaster servers, which makes 10 total HMasters, counting the primary. To start a backup HMaster, use the `local-master-backup.sh`. For each backup master you want to start, add a parameter representing the port offset for that master. Each HMaster uses two ports (16000 and 16010 by default). The port offset is added to these ports, so using an offset of 2, the backup HMaster would use ports 16002 and 16012. The following command starts 3 backup servers using ports 16002/16012, 16003/16013, and 16005/16015.\n\n    ```bash\n    ./bin/local-master-backup.sh start 2 3 5\n    ```\n\n    To kill a backup master without killing the entire cluster, you need to find its process ID (PID). The PID is stored in a file with a name like */tmp/hbase-USER-X-master.pid*. The only contents of the file is the PID. You can use the `kill -9` command to kill that PID. The following command will kill the master with port offset 1, but leave the cluster running:\n\n    ```bash\n    cat /tmp/hbase-testuser-1-master.pid |xargs kill -9\n    ```\n  </Step>\n\n  <Step>\n    #### Start and stop additional RegionServers\n\n    The HRegionServer manages the data in its StoreFiles as directed by the HMaster. Generally, one HRegionServer runs per node in the cluster. Running multiple HRegionServers on the same system can be useful for testing in pseudo-distributed mode. The `local-regionservers.sh` command allows you to run multiple RegionServers. It works in a similar way to the `local-master-backup.sh` command, in that each parameter you provide represents the port offset for an instance. Each RegionServer requires two ports, and the default ports are 16020 and 16030. Since HBase version 1.1.0, HMaster doesn't use region server ports, this leaves 10 ports (16020 to 16029 and 16030 to 16039) to be used for RegionServers. For supporting additional RegionServers, set environment variables HBASE\\_RS\\_BASE\\_PORT and HBASE\\_RS\\_INFO\\_BASE\\_PORT to appropriate values before running script `local-regionservers.sh`. e.g. With values 16200 and 16300 for base ports, 99 additional RegionServers can be supported, on a server. The following command starts four additional RegionServers, running on sequential ports starting at 16022/16032 (base ports 16020/16030 plus 2).\n\n    ```bash\n    ./bin/local-regionservers.sh start 2 3 4 5\n    ```\n\n    To stop a RegionServer manually, use the `local-regionservers.sh` command with the `stop` parameter and the offset of the server to stop.\n\n    ```bash\n    ./bin/local-regionservers.sh stop 3\n    ```\n  </Step>\n\n  <Step>\n    #### Stop HBase\n\n    You can stop HBase the same way as in the [quickstart](/docs/getting-started#quick-start---standalone-hbase) procedure, using the *bin/stop-hbase.sh* command.\n  </Step>\n</Steps>\n\n## Fully Distributed for Production\n\nIn reality, you need a fully-distributed configuration to fully test HBase and to use it in real-world scenarios. In a distributed configuration, the cluster contains multiple nodes, each of which runs one or more HBase daemon. These include primary and backup Master instances, multiple ZooKeeper nodes, and multiple RegionServer nodes.\n\nThis advanced quickstart adds two more nodes to your cluster. The architecture will be as follows:\n\n| Node Name          | Master | ZooKeeper | RegionServer |\n| ------------------ | ------ | --------- | ------------ |\n| node-a.example.com | yes    | yes       | no           |\n| node-b.example.com | backup | yes       | yes          |\n| node-c.example.com | no     | yes       | yes          |\n\nDistributed Cluster Demo Architecture\n\nThis quickstart assumes that each node is a virtual machine and that they are all on the same network. It builds upon the previous quickstart, [Pseudo-Distributed for Local Testing](/docs/getting-started#pseudo-distributed-for-local-testing), assuming that the system you configured in that procedure is now `node-a`. Stop HBase on `node-a` before continuing.\n\n<Callout type=\"info\">\n  Be sure that all the nodes have full access to communicate, and that no firewall rules are in\n  place which could prevent them from talking to each other. If you see any errors like `no route to\n    host`, check your firewall.\n</Callout>\n\n### Procedure: Configure Passwordless SSH Access\n\n`node-a` needs to be able to log into `node-b` and `node-c` (and to itself) in order to start the daemons. The easiest way to accomplish this is to use the same username on all hosts, and configure password-less SSH login from `node-a` to each of the others.\n\n<Steps>\n  <Step>\n    #### On `node-a`, generate a key pair\n\n    While logged in as the user who will run HBase, generate a SSH key pair, using the following command:\n\n    ```bash\n    ssh-keygen -t rsa\n    ```\n\n    If the command succeeds, the location of the key pair is printed to standard output. The default name of the public key is *id\\_rsa.pub*.\n  </Step>\n\n  <Step>\n    #### Create the directory that will hold the shared keys on the other nodes\n\n    On `node-b` and `node-c`, log in as the HBase user and create a *.ssh/* directory in the user's home directory, if it does not already exist. If it already exists, be aware that it may already contain other keys.\n  </Step>\n\n  <Step>\n    #### Copy the public key to the other nodes\n\n    Securely copy the public key from `node-a` to each of the nodes, by using the `scp` or some other secure means. On each of the other nodes, create a new file called *.ssh/authorized\\_keys* *if it does not already exist*, and append the contents of the *id\\_rsa.pub* file to the end of it. Note that you also need to do this for `node-a` itself.\n\n    ```bash\n    cat id_rsa.pub >> ~/.ssh/authorized_keys\n    ```\n  </Step>\n\n  <Step>\n    #### Test password-less login\n\n    If you performed the procedure correctly, you should not be prompted for a password when you SSH from `node-a` to either of the other nodes using the same username.\n  </Step>\n\n  <Step>\n    Since `node-b` will run a backup Master, repeat the procedure above, substituting `node-b` everywhere you see `node-a`. Be sure not to overwrite your existing *.ssh/authorized\\_keys* files, but concatenate the new key onto the existing file using the `>>` operator rather than the `>` operator.\n  </Step>\n</Steps>\n\n### Procedure: Prepare `node-a`\n\n`node-a` will run your primary master and ZooKeeper processes, but no RegionServers. Stop the RegionServer from starting on `node-a`.\n\n<Steps>\n  <Step>\n    Edit *conf/regionservers* and remove the line which contains `localhost`. Add lines with the hostnames or IP addresses for `node-b` and `node-c`.\n\n    Even if you did want to run a RegionServer on `node-a`, you should refer to it by the hostname the other servers would use to communicate with it. In this case, that would be `node-a.example.com`. This enables you to distribute the configuration to each node of your cluster any hostname conflicts. Save the file.\n  </Step>\n\n  <Step>\n    #### Configure HBase to use `node-b` as a backup master\n\n    Create a new file in *conf/* called *backup-masters*, and add a new line to it with the hostname for `node-b`. In this demonstration, the hostname is `node-b.example.com`.\n  </Step>\n\n  <Step>\n    #### Configure ZooKeeper\n\n    In reality, you should carefully consider your ZooKeeper configuration. You can find out more about configuring ZooKeeper in [zookeeper](/docs/zookeeper) section. This configuration will direct HBase to start and manage a ZooKeeper instance on each node of the cluster.\n\n    On `node-a`, edit *conf/hbase-site.xml* and add the following properties.\n\n    ```xml\n    <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>node-a.example.com,node-b.example.com,node-c.example.com</value>\n    </property>\n    <property>\n    <name>hbase.zookeeper.property.dataDir</name>\n    <value>/usr/local/zookeeper</value>\n    </property>\n    ```\n  </Step>\n\n  <Step>\n    Everywhere in your configuration that you have referred to `node-a` as `localhost`, change the reference to point to the hostname that the other nodes will use to refer to `node-a`. In these examples, the hostname is `node-a.example.com`.\n  </Step>\n</Steps>\n\n### Procedure: Prepare `node-b` and `node-c`\n\n`node-b` will run a backup master server and a ZooKeeper instance.\n\n<Steps>\n  <Step>\n    #### Download and unpack HBase\n\n    Download and unpack HBase to `node-b`, just as you did for the standalone and pseudo-distributed quickstarts.\n  </Step>\n\n  <Step>\n    #### Copy the configuration files from `node-a` to `node-b`.and `node-c`\n\n    Each node of your cluster needs to have the same configuration information. Copy the contents of the *conf/* directory to the *conf/* directory on `node-b` and `node-c`.\n  </Step>\n</Steps>\n\n### Procedure: Start and Test Your Cluster\n\n<Steps>\n  <Step>\n    #### Be sure HBase is not running on any node\n\n    If you forgot to stop HBase from previous testing, you will have errors. Check to see whether HBase is running on any of your nodes by using the `jps` command. Look for the processes `HMaster`, `HRegionServer`, and `HQuorumPeer`. If they exist, kill them.\n  </Step>\n\n  <Step>\n    #### Start the cluster\n\n    On `node-a`, issue the `start-hbase.sh` command. Your output will be similar to that below.\n\n    ```bash\n    $ bin/start-hbase.sh\n    node-c.example.com: starting zookeeper, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-zookeeper-node-c.example.com.out\n    node-a.example.com: starting zookeeper, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-zookeeper-node-a.example.com.out\n    node-b.example.com: starting zookeeper, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-zookeeper-node-b.example.com.out\n    starting master, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-master-node-a.example.com.out\n    node-c.example.com: starting regionserver, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-regionserver-node-c.example.com.out\n    node-b.example.com: starting regionserver, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-regionserver-node-b.example.com.out\n    node-b.example.com: starting master, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-master-nodeb.example.com.out\n    ```\n\n    ZooKeeper starts first, followed by the master, then the RegionServers, and finally the backup masters.\n  </Step>\n\n  <Step>\n    #### Verify that the processes are running\n\n    On each node of the cluster, run the `jps` command and verify that the correct processes are running on each server. You may see additional Java processes running on your servers as well, if they are used for other purposes.\n\n    `node-a` `jps` Output\n\n    ```bash\n    $ jps\n    20355 Jps\n    20071 HQuorumPeer\n    20137 HMaster\n    ```\n\n    `node-b` `jps` Output\n\n    ```bash\n    $ jps\n    15930 HRegionServer\n    16194 Jps\n    15838 HQuorumPeer\n    16010 HMaster\n    ```\n\n    `node-c` `jps` Output\n\n    ```bash\n    $ jps\n    13901 Jps\n    13639 HQuorumPeer\n    13737 HRegionServer\n    ```\n\n    <Callout type=\"info\">\n      The `HQuorumPeer` process is a ZooKeeper instance which is controlled and started by HBase. If you\n      use ZooKeeper this way, it is limited to one instance per cluster node and is appropriate for\n      testing only. If ZooKeeper is run outside of HBase, the process is called `QuorumPeer`. For more\n      about ZooKeeper configuration, including using an external ZooKeeper instance with HBase, see\n      [zookeeper](/docs/zookeeper) section.\n    </Callout>\n  </Step>\n\n  <Step>\n    #### Browse to the Web UI\n\n    If everything is set up correctly, you should be able to connect to the UI for the Master `http://node-a.example.com:16010/` or the secondary master at `http://node-b.example.com:16010/` using a web browser. If you can connect via `localhost` but not from another host, check your firewall rules. You can see the web UI for each of the RegionServers at port 16030 of their IP addresses, or by clicking their links in the web UI for the Master.\n  </Step>\n\n  <Step>\n    #### Test what happens when nodes or services disappear\n\n    With a three-node cluster you have configured, things will not be very resilient. You can still test the behavior of the primary Master or a RegionServer by killing the associated processes and watching the logs.\n  </Step>\n</Steps>\n\n## Where to go next\n\nThe next chapter, [configuration](/docs/configuration), gives more information about the different HBase run modes, system requirements for running HBase, and critical configuration areas for setting up a distributed HBase cluster.\n\n***\n\n# Configuration\n\nThis chapter expands upon the [Getting Started](/docs/getting-started) chapter to further explain configuration of Apache HBase. Please read this chapter carefully, especially the [Basic Prerequisites](basic-prerequisites) to ensure that your HBase testing and deployment goes smoothly. Familiarize yourself with [Support and Testing Expectations](/docs#support-and-testing-expectations) as well.\n\n## Configuration Files\n\nApache HBase uses the same configuration system as Apache Hadoop. All configuration files are located in the *conf/* directory, which needs to be kept in sync for each node on your cluster.\n\n***backup-masters***\\\nNot present by default. A plain-text file which lists hosts on which the Master should start a backup Master process, one host per line.\n\n***hadoop-metrics2-hbase.properties***\\\nUsed to connect HBase Hadoop's Metrics2 framework. See the [Hadoop Wiki entry](https://cwiki.apache.org/confluence/display/HADOOP2/HADOOP-6728-MetricsV2) for more information on Metrics2. Contains only commented-out examples by default.\n\n***hbase-env.cmd* and *hbase-env.sh***\\\nScript for Windows and Linux / Unix environments to set up the working environment for HBase, including the location of Java, Java options, and other environment variables. The file contains many commented-out examples to provide guidance.\n\n***hbase-policy.xml***\\\nThe default policy configuration file used by RPC servers to make authorization decisions on client requests. Only used if HBase [security](/docs/security) is enabled.\n\n***hbase-site.xml***\\\nThe main HBase configuration file. This file specifies configuration options which override HBase's default configuration. You can view (but do not edit) the default configuration file at *hbase-common/src/main/resources/hbase-default.xml*. You can also view the entire effective configuration for your cluster (defaults and overrides) in the **HBase Configuration** tab of the HBase Web UI.\n\n***log4j2.properties***\\\nConfiguration file for HBase logging via `log4j2`.\n\n***regionservers***\\\nA plain-text file containing a list of hosts which should run a RegionServer in your HBase cluster. By default, this file contains the single entry `localhost`. It should contain a list of hostnames or IP addresses, one per line, and should only contain `localhost` if each node in your cluster will run a RegionServer on its `localhost` interface.\n\n<Callout type=\"tip\">\n  When you edit XML, it is a good idea to use an XML-aware editor to be sure that your syntax is\n  correct and your XML is well-formed. You can also use the `xmllint` utility to check that your XML\n  is well-formed. By default, `xmllint` re-flows and prints the XML to standard output. To check for\n  well-formedness and only print output if errors exist, use the command `xmllint -noout\n    filename.xml`.\n</Callout>\n\n<Callout type=\"warn\">\n  When running in distributed mode, after you make an edit to an HBase configuration, make sure you\n  copy the contents of the *conf/* directory to all nodes of the cluster. HBase will not do this for\n  you. Use a configuration management tool for managing and copying the configuration files to your\n  nodes. For most configurations, a restart is needed for servers to pick up changes. Dynamic\n  configuration is an exception to this, to be described later below.\n</Callout>\n\n## Basic Prerequisites\n\n## Java\n\nHBase runs on the Java Virtual Machine, thus all HBase deployments require a JVM runtime.\n\nThe following table summarizes the recommendations of the HBase community with respect to running on various Java versions. The ✅ symbol indicates a base level of testing and willingness to help diagnose and address issues you might run into; these are the expected deployment combinations. An entry of ⚠️ means that there may be challenges with this combination, and you should look for more information before deciding to pursue this as your deployment strategy. The ❌ means this combination does not work; either an older Java version is considered deprecated by the HBase community, or this combination is known to not work. For combinations of newer JDK with older HBase releases, it's likely there are known compatibility issues that cannot be addressed under our compatibility guarantees, making the combination impossible. In some cases, specific guidance on limitations (e.g. whether compiling / unit tests work, specific operational issues, etc) are also noted. Assume any combination not listed here is considered ❌.\n\n<Callout type=\"warn\">\n  HBase recommends downstream users rely only on JDK releases that are marked as Long-Term Supported\n  (LTS), either from the OpenJDK project or vendors. At the time of this writing, the following JDK\n  releases are NOT LTS releases and are NOT tested or advocated for use by the Apache HBase\n  community: JDK9, JDK10, JDK12, JDK13, and JDK14. Community discussion around this decision is\n  recorded on [HBASE-20264](https://issues.apache.org/jira/browse/HBASE-20264).\n</Callout>\n\n<Callout type=\"tip\">\n  At this time, all testing performed by the Apache HBase project runs on the HotSpot variant of the\n  JVM. When selecting your JDK distribution, please take this into consideration.\n</Callout>\n\n**Java support by release line**\n\n| HBase Version | JDK 6 | JDK 7 | JDK 8 | JDK 11 | JDK 17 |\n| :-----------: | :---: | :---: | :---: | :----: | :----: |\n|   HBase 2.6   |   ❌   |   ❌   |   ✅   |    ✅   |    ✅   |\n|   HBase 2.5   |   ❌   |   ❌   |   ✅   |    ✅   |  ⚠️\\*  |\n|   HBase 2.4   |   ❌   |   ❌   |   ✅   |    ✅   |    ❌   |\n|   HBase 2.3   |   ❌   |   ❌   |   ✅   |  ⚠️\\*  |    ❌   |\n| HBase 2.0-2.2 |   ❌   |   ❌   |   ✅   |    ❌   |    ❌   |\n|   HBase 1.2+  |   ❌   |   ✅   |   ✅   |    ❌   |    ❌   |\n| HBase 1.0-1.1 |   ❌   |   ✅   |   ⚠️  |    ❌   |    ❌   |\n|   HBase 0.98  |   ✅   |   ✅   |   ⚠️  |    ❌   |    ❌   |\n|   HBase 0.94  |   ✅   |   ✅   |   ❌   |    ❌   |    ❌   |\n\n<Callout type=\"warn\">\n  Preliminary support for JDK11 is introduced with HBase 2.3.0, and for JDK17 is introduced with HBase 2.5.x. We will compile and run test suites with JDK11/17 in pre commit checks and nightly checks. We will mark the support as ✅ as long as we have run some ITs with the JDK version and also there are users in the community use the JDK version in real production clusters.\n\n  For JDK11/JDK17 support in HBase, please refer to [HBASE-22972](https://issues.apache.org/jira/browse/HBASE-22972) and [HBASE-26038](https://issues.apache.org/jira/browse/HBASE-26038)\n\n  For JDK11/JDK17 support in Hadoop, which may also affect HBase, please refer to [HADOOP-15338](https://issues.apache.org/jira/browse/HADOOP-15338) and [HADOOP-17177](https://issues.apache.org/jira/browse/HADOOP-17177)\n</Callout>\n\n<Callout type=\"info\">\n  You must set `JAVA_HOME` on each node of your cluster. *hbase-env.sh* provides a handy mechanism\n  to do this.\n</Callout>\n\n### Operating System Utilities\n\n#### ssh\n\nHBase uses the Secure Shell (ssh) command and utilities extensively to communicate between cluster nodes. Each server in the cluster must be running `ssh` so that the Hadoop and HBase daemons can be managed. You must be able to connect to all nodes via SSH, including the local node, from the Master as well as any backup Master, using a shared key rather than a password. You can see the basic methodology for such a set-up in Linux or Unix systems at \"[Procedure: Configure Passwordless SSH Access](/docs/getting-started#procedure-configure-passwordless-ssh-access)\" chapter. If your cluster nodes use OS X, see the section, [SSH: Setting up Remote Desktop and Enabling Self-Login](https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=120730246#RunningHadoopOnOSX10.564-bit\\(Single-NodeCluster\\)-SSH:SettingupRemoteDesktopandEnablingSelf-Login) on the Hadoop wiki.\n\n#### DNS\n\nHBase uses the local hostname to self-report its IP address.\n\n#### NTP\n\nThe clocks on cluster nodes should be synchronized. A small amount of variation is acceptable, but larger amounts of skew can cause erratic and unexpected behavior. Time synchronization is one of the first things to check if you see unexplained problems in your cluster. It is recommended that you run a Network Time Protocol (NTP) service, or another time-synchronization mechanism on your cluster and that all nodes look to the same service for time synchronization. See the [Basic NTP Configuration](http://www.tldp.org/LDP/sag/html/basic-ntp-config.html) at *The Linux Documentation Project (TLDP)* to set up NTP.\n\n#### Limits on Number of Files and Processes (ulimit)\n\nApache HBase is a database. It requires the ability to open a large number of files at once. Many Linux distributions limit the number of files a single user is allowed to open to `1024` (or `256` on older versions of OS X). You can check this limit on your servers by running the command `ulimit -n` when logged in as the user which runs HBase. See [the Troubleshooting section](/docs/troubleshooting#javaioioexceptiontoo-many-open-files) for some of the problems you may experience if the limit is too low. You may also notice errors such as the following:\n\n```text\n2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Exception increateBlockOutputStream java.io.EOFException\n2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Abandoning block blk_-6935524980745310745_1391901\n```\n\nIt is recommended to raise the ulimit to at least 10,000, but more likely 10,240, because the value is usually expressed in multiples of 1024. Each ColumnFamily has at least one StoreFile, and possibly more than six StoreFiles if the region is under load. The number of open files required depends upon the number of ColumnFamilies and the number of regions. The following is a rough formula for calculating the potential number of open files on a RegionServer.\n\n**Calculate the Potential Number of Open Files:**\n\n```text\n(StoreFiles per ColumnFamily) x (regions per RegionServer)\n```\n\nFor example, assuming that a schema had 3 ColumnFamilies per region with an average of 3 StoreFiles per ColumnFamily, and there are 100 regions per RegionServer, the JVM will open `3 * 3 * 100 = 900` file descriptors, not counting open JAR files, configuration files, and others. Opening a file does not take many resources, and the risk of allowing a user to open too many files is minimal.\n\nAnother related setting is the number of processes a user is allowed to run at once. In Linux and Unix, the number of processes is set using the `ulimit -u` command. This should not be confused with the `nproc` command, which controls the number of CPUs available to a given user. Under load, a `ulimit -u` that is too low can cause OutOfMemoryError exceptions.\n\nConfiguring the maximum number of file descriptors and processes for the user who is running the HBase process is an operating system configuration, rather than an HBase configuration. It is also important to be sure that the settings are changed for the user that actually runs HBase. To see which user started HBase, and that user's ulimit configuration, look at the first line of the HBase log for that instance.\n\n#### Example: `ulimit` Settings on Ubuntu \\[!toc]\n\nTo configure ulimit settings on Ubuntu, edit */etc/security/limits.conf*, which is a space-delimited file with four columns. Refer to the man page for *limits.conf* for details about the format of this file. In the following example, the first line sets both soft and hard limits for the number of open files (nofile) to 32768 for the operating system user with the username hadoop. The second line sets the number of processes to 32000 for the same user.\n\n```text\nhadoop  -       nofile  32768\nhadoop  -       nproc   32000\n```\n\nThe settings are only applied if the Pluggable Authentication Module (PAM) environment is directed to use them. To configure PAM to use these limits, be sure that the */etc/pam.d/common-session* file contains the following line:\n\n```text\nsession required  pam_limits.so\n```\n\n#### Linux Shell\n\nAll of the shell scripts that come with HBase rely on the [GNU Bash](http://www.gnu.org/software/bash) shell.\n\n#### Windows\n\nRunning production systems on Windows machines is not recommended.\n\n## Hadoop\n\nThe following table summarizes the versions of [Hadoop](https://hadoop.apache.org) supported with each version of HBase. Older versions not appearing in this table are considered unsupported and likely missing necessary features, while newer versions are untested but may be suitable.\n\nBased on the version of HBase, you should select the most appropriate version of Hadoop. You can use Apache Hadoop, or a vendor's distribution of Hadoop. No distinction is made here. See [the Hadoop wiki](https://cwiki.apache.org/confluence/display/HADOOP2/Distributions+and+Commercial+Support) for information about vendors of Hadoop.\n\n<Callout type=\"tip\">\n  Comparing to Hadoop 1.x, Hadoop 2.x is faster and includes features, such as short-circuit reads (see [Leveraging local data](/docs/performance#leveraging-local-data)), which will help improve your HBase random read profile. Hadoop 2.x also includes important bug fixes that will improve your overall HBase experience. HBase does not support running with earlier versions of Hadoop. See the table below for requirements specific to different HBase versions.\n\n  Today, Hadoop 3.x is recommended as the last Hadoop 2.x release 2.10.2 was released years ago, and there is no release for Hadoop 2.x for a very long time, although the Hadoop community does not officially EOL Hadoop 2.x yet.\n</Callout>\n\nUse the following legend to interpret these tables:\n\n* ✅ = Tested to be fully-functional\n* ❌ = Known to not be fully-functional, or there are [CVEs](https://hadoop.apache.org/cve_list.html) so we drop the support in newer minor releases\n* ⚠️ = Not tested, may/may-not function\n\n|                    | HBase-2.5.x | HBase-2.6.x |\n| ------------------ | ----------- | ----------- |\n| Hadoop-2.10.\\[0-1] | ❌           | ❌           |\n| Hadoop-2.10.2+     | ✅           | ✅           |\n| Hadoop-3.1.0       | ❌           | ❌           |\n| Hadoop-3.1.1+      | ❌           | ❌           |\n| Hadoop-3.2.\\[0-2]  | ❌           | ❌           |\n| Hadoop-3.2.3+      | ✅           | ❌           |\n| Hadoop-3.3.\\[0-1]  | ❌           | ❌           |\n| Hadoop-3.3.\\[2-4]  | ✅           | ❌           |\n| Hadoop-3.3.5+      | ✅           | ✅           |\n| Hadoop-3.4.0+      | ✅ (2.5.11+) | ✅ (2.6.2+)  |\n\n### Hadoop version support matrix for active release lines\n\n|               | HBase-2.3.x | HBase-2.4.x |\n| ------------- | ----------- | ----------- |\n| Hadoop-2.10.x | ✅           | ✅           |\n| Hadoop-3.1.0  | ❌           | ❌           |\n| Hadoop-3.1.1+ | ✅           | ✅           |\n| Hadoop-3.2.x  | ✅           | ✅           |\n| Hadoop-3.3.x  | ✅           | ✅           |\n\n### Hadoop version support matrix for EOM 2.3+ release lines\n\n|                   | HBase-2.0.x | HBase-2.1.x | HBase-2.2.x |\n| ----------------- | ----------- | ----------- | ----------- |\n| Hadoop-2.6.1+     | ✅           | ❌           | ❌           |\n| Hadoop-2.7.\\[0-6] | ❌           | ❌           | ❌           |\n| Hadoop-2.7.7+     | ✅           | ✅           | ❌           |\n| Hadoop-2.8.\\[0-2] | ❌           | ❌           | ❌           |\n| Hadoop-2.8.\\[3-4] | ✅           | ✅           | ❌           |\n| Hadoop-2.8.5+     | ✅           | ✅           | ✅           |\n| Hadoop-2.9.\\[0-1] | ⚠️          | ❌           | ❌           |\n| Hadoop-2.9.2+     | ⚠️          | ⚠️          | ✅           |\n| Hadoop-3.0.\\[0-2] | ❌           | ❌           | ❌           |\n| Hadoop-3.0.3+     | ❌           | ✅           | ❌           |\n| Hadoop-3.1.0      | ❌           | ❌           | ❌           |\n| Hadoop-3.1.1+     | ❌           | ✅           | ✅           |\n\n### Hadoop version support matrix for EOM 2.x release lines\n\n|                   | HBase-1.5.x | HBase-1.6.x | HBase-1.7.x |\n| ----------------- | ----------- | ----------- | ----------- |\n| Hadoop-2.7.7+     | ✅           | ❌           | ❌           |\n| Hadoop-2.8.\\[0-4] | ❌           | ❌           | ❌           |\n| Hadoop-2.8.5+     | ✅           | ✅           | ✅           |\n| Hadoop-2.9.\\[0-1] | ❌           | ❌           | ❌           |\n| Hadoop-2.9.2+     | ✅           | ✅           | ✅           |\n| Hadoop-2.10.x     | ⚠️          | ✅           | ✅           |\n\n### Hadoop version support matrix for EOM 1.5+ release lines\n\n|               | HBase-1.0.x (Hadoop 1.x is NOT supported) | HBase-1.1.x | HBase-1.2.x | HBase-1.3.x | HBase-1.4.x |\n| ------------- | ----------------------------------------- | ----------- | ----------- | ----------- | ----------- |\n| Hadoop-2.4.x  | ✅                                         | ✅           | ✅           | ✅           | ❌           |\n| Hadoop-2.5.x  | ✅                                         | ✅           | ✅           | ✅           | ❌           |\n| Hadoop-2.6.0  | ❌                                         | ❌           | ❌           | ❌           | ❌           |\n| Hadoop-2.6.1+ | ⚠️                                        | ⚠️          | ✅           | ✅           | ❌           |\n| Hadoop-2.7.0  | ❌                                         | ❌           | ❌           | ❌           | ❌           |\n| Hadoop-2.7.1+ | ⚠️                                        | ⚠️          | ✅           | ✅           | ✅           |\n\n### Hadoop version support matrix for EOM 1.x release lines\n\n|                    | HBase-0.92.x | HBase-0.94.x | HBase-0.96.x | HBase-0.98.x (Support for Hadoop 1.1+ is deprecated.) |\n| ------------------ | ------------ | ------------ | ------------ | ----------------------------------------------------- |\n| Hadoop-0.20.205    | ✅            | ❌            | ❌            | ❌                                                     |\n| Hadoop-0.22.x      | ✅            | ❌            | ❌            | ❌                                                     |\n| Hadoop-1.0.x       | ❌            | ❌            | ❌            | ❌                                                     |\n| Hadoop-1.1.x       | ⚠️           | ✅            | ✅            | ⚠️                                                    |\n| Hadoop-0.23.x      | ❌            | ✅            | ⚠️           | ❌                                                     |\n| Hadoop-2.0.x-alpha | ❌            | ⚠️           | ❌            | ❌                                                     |\n| Hadoop-2.1.0-beta  | ❌            | ⚠️           | ✅            | ❌                                                     |\n| Hadoop-2.2.0       | ❌            | ⚠️           | ✅            | ✅                                                     |\n| Hadoop-2.3.x       | ❌            | ⚠️           | ✅            | ✅                                                     |\n| Hadoop-2.4.x       | ❌            | ⚠️           | ✅            | ✅                                                     |\n| Hadoop-2.5.x       | ❌            | ⚠️           | ✅            | ✅                                                     |\n\n### Hadoop version support matrix for EOM pre-1.0 release lines\n\n<Callout type=\"idea\">\n  Starting around the time of Hadoop version 2.7.0, the Hadoop PMC got into the habit of calling out\n  new minor releases on their major version 2 release line as not stable / production ready. As\n  such, HBase expressly advises downstream users to avoid running on top of these releases. Note\n  that additionally the 2.8.1 release was given the same caveat by the Hadoop PMC. For reference,\n  see the release announcements for [Apache Hadoop\n  2.7.0](https://s.apache.org/hadoop-2.7.0-announcement), [Apache Hadoop\n  2.8.0](https://s.apache.org/hadoop-2.8.0-announcement), [Apache Hadoop\n  2.8.1](https://s.apache.org/hadoop-2.8.1-announcement), and [Apache Hadoop\n  2.9.0](https://s.apache.org/hadoop-2.9.0-announcement).\n</Callout>\n\n<Callout type=\"idea\">\n  The Hadoop PMC called out the 3.1.0 release as not stable / production ready. As such, HBase\n  expressly advises downstream users to avoid running on top of this release. For reference, see the\n  [release announcement for Hadoop 3.1.0](https://s.apache.org/hadoop-3.1.0-announcement).\n</Callout>\n\n<Callout type=\"info\">\n  Because HBase depends on Hadoop, it bundles Hadoop jars under its *lib* directory. The bundled\n  jars are ONLY for use in stand-alone mode. In distributed mode, it is *critical* that the version\n  of Hadoop that is out on your cluster match what is under HBase. Replace the hadoop jars found in\n  the HBase lib directory with the equivalent hadoop jars from the version you are running on your\n  cluster to avoid version mismatch issues. Make sure you replace the jars under HBase across your\n  whole cluster. Hadoop version mismatch issues have various manifestations. Check for mismatch if\n  HBase appears hung.\n</Callout>\n\n### Hadoop 3 Support for the HBase Binary Releases and Maven Artifacts\n\nFor HBase 2.5.1 and earlier, the official HBase binary releases and Maven artifacts were built with Hadoop 2.x.\n\nStarting with HBase 2.5.2, HBase provides binary releases and Maven artifacts built with both Hadoop 2.x and Hadoop 3.x. The Hadoop 2 artifacts do not have any version suffix, the Hadoop 3 artifacts add the `-hadoop-3` suffix to the version. i.e. `hbase-2.5.2-bin.tar.gz.asc` is the Binary release built with Hadoop2, and `hbase-2.5.2-hadoop3-bin.tar.gz` is the release built with Hadoop 3.\n\n### Hadoop 3 version policy\n\nEach HBase release has a default Hadoop 3 version. This is used when the Hadoop 3 version is not specified during build, and for building the official binary releases and artifacts. Generally when a new minor version is released (i.e. 2.5.0) the default version is set to the latest supported Hadoop 3 version at the start of the release process.\n\nUp to HBase 2.5.10 and 2.6.1 even if HBase added support for newer Hadoop 3 releases in a patch release, the default Hadoop 3 version (and the one used in the official binary releases) was not updated. This simplified upgrading, but meant that HBase releases often included old unfixed CVEs both from Hadoop and Hadoop's dependencies, even when newer Hadoop releases with fixes were available.\n\nStarting with HBase 2.5.11 and 2.6.2, the default Hadoop 3 version is always set to the latest supported Hadoop 3 version, and is also used for the `-hadoop3` binary releases and artifacts. This will drastically reduce the number of known CVEs shipped in the HBase binary releases, and make sure that all fixes and improvements in Hadoop are included.\n\n### `dfs.datanode.max.transfer.threads`\n\nAn HDFS DataNode has an upper bound on the number of files that it will serve at any one time. Before doing any loading, make sure you have configured Hadoop's *conf/hdfs-site.xml*, setting the `dfs.datanode.max.transfer.threads` value to at least the following:\n\n```xml\n<property>\n  <name>dfs.datanode.max.transfer.threads</name>\n  <value>4096</value>\n</property>\n```\n\nBe sure to restart your HDFS after making the above configuration.\n\nNot having this configuration in place makes for strange-looking failures. One manifestation is a complaint about missing blocks. For example:\n\n```text\n10/12/08 20:10:31 INFO hdfs.DFSClient: Could not obtain block\n          blk_XXXXXXXXXXXXXXXXXXXXXX_YYYYYYYY from any node: java.io.IOException: No live nodes\n          contain current block. Will get new block locations from namenode and retry...\n```\n\nSee also [Case Studies](/docs/case-studies#case-study-4-maxtransferthreads-config) and note that this property was previously known as `dfs.datanode.max.xcievers` (e.g. [Hadoop HDFS: Deceived by Xciever](http://ccgtech.blogspot.com/2010/02/hadoop-hdfs-deceived-by-xciever.html)).\n\n## ZooKeeper Requirements\n\nAn Apache ZooKeeper quorum is required. The exact version depends on your version of HBase, though the minimum ZooKeeper version is 3.4.x due to the `useMulti` feature made default in 1.0.0 (see [HBASE-16598](https://issues.apache.org/jira/browse/HBASE-16598)).\n\n## HBase run modes: Standalone and Distributed\n\nHBase has two run modes: [standalone](/docs/configuration/hbase-run-models#standalone-hbase) and [distributed](/docs/configuration/hbase-run-models#distributed). Out of the box, HBase runs in standalone mode. Whatever your mode, you will need to configure HBase by editing files in the HBase *conf* directory. At a minimum, you must edit `conf/hbase-env.sh` to tell HBase which java to use. In this file you set HBase environment variables such as the heapsize and other options for the `JVM`, the preferred location for log files, etc. Set `JAVA_HOME` to point at the root of your java install.\n\n## Standalone HBase\n\nThis is the default mode. Standalone mode is what is described in the [quickstart](/docs/getting-started#quick-start---standalone-hbase) section. In standalone mode, HBase does not use HDFS — it uses the local filesystem instead — and it runs all HBase daemons and a local ZooKeeper all up in the same JVM. ZooKeeper binds to a well-known port so clients may talk to HBase.\n\n### Standalone HBase over HDFS\n\nA sometimes useful variation on standalone hbase has all daemons running inside the one JVM but rather than persist to the local filesystem, instead they persist to an HDFS instance.\n\nYou might consider this profile when you are intent on a simple deploy profile, the loading is light, but the data must persist across node comings and goings. Writing to HDFS where data is replicated ensures the latter.\n\nTo configure this standalone variant, edit your *hbase-site.xml* setting *hbase.rootdir* to point at a directory in your HDFS instance but then set *hbase.cluster.distributed* to *false*. For example:\n\n```xml\n<configuration>\n  <property>\n    <name>hbase.rootdir</name>\n    <value>hdfs://namenode.example.org:9000/hbase</value>\n  </property>\n  <property>\n    <name>hbase.cluster.distributed</name>\n    <value>false</value>\n  </property>\n</configuration>\n```\n\n## Distributed\n\nDistributed mode can be subdivided into distributed but all daemons run on a single node — a.k.a. *pseudo-distributed* — and *fully-distributed* where the daemons are spread across all nodes in the cluster. The *pseudo-distributed* vs. *fully-distributed* nomenclature comes from Hadoop.\n\nPseudo-distributed mode can run against the local filesystem or it can run against an instance of the *Hadoop Distributed File System* (HDFS). Fully-distributed mode can ONLY run on HDFS. See the Hadoop [documentation](https://hadoop.apache.org/docs/current/) for how to set up HDFS. A good walk-through for setting up HDFS on Hadoop 2 can be found at [https://web.archive.org/web/20221007121526/https://www.alexjf.net/blog/distributed-systems/hadoop-yarn-installation-definitive-guide/](https://web.archive.org/web/20221007121526/https://www.alexjf.net/blog/distributed-systems/hadoop-yarn-installation-definitive-guide/).\n\n### Pseudo-distributed\n\n<Callout type=\"info\">\n  A quickstart has been added to the\n  [quickstart](/docs/getting-started#quick-start---standalone-hbase) chapter. See\n  [quickstart-pseudo](/docs/getting-started#pseudo-distributed-for-local-testing). Some of the\n  information that was originally in this section has been moved there.\n</Callout>\n\nA pseudo-distributed mode is simply a fully-distributed mode run on a single host. Use this HBase configuration for testing and prototyping purposes only. Do not use this configuration for production or for performance evaluation.\n\n## Fully-distributed\n\nBy default, HBase runs in stand-alone mode. Both stand-alone mode and pseudo-distributed mode are provided for the purposes of small-scale testing. For a production environment, distributed mode is advised. In distributed mode, multiple instances of HBase daemons run on multiple servers in the cluster.\n\nJust as in pseudo-distributed mode, a fully distributed configuration requires that you set the `hbase.cluster.distributed` property to `true`. Typically, the `hbase.rootdir` is configured to point to a highly-available HDFS filesystem.\n\nIn addition, the cluster is configured so that multiple cluster nodes enlist as RegionServers, ZooKeeper QuorumPeers, and backup HMaster servers. These configuration basics are all demonstrated in [quickstart-fully-distributed](/docs/getting-started#fully-distributed-for-production).\n\n### Distributed RegionServers\n\nTypically, your cluster will contain multiple RegionServers all running on different servers, as well as primary and backup Master and ZooKeeper daemons. The *conf/regionservers* file on the master server contains a list of hosts whose RegionServers are associated with this cluster. Each host is on a separate line. All hosts listed in this file will have their RegionServer processes started and stopped when the master server starts or stops.\n\n### ZooKeeper and HBase\n\nSee the [ZooKeeper](/docs/zookeeper) section for ZooKeeper setup instructions for HBase.\n\n### Example: Distributed HBase Cluster\n\nThis is a bare-bones *conf/hbase-site.xml* for a distributed HBase cluster. A cluster that is used for real-world work would contain more custom configuration parameters. Most HBase configuration directives have default values, which are used unless the value is overridden in the *hbase-site.xml*. See \"[Configuration Files](/docs/configuration/default)\" for more information.\n\n```xml\n<configuration>\n  <property>\n    <name>hbase.rootdir</name>\n    <value>hdfs://namenode.example.org:9000/hbase</value>\n  </property>\n  <property>\n    <name>hbase.cluster.distributed</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>node-a.example.com,node-b.example.com,node-c.example.com</value>\n  </property>\n</configuration>\n```\n\nThis is an example *conf/regionservers* file, which contains a list of nodes that should run a RegionServer in the cluster. These nodes need HBase installed and they need to use the same contents of the *conf/* directory as the Master server.\n\n```text\nnode-a.example.com\nnode-b.example.com\nnode-c.example.com\n```\n\nThis is an example *conf/backup-masters* file, which contains a list of each node that should run a backup Master instance. The backup Master instances will sit idle unless the main Master becomes unavailable.\n\n```text\nnode-b.example.com\nnode-c.example.com\n```\n\n### Distributed HBase Quickstart\n\nSee [quickstart-fully-distributed](/docs/getting-started#fully-distributed-for-production) for a walk-through of a simple three-node cluster configuration with multiple ZooKeeper, backup HMaster, and RegionServer instances.\n\n### Procedure: HDFS Client Configuration\n\n1. Of note, if you have made HDFS client configuration changes on your Hadoop cluster, such as configuration directives for HDFS clients, as opposed to server-side configurations, you must use one of the following methods to enable HBase to see and use these configuration changes:\n   * Add a pointer to your `HADOOP_CONF_DIR` to the `HBASE_CLASSPATH` environment variable in *hbase-env.sh*.\n   * Add a copy of *hdfs-site.xml* (or *hadoop-site.xml*) or, better, symlinks, under `$HBASE_HOME/conf`, or\n   * if only a small set of HDFS client configurations, add them to *hbase-site.xml*.\n\nAn example of such an HDFS client configuration is `dfs.replication`. If for example, you want to run with a replication factor of 5, HBase will create files with the default of 3 unless you do the above to make the configuration available to HBase.\n\n## Choosing between the Classic Package and the BYO Hadoop Package\n\nStarting with HBase 3.0, HBase includes two binary packages. The classic package includes both the HBase and Hadoop components, while the Hadoop-less \"Bring Your Own Hadoop\" package omits the Hadoop components, and uses the files from an existing Hadoop installation. The classic binary package filename is named `hbase-VERSION-bin.tar.gz` (e.g. *hbase-3.0.0-bin.tar.gz*), while the Hadoop-less package is `hbase-byo-hadoop-VERSION-bin.tar.gz` (e.g. *hbase-byo-hadoop-3.0.0-bin.tar.gz*).\n\nIf the cluster nodes already have Hadoop installed, you can use the Hadoop-less package. In this case you need to make sure that the `HADOOP_HOME` environment variable is set and points to the Hadoop installation. The easiest way to ensure this is to set it in *hbase-env.sh*. You still need to make sure that the Hadoop configuration files are present on the HBase classpath, as described above.\n\n## Advantages of the BYO Hadoop package:\n\n* There is no need to replace the Hadoop libraries.\n* It is easier to upgrade Hadoop and HBase independently (as long as compatible versions are used).\n* Both the package and installed size are about 100 MB smaller.\n\n## Running and Confirming Your Installation\n\nMake sure HDFS is running first. Start and stop the Hadoop HDFS daemons by running *bin/start-hdfs.sh* over in the `HADOOP_HOME` directory. You can ensure it started properly by testing the `put` and `get` of files into the Hadoop filesystem. HBase does not normally use the MapReduce or YARN daemons. These do not need to be started.\n\n*If* you are managing your own ZooKeeper, start it and confirm it's running, else HBase will start up ZooKeeper for you as part of its start process.\n\nStart HBase with the following command:\n\n```bash\nbin/start-hbase.sh\n```\n\nRun the above from the `HBASE_HOME` directory.\n\nYou should now have a running HBase instance. HBase logs can be found in the *logs* subdirectory. Check them out especially if HBase had trouble starting.\n\nHBase also puts up a UI listing vital attributes. By default it's deployed on the Master host at port 16010 (HBase RegionServers listen on port 16020 by default and put up an informational HTTP server at port 16030). If the Master is running on a host named `master.example.org` on the default port, point your browser at [http://master.example.org:16010](http://master.example.org:16010) to see the web interface.\n\nOnce HBase has started, see the [shell exercises](/docs/getting-started#procedure-use-hbase-for-the-first-time) documentation for how to create tables, add data, scan your insertions, and finally disable and drop your tables.\n\nTo stop HBase after exiting the HBase shell enter\n\n```bash\n$ ./bin/stop-hbase.sh\nstopping hbase...............\n```\n\nShutdown can take a moment to complete. It can take longer if your cluster is comprised of many machines. If you are running a distributed operation, be sure to wait until HBase has shut down completely before stopping the Hadoop daemons.\n\n## Default Configuration\n\n## *hbase-site.xml* and *hbase-default.xml*\n\nJust as in Hadoop where you add site-specific HDFS configuration to the *hdfs-site.xml* file, for HBase, site specific customizations go into the file *conf/hbase-site.xml*. For the list of configurable properties, see [hbase default configurations](/docs/configuration/default#configuration-default-hbase-default-configuration) below or view the raw *hbase-default.xml* source file in the HBase source code at *src/main/resources*.\n\nNot all configuration options make it out to *hbase-default.xml*. Some configurations would only appear in source code; the only way to identify these changes are through code review.\n\nCurrently, changes here will require a cluster restart for HBase to notice the change.\n\n## HBase Default configuration\n\nThe documentation below is generated using the default hbase configuration file, *hbase-default.xml*, as source.\n\n#### `hbase.tmp.dir` \\[!toc]\n\n**Description:** Temporary directory on the local filesystem. Change this setting to point to a location more permanent than '/tmp', the usual resolve for java.io.tmpdir, as the '/tmp' directory is cleared on machine restart.\\\n**Default:** `${java.io.tmpdir}/hbase-${user.name}`\n\n#### `hbase.rootdir` \\[!toc]\n\n**Description:** The directory shared by region servers and into which HBase persists. The URL should be 'fully-qualified' to include the filesystem scheme. For example, to specify the HDFS directory '/hbase' where the HDFS instance's namenode is running at namenode.example.org on port 9000, set this value to: hdfs\\://namenode.example.org:9000/hbase. By default, we write to whatever $\\{hbase.tmp.dir} is set too -- usually /tmp -- so change this configuration or else all data will be lost on machine restart.\\\n**Default:** `${hbase.tmp.dir}/hbase`\n\n#### `hbase.cluster.distributed` \\[!toc]\n\n**Description:** The mode the cluster will be in. Possible values are false for standalone mode and true for distributed mode. If false, startup will run all HBase and ZooKeeper daemons together in the one JVM.\\\n**Default:** `false`\n\n#### `hbase.zookeeper.quorum` \\[!toc]\n\n**Description:** Comma separated list of servers in the ZooKeeper ensemble (This config. should have been named hbase.zookeeper.ensemble). For example, \"host1.mydomain.com,host2.mydomain.com,host3.mydomain.com\". By default this is set to localhost for local and pseudo-distributed modes of operation. For a fully-distributed setup, this should be set to a full list of ZooKeeper ensemble servers. If HBASE\\_MANAGES\\_ZK is set in hbase-env.sh this is the list of servers which hbase will start/stop ZooKeeper on as part of cluster start/stop. Client-side, we will take this list of ensemble members and put it together with the hbase.zookeeper.property.clientPort config. and pass it into zookeeper constructor as the connectString parameter.\\\n**Default:** `127.0.0.1`\n\n#### `zookeeper.recovery.retry.maxsleeptime` \\[!toc]\n\n**Description:** Max sleep time before retry zookeeper operations in milliseconds, a max time is needed here so that sleep time won't grow unboundedly\\\n**Default:** `60000`\n\n#### `hbase.local.dir` \\[!toc]\n\n**Description:** Directory on the local filesystem to be used as a local storage.\\\n**Default:** `${hbase.tmp.dir}/local/`\n\n#### `hbase.master.port` \\[!toc]\n\n**Description:** The port the HBase Master should bind to.\\\n**Default:** `16000`\n\n#### `hbase.master.info.port` \\[!toc]\n\n**Description:** The port for the HBase Master web UI. Set to -1 if you do not want a UI instance run.\\\n**Default:** `16010`\n\n#### `hbase.master.info.bindAddress` \\[!toc]\n\n**Description:** The bind address for the HBase Master web UI\\\n**Default:** `0.0.0.0`\n\n#### `hbase.master.logcleaner.plugins` \\[!toc]\n\n**Description:** A comma-separated list of BaseLogCleanerDelegate invoked by the LogsCleaner service. These WAL cleaners are called in order, so put the cleaner that prunes the most files in front. To implement your own BaseLogCleanerDelegate, just put it in HBase's classpath and add the fully qualified class name here. Always add the above default log cleaners in the list.\\\n**Default:** `org.apache.hadoop.hbase.master.cleaner.TimeToLiveLogCleaner,org.apache.hadoop.hbase.master.cleaner.TimeToLiveProcedureWALCleaner,org.apache.hadoop.hbase.master.cleaner.TimeToLiveMasterLocalStoreWALCleaner`\n\n#### `hbase.master.logcleaner.ttl` \\[!toc]\n\n**Description:** How long a WAL remain in the archive (\\{hbase.rootdir}/oldWALs) directory, after which it will be cleaned by a Master thread. The value is in milliseconds.\\\n**Default:** `600000`\n\n#### `hbase.master.hfilecleaner.plugins` \\[!toc]\n\n**Description:** A comma-separated list of BaseHFileCleanerDelegate invoked by the HFileCleaner service. These HFiles cleaners are called in order, so put the cleaner that prunes the most files in front. To implement your own BaseHFileCleanerDelegate, just put it in HBase's classpath and add the fully qualified class name here. Always add the above default hfile cleaners in the list as they will be overwritten in hbase-site.xml.\\\n**Default:** `org.apache.hadoop.hbase.master.cleaner.TimeToLiveHFileCleaner,org.apache.hadoop.hbase.master.cleaner.TimeToLiveMasterLocalStoreHFileCleaner`\n\n#### `hbase.master.infoserver.redirect` \\[!toc]\n\n**Description:** Whether or not the Master listens to the Master web UI port (hbase.master.info.port) and redirects requests to the web UI server shared by the Master and RegionServer. Config. makes sense when Master is serving Regions (not the default).\\\n**Default:** `true`\n\n#### `hbase.master.fileSplitTimeout` \\[!toc]\n\n**Description:** Splitting a region, how long to wait on the file-splitting step before aborting the attempt. Default: 600000. This setting used to be known as hbase.regionserver.fileSplitTimeout in hbase-1.x. Split is now run master-side hence the rename (If a 'hbase.master.fileSplitTimeout' setting found, will use it to prime the current 'hbase.master.fileSplitTimeout' Configuration.\\\n**Default:** `600000`\n\n#### `hbase.regionserver.port` \\[!toc]\n\n**Description:** The port the HBase RegionServer binds to.\\\n**Default:** `16020`\n\n#### `hbase.regionserver.info.port` \\[!toc]\n\n**Description:** The port for the HBase RegionServer web UI Set to -1 if you do not want the RegionServer UI to run.\\\n**Default:** `16030`\n\n#### `hbase.regionserver.info.bindAddress` \\[!toc]\n\n**Description:** The address for the HBase RegionServer web UI\\\n**Default:** `0.0.0.0`\n\n#### `hbase.regionserver.info.port.auto` \\[!toc]\n\n**Description:** Whether or not the Master or RegionServer UI should search for a port to bind to. Enables automatic port search if hbase.regionserver.info.port is already in use. Useful for testing, turned off by default.\\\n**Default:** `false`\n\n#### `hbase.regionserver.handler.count` \\[!toc]\n\n**Description:** Count of RPC Listener instances spun up on RegionServers. Same property is used by the Master for count of master handlers. Too many handlers can be counter-productive. Make it a multiple of CPU count. If mostly read-only, handlers count close to cpu count does well. Start with twice the CPU count and tune from there.\\\n**Default:** `30`\n\n#### `hbase.ipc.server.callqueue.handler.factor` \\[!toc]\n\n**Description:** Factor to determine the number of call queues. A value of 0 means a single queue shared between all the handlers. A value of 1 means that each handler has its own queue.\\\n**Default:** `0.1`\n\n#### `hbase.ipc.server.callqueue.read.ratio` \\[!toc]\n\n**Description:** Split the call queues into read and write queues. The specified interval (which should be between 0.0 and 1.0) will be multiplied by the number of call queues. A value of 0 indicate to not split the call queues, meaning that both read and write requests will be pushed to the same set of queues. A value lower than 0.5 means that there will be less read queues than write queues. A value of 0.5 means there will be the same number of read and write queues. A value greater than 0.5 means that there will be more read queues than write queues. A value of 1.0 means that all the queues except one are used to dispatch read requests. Example: Given the total number of call queues being 10 a read.ratio of 0 means that: the 10 queues will contain both read/write requests. a read.ratio of 0.3 means that: 3 queues will contain only read requests and 7 queues will contain only write requests. a read.ratio of 0.5 means that: 5 queues will contain only read requests and 5 queues will contain only write requests. a read.ratio of 0.8 means that: 8 queues will contain only read requests and 2 queues will contain only write requests. a read.ratio of 1 means that: 9 queues will contain only read requests and 1 queues will contain only write requests.\\\n**Default:** `0`\n\n#### `hbase.ipc.server.callqueue.scan.ratio` \\[!toc]\n\n**Description:** Given the number of read call queues, calculated from the total number of call queues multiplied by the callqueue.read.ratio, the scan.ratio property will split the read call queues into small-read and long-read queues. A value lower than 0.5 means that there will be less long-read queues than short-read queues. A value of 0.5 means that there will be the same number of short-read and long-read queues. A value greater than 0.5 means that there will be more long-read queues than short-read queues A value of 0 or 1 indicate to use the same set of queues for gets and scans. Example: Given the total number of read call queues being 8 a scan.ratio of 0 or 1 means that: 8 queues will contain both long and short read requests. a scan.ratio of 0.3 means that: 2 queues will contain only long-read requests and 6 queues will contain only short-read requests. a scan.ratio of 0.5 means that: 4 queues will contain only long-read requests and 4 queues will contain only short-read requests. a scan.ratio of 0.8 means that: 6 queues will contain only long-read requests and 2 queues will contain only short-read requests.\\\n**Default:** `0`\n\n#### `hbase.regionserver.msginterval` \\[!toc]\n\n**Description:** Interval between messages from the RegionServer to Master in milliseconds.\\\n**Default:** `3000`\n\n#### `hbase.regionserver.logroll.period` \\[!toc]\n\n**Description:** Period at which we will roll the commit log regardless of how many edits it has.\\\n**Default:** `3600000`\n\n#### `hbase.regionserver.logroll.errors.tolerated` \\[!toc]\n\n**Description:** The number of consecutive WAL close errors we will allow before triggering a server abort. A setting of 0 will cause the region server to abort if closing the current WAL writer fails during log rolling. Even a small value (2 or 3) will allow a region server to ride over transient HDFS errors.\\\n**Default:** `2`\n\n#### `hbase.regionserver.free.heap.min.memory.size` \\[!toc]\n\n**Description:** Defines the minimum amount of heap memory that must remain free for the RegionServer to start, specified in bytes or human-readable formats like '512m' for megabytes or '4g' for gigabytes. If not set, the default is 20% of the total heap size. To disable the check entirely, set this value to 0. If the combined memory usage of memstore and block cache exceeds (total heap - this value), the RegionServer will fail to start.\\\n**Default:** `(empty)`\n\n#### `hbase.regionserver.global.memstore.size` \\[!toc]\n\n**Description:** Maximum size of all memstores in a region server before new updates are blocked and flushes are forced. Defaults to 40% of heap (0.4). Updates are blocked and flushes are forced until size of all memstores in a region server hits hbase.regionserver.global.memstore.size.lower.limit. The default value in this configuration has been intentionally left empty in order to honor the old hbase.regionserver.global.memstore.upperLimit property if present.\\\n**Default:** `(empty)`\n\n#### `hbase.regionserver.global.memstore.size.lower.limit` \\[!toc]\n\n**Description:** Maximum size of all memstores in a region server before flushes are forced. Defaults to 95% of hbase.regionserver.global.memstore.size (0.95). A 100% value for this value causes the minimum possible flushing to occur when updates are blocked due to memstore limiting. The default value in this configuration has been intentionally left empty in order to honor the old hbase.regionserver.global.memstore.lowerLimit property if present.\\\n**Default:** `(empty)`\n\n#### `hbase.systemtables.compacting.memstore.type` \\[!toc]\n\n**Description:** Determines the type of memstore to be used for system tables like META, namespace tables etc. By default NONE is the type and hence we use the default memstore for all the system tables. If we need to use compacting memstore for system tables then set this property to BASIC/EAGER\\\n**Default:** `NONE`\n\n#### `hbase.regionserver.optionalcacheflushinterval` \\[!toc]\n\n**Description:** Maximum amount of time an edit lives in memory before being automatically flushed. Default 1 hour. Set it to 0 to disable automatic flushing.\\\n**Default:** `3600000`\n\n#### `hbase.regionserver.dns.interface` \\[!toc]\n\n**Description:** The name of the Network Interface from which a region server should report its IP address.\\\n**Default:** `default`\n\n#### `hbase.regionserver.dns.nameserver` \\[!toc]\n\n**Description:** The host name or IP address of the name server (DNS) which a region server should use to determine the host name used by the master for communication and display purposes.\\\n**Default:** `default`\n\n#### `hbase.regionserver.region.split.policy` \\[!toc]\n\n**Description:** A split policy determines when a region should be split. The various other split policies that are available currently are BusyRegionSplitPolicy, ConstantSizeRegionSplitPolicy, DisabledRegionSplitPolicy, DelimitedKeyPrefixRegionSplitPolicy, KeyPrefixRegionSplitPolicy, and SteppingSplitPolicy. DisabledRegionSplitPolicy blocks manual region splitting.\\\n**Default:** `org.apache.hadoop.hbase.regionserver.SteppingSplitPolicy`\n\n#### `hbase.regionserver.regionSplitLimit` \\[!toc]\n\n**Description:** Limit for the number of regions after which no more region splitting should take place. This is not hard limit for the number of regions but acts as a guideline for the regionserver to stop splitting after a certain limit. Default is set to 1000.\\\n**Default:** `1000`\n\n#### `zookeeper.session.timeout` \\[!toc]\n\n**Description:** ZooKeeper session timeout in milliseconds. It is used in two different ways. First, this value is used in the ZK client that HBase uses to connect to the ensemble. It is also used by HBase when it starts a ZK server and it is passed as the 'maxSessionTimeout'. See [https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch\\_zkSessions](https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkSessions). For example, if an HBase region server connects to a ZK ensemble that's also managed by HBase, then the session timeout will be the one specified by this configuration. But, a region server that connects to an ensemble managed with a different configuration will be subjected that ensemble's maxSessionTimeout. So, even though HBase might propose using 90 seconds, the ensemble can have a max timeout lower than this and it will take precedence. The current default maxSessionTimeout that ZK ships with is 40 seconds, which is lower than HBase's.\\\n**Default:** `90000`\n\n#### `zookeeper.znode.parent` \\[!toc]\n\n**Description:** Root ZNode for HBase in ZooKeeper. All of HBase's ZooKeeper files that are configured with a relative path will go under this node. By default, all of HBase's ZooKeeper file paths are configured with a relative path, so they will all go under this directory unless changed.\\\n**Default:** `/hbase`\n\n#### `zookeeper.znode.acl.parent` \\[!toc]\n\n**Description:** Root ZNode for access control lists.\\\n**Default:** `acl`\n\n#### `hbase.zookeeper.dns.interface` \\[!toc]\n\n**Description:** The name of the Network Interface from which a ZooKeeper server should report its IP address.\\\n**Default:** `default`\n\n#### `hbase.zookeeper.dns.nameserver` \\[!toc]\n\n**Description:** The host name or IP address of the name server (DNS) which a ZooKeeper server should use to determine the host name used by the master for communication and display purposes.\\\n**Default:** `default`\n\n#### `hbase.zookeeper.peerport` \\[!toc]\n\n**Description:** Port used by ZooKeeper peers to talk to each other. See [https://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html#sc\\_RunningReplicatedZooKeeper](https://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html#sc_RunningReplicatedZooKeeper) for more information.\\\n**Default:** `2888`\n\n#### `hbase.zookeeper.leaderport` \\[!toc]\n\n**Description:** Port used by ZooKeeper for leader election. See [https://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html#sc\\_RunningReplicatedZooKeeper](https://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html#sc_RunningReplicatedZooKeeper) for more information.\\\n**Default:** `3888`\n\n#### `hbase.zookeeper.property.initLimit` \\[!toc]\n\n**Description:**\\\n**Default:** `10`\n\n#### `hbase.zookeeper.property.initLimit` \\[!toc]\n\n**Description:** Property from ZooKeeper's config zoo.cfg. The number of ticks that the initial synchronization phase can take.\\\n**Default:** `10`\n\n#### `hbase.zookeeper.property.syncLimit` \\[!toc]\n\n**Description:** Property from ZooKeeper's config zoo.cfg. The number of ticks that can pass between sending a request and getting an acknowledgment.\\\n**Default:** `5`\n\n#### `hbase.zookeeper.property.dataDir` \\[!toc]\n\n**Description:** Property from ZooKeeper's config zoo.cfg. The directory where the snapshot is stored.\\\n**Default:** `${hbase.tmp.dir}/zookeeper`\n\n#### `hbase.zookeeper.property.clientPort` \\[!toc]\n\n**Description:** Property from ZooKeeper's config zoo.cfg. The port at which the clients will connect.\\\n**Default:** `2181`\n\n#### `hbase.zookeeper.property.maxClientCnxns` \\[!toc]\n\n**Description:** Property from ZooKeeper's config zoo.cfg. Limit on number of concurrent connections (at the socket level) that a single client, identified by IP address, may make to a single member of the ZooKeeper ensemble. Set high to avoid zk connection issues running standalone and pseudo-distributed.\\\n**Default:** `300`\n\n#### `hbase.client.write.buffer` \\[!toc]\n\n**Description:** Default size of the BufferedMutator write buffer in bytes. A bigger buffer takes more memory -- on both the client and server side since server instantiates the passed write buffer to process it -- but a larger buffer size reduces the number of RPCs made. For an estimate of server-side memory-used, evaluate hbase.client.write.buffer \\* hbase.regionserver.handler.count\\\n**Default:** `2097152`\n\n#### `hbase.client.pause` \\[!toc]\n\n**Description:** General client pause value. Used mostly as value to wait before running a retry of a failed get, region lookup, etc. See hbase.client.retries.number for description of how we backoff from this initial pause amount and how this pause works w/ retries.\\\n**Default:** `100`\n\n#### `hbase.client.pause.server.overloaded` \\[!toc]\n\n**Description:** Pause time when encountering an exception indicating a server is overloaded, CallQueueTooBigException or CallDroppedException. Set this property to a higher value than hbase.client.pause if you observe frequent CallQueueTooBigException or CallDroppedException from the same RegionServer and the call queue there keeps filling up. This config used to be called hbase.client.pause.cqtbe, which has been deprecated as of 2.5.0.\\\n**Default:** `(empty)`\n\n#### `hbase.client.retries.number` \\[!toc]\n\n**Description:** Maximum retries. Used as maximum for all retryable operations such as the getting of a cell's value, starting a row update, etc. Retry interval is a rough function based on hbase.client.pause. At first we retry at this interval but then with backoff, we pretty quickly reach retrying every ten seconds. See HConstants#RETRY\\_BACKOFF for how the backup ramps up. Change this setting and hbase.client.pause to suit your workload.\\\n**Default:** `15`\n\n#### `hbase.client.max.total.tasks` \\[!toc]\n\n**Description:** The maximum number of concurrent mutation tasks a single HTable instance will send to the cluster.\\\n**Default:** `100`\n\n#### `hbase.client.max.perserver.tasks` \\[!toc]\n\n**Description:** The maximum number of concurrent mutation tasks a single HTable instance will send to a single region server.\\\n**Default:** `2`\n\n#### `hbase.client.max.perregion.tasks` \\[!toc]\n\n**Description:** The maximum number of concurrent mutation tasks the client will maintain to a single Region. That is, if there is already hbase.client.max.perregion.tasks writes in progress for this region, new puts won't be sent to this region until some writes finishes.\\\n**Default:** `1`\n\n#### `hbase.client.perserver.requests.threshold` \\[!toc]\n\n**Description:** The max number of concurrent pending requests for one server in all client threads (process level). Exceeding requests will be thrown ServerTooBusyException immediately to prevent user's threads being occupied and blocked by only one slow region server. If you use a fix number of threads to access HBase in a synchronous way, set this to a suitable value which is related to the number of threads will help you. See [https://issues.apache.org/jira/browse/HBASE-16388](https://issues.apache.org/jira/browse/HBASE-16388) for details.\\\n**Default:** `2147483647`\n\n#### `hbase.client.scanner.caching` \\[!toc]\n\n**Description:** Number of rows that we try to fetch when calling next on a scanner if it is not served from (local, client) memory. This configuration works together with hbase.client.scanner.max.result.size to try and use the network efficiently. The default value is Integer.MAX\\_VALUE by default so that the network will fill the chunk size defined by hbase.client.scanner.max.result.size rather than be limited by a particular number of rows since the size of rows varies table to table. If you know ahead of time that you will not require more than a certain number of rows from a scan, this configuration should be set to that row limit via Scan#setCaching. Higher caching values will enable faster scanners but will eat up more memory and some calls of next may take longer and longer times when the cache is empty. Do not set this value such that the time between invocations is greater than the scanner timeout; i.e. hbase.client.scanner.timeout.period\\\n**Default:** `2147483647`\n\n#### `hbase.client.keyvalue.maxsize` \\[!toc]\n\n**Description:** Specifies the combined maximum allowed size of a KeyValue instance. This is to set an upper boundary for a single entry saved in a storage file. Since they cannot be split it helps avoiding that a region cannot be split any further because the data is too large. It seems wise to set this to a fraction of the maximum region size. Setting it to zero or less disables the check.\\\n**Default:** `10485760`\n\n#### `hbase.server.keyvalue.maxsize` \\[!toc]\n\n**Description:** Maximum allowed size of an individual cell, inclusive of value and all key components. A value of 0 or less disables the check. The default value is 10MB. This is a safety setting to protect the server from OOM situations.\\\n**Default:** `10485760`\n\n#### `hbase.client.scanner.timeout.period` \\[!toc]\n\n**Description:** Client scanner lease period in milliseconds.\\\n**Default:** `60000`\n\n#### `hbase.client.localityCheck.threadPoolSize` \\[!toc]\n\n**Description:**\\\n**Default:** `2`\n\n#### `hbase.bulkload.retries.number` \\[!toc]\n\n**Description:** Maximum retries. This is maximum number of iterations to atomic bulk loads are attempted in the face of splitting operations 0 means never give up.\\\n**Default:** `10`\n\n#### `hbase.compaction.after.bulkload.enable` \\[!toc]\n\n**Description:** Request Compaction after bulkload immediately. If bulkload is continuous, the triggered compactions may increase load, bring about performance side effect.\\\n**Default:** `false`\n\n#### `hbase.master.balancer.maxRitPercent` \\[!toc]\n\n**Description:** The max percent of regions in transition when balancing. The default value is 1.0. So there are no balancer throttling. If set this config to 0.01, It means that there are at most 1% regions in transition when balancing. Then the cluster's availability is at least 99% when balancing.\\\n**Default:** `1.0`\n\n#### `hbase.balancer.period` \\[!toc]\n\n**Description:** Period at which the region balancer runs in the Master, in milliseconds.\\\n**Default:** `300000`\n\n#### `hbase.master.oldwals.dir.updater.period` \\[!toc]\n\n**Description:** Period at which the oldWALs directory size calculator/updater will run in the Master, in milliseconds.\\\n**Default:** `300000`\n\n#### `hbase.regions.slop` \\[!toc]\n\n**Description:** The load balancer can trigger for several reasons. This value controls one of those reasons. Run the balancer if any regionserver has a region count outside the range of average +/- (average \\* slop) regions. If the value of slop is negative, disable sloppiness checks. The balancer can still run for other reasons, but sloppiness will not be one of them. If the value of slop is 0, run the balancer if any server has a region count more than 1 from the average. If the value of slop is 100, run the balancer if any server has a region count greater than 101 times the average. The default value of this parameter is 0.2, which runs the balancer if any server has a region count less than 80% of the average, or greater than 120% of the average. Note that for the default StochasticLoadBalancer, this does not guarantee any balancing actions will be taken, but only that the balancer will attempt to run.\\\n**Default:** `0.2`\n\n#### `hbase.normalizer.period` \\[!toc]\n\n**Description:** Period at which the region normalizer runs in the Master, in milliseconds.\\\n**Default:** `300000`\n\n#### `hbase.normalizer.split.enabled` \\[!toc]\n\n**Description:** Whether to split a region as part of normalization.\\\n**Default:** `true`\n\n#### `hbase.normalizer.merge.enabled` \\[!toc]\n\n**Description:** Whether to merge a region as part of normalization.\\\n**Default:** `true`\n\n#### `hbase.normalizer.merge.min.region.count` \\[!toc]\n\n**Description:** The minimum number of regions in a table to consider it for merge normalization.\\\n**Default:** `3`\n\n#### `hbase.normalizer.merge.min_region_age.days` \\[!toc]\n\n**Description:** The minimum age for a region to be considered for a merge, in days.\\\n**Default:** `3`\n\n#### `hbase.normalizer.merge.min_region_size.mb` \\[!toc]\n\n**Description:** The minimum size for a region to be considered for a merge, in whole MBs.\\\n**Default:** `1`\n\n#### `hbase.normalizer.merge.merge_request_max_number_of_regions` \\[!toc]\n\n**Description:** The maximum number of region count in a merge request for merge normalization.\\\n**Default:** `100`\n\n#### `hbase.table.normalization.enabled` \\[!toc]\n\n**Description:** This config is used to set default behaviour of normalizer at table level. To override this at table level one can set NORMALIZATION\\_ENABLED at table descriptor level and that property will be honored\\\n**Default:** `false`\n\n#### `hbase.server.thread.wakefrequency` \\[!toc]\n\n**Description:** In master side, this config is the period used for FS related behaviors: checking if hdfs is out of safe mode, setting or checking hbase.version file, setting or checking hbase.id file. Using default value should be fine. In regionserver side, this config is used in several places: flushing check interval, compaction check interval, wal rolling check interval. Specially, admin can tune flushing and compaction check interval by hbase.regionserver.flush.check.period and hbase.regionserver.compaction.check.period. (in milliseconds)\\\n**Default:** `10000`\n\n#### `hbase.regionserver.flush.check.period` \\[!toc]\n\n**Description:** It determines the flushing check period of PeriodicFlusher in regionserver. If unset, it uses hbase.server.thread.wakefrequency as default value. (in milliseconds)\\\n**Default:** `${hbase.server.thread.wakefrequency}`\n\n#### `hbase.regionserver.compaction.check.period` \\[!toc]\n\n**Description:** It determines the compaction check period of CompactionChecker in regionserver. If unset, it uses hbase.server.thread.wakefrequency as default value. (in milliseconds)\\\n**Default:** `${hbase.server.thread.wakefrequency}`\n\n#### `hbase.server.versionfile.writeattempts` \\[!toc]\n\n**Description:** How many times to retry attempting to write a version file before just aborting. Each attempt is separated by the hbase.server.thread.wakefrequency milliseconds.\\\n**Default:** `3`\n\n#### `hbase.hregion.memstore.flush.size` \\[!toc]\n\n**Description:** Memstore will be flushed to disk if size of the memstore exceeds this number of bytes. Value is checked by a thread that runs every hbase.server.thread.wakefrequency.\\\n**Default:** `134217728`\n\n#### `hbase.hregion.percolumnfamilyflush.size.lower.bound.min` \\[!toc]\n\n**Description:** If FlushLargeStoresPolicy is used and there are multiple column families, then every time that we hit the total memstore limit, we find out all the column families whose memstores exceed a \"lower bound\" and only flush them while retaining the others in memory. The \"lower bound\" will be \"hbase.hregion.memstore.flush.size / column\\_family\\_number\" by default unless value of this property is larger than that. If none of the families have their memstore size more than lower bound, all the memstores will be flushed (just as usual).\\\n**Default:** `16777216`\n\n#### `hbase.hregion.preclose.flush.size` \\[!toc]\n\n**Description:** If the memstores in a region are this size or larger when we go to close, run a \"pre-flush\" to clear out memstores before we put up the region closed flag and take the region offline. On close, a flush is run under the close flag to empty memory. During this time the region is offline and we are not taking on any writes. If the memstore content is large, this flush could take a long time to complete. The preflush is meant to clean out the bulk of the memstore before putting up the close flag and taking the region offline so the flush that runs under the close flag has little to do.\\\n**Default:** `5242880`\n\n#### `hbase.hregion.memstore.block.multiplier` \\[!toc]\n\n**Description:** Block updates if memstore has hbase.hregion.memstore.block.multiplier times hbase.hregion.memstore.flush.size bytes. Useful preventing runaway memstore during spikes in update traffic. Without an upper-bound, memstore fills such that when it flushes the resultant flush files take a long time to compact or split, or worse, we OOME.\\\n**Default:** `4`\n\n#### `hbase.hregion.memstore.mslab.enabled` \\[!toc]\n\n**Description:** Enables the MemStore-Local Allocation Buffer, a feature which works to prevent heap fragmentation under heavy write loads. This can reduce the frequency of stop-the-world GC pauses on large heaps.\\\n**Default:** `true`\n\n#### `hbase.hregion.memstore.mslab.chunksize` \\[!toc]\n\n**Description:** The maximum byte size of a chunk in the MemStoreLAB. Unit: bytes\\\n**Default:** `2097152`\n\n#### `hbase.regionserver.offheap.global.memstore.size` \\[!toc]\n\n**Description:** The amount of off-heap memory all MemStores in a RegionServer may use. A value of 0 means that no off-heap memory will be used and all chunks in MSLAB will be HeapByteBuffer, otherwise the non-zero value means how many megabyte of off-heap memory will be used for chunks in MSLAB and all chunks in MSLAB will be DirectByteBuffer. Unit: megabytes.\\\n**Default:** `0`\n\n#### `hbase.hregion.memstore.mslab.max.allocation` \\[!toc]\n\n**Description:** The maximal size of one allocation in the MemStoreLAB, if the desired byte size exceed this threshold then it will be just allocated from JVM heap rather than MemStoreLAB.\\\n**Default:** `262144`\n\n#### `hbase.hregion.max.filesize` \\[!toc]\n\n**Description:** Maximum file size. If the sum of the sizes of a region's HFiles has grown to exceed this value, the region is split in two. There are two choices of how this option works, the first is when any store's size exceed the threshold then split, and the other is overall region's size exceed the threshold then split, it can be configed by hbase.hregion.split.overallfiles.\\\n**Default:** `10737418240`\n\n#### `hbase.hregion.split.overallfiles` \\[!toc]\n\n**Description:** If we should sum overall region files size when check to split.\\\n**Default:** `true`\n\n#### `hbase.hregion.majorcompaction` \\[!toc]\n\n**Description:** Time between major compactions, expressed in milliseconds. Set to 0 to disable time-based automatic major compactions. User-requested and size-based major compactions will still run. This value is multiplied by hbase.hregion.majorcompaction.jitter to cause compaction to start at a somewhat-random time during a given window of time. The default value is 7 days, expressed in milliseconds. If major compactions are causing disruption in your environment, you can configure them to run at off-peak times for your deployment, or disable time-based major compactions by setting this parameter to 0, and run major compactions in a cron job or by another external mechanism.\\\n**Default:** `604800000`\n\n#### `hbase.hregion.majorcompaction.jitter` \\[!toc]\n\n**Description:** A multiplier applied to hbase.hregion.majorcompaction to cause compaction to occur a given amount of time either side of hbase.hregion.majorcompaction. The smaller the number, the closer the compactions will happen to the hbase.hregion.majorcompaction interval.\\\n**Default:** `0.50`\n\n#### `hbase.hstore.compactionThreshold` \\[!toc]\n\n**Description:** If more than or equal to this number of StoreFiles exist in any one Store (one StoreFile is written per flush of MemStore), a compaction is run to rewrite all StoreFiles into a single StoreFile. Larger values delay compaction, but when compaction does occur, it takes longer to complete.\\\n**Default:** `3`\n\n#### `hbase.regionserver.compaction.enabled` \\[!toc]\n\n**Description:** Enable/disable compactions on by setting true/false. We can further switch compactions dynamically with the compaction\\_switch shell command.\\\n**Default:** `true`\n\n#### `hbase.hstore.flusher.count` \\[!toc]\n\n**Description:** The number of flush threads. With fewer threads, the MemStore flushes will be queued. With more threads, the flushes will be executed in parallel, increasing the load on HDFS, and potentially causing more compactions.\\\n**Default:** `2`\n\n#### `hbase.hstore.blockingStoreFiles` \\[!toc]\n\n**Description:** If more than this number of StoreFiles exist in any one Store (one StoreFile is written per flush of MemStore), updates are blocked for this region until a compaction is completed, or until hbase.hstore.blockingWaitTime has been exceeded.\\\n**Default:** `16`\n\n#### `hbase.hstore.blockingWaitTime` \\[!toc]\n\n**Description:** The time for which a region will block updates after reaching the StoreFile limit defined by hbase.hstore.blockingStoreFiles. After this time has elapsed, the region will stop blocking updates even if a compaction has not been completed.\\\n**Default:** `90000`\n\n#### `hbase.hstore.compaction.min` \\[!toc]\n\n**Description:** The minimum number of StoreFiles which must be eligible for compaction before compaction can run. The goal of tuning hbase.hstore.compaction.min is to avoid ending up with too many tiny StoreFiles to compact. Setting this value to 2 would cause a minor compaction each time you have two StoreFiles in a Store, and this is probably not appropriate. If you set this value too high, all the other values will need to be adjusted accordingly. For most cases, the default value is appropriate (empty value here, results in 3 by code logic). In previous versions of HBase, the parameter hbase.hstore.compaction.min was named hbase.hstore.compactionThreshold.\\\n**Default:** `(empty)`\n\n#### `hbase.hstore.compaction.max` \\[!toc]\n\n**Description:** The maximum number of StoreFiles which will be selected for a single minor compaction, regardless of the number of eligible StoreFiles. Effectively, the value of hbase.hstore.compaction.max controls the length of time it takes a single compaction to complete. Setting it larger means that more StoreFiles are included in a compaction. For most cases, the default value is appropriate.\\\n**Default:** `10`\n\n#### `hbase.hstore.compaction.min.size` \\[!toc]\n\n**Description:** A StoreFile (or a selection of StoreFiles, when using ExploringCompactionPolicy) smaller than this size will always be eligible for minor compaction. HFiles this size or larger are evaluated by hbase.hstore.compaction.ratio to determine if they are eligible. Because this limit represents the \"automatic include\" limit for all StoreFiles smaller than this value, this value may need to be reduced in write-heavy environments where many StoreFiles in the 1-2 MB range are being flushed, because every StoreFile will be targeted for compaction and the resulting StoreFiles may still be under the minimum size and require further compaction. If this parameter is lowered, the ratio check is triggered more quickly. This addressed some issues seen in earlier versions of HBase but changing this parameter is no longer necessary in most situations. Default: 128 MB expressed in bytes.\\\n**Default:** `134217728`\n\n#### `hbase.hstore.compaction.max.size` \\[!toc]\n\n**Description:** A StoreFile (or a selection of StoreFiles, when using ExploringCompactionPolicy) larger than this size will be excluded from compaction. The effect of raising hbase.hstore.compaction.max.size is fewer, larger StoreFiles that do not get compacted often. If you feel that compaction is happening too often without much benefit, you can try raising this value. Default: the value of LONG.MAX\\_VALUE, expressed in bytes.\\\n**Default:** `9223372036854775807`\n\n#### `hbase.hstore.compaction.ratio` \\[!toc]\n\n**Description:** For minor compaction, this ratio is used to determine whether a given StoreFile which is larger than hbase.hstore.compaction.min.size is eligible for compaction. Its effect is to limit compaction of large StoreFiles. The value of hbase.hstore.compaction.ratio is expressed as a floating-point decimal. A large ratio, such as 10, will produce a single giant StoreFile. Conversely, a low value, such as .25, will produce behavior similar to the BigTable compaction algorithm, producing four StoreFiles. A moderate value of between 1.0 and 1.4 is recommended. When tuning this value, you are balancing write costs with read costs. Raising the value (to something like 1.4) will have more write costs, because you will compact larger StoreFiles. However, during reads, HBase will need to seek through fewer StoreFiles to accomplish the read. Consider this approach if you cannot take advantage of Bloom filters. Otherwise, you can lower this value to something like 1.0 to reduce the background cost of writes, and use Bloom filters to control the number of StoreFiles touched during reads. For most cases, the default value is appropriate.\\\n**Default:** `1.2F`\n\n#### `hbase.hstore.compaction.ratio.offpeak` \\[!toc]\n\n**Description:** Allows you to set a different (by default, more aggressive) ratio for determining whether larger StoreFiles are included in compactions during off-peak hours. Works in the same way as hbase.hstore.compaction.ratio. Only applies if hbase.offpeak.start.hour and hbase.offpeak.end.hour are also enabled.\\\n**Default:** `5.0F`\n\n#### `hbase.hstore.time.to.purge.deletes` \\[!toc]\n\n**Description:** The amount of time to delay purging of delete markers with future timestamps. If unset, or set to 0, all delete markers, including those with future timestamps, are purged during the next major compaction. Otherwise, a delete marker is kept until the major compaction which occurs after the marker's timestamp plus the value of this setting, in milliseconds.\\\n**Default:** `0`\n\n#### `hbase.offpeak.start.hour` \\[!toc]\n\n**Description:** The start of off-peak hours, expressed as an integer between 0 and 23, inclusive. Set to -1 to disable off-peak.\\\n**Default:** `-1`\n\n#### `hbase.offpeak.end.hour` \\[!toc]\n\n**Description:** The end of off-peak hours, expressed as an integer between 0 and 23, inclusive. Set to -1 to disable off-peak.\\\n**Default:** `-1`\n\n#### `hbase.regionserver.thread.compaction.throttle` \\[!toc]\n\n**Description:** There are two different thread pools for compactions, one for large compactions and the other for small compactions. This helps to keep compaction of lean tables (such as hbase:meta) fast. If a compaction is larger than this threshold, it goes into the large compaction pool. In most cases, the default value is appropriate. Default: 2 x hbase.hstore.compaction.max x hbase.hregion.memstore.flush.size (which defaults to 128MB). The value field assumes that the value of hbase.hregion.memstore.flush.size is unchanged from the default.\\\n**Default:** `2684354560`\n\n#### `hbase.regionserver.majorcompaction.pagecache.drop` \\[!toc]\n\n**Description:** Specifies whether to drop pages read/written into the system page cache by major compactions. Setting it to true helps prevent major compactions from polluting the page cache, which is almost always required, especially for clusters with low/moderate memory to storage ratio.\\\n**Default:** `true`\n\n#### `hbase.regionserver.minorcompaction.pagecache.drop` \\[!toc]\n\n**Description:** Specifies whether to drop pages read/written into the system page cache by minor compactions. Setting it to true helps prevent minor compactions from polluting the page cache, which is most beneficial on clusters with low memory to storage ratio or very write heavy clusters. You may want to set it to false under moderate to low write workload when bulk of the reads are on the most recently written data.\\\n**Default:** `true`\n\n#### `hbase.hstore.compaction.kv.max` \\[!toc]\n\n**Description:** The maximum number of KeyValues to read and then write in a batch when flushing or compacting. Set this lower if you have big KeyValues and problems with Out Of Memory Exceptions Set this higher if you have wide, small rows.\\\n**Default:** `10`\n\n#### `hbase.storescanner.parallel.seek.enable` \\[!toc]\n\n**Description:** Enables StoreFileScanner parallel-seeking in StoreScanner, a feature which can reduce response latency under special conditions.\\\n**Default:** `false`\n\n#### `hbase.storescanner.parallel.seek.threads` \\[!toc]\n\n**Description:** The default thread pool size if parallel-seeking feature enabled.\\\n**Default:** `10`\n\n#### `hfile.block.cache.policy` \\[!toc]\n\n**Description:** The eviction policy for the L1 block cache (LRU or TinyLFU).\\\n**Default:** `LRU`\n\n#### `hfile.block.cache.size` \\[!toc]\n\n**Description:** Percentage of maximum heap (-Xmx setting) to allocate to block cache used by a StoreFile. Default of 0.4 means allocate 40%. Set to 0 to disable but it's not recommended; you need at least enough cache to hold the storefile indices.\\\n**Default:** `0.4`\n\n#### `hfile.block.cache.memory.size` \\[!toc]\n\n**Description:** Defines the maximum heap memory allocated for the HFile block cache, specified in bytes or human-readable formats like '10m' for megabytes or '10g' for gigabytes. This configuration allows setting an absolute memory size instead of a percentage of the maximum heap. Takes precedence over hfile.block.cache.size if both are specified.\\\n**Default:** `(empty)`\n\n#### `hfile.block.index.cacheonwrite` \\[!toc]\n\n**Description:** This allows to put non-root multi-level index blocks into the block cache at the time the index is being written.\\\n**Default:** `false`\n\n#### `hfile.index.block.max.size` \\[!toc]\n\n**Description:** When the size of a leaf-level, intermediate-level, or root-level index block in a multi-level block index grows to this size, the block is written out and a new block is started.\\\n**Default:** `131072`\n\n#### `hbase.bucketcache.ioengine` \\[!toc]\n\n**Description:** Where to store the contents of the bucketcache. One of: offheap, file, files, mmap or pmem. If a file or files, set it to file(s):PATH\\_TO\\_FILE. mmap means the content will be in an mmaped file. Use mmap:PATH\\_TO\\_FILE. 'pmem' is bucket cache over a file on the persistent memory device. Use pmem:PATH\\_TO\\_FILE. See [http://hbase.apache.org/book.html#offheap.blockcache](http://hbase.apache.org/book.html#offheap.blockcache) for more information.\\\n**Default:** `(empty)`\n\n#### `hbase.hstore.compaction.throughput.lower.bound` \\[!toc]\n\n**Description:** The target lower bound on aggregate compaction throughput, in bytes/sec. Allows you to tune the minimum available compaction throughput when the PressureAwareCompactionThroughputController throughput controller is active. (It is active by default.)\\\n**Default:** `52428800`\n\n#### `hbase.hstore.compaction.throughput.higher.bound` \\[!toc]\n\n**Description:** The target upper bound on aggregate compaction throughput, in bytes/sec. Allows you to control aggregate compaction throughput demand when the PressureAwareCompactionThroughputController throughput controller is active. (It is active by default.) The maximum throughput will be tuned between the lower and upper bounds when compaction pressure is within the range \\[0.0, 1.0]. If compaction pressure is 1.0 or greater the higher bound will be ignored until pressure returns to the normal range.\\\n**Default:** `104857600`\n\n#### `hbase.bucketcache.size` \\[!toc]\n\n**Description:** It is the total capacity in megabytes of BucketCache. Default: 0.0\\\n**Default:** `(empty)`\n\n#### `hbase.bucketcache.bucket.sizes` \\[!toc]\n\n**Description:** A comma-separated list of sizes for buckets for the bucketcache. Can be multiple sizes. List block sizes in order from smallest to largest. The sizes you use will depend on your data access patterns. Must be a multiple of 256 else you will run into 'java.io.IOException: Invalid HFile block magic' when you go to read from cache. If you specify no values here, then you pick up the default bucketsizes set in code (See BucketAllocator#DEFAULT\\_BUCKET\\_SIZES).\\\n**Default:** `(empty)`\n\n#### `hfile.format.version` \\[!toc]\n\n**Description:** The HFile format version to use for new files. Version 3 adds support for tags in hfiles (See [http://hbase.apache.org/book.html#hbase.tags](http://hbase.apache.org/book.html#hbase.tags)). Also see the configuration 'hbase.replication.rpc.codec'.\\\n**Default:** `3`\n\n#### `hfile.block.bloom.cacheonwrite` \\[!toc]\n\n**Description:** Enables cache-on-write for inline blocks of a compound Bloom filter.\\\n**Default:** `false`\n\n#### `io.storefile.bloom.block.size` \\[!toc]\n\n**Description:** The size in bytes of a single block (\"chunk\") of a compound Bloom filter. This size is approximate, because Bloom blocks can only be inserted at data block boundaries, and the number of keys per data block varies.\\\n**Default:** `131072`\n\n#### `hbase.rs.cacheblocksonwrite` \\[!toc]\n\n**Description:** Whether an HFile block should be added to the block cache when the block is finished.\\\n**Default:** `false`\n\n#### `hbase.rpc.timeout` \\[!toc]\n\n**Description:** This is for the RPC layer to define how long (millisecond) HBase client applications take for a remote call to time out. It uses pings to check connections but will eventually throw a TimeoutException.\\\n**Default:** `60000`\n\n#### `hbase.client.operation.timeout` \\[!toc]\n\n**Description:** Operation timeout is a top-level restriction (millisecond) that makes sure a blocking operation in Table will not be blocked more than this. In each operation, if rpc request fails because of timeout or other reason, it will retry until success or throw RetriesExhaustedException. But if the total time being blocking reach the operation timeout before retries exhausted, it will break early and throw SocketTimeoutException.\\\n**Default:** `1200000`\n\n#### `hbase.client.connection.metacache.invalidate-interval.ms` \\[!toc]\n\n**Description:** Interval in milliseconds of checking and invalidating meta cache when table disabled or dropped, when set to zero means disable checking, suggest set it to 24h or a higher value, because disable/delete table usually not very frequently.\\\n**Default:** `0`\n\n#### `hbase.cells.scanned.per.heartbeat.check` \\[!toc]\n\n**Description:** The number of cells scanned in between heartbeat checks. Heartbeat checks occur during the processing of scans to determine whether or not the server should stop scanning in order to send back a heartbeat message to the client. Heartbeat messages are used to keep the client-server connection alive during long running scans. Small values mean that the heartbeat checks will occur more often and thus will provide a tighter bound on the execution time of the scan. Larger values mean that the heartbeat checks occur less frequently\\\n**Default:** `10000`\n\n#### `hbase.rpc.shortoperation.timeout` \\[!toc]\n\n**Description:** This is another version of \"hbase.rpc.timeout\". For those RPC operation within cluster, we rely on this configuration to set a short timeout limitation for short operation. For example, short rpc timeout for region server's trying to report to active master can benefit quicker master failover process.\\\n**Default:** `10000`\n\n#### `hbase.ipc.client.tcpnodelay` \\[!toc]\n\n**Description:** Set no delay on rpc socket connections. See [http://docs.oracle.com/javase/1.5.0/docs/api/java/net/Socket.html#getTcpNoDelay()](http://docs.oracle.com/javase/1.5.0/docs/api/java/net/Socket.html#getTcpNoDelay\\(\\))\\\n**Default:** `true`\n\n#### `hbase.unsafe.regionserver.hostname` \\[!toc]\n\n**Description:** This config is for experts: don't set its value unless you really know what you are doing. When set to a non-empty value, this represents the (external facing) hostname for the underlying server. See [https://issues.apache.org/jira/browse/HBASE-12954](https://issues.apache.org/jira/browse/HBASE-12954) for details.\\\n**Default:** `(empty)`\n\n#### `hbase.unsafe.regionserver.hostname.disable.master.reversedns` \\[!toc]\n\n**Description:** This config is for experts: don't set its value unless you really know what you are doing. When set to true, regionserver will use the current node hostname for the servername and HMaster will skip reverse DNS lookup and use the hostname sent by regionserver instead. Note that this config and hbase.unsafe.regionserver.hostname are mutually exclusive. See [https://issues.apache.org/jira/browse/HBASE-18226](https://issues.apache.org/jira/browse/HBASE-18226) for more details.\\\n**Default:** `false`\n\n#### `hbase.master.keytab.file` \\[!toc]\n\n**Description:** Full path to the kerberos keytab file to use for logging in the configured HMaster server principal.\\\n**Default:** `(empty)`\n\n#### `hbase.master.kerberos.principal` \\[!toc]\n\n**Description:** Ex. \"hbase/\\_[HOST@EXAMPLE.COM](mailto:HOST@EXAMPLE.COM)\". The kerberos principal name that should be used to run the HMaster process. The principal name should be in the form: user/hostname\\@DOMAIN. If \"\\_HOST\" is used as the hostname portion, it will be replaced with the actual hostname of the running instance.\\\n**Default:** `(empty)`\n\n#### `hbase.regionserver.keytab.file` \\[!toc]\n\n**Description:** Full path to the kerberos keytab file to use for logging in the configured HRegionServer server principal.\\\n**Default:** `(empty)`\n\n#### `hbase.regionserver.kerberos.principal` \\[!toc]\n\n**Description:** Ex. \"hbase/\\_[HOST@EXAMPLE.COM](mailto:HOST@EXAMPLE.COM)\". The kerberos principal name that should be used to run the HRegionServer process. The principal name should be in the form: user/hostname\\@DOMAIN. If \"\\_HOST\" is used as the hostname portion, it will be replaced with the actual hostname of the running instance. An entry for this principal must exist in the file specified in hbase.regionserver.keytab.file\\\n**Default:** `(empty)`\n\n#### `hadoop.policy.file` \\[!toc]\n\n**Description:** The policy configuration file used by RPC servers to make authorization decisions on client requests. Only used when HBase security is enabled.\\\n**Default:** `hbase-policy.xml`\n\n#### `hbase.superuser` \\[!toc]\n\n**Description:** List of users or groups (comma-separated), who are allowed full privileges, regardless of stored ACLs, across the cluster. Only used when HBase security is enabled. Group names should be prefixed with \"@\".\\\n**Default:** `(empty)`\n\n#### `hbase.auth.key.update.interval` \\[!toc]\n\n**Description:** The update interval for master key for authentication tokens in servers in milliseconds. Only used when HBase security is enabled.\\\n**Default:** `86400000`\n\n#### `hbase.auth.token.max.lifetime` \\[!toc]\n\n**Description:** The maximum lifetime in milliseconds after which an authentication token expires. Only used when HBase security is enabled.\\\n**Default:** `604800000`\n\n#### `hbase.ipc.client.fallback-to-simple-auth-allowed` \\[!toc]\n\n**Description:** When a client is configured to attempt a secure connection, but attempts to connect to an insecure server, that server may instruct the client to switch to SASL SIMPLE (unsecure) authentication. This setting controls whether or not the client will accept this instruction from the server. When false (the default), the client will not allow the fallback to SIMPLE authentication, and will abort the connection.\\\n**Default:** `false`\n\n#### `hbase.ipc.server.fallback-to-simple-auth-allowed` \\[!toc]\n\n**Description:** When a server is configured to require secure connections, it will reject connection attempts from clients using SASL SIMPLE (unsecure) authentication. This setting allows secure servers to accept SASL SIMPLE connections from clients when the client requests. When false (the default), the server will not allow the fallback to SIMPLE authentication, and will reject the connection. WARNING: This setting should ONLY be used as a temporary measure while converting clients over to secure authentication. It MUST BE DISABLED for secure operation.\\\n**Default:** `false`\n\n#### `hbase.unsafe.client.kerberos.hostname.disable.reversedns` \\[!toc]\n\n**Description:** This config is for experts: don't set its value unless you really know what you are doing. When set to true, HBase client using SASL Kerberos will skip reverse DNS lookup and use provided hostname of the destination for the principal instead. See [https://issues.apache.org/jira/browse/HBASE-25665](https://issues.apache.org/jira/browse/HBASE-25665) for more details.\\\n**Default:** `false`\n\n#### `hbase.display.keys` \\[!toc]\n\n**Description:** When this is set to true the webUI and such will display all start/end keys as part of the table details, region names, etc. When this is set to false, the keys are hidden.\\\n**Default:** `true`\n\n#### `hbase.coprocessor.enabled` \\[!toc]\n\n**Description:** Enables or disables coprocessor loading. If 'false' (disabled), any other coprocessor related configuration will be ignored.\\\n**Default:** `true`\n\n#### `hbase.coprocessor.user.enabled` \\[!toc]\n\n**Description:** Enables or disables user (aka. table) coprocessor loading. If 'false' (disabled), any table coprocessor attributes in table descriptors will be ignored. If \"hbase.coprocessor.enabled\" is 'false' this setting has no effect.\\\n**Default:** `true`\n\n#### `hbase.coprocessor.region.classes` \\[!toc]\n\n**Description:** A comma-separated list of region observer or endpoint coprocessors that are loaded by default on all tables. For any override coprocessor method, these classes will be called in order. After implementing your own Coprocessor, add it to HBase's classpath and add the fully qualified class name here. A coprocessor can also be loaded on demand by setting HTableDescriptor or the HBase shell.\\\n**Default:** `(empty)`\n\n#### `hbase.coprocessor.master.classes` \\[!toc]\n\n**Description:** A comma-separated list of org.apache.hadoop.hbase.coprocessor.MasterObserver coprocessors that are loaded by default on the active HMaster process. For any implemented coprocessor methods, the listed classes will be called in order. After implementing your own MasterObserver, just put it in HBase's classpath and add the fully qualified class name here.\\\n**Default:** `(empty)`\n\n#### `hbase.coprocessor.abortonerror` \\[!toc]\n\n**Description:** Set to true to cause the hosting server (master or regionserver) to abort if a coprocessor fails to load, fails to initialize, or throws an unexpected Throwable object. Setting this to false will allow the server to continue execution but the system wide state of the coprocessor in question will become inconsistent as it will be properly executing in only a subset of servers, so this is most useful for debugging only.\\\n**Default:** `true`\n\n#### `hbase.rest.port` \\[!toc]\n\n**Description:** The port for the HBase REST server.\\\n**Default:** `8080`\n\n#### `hbase.rest.readonly` \\[!toc]\n\n**Description:** Defines the mode the REST server will be started in. Possible values are: false: All HTTP methods are permitted - GET/PUT/POST/DELETE. true: Only the GET method is permitted.\\\n**Default:** `false`\n\n#### `hbase.rest.threads.max` \\[!toc]\n\n**Description:** The maximum number of threads of the REST server thread pool. Threads in the pool are reused to process REST requests. This controls the maximum number of requests processed concurrently. It may help to control the memory used by the REST server to avoid OOM issues. If the thread pool is full, incoming requests will be queued up and wait for some free threads.\\\n**Default:** `100`\n\n#### `hbase.rest.threads.min` \\[!toc]\n\n**Description:** The minimum number of threads of the REST server thread pool. The thread pool always has at least these number of threads so the REST server is ready to serve incoming requests.\\\n**Default:** `2`\n\n#### `hbase.rest.support.proxyuser` \\[!toc]\n\n**Description:** Enables running the REST server to support proxy-user mode.\\\n**Default:** `false`\n\n#### `hbase.defaults.for.version.skip` \\[!toc]\n\n**Description:** Set to true to skip the 'hbase.defaults.for.version' check. Setting this to true can be useful in contexts other than the other side of a maven generation; i.e. running in an IDE. You'll want to set this boolean to true to avoid seeing the RuntimeException complaint: \"hbase-default.xml file seems to be for and old version of HBase ($\\{hbase.version}), this version is X.X.X-SNAPSHOT\"\\\n**Default:** `false`\n\n#### `hbase.table.lock.enable` \\[!toc]\n\n**Description:** Set to true to enable locking the table in zookeeper for schema change operations. Table locking from master prevents concurrent schema modifications to corrupt table state.\\\n**Default:** `true`\n\n#### `hbase.table.max.rowsize` \\[!toc]\n\n**Description:** Maximum size of single row in bytes (default is 1 Gb) for Get'ting or Scan'ning without in-row scan flag set. If row size exceeds this limit RowTooBigException is thrown to client.\\\n**Default:** `1073741824`\n\n#### `hbase.thrift.minWorkerThreads` \\[!toc]\n\n**Description:** The \"core size\" of the thread pool. New threads are created on every connection until this many threads are created.\\\n**Default:** `16`\n\n#### `hbase.thrift.maxWorkerThreads` \\[!toc]\n\n**Description:** The maximum size of the thread pool. When the pending request queue overflows, new threads are created until their number reaches this number. After that, the server starts dropping connections.\\\n**Default:** `1000`\n\n#### `hbase.thrift.maxQueuedRequests` \\[!toc]\n\n**Description:** The maximum number of pending Thrift connections waiting in the queue. If there are no idle threads in the pool, the server queues requests. Only when the queue overflows, new threads are added, up to hbase.thrift.maxQueuedRequests threads.\\\n**Default:** `1000`\n\n#### `hbase.regionserver.thrift.framed` \\[!toc]\n\n**Description:** Use Thrift TFramedTransport on the server side. This is the recommended transport for thrift servers and requires a similar setting on the client side. Changing this to false will select the default transport, vulnerable to DoS when malformed requests are issued due to THRIFT-601.\\\n**Default:** `false`\n\n#### `hbase.regionserver.thrift.framed.max_frame_size_in_mb` \\[!toc]\n\n**Description:** Default frame size when using framed transport, in MB\\\n**Default:** `2`\n\n#### `hbase.regionserver.thrift.compact` \\[!toc]\n\n**Description:** Use Thrift TCompactProtocol binary serialization protocol.\\\n**Default:** `false`\n\n#### `hbase.rootdir.perms` \\[!toc]\n\n**Description:** FS Permissions for the root data subdirectory in a secure (kerberos) setup. When master starts, it creates the rootdir with this permissions or sets the permissions if it does not match.\\\n**Default:** `700`\n\n#### `hbase.wal.dir.perms` \\[!toc]\n\n**Description:** FS Permissions for the root WAL directory in a secure(kerberos) setup. When master starts, it creates the WAL dir with this permissions or sets the permissions if it does not match.\\\n**Default:** `700`\n\n#### `hbase.data.umask.enable` \\[!toc]\n\n**Description:** Enable, if true, that file permissions should be assigned to the files written by the regionserver\\\n**Default:** `false`\n\n#### `hbase.data.umask` \\[!toc]\n\n**Description:** File permissions that should be used to write data files when hbase.data.umask.enable is true\\\n**Default:** `000`\n\n#### `hbase.snapshot.enabled` \\[!toc]\n\n**Description:** Set to true to allow snapshots to be taken / restored / cloned.\\\n**Default:** `true`\n\n#### `hbase.snapshot.restore.take.failsafe.snapshot` \\[!toc]\n\n**Description:** Set to true to take a snapshot before the restore operation. The snapshot taken will be used in case of failure, to restore the previous state. At the end of the restore operation this snapshot will be deleted\\\n**Default:** `true`\n\n#### `hbase.snapshot.restore.failsafe.name` \\[!toc]\n\n**Description:** Name of the failsafe snapshot taken by the restore operation. You can use the \\{snapshot.name}, \\{table.name} and \\{restore.timestamp} variables to create a name based on what you are restoring.\\\n**Default:** `hbase-failsafe-{snapshot.name}-{restore.timestamp}`\n\n#### `hbase.snapshot.working.dir` \\[!toc]\n\n**Description:** Location where the snapshotting process will occur. The location of the completed snapshots will not change, but the temporary directory where the snapshot process occurs will be set to this location. This can be a separate filesystem than the root directory, for performance increase purposes. See HBASE-21098 for more information\\\n**Default:** `(empty)`\n\n#### `hbase.server.compactchecker.interval.multiplier` \\[!toc]\n\n**Description:** The number that determines how often we scan to see if compaction is necessary. Normally, compactions are done after some events (such as memstore flush), but if region didn't receive a lot of writes for some time, or due to different compaction policies, it may be necessary to check it periodically. The interval between checks is hbase.server.compactchecker.interval.multiplier multiplied by hbase.server.thread.wakefrequency.\\\n**Default:** `1000`\n\n#### `hbase.lease.recovery.timeout` \\[!toc]\n\n**Description:** How long we wait on dfs lease recovery in total before giving up.\\\n**Default:** `900000`\n\n#### `hbase.lease.recovery.dfs.timeout` \\[!toc]\n\n**Description:** How long between dfs recover lease invocations. Should be larger than the sum of the time it takes for the namenode to issue a block recovery command as part of datanode; dfs.heartbeat.interval and the time it takes for the primary datanode, performing block recovery to timeout on a dead datanode; usually dfs.client.socket-timeout. See the end of HBASE-8389 for more.\\\n**Default:** `64000`\n\n#### `hbase.column.max.version` \\[!toc]\n\n**Description:** New column family descriptors will use this value as the default number of versions to keep.\\\n**Default:** `1`\n\n#### `dfs.client.read.shortcircuit` \\[!toc]\n\n**Description:** If set to true, this configuration parameter enables short-circuit local reads.\\\n**Default:** `(empty)`\n\n#### `dfs.domain.socket.path` \\[!toc]\n\n**Description:** This is a path to a UNIX domain socket that will be used for communication between the DataNode and local HDFS clients, if dfs.client.read.shortcircuit is set to true. If the string \"\\_PORT\" is present in this path, it will be replaced by the TCP port of the DataNode. Be careful about permissions for the directory that hosts the shared domain socket; dfsclient will complain if open to other users than the HBase user.\\\n**Default:** `(empty)`\n\n#### `hbase.dfs.client.read.shortcircuit.buffer.size` \\[!toc]\n\n**Description:** If the DFSClient configuration dfs.client.read.shortcircuit.buffer.size is unset, we will use what is configured here as the short circuit read default direct byte buffer size. DFSClient native default is 1MB; HBase keeps its HDFS files open so number of file blocks \\* 1MB soon starts to add up and threaten OOME because of a shortage of direct memory. So, we set it down from the default. Make it > the default hbase block size set in the HColumnDescriptor which is usually 64k.\\\n**Default:** `131072`\n\n#### `hbase.regionserver.checksum.verify` \\[!toc]\n\n**Description:** If set to true (the default), HBase verifies the checksums for hfile blocks. HBase writes checksums inline with the data when it writes out hfiles. HDFS (as of this writing) writes checksums to a separate file than the data file necessitating extra seeks. Setting this flag saves some on i/o. Checksum verification by HDFS will be internally disabled on hfile streams when this flag is set. If the hbase-checksum verification fails, we will switch back to using HDFS checksums (so do not disable HDFS checksums! And besides this feature applies to hfiles only, not to WALs). If this parameter is set to false, then hbase will not verify any checksums, instead it will depend on checksum verification being done in the HDFS client.\\\n**Default:** `true`\n\n#### `hbase.hstore.bytes.per.checksum` \\[!toc]\n\n**Description:** Number of bytes in a newly created checksum chunk for HBase-level checksums in hfile blocks.\\\n**Default:** `16384`\n\n#### `hbase.hstore.checksum.algorithm` \\[!toc]\n\n**Description:** Name of an algorithm that is used to compute checksums. Possible values are NULL, CRC32, CRC32C.\\\n**Default:** `CRC32C`\n\n#### `hbase.client.scanner.max.result.size` \\[!toc]\n\n**Description:** Maximum number of bytes returned when calling a scanner's next method. Note that when a single row is larger than this limit the row is still returned completely. The default value is 2MB, which is good for 1ge networks. With faster and/or high latency networks this value should be increased.\\\n**Default:** `2097152`\n\n#### `hbase.server.scanner.max.result.size` \\[!toc]\n\n**Description:** Maximum number of bytes returned when calling a scanner's next method. Note that when a single row is larger than this limit the row is still returned completely. The default value is 100MB. This is a safety setting to protect the server from OOM situations.\\\n**Default:** `104857600`\n\n#### `hbase.status.published` \\[!toc]\n\n**Description:** This setting activates the publication by the master of the status of the region server. When a region server dies and its recovery starts, the master will push this information to the client application, to let them cut the connection immediately instead of waiting for a timeout.\\\n**Default:** `false`\n\n#### `hbase.status.publisher.class` \\[!toc]\n\n**Description:** Implementation of the status publication with a multicast message.\\\n**Default:** `org.apache.hadoop.hbase.master.ClusterStatusPublisher$MulticastPublisher`\n\n#### `hbase.status.listener.class` \\[!toc]\n\n**Description:** Implementation of the status listener with a multicast message.\\\n**Default:** `org.apache.hadoop.hbase.client.ClusterStatusListener$MulticastListener`\n\n#### `hbase.status.multicast.address.ip` \\[!toc]\n\n**Description:** Multicast address to use for the status publication by multicast.\\\n**Default:** `226.1.1.3`\n\n#### `hbase.status.multicast.address.port` \\[!toc]\n\n**Description:** Multicast port to use for the status publication by multicast.\\\n**Default:** `16100`\n\n#### `hbase.dynamic.jars.dir` \\[!toc]\n\n**Description:** The directory from which the custom filter JARs can be loaded dynamically by the region server without the need to restart. However, an already loaded filter/co-processor class would not be un-loaded. See HBASE-1936 for more details. Does not apply to coprocessors.\\\n**Default:** `${hbase.rootdir}/lib`\n\n#### `hbase.security.authentication` \\[!toc]\n\n**Description:** Controls whether or not secure authentication is enabled for HBase. Possible values are 'simple' (no authentication), and 'kerberos'.\\\n**Default:** `simple`\n\n#### `hbase.rest.filter.classes` \\[!toc]\n\n**Description:** Servlet filters for REST service.\\\n**Default:** `org.apache.hadoop.hbase.rest.filter.GzipFilter`\n\n#### `hbase.master.loadbalancer.class` \\[!toc]\n\n**Description:** Class used to execute the regions balancing when the period occurs. See the class comment for more on how it works [http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/balancer/StochasticLoadBalancer.html](http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/balancer/StochasticLoadBalancer.html) It replaces the DefaultLoadBalancer as the default (since renamed as the SimpleLoadBalancer).\\\n**Default:** `org.apache.hadoop.hbase.master.balancer.StochasticLoadBalancer`\n\n#### `hbase.master.loadbalance.bytable` \\[!toc]\n\n**Description:** Factor Table name when the balancer runs. Default: false.\\\n**Default:** `false`\n\n#### `hbase.master.normalizer.class` \\[!toc]\n\n**Description:** Class used to execute the region normalization when the period occurs. See the class comment for more on how it works [http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.html](http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.html)\\\n**Default:** `org.apache.hadoop.hbase.master.normalizer.SimpleRegionNormalizer`\n\n#### `hbase.rest.csrf.enabled` \\[!toc]\n\n**Description:** Set to true to enable protection against cross-site request forgery (CSRF)\\\n**Default:** `false`\n\n#### `hbase.rest-csrf.browser-useragents-regex` \\[!toc]\n\n**Description:** A comma-separated list of regular expressions used to match against an HTTP request's User-Agent header when protection against cross-site request forgery (CSRF) is enabled for REST server by setting hbase.rest.csrf.enabled to true. If the incoming User-Agent matches any of these regular expressions, then the request is considered to be sent by a browser, and therefore CSRF prevention is enforced. If the request's User-Agent does not match any of these regular expressions, then the request is considered to be sent by something other than a browser, such as scripted automation. In this case, CSRF is not a potential attack vector, so the prevention is not enforced. This helps achieve backwards-compatibility with existing automation that has not been updated to send the CSRF prevention header.\\\n**Default:** `^Mozilla.*,^Opera.*`\n\n#### `hbase.security.exec.permission.checks` \\[!toc]\n\n**Description:** If this setting is enabled and ACL based access control is active (the AccessController coprocessor is installed either as a system coprocessor or on a table as a table coprocessor) then you must grant all relevant users EXEC privilege if they require the ability to execute coprocessor endpoint calls. EXEC privilege, like any other permission, can be granted globally to a user, or to a user on a per table or per namespace basis. For more information on coprocessor endpoints, see the coprocessor section of the HBase online manual. For more information on granting or revoking permissions using the AccessController, see the security section of the HBase online manual.\\\n**Default:** `false`\n\n#### `hbase.procedure.regionserver.classes` \\[!toc]\n\n**Description:** A comma-separated list of org.apache.hadoop.hbase.procedure.RegionServerProcedureManager procedure managers that are loaded by default on the active HRegionServer process. The lifecycle methods (init/start/stop) will be called by the active HRegionServer process to perform the specific globally barriered procedure. After implementing your own RegionServerProcedureManager, just put it in HBase's classpath and add the fully qualified class name here.\\\n**Default:** `(empty)`\n\n#### `hbase.procedure.master.classes` \\[!toc]\n\n**Description:** A comma-separated list of org.apache.hadoop.hbase.procedure.MasterProcedureManager procedure managers that are loaded by default on the active HMaster process. A procedure is identified by its signature and users can use the signature and an instant name to trigger an execution of a globally barriered procedure. After implementing your own MasterProcedureManager, just put it in HBase's classpath and add the fully qualified class name here.\\\n**Default:** `(empty)`\n\n#### `hbase.coordinated.state.manager.class` \\[!toc]\n\n**Description:** Fully qualified name of class implementing coordinated state manager.\\\n**Default:** `org.apache.hadoop.hbase.coordination.ZkCoordinatedStateManager`\n\n#### `hbase.regionserver.storefile.refresh.period` \\[!toc]\n\n**Description:** The period (in milliseconds) for refreshing the store files for the secondary regions. 0 means this feature is disabled. Secondary regions sees new files (from flushes and compactions) from primary once the secondary region refreshes the list of files in the region (there is no notification mechanism). But too frequent refreshes might cause extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger value is also recommended with this setting.\\\n**Default:** `0`\n\n#### `hbase.region.replica.replication.enabled` \\[!toc]\n\n**Description:** Whether asynchronous WAL replication to the secondary region replicas is enabled or not. We have a separated implementation for replicating the WAL without using the general inter-cluster replication framework, so now we will not add any replication peers.\\\n**Default:** `false`\n\n#### `hbase.http.filter.initializers` \\[!toc]\n\n**Description:** A comma separated list of class names. Each class in the list must extend org.apache.hadoop.hbase.http.FilterInitializer. The corresponding Filter will be initialized. Then, the Filter will be applied to all user facing jsp and servlet web pages. The ordering of the list defines the ordering of the filters. The default StaticUserWebFilter add a user principal as defined by the hbase.http.staticuser.user property.\\\n**Default:** `org.apache.hadoop.hbase.http.lib.StaticUserWebFilter`\n\n#### `hbase.security.visibility.mutations.checkauths` \\[!toc]\n\n**Description:** This property if enabled, will check whether the labels in the visibility expression are associated with the user issuing the mutation\\\n**Default:** `false`\n\n#### `hbase.http.max.threads` \\[!toc]\n\n**Description:** The maximum number of threads that the HTTP Server will create in its ThreadPool.\\\n**Default:** `16`\n\n#### `hbase.http.metrics.servlets` \\[!toc]\n\n**Description:** Comma separated list of servlet names to enable for metrics collection. Supported servlets are jmx, metrics, prometheus\\\n**Default:** `jmx,metrics,prometheus`\n\n#### `hbase.replication.rpc.codec` \\[!toc]\n\n**Description:** The codec that is to be used when replication is enabled so that the tags are also replicated. This is used along with HFileV3 which supports tags in them. If tags are not used or if the hfile version used is HFileV2 then KeyValueCodec can be used as the replication codec. Note that using KeyValueCodecWithTags for replication when there are no tags causes no harm.\\\n**Default:** `org.apache.hadoop.hbase.codec.KeyValueCodecWithTags`\n\n#### `hbase.replication.source.maxthreads` \\[!toc]\n\n**Description:** The maximum number of threads any replication source will use for shipping edits to the sinks in parallel. This also limits the number of chunks each replication batch is broken into. Larger values can improve the replication throughput between the master and slave clusters. The default of 10 will rarely need to be changed.\\\n**Default:** `10`\n\n#### `hbase.http.staticuser.user` \\[!toc]\n\n**Description:** The user name to filter as, on static web filters while rendering content. An example use is the HDFS web UI (user to be used for browsing files).\\\n**Default:** `dr.stack`\n\n#### `hbase.regionserver.handler.abort.on.error.percent` \\[!toc]\n\n**Description:** The percent of region server RPC threads failed to abort RS. -1 Disable aborting; 0 Abort if even a single handler has died; 0.x Abort only when this percent of handlers have died; 1 Abort only all of the handers have died.\\\n**Default:** `0.5`\n\n#### `hbase.mob.file.cache.size` \\[!toc]\n\n**Description:** Number of opened file handlers to cache. A larger value will benefit reads by providing more file handlers per mob file cache and would reduce frequent file opening and closing. However, if this is set too high, this could lead to a \"too many opened file handlers\" The default value is 1000.\\\n**Default:** `1000`\n\n#### `hbase.mob.cache.evict.period` \\[!toc]\n\n**Description:** The amount of time in seconds before the mob cache evicts cached mob files. The default value is 3600 seconds.\\\n**Default:** `3600`\n\n#### `hbase.mob.cache.evict.remain.ratio` \\[!toc]\n\n**Description:** The ratio (between 0.0 and 1.0) of files that remains cached after an eviction is triggered when the number of cached mob files exceeds the hbase.mob.file.cache.size. The default value is 0.5f.\\\n**Default:** `0.5f`\n\n#### `hbase.master.mob.cleaner.period` \\[!toc]\n\n**Description:** The period that MobFileCleanerChore runs. The unit is second. The default value is one day. The MOB file name uses only the date part of the file creation time in it. We use this time for deciding TTL expiry of the files. So the removal of TTL expired files might be delayed. The max delay might be 24 hrs.\\\n**Default:** `86400`\n\n#### `hbase.mob.major.compaction.region.batch.size` \\[!toc]\n\n**Description:** The max number of a MOB table regions that is allowed in a batch of the mob compaction. By setting this number to a custom value, users can control the overall effect of a major compaction of a large MOB-enabled table. Default is 0 - means no limit - all regions of a MOB table will be compacted at once\\\n**Default:** `0`\n\n#### `hbase.mob.compaction.chore.period` \\[!toc]\n\n**Description:** The period that MobCompactionChore runs. The unit is second. The default value is one week.\\\n**Default:** `604800`\n\n#### `hbase.snapshot.master.timeout.millis` \\[!toc]\n\n**Description:** Timeout for master for the snapshot procedure execution.\\\n**Default:** `300000`\n\n#### `hbase.snapshot.region.timeout` \\[!toc]\n\n**Description:** Timeout for regionservers to keep threads in snapshot request pool waiting.\\\n**Default:** `300000`\n\n#### `hbase.rpc.rows.warning.threshold` \\[!toc]\n\n**Description:** Number of rows in a batch operation above which a warning will be logged. If hbase.client.write.buffer.maxmutations is not set, this will be used as fallback for that setting.\\\n**Default:** `5000`\n\n#### `hbase.master.wait.on.service.seconds` \\[!toc]\n\n**Description:** Default is 5 minutes. Make it 30 seconds for tests. See HBASE-19794 for some context.\\\n**Default:** `30`\n\n#### `hbase.master.cleaner.snapshot.interval` \\[!toc]\n\n**Description:** Snapshot Cleanup chore interval in milliseconds. The cleanup thread keeps running at this interval to find all snapshots that are expired based on TTL and delete them.\\\n**Default:** `1800000`\n\n#### `hbase.master.snapshot.ttl` \\[!toc]\n\n**Description:** Default Snapshot TTL to be considered when the user does not specify TTL while creating snapshot. Default value 0 indicates FOREVERE - snapshot should not be automatically deleted until it is manually deleted\\\n**Default:** `0`\n\n#### `hbase.master.regions.recovery.check.interval` \\[!toc]\n\n**Description:** Regions Recovery Chore interval in milliseconds. This chore keeps running at this interval to find all regions with configurable max store file ref count and reopens them.\\\n**Default:** `1200000`\n\n#### `hbase.regions.recovery.store.file.ref.count` \\[!toc]\n\n**Description:** Very large number of ref count on a compacted store file indicates that it is a ref leak on that object(compacted store file). Such files can not be removed after it is invalidated via compaction. Only way to recover in such scenario is to reopen the region which can release all resources, like the refcount, leases, etc. This config represents Store files Ref Count threshold value considered for reopening regions. Any region with compacted store files ref count > this value would be eligible for reopening by master. Here, we get the max refCount among all refCounts on all compacted away store files that belong to a particular region. Default value -1 indicates this feature is turned off. Only positive integer value should be provided to enable this feature.\\\n**Default:** `-1`\n\n#### `hbase.regionserver.slowlog.ringbuffer.size` \\[!toc]\n\n**Description:** Default size of ringbuffer to be maintained by each RegionServer in order to store online slowlog responses. This is an in-memory ring buffer of requests that were judged to be too slow in addition to the responseTooSlow logging. The in-memory representation would be complete. For more details, please look into Doc Section: Get Slow Response Log from shell\\\n**Default:** `256`\n\n#### `hbase.regionserver.slowlog.buffer.enabled` \\[!toc]\n\n**Description:** Indicates whether RegionServers have ring buffer running for storing Online Slow logs in FIFO manner with limited entries. The size of the ring buffer is indicated by config: hbase.regionserver.slowlog.ringbuffer.size The default value is false, turn this on and get latest slowlog responses with complete data.\\\n**Default:** `false`\n\n#### `hbase.regionserver.slowlog.systable.enabled` \\[!toc]\n\n**Description:** Should be enabled only if hbase.regionserver.slowlog.buffer.enabled is enabled. If enabled (true), all slow/large RPC logs would be persisted to system table hbase:slowlog (in addition to in-memory ring buffer at each RegionServer). The records are stored in increasing order of time. Operators can scan the table with various combination of ColumnValueFilter. More details are provided in the doc section: \"Get Slow/Large Response Logs from System table hbase:slowlog\"\\\n**Default:** `false`\n\n#### `hbase.master.metafixer.max.merge.count` \\[!toc]\n\n**Description:** Maximum regions to merge at a time when we fix overlaps noted in CJ consistency report, but avoid merging 100 regions in one go!\\\n**Default:** `64`\n\n#### `hbase.rpc.rows.size.threshold.reject` \\[!toc]\n\n**Description:** If value is true, RegionServer will abort batch requests of Put/Delete with number of rows in a batch operation exceeding threshold defined by value of config: hbase.rpc.rows.warning.threshold. The default value is false and hence, by default, only warning will be logged. This config should be turned on to prevent RegionServer from serving very large batch size of rows and this way we can improve CPU usages by discarding too large batch request.\\\n**Default:** `false`\n\n#### `hbase.namedqueue.provider.classes` \\[!toc]\n\n**Description:** Default values for NamedQueueService implementors. This comma separated full class names represent all implementors of NamedQueueService that we would like to be invoked by LogEvent handler service. One example of NamedQueue service is SlowLogQueueService which is used to store slow/large RPC logs in ringbuffer at each RegionServer. All implementors of NamedQueueService should be found under package: \"org.apache.hadoop.hbase.namequeues.impl\"\\\n**Default:** `org.apache.hadoop.hbase.namequeues.impl.SlowLogQueueService,org.apache.hadoop.hbase.namequeues.impl.BalancerDecisionQueueService,org.apache.hadoop.hbase.namequeues.impl.BalancerRejectionQueueService,org.apache.hadoop.hbase.namequeues.WALEventTrackerQueueService`\n\n#### `hbase.master.balancer.decision.buffer.enabled` \\[!toc]\n\n**Description:** Indicates whether active HMaster has ring buffer running for storing balancer decisions in FIFO manner with limited entries. The size of the ring buffer is indicated by config: hbase.master.balancer.decision.queue.size\\\n**Default:** `false`\n\n#### `hbase.master.balancer.rejection.buffer.enabled` \\[!toc]\n\n**Description:** Indicates whether active HMaster has ring buffer running for storing balancer rejection in FIFO manner with limited entries. The size of the ring buffer is indicated by config: hbase.master.balancer.rejection.queue.size\\\n**Default:** `false`\n\n#### `hbase.locality.inputstream.derive.enabled` \\[!toc]\n\n**Description:** If true, derive StoreFile locality metrics from the underlying DFSInputStream backing reads for that StoreFile. This value will update as the DFSInputStream's block locations are updated over time. Otherwise, locality is computed on StoreFile open, and cached until the StoreFile is closed.\\\n**Default:** `false`\n\n#### `hbase.locality.inputstream.derive.cache.period` \\[!toc]\n\n**Description:** If deriving StoreFile locality metrics from the underlying DFSInputStream, how long should the derived values be cached for. The derivation process may involve hitting the namenode, if the DFSInputStream's block list is incomplete.\\\n**Default:** `60000`\n\n## hbase-env.sh\n\nSet HBase environment variables in this file. Examples include options to pass the JVM on start of an HBase daemon such as heap size and garbage collector configs. You can also set configurations for HBase configuration, log directories, niceness, ssh options, where to locate process pid files, etc. Open the file at *conf/hbase-env.sh* and peruse its content. Each option is fairly well documented. Add your own environment variables here if you want them read by HBase daemons on startup.\n\nChanges here will require a cluster restart for HBase to notice the change.\n\n## *log4j2.properties*\n\nSince version 2.5.0, HBase has upgraded to Log4j2, so the configuration file name and format has changed. Read more in [Apache Log4j2](https://logging.apache.org/log4j/2.x/index.html).\n\nEdit this file to change rate at which HBase files are rolled and to change the level at which HBase logs messages.\n\nChanges here will require a cluster restart for HBase to notice the change though log levels can be changed for particular daemons via the HBase UI.\n\n## Client configuration and dependencies connecting to an HBase cluster\n\nIf you are running HBase in standalone mode, you don't need to configure anything for your client to work provided that they are all on the same machine.\n\nStarting release 3.0.0, the default connection registry has been switched to a rpc based implementation. Refer to [Rpc Connection Registry (new as of 2.5.0)](/docs/architecture/client#rpc-connection-registry-new-as-of-250). Depending on your HBase version, following is the expected minimal client configuration.\n\n### Up until 2.x.y releases\n\nIn 2.x.y releases, the default connection registry was based on ZooKeeper as the source of truth. This means that the clients always looked up ZooKeeper znodes to fetch the required metadata. For example, if an active master crashed and the a new master is elected, clients looked up the master znode to fetch the active master address (similarly for meta locations). This meant that the clients needed to have access to ZooKeeper and need to know the ZooKeeper ensemble information before they can do anything. This can be configured in the client configuration xml as follows:\n\n```xml\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<configuration>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>example1,example2,example3</value>\n    <description>Zookeeper ensemble information</description>\n  </property>\n</configuration>\n```\n\n### Starting from 3.0.0 release\n\nThe default implementation was switched to a rpc based connection registry. With this implementation, by default clients contact the active or stand-by master RPC end points to fetch the connection registry information. This means that the clients should have access to the list of active and master end points before they can do anything. This can be configured in the client configuration xml as follows:\n\n```xml\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<configuration>\n  <property>\n    <name>hbase.masters</name>\n    <value>example1,example2,example3</value>\n    <description>List of master rpc end points for the hbase cluster.</description>\n  </property>\n</configuration>\n```\n\nThe configuration value for *hbase.masters* is a comma separated list of *host:port* values. If no port value is specified, the default of *16000* is assumed.\n\nOf course you are free to specify bootstrap nodes other than masters, like:\n\n```xml\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<property>\n  <name>hbase.client.bootstrap.servers</name>\n  <value>server1:16020,server2:16020,server3:16020</value>\n</property>\n```\n\nThe configuration value for *hbase.client.bootstrap.servers* is a comma separated list of *host:port* values. Notice that port must be specified here.\n\nUsually these configurations are kept out in the *hbase-site.xml* and is picked up by the client from the `CLASSPATH`.\n\nIf you are configuring an IDE to run an HBase client, you should include the *conf/* directory on your classpath so *hbase-site.xml* settings can be found (or add *src/test/resources* to pick up the hbase-site.xml used by tests).\n\nFor Java applications using Maven, including the hbase-shaded-client module is the recommended dependency when connecting to a cluster:\n\n```xml\n<dependency>\n  <groupId>org.apache.hbase</groupId>\n  <artifactId>hbase-shaded-client</artifactId>\n  <version>2.0.0</version>\n</dependency>\n```\n\n### Java client configuration\n\nThe configuration used by a Java client is kept in an [HBaseConfiguration](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/HBaseConfiguration) instance.\n\nThe factory method on HBaseConfiguration, `HBaseConfiguration.create();`, on invocation, will read in the content of the first *hbase-site.xml* found on the client's `CLASSPATH`, if one is present (Invocation will also factor in any *hbase-default.xml* found; an *hbase-default.xml* ships inside the *hbase.X.X.X.jar*). It is also possible to specify configuration directly without having to read from a *hbase-site.xml*.\n\nFor example, to set the ZooKeeper ensemble or bootstrap nodes for the cluster programmatically do as follows:\n\n```java\nConfiguration config = HBaseConfiguration.create();\nconfig.set(\"hbase.zookeeper.quorum\", \"localhost\");  // Until 2.x.y versions\n// ---- or ----\nconfig.set(\"hbase.client.bootstrap.servers\", \"localhost:1234\"); // Starting 3.0.0 version\n```\n\n## Timeout settings\n\nHBase provides a wide variety of timeout settings to limit the execution time of various remote operations.\n\n* hbase.rpc.timeout\n* hbase.rpc.read.timeout\n* hbase.rpc.write.timeout\n* hbase.client.operation.timeout\n* hbase.client.meta.operation.timeout\n* hbase.client.scanner.timeout.period\n\nThe `hbase.rpc.timeout` property limits how long a single RPC call can run before timing out. To fine tune read or write related RPC timeouts set `hbase.rpc.read.timeout` and `hbase.rpc.write.timeout` configuration properties. In the absence of these properties `hbase.rpc.timeout` will be used.\n\nA higher-level timeout is `hbase.client.operation.timeout` which is valid for each client call. When an RPC call fails for instance for a timeout due to `hbase.rpc.timeout` it will be retried until `hbase.client.operation.timeout` is reached. Client operation timeout for system tables can be fine tuned by setting `hbase.client.meta.operation.timeout` configuration value. When this is not set its value will use `hbase.client.operation.timeout`.\n\nTimeout for scan operations is controlled differently. Use `hbase.client.scanner.timeout.period` property to set this timeout.\n\n## Example Configurations\n\n## Basic Distributed HBase Install\n\nHere is a basic configuration example for a distributed ten node cluster: \\* The nodes are named `example0`, `example1`, etc., through node `example9` in this example. \\* The HBase Master and the HDFS NameNode are running on the node `example0`. \\* RegionServers run on nodes `example1`-`example9`. \\* A 3-node ZooKeeper ensemble runs on `example1`, `example2`, and `example3` on the default ports. \\* ZooKeeper data is persisted to the directory */export/zookeeper*.\n\nBelow we show what the main configuration files — *hbase-site.xml*, *regionservers*, and *hbase-env.sh* — found in the HBase *conf* directory might look like.\n\n### hbase-site.xml\n\n```xml\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<configuration>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>example1,example2,example3</value>\n    <description>The directory shared by RegionServers.</description>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.dataDir</name>\n    <value>/export/zookeeper</value>\n    <description>Property from ZooKeeper config zoo.cfg.\n      The directory where the snapshot is stored.\n    </description>\n  </property>\n  <property>\n    <name>hbase.rootdir</name>\n    <value>hdfs://example0:9000/hbase</value>\n    <description>The directory shared by RegionServers.</description>\n  </property>\n  <property>\n    <name>hbase.cluster.distributed</name>\n    <value>true</value>\n    <description>The mode the cluster will be in. Possible values are\n      false: standalone and pseudo-distributed setups with managed ZooKeeper\n      true: fully-distributed with unmanaged ZooKeeper Quorum (see hbase-env.sh)\n    </description>\n  </property>\n</configuration>\n```\n\n### *regionservers*\n\nIn this file you list the nodes that will run RegionServers. In our case, these nodes are `example1`-`example9`.\n\n```text\nexample1\nexample2\nexample3\nexample4\nexample5\nexample6\nexample7\nexample8\nexample9\n```\n\n### hbase-env.sh\n\nThe following lines in the *hbase-env.sh* file show how to set the `JAVA_HOME` environment variable (required for HBase) and set the heap to 4 GB (rather than the default value of 1 GB). If you copy and paste this example, be sure to adjust the `JAVA_HOME` to suit your environment.\n\n```bash\n# The java implementation to use.\nexport JAVA_HOME=/usr/java/jdk1.8.0/\n\n# The maximum amount of heap to use. Default is left to JVM default.\nexport HBASE_HEAPSIZE=4G\n```\n\nUse rsync to copy the content of the *conf* directory to all nodes of the cluster.\n\n## The Important Configurations\n\n## Required Configurations\n\nReview the [os](/docs/configuration/basic-prerequisites#operating-system-utilities) and [hadoop](/docs/configuration/basic-prerequisites#hadoop) sections.\n\n### Big Cluster Configurations\n\nIf you have a cluster with a lot of regions, it is possible that a Regionserver checks in briefly after the Master starts while all the remaining RegionServers lag behind. This first server to check in will be assigned all regions which is not optimal. To prevent the above scenario from happening, up the `hbase.master.wait.on.regionservers.mintostart` property from its default value of 1. See [HBASE-6389 Modify the conditions to ensure that Master waits for sufficient number of Region Servers before starting region assignments](https://issues.apache.org/jira/browse/HBASE-6389) for more detail.\n\n## Recommended Configurations\n\n### ZooKeeper Configuration\n\n#### `zookeeper.session.timeout`\n\nThe default timeout is 90 seconds (specified in milliseconds). This means that if a server crashes, it will be 90 seconds before the Master notices the crash and starts recovery. You might need to tune the timeout down to a minute or even less so the Master notices failures sooner. Before changing this value, be sure you have your JVM garbage collection configuration under control, otherwise, a long garbage collection that lasts beyond the ZooKeeper session timeout will take out your RegionServer. (You might be fine with this — you probably want recovery to start on the server if a RegionServer has been in GC for a long period of time).\n\nTo change this configuration, edit *hbase-site.xml*, copy the changed file across the cluster and restart.\n\nWe set this value high to save our having to field questions up on the mailing lists asking why a RegionServer went down during a massive import. The usual cause is that their JVM is untuned and they are running into long GC pauses. Our thinking is that while users are getting familiar with HBase, we'd save them having to know all of its intricacies. Later when they've built some confidence, then they can play with configuration such as this.\n\n#### Number of ZooKeeper Instances\n\nSee [zookeeper](/docs/zookeeper).\n\n### HDFS Configurations\n\n#### `dfs.datanode.failed.volumes.tolerated`\n\nThis is the \"...number of volumes that are allowed to fail before a DataNode stops offering service. By default, any volume failure will cause a datanode to shutdown\" from the *hdfs-default.xml* description. You might want to set this to about half the amount of your available disks.\n\n#### `hbase.regionserver.handler.count`\n\nThis setting defines the number of threads that are kept open to answer incoming requests to user tables. The rule of thumb is to keep this number low when the payload per request approaches the MB (big puts, scans using a large cache) and high when the payload is small (gets, small puts, ICVs, deletes). The total size of the queries in progress is limited by the setting `hbase.ipc.server.max.callqueue.size`.\n\nIt is safe to set that number to the maximum number of incoming clients if their payload is small, the typical example being a cluster that serves a website since puts aren't typically buffered and most of the operations are gets.\n\nThe reason why it is dangerous to keep this setting high is that the aggregate size of all the puts that are currently happening in a region server may impose too much pressure on its memory, or even trigger an OutOfMemoryError. A RegionServer running on low memory will trigger its JVM's garbage collector to run more frequently up to a point where GC pauses become noticeable (the reason being that all the memory used to keep all the requests' payloads cannot be trashed, no matter how hard the garbage collector tries). After some time, the overall cluster throughput is affected since every request that hits that RegionServer will take longer, which exacerbates the problem even more.\n\nYou can get a sense of whether you have too little or too many handlers by [rpc.logging](/docs/troubleshooting#enabling-rpc-level-logging) on an individual RegionServer then tailing its logs (Queued requests consume memory).\n\n### Configuration for large memory machines\n\nHBase ships with a reasonable, conservative configuration that will work on nearly all machine types that people might want to test with. If you have larger machines — HBase has 8G and larger heap — you might find the following configuration options helpful. TODO.\n\n### Compression\n\nYou should consider enabling ColumnFamily compression. There are several options that are near-frictionless and in most all cases boost performance by reducing the size of StoreFiles and thus reducing I/O.\n\nSee [compression](/docs/compression) for more information.\n\n### Configuring the size and number of WAL files\n\nHBase uses \\[wal]/docs/architecture/regionserver#write-ahead-log-wal to recover the memstore data that has not been flushed to disk in case of an RS failure. These WAL files should be configured to be slightly smaller than HDFS block (by default a HDFS block is 64Mb and a WAL file is \\~60Mb).\n\nHBase also has a limit on the number of WAL files, designed to ensure there's never too much data that needs to be replayed during recovery. This limit needs to be set according to memstore configuration, so that all the necessary data would fit. It is recommended to allocate enough WAL files to store at least that much data (when all memstores are close to full). For example, with 16Gb RS heap, default memstore settings (0.4), and default WAL file size (\\~60Mb), 16Gb\\*0.4/60, the starting point for WAL file count is \\~109. However, as all memstores are not expected to be full all the time, less WAL files can be allocated.\n\n### Managed Splitting\n\nHBase generally handles splitting of your regions based upon the settings in your *hbase-default.xml* and *hbase-site.xml* configuration files. Important settings include `hbase.regionserver.region.split.policy`, `hbase.hregion.max.filesize`, `hbase.regionserver.regionSplitLimit`. A simplistic view of splitting is that when a region grows to `hbase.hregion.max.filesize`, it is split. For most usage patterns, you should use automatic splitting. See [manual region splitting decisions](/docs/architecture/regions#manual-region-splitting) for more information about manual region splitting.\n\nInstead of allowing HBase to split your regions automatically, you can choose to manage the splitting yourself. Manually managing splits works if you know your keyspace well, otherwise let HBase figure where to split for you. Manual splitting can mitigate region creation and movement under load. It also makes it so region boundaries are known and invariant (if you disable region splitting). If you use manual splits, it is easier doing staggered, time-based major compactions to spread out your network IO load.\n\n#### Disable Automatic Splitting\n\nTo disable automatic splitting, you can set region split policy in either cluster configuration or table configuration to be `org.apache.hadoop.hbase.regionserver.DisabledRegionSplitPolicy`\n\n<Callout type=\"info\">\n  If you disable automatic splits to diagnose a problem or during a period of fast data growth, it\n  is recommended to re-enable them when your situation becomes more stable. The potential benefits\n  of managing region splits yourself are not undisputed.\n</Callout>\n\n#### Determine the Optimal Number of Pre-Split Regions\n\nThe optimal number of pre-split regions depends on your application and environment. A good rule of thumb is to start with 10 pre-split regions per server and watch as data grows over time. It is better to err on the side of too few regions and perform rolling splits later. The optimal number of regions depends upon the largest StoreFile in your region. The size of the largest StoreFile will increase with time if the amount of data grows. The goal is for the largest region to be just large enough that the compaction selection algorithm only compacts it during a timed major compaction. Otherwise, the cluster can be prone to compaction storms with a large number of regions under compaction at the same time. It is important to understand that the data growth causes compaction storms and not the manual split decision.\n\nIf the regions are split into too many large regions, you can increase the major compaction interval by configuring `HConstants.MAJOR_COMPACTION_PERIOD`. The `org.apache.hadoop.hbase.util.RegionSplitter` utility also provides a network-IO-safe rolling split of all regions.\n\n### Managed Compactions\n\nBy default, major compactions are scheduled to run once in a 7-day period.\n\nIf you need to control exactly when and how often major compaction runs, you can disable managed major compactions. See the entry for `hbase.hregion.majorcompaction` in the [compaction.parameters](/docs/architecture/regions#parameters-used-by-compaction-algorithm) table for details.\n\n<Callout type=\"warn\">\n  Major compactions are absolutely necessary for StoreFile clean-up. Do not disable them altogether.\n  You can run major compactions manually via the HBase shell or via the [Admin\n  API](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Admin.html#majorCompact\\(org.apache.hadoop.hbase.TableName\\)).\n</Callout>\n\nFor more information about compactions and the compaction file selection process, see [compaction](/docs/architecture/regions#compaction)\n\n### Speculative Execution\n\nSpeculative Execution of MapReduce tasks is on by default, and for HBase clusters it is generally advised to turn off Speculative Execution at a system-level unless you need it for a specific case, where it can be configured per-job. Set the properties `mapreduce.map.speculative` and `mapreduce.reduce.speculative` to false.\n\n## Other Configurations\n\n### Balancer\n\nThe balancer is a periodic operation which is run on the master to redistribute regions on the cluster. It is configured via `hbase.balancer.period` and defaults to 300000 (5 minutes).\n\nSee [master.processes.loadbalancer](/docs/architecture/master#loadbalancer) for more information on the LoadBalancer.\n\n### Disabling Blockcache\n\nDo not turn off block cache (You'd do it by setting `hfile.block.cache.size` to zero). Currently, we do not do well if you do this because the RegionServer will spend all its time loading HFile indices over and over again. If your working set is such that block cache does you no good, at least size the block cache such that HFile indices will stay up in the cache (you can get a rough idea on the size you need by surveying RegionServer UIs; you'll see index block size accounted near the top of the webpage).\n\n### Nagle's or the small package problem\n\nIf a big 40ms or so occasional delay is seen in operations against HBase, try the [Nagle's](https://en.wikipedia.org/wiki/Nagle%27s_algorithm) setting. For example, see the user mailing list thread, [Inconsistent scan performance with caching set to 1](https://lists.apache.org/thread.html/3d7ceb41c04a955b1b1c80480cdba95208ca3e97bf6895a40e0c1bbb%401346186127%40%3Cuser.hbase.apache.org%3E) and the issue cited therein where setting `notcpdelay` improved scan speeds. You might also see the graphs on the tail of [HBASE-7008 Set scanner caching to a better default](https://issues.apache.org/jira/browse/HBASE-7008) where our Lars Hofhansl tries various data sizes w/ Nagle's on and off measuring the effect.\n\n### Better Mean Time to Recover (MTTR)\n\nThis section is about configurations that will make servers come back faster after a fail. See the Deveraj Das and Nicolas Liochon blog post [Introduction to HBase Mean Time to Recover (MTTR)](http://hortonworks.com/blog/introduction-to-hbase-mean-time-to-recover-mttr/) for a brief introduction.\n\nThe issue [HBASE-8354 forces Namenode into loop with lease recovery requests](https://issues.apache.org/jira/browse/HBASE-8389) is messy but has a bunch of good discussion toward the end on low timeouts and how to cause faster recovery including citation of fixes added to HDFS. Read the Varun Sharma comments. The below suggested configurations are Varun's suggestions distilled and tested. Make sure you are running on a late-version HDFS so you have the fixes he refers to and himself adds to HDFS that help HBase MTTR (e.g. HDFS-3703, HDFS-3712, and HDFS-4791 — Hadoop 2 for sure has them and late Hadoop 1 has some). Set the following in the RegionServer.\n\n```xml\n<property>\n  <name>hbase.lease.recovery.dfs.timeout</name>\n  <value>23000</value>\n  <description>How much time we allow elapse between calls to recover lease.\n  Should be larger than the dfs timeout.</description>\n</property>\n<property>\n  <name>dfs.client.socket-timeout</name>\n  <value>10000</value>\n  <description>Down the DFS timeout from 60 to 10 seconds.</description>\n</property>\n```\n\nAnd on the NameNode/DataNode side, set the following to enable 'staleness' introduced in HDFS-3703, HDFS-3912.\n\n```xml\n<property>\n  <name>dfs.client.socket-timeout</name>\n  <value>10000</value>\n  <description>Down the DFS timeout from 60 to 10 seconds.</description>\n</property>\n<property>\n  <name>dfs.datanode.socket.write.timeout</name>\n  <value>10000</value>\n  <description>Down the DFS timeout from 8 * 60 to 10 seconds.</description>\n</property>\n<property>\n  <name>ipc.client.connect.timeout</name>\n  <value>3000</value>\n  <description>Down from 60 seconds to 3.</description>\n</property>\n<property>\n  <name>ipc.client.connect.max.retries.on.timeouts</name>\n  <value>2</value>\n  <description>Down from 45 seconds to 3 (2 == 3 retries).</description>\n</property>\n<property>\n  <name>dfs.namenode.avoid.read.stale.datanode</name>\n  <value>true</value>\n  <description>Enable stale state in hdfs</description>\n</property>\n<property>\n  <name>dfs.namenode.stale.datanode.interval</name>\n  <value>20000</value>\n  <description>Down from default 30 seconds</description>\n</property>\n<property>\n  <name>dfs.namenode.avoid.write.stale.datanode</name>\n  <value>true</value>\n  <description>Enable stale state in hdfs</description>\n</property>\n```\n\n### JMX\n\nJMX (Java Management Extensions) provides built-in instrumentation that enables you to monitor and manage the Java VM. To enable monitoring and management from remote systems, you need to set system property `com.sun.management.jmxremote.port` (the port number through which you want to enable JMX RMI connections) when you start the Java VM. See the [official documentation](http://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html) for more information. Historically, besides above port mentioned, JMX opens two additional random TCP listening ports, which could lead to port conflict problem. (See [HBASE-10289](https://issues.apache.org/jira/browse/HBASE-10289) for details)\n\nAs an alternative, you can use the coprocessor-based JMX implementation provided by HBase. To enable it, add below property in *hbase-site.xml*:\n\n```xml\n<property>\n  <name>hbase.coprocessor.regionserver.classes</name>\n  <value>org.apache.hadoop.hbase.JMXListener</value>\n</property>\n```\n\n<Callout type=\"info\">\n  DO NOT set `com.sun.management.jmxremote.port` for Java VM at the same time.\n</Callout>\n\nCurrently it supports Master and RegionServer Java VM. By default, the JMX listens on TCP port 10102, you can further configure the port using below properties:\n\n```xml\n<property>\n  <name>regionserver.rmi.registry.port</name>\n  <value>61130</value>\n</property>\n<property>\n  <name>regionserver.rmi.connector.port</name>\n  <value>61140</value>\n</property>\n```\n\nThe registry port can be shared with connector port in most cases, so you only need to configure `regionserver.rmi.registry.port`. However, if you want to use SSL communication, the 2 ports must be configured to different values.\n\nBy default the password authentication and SSL communication is disabled. To enable password authentication, you need to update *hbase-env.sh* like below:\n\n```bash\nexport HBASE_JMX_BASE=\"-Dcom.sun.management.jmxremote.authenticate=true                  \\\n                       -Dcom.sun.management.jmxremote.password.file=your_password_file   \\\n                       -Dcom.sun.management.jmxremote.access.file=your_access_file\"\n\nexport HBASE_MASTER_OPTS=\"$HBASE_MASTER_OPTS $HBASE_JMX_BASE \"\nexport HBASE_REGIONSERVER_OPTS=\"$HBASE_REGIONSERVER_OPTS $HBASE_JMX_BASE \"\n```\n\nSee example password/access file under `$JRE_HOME/lib/management`.\n\nTo enable SSL communication with password authentication, follow below steps:\n\n```bash\n#1. generate a key pair, stored in myKeyStore\nkeytool -genkey -alias jconsole -keystore myKeyStore\n\n#2. export it to file jconsole.cert\nkeytool -export -alias jconsole -keystore myKeyStore -file jconsole.cert\n\n#3. copy jconsole.cert to jconsole client machine, import it to jconsoleKeyStore\nkeytool -import -alias jconsole -keystore jconsoleKeyStore -file jconsole.cert\n```\n\nAnd then update *hbase-env.sh* like below:\n\n```bash\nexport HBASE_JMX_BASE=\"-Dcom.sun.management.jmxremote.ssl=true                         \\\n                       -Djavax.net.ssl.keyStore=/home/tianq/myKeyStore                 \\\n                       -Djavax.net.ssl.keyStorePassword=your_password_in_step_1        \\\n                       -Dcom.sun.management.jmxremote.authenticate=true                \\\n                       -Dcom.sun.management.jmxremote.password.file=your_password file \\\n                       -Dcom.sun.management.jmxremote.access.file=your_access_file\"\n\nexport HBASE_MASTER_OPTS=\"$HBASE_MASTER_OPTS $HBASE_JMX_BASE \"\nexport HBASE_REGIONSERVER_OPTS=\"$HBASE_REGIONSERVER_OPTS $HBASE_JMX_BASE \"\n```\n\nFinally start `jconsole` on the client using the key store:\n\n```bash\njconsole -J-Djavax.net.ssl.trustStore=/home/tianq/jconsoleKeyStore\n```\n\n<Callout type=\"info\">\n  To enable the HBase JMX implementation on Master, you also need to add below property in\n  *hbase-site.xml*:\n</Callout>\n\n```xml\n<property>\n  <name>hbase.coprocessor.master.classes</name>\n  <value>org.apache.hadoop.hbase.JMXListener</value>\n</property>\n```\n\nThe corresponding properties for port configuration are `master.rmi.registry.port` (by default 10101) and `master.rmi.connector.port` (by default the same as registry.port)\n\n## Dynamic Configuration\n\nIt is possible to change a subset of the configuration without requiring a server restart. In the HBase shell, the operations `update_config`, `update_all_config` and `update_rsgroup_config` will prompt a server, all servers or all servers in the RSGroup to reload configuration.\n\nOnly a subset of all configurations can currently be changed in the running server. Here are those configurations:\n\nConfigurations that support dynamically change\n\n| Key                                                                    |\n| ---------------------------------------------------------------------- |\n| hbase.ipc.server.fallback-to-simple-auth-allowed                       |\n| hbase.cleaner.scan.dir.concurrent.size                                 |\n| hbase.coprocessor.master.classes                                       |\n| hbase.coprocessor.region.classes                                       |\n| hbase.coprocessor.regionserver.classes                                 |\n| hbase.coprocessor.user.region.classes                                  |\n| hbase.regionserver.thread.compaction.large                             |\n| hbase.regionserver.thread.compaction.small                             |\n| hbase.regionserver.thread.split                                        |\n| hbase.regionserver.throughput.controller                               |\n| hbase.regionserver.thread.hfilecleaner.throttle                        |\n| hbase.regionserver.hfilecleaner.large.queue.size                       |\n| hbase.regionserver.hfilecleaner.small.queue.size                       |\n| hbase.regionserver.hfilecleaner.large.thread.count                     |\n| hbase.regionserver.hfilecleaner.small.thread.count                     |\n| hbase.regionserver.hfilecleaner.thread.timeout.msec                    |\n| hbase.regionserver.hfilecleaner.thread.check.interval.msec             |\n| hbase.regionserver.flush.throughput.controller                         |\n| hbase.hstore.compaction.max.size                                       |\n| hbase.hstore.compaction.max.size.offpeak                               |\n| hbase.hstore.compaction.min.size                                       |\n| hbase.hstore.compaction.min                                            |\n| hbase.hstore.compaction.max                                            |\n| hbase.hstore.compaction.ratio                                          |\n| hbase.hstore.compaction.ratio.offpeak                                  |\n| hbase.regionserver.thread.compaction.throttle                          |\n| hbase.hregion.majorcompaction                                          |\n| hbase.hregion.majorcompaction.jitter                                   |\n| hbase.hstore.min.locality.to.skip.major.compact                        |\n| hbase.hstore.compaction.date.tiered.max.storefile.age.millis           |\n| hbase.hstore.compaction.date.tiered.incoming.window\\.min               |\n| hbase.hstore.compaction.date.tiered.window\\.policy.class               |\n| hbase.hstore.compaction.date.tiered.single.output.for.minor.compaction |\n| hbase.hstore.compaction.date.tiered.window\\.factory.class              |\n| hbase.offpeak.start.hour                                               |\n| hbase.offpeak.end.hour                                                 |\n| hbase.oldwals.cleaner.thread.size                                      |\n| hbase.oldwals.cleaner.thread.timeout.msec                              |\n| hbase.oldwals.cleaner.thread.check.interval.msec                       |\n| hbase.procedure.worker.keep.alive.time.msec                            |\n| hbase.procedure.worker.add.stuck.percentage                            |\n| hbase.procedure.worker.monitor.interval.msec                           |\n| hbase.procedure.worker.stuck.threshold.msec                            |\n| hbase.regions.slop                                                     |\n| hbase.regions.overallSlop                                              |\n| hbase.balancer.tablesOnMaster                                          |\n| hbase.balancer.tablesOnMaster.systemTablesOnly                         |\n| hbase.util.ip.to.rack.determiner                                       |\n| hbase.ipc.server.max.callqueue.length                                  |\n| hbase.ipc.server.priority.max.callqueue.length                         |\n| hbase.ipc.server.callqueue.type                                        |\n| hbase.ipc.server.callqueue.codel.target.delay                          |\n| hbase.ipc.server.callqueue.codel.interval                              |\n| hbase.ipc.server.callqueue.codel.lifo.threshold                        |\n| hbase.master.balancer.stochastic.maxSteps                              |\n| hbase.master.balancer.stochastic.stepsPerRegion                        |\n| hbase.master.balancer.stochastic.maxRunningTime                        |\n| hbase.master.balancer.stochastic.runMaxSteps                           |\n| hbase.master.balancer.stochastic.numRegionLoadsToRemember              |\n| hbase.master.loadbalance.bytable                                       |\n| hbase.master.balancer.stochastic.minCostNeedBalance                    |\n| hbase.master.balancer.stochastic.localityCost                          |\n| hbase.master.balancer.stochastic.rackLocalityCost                      |\n| hbase.master.balancer.stochastic.readRequestCost                       |\n| hbase.master.balancer.stochastic.writeRequestCost                      |\n| hbase.master.balancer.stochastic.memstoreSizeCost                      |\n| hbase.master.balancer.stochastic.storefileSizeCost                     |\n| hbase.master.balancer.stochastic.regionReplicaHostCostKey              |\n| hbase.master.balancer.stochastic.regionReplicaRackCostKey              |\n| hbase.master.balancer.stochastic.regionCountCost                       |\n| hbase.master.balancer.stochastic.primaryRegionCountCost                |\n| hbase.master.balancer.stochastic.moveCost                              |\n| hbase.master.balancer.stochastic.moveCost.offpeak                      |\n| hbase.master.balancer.stochastic.maxMovePercent                        |\n| hbase.master.balancer.stochastic.tableSkewCost                         |\n| hbase.master.regions.recovery.check.interval                           |\n| hbase.regions.recovery.store.file.ref.count                            |\n| hbase.rsgroup.fallback.enable                                          |\n\n***\n\n# Upgrading\n\nYou cannot skip major versions when upgrading. If you are upgrading from version 0.98.x to 2.x, you must first go from 0.98.x to 1.2.x and then go from 1.2.x to 2.x.\n\nReview [Apache HBase Configuration](/docs/configuration), in particular [Hadoop](/docs/configuration/basic-prerequisites#hadoop). Familiarize yourself with [Support and Testing Expectations](/docs#support-and-testing-expectations).\n\n## HBase version number and compatibility\n\n## Aspirational Semantic Versioning\n\nStarting with the 1.0.0 release, HBase is working towards [Semantic Versioning](http://semver.org/) for its release versioning. In summary:\n\n#### Given a version number MAJOR.MINOR.PATCH, increment the: \\[!toc]\n\n* MAJOR version when you make incompatible API changes,\n* MINOR version when you add functionality in a backwards-compatible manner, and\n* PATCH version when you make backwards-compatible bug fixes.\n* Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\n\n#### Compatibility Dimensions \\[!toc]\n\nIn addition to the usual API versioning considerations HBase has other compatibility dimensions that we need to consider.\n\n#### Client-Server wire protocol compatibility \\[!toc]\n\n* Allows updating client and server out of sync.\n* We could only allow upgrading the server first. I.e. the server would be backward compatible to an old client, that way new APIs are OK.\n* Example: A user should be able to use an old client to connect to an upgraded cluster.\n\n#### Server-Server protocol compatibility \\[!toc]\n\n* Servers of different versions can co-exist in the same cluster.\n* The wire protocol between servers is compatible.\n* Workers for distributed tasks, such as replication and log splitting, can co-exist in the same cluster.\n* Dependent protocols (such as using ZK for coordination) will also not be changed.\n* Example: A user can perform a rolling upgrade.\n\n#### File format compatibility \\[!toc]\n\n* Support file formats backward and forward compatible\n* Example: File, ZK encoding, directory layout is upgraded automatically as part of an HBase upgrade. User can downgrade to the older version and everything will continue to work.\n\n#### Client API compatibility \\[!toc]\n\n* Allow changing or removing existing client APIs.\n* An API needs to be deprecated for a whole major version before we will change/remove it.\n  * An example: An API was deprecated in 2.0.1 and will be marked for deletion in 4.0.0. On the other hand, an API deprecated in 2.0.0 can be removed in 3.0.0.\n  * Occasionally mistakes are made and internal classes are marked with a higher access level than they should. In these rare circumstances, we will accelerate the deprecation schedule to the next major version (i.e., deprecated in 2.2.x, marked `IA.Private` 3.0.0). Such changes are communicated and explained via release note in Jira.\n* APIs available in a patch version will be available in all later patch versions. However, new APIs may be added which will not be available in earlier patch versions.\n* New APIs introduced in a patch version will only be added in a source compatible way: i.e. code that implements public APIs will continue to compile. [^1]\n  * Example: A user using a newly deprecated API does not need to modify application code with HBase API calls until the next major version. \\*\n\n#### Client Binary compatibility \\[!toc]\n\n* Client code written to APIs available in a given patch release can run unchanged (no recompilation needed) against the new jars of later patch versions.\n* Client code written to APIs available in a given patch release might not run against the old jars from an earlier patch version.\n  * Example: Old compiled client code will work unchanged with the new jars.\n* If a Client implements an HBase Interface, a recompile MAY be required upgrading to a newer minor version (See release notes for warning about incompatible changes). All effort will be made to provide a default implementation so this case should not arise.\n\n#### Server-Side Limited API compatibility (taken from Hadoop) \\[!toc]\n\n* Internal APIs are marked as Stable, Evolving, or Unstable\n* This implies binary compatibility for coprocessors and plugins (pluggable classes, including replication) as long as these are only using marked interfaces/classes.\n* Example: Old compiled Coprocessor, Filter, or Plugin code will work unchanged with the new jars.\n\n#### Dependency Compatibility \\[!toc]\n\n* An upgrade of HBase will not require an incompatible upgrade of a dependent project, except for Apache Hadoop.\n* An upgrade of HBase will not require an incompatible upgrade of the Java runtime.\n* Example: Upgrading HBase to a version that supports *Dependency Compatibility* won't require that you upgrade your Apache ZooKeeper service.\n* Example: If your current version of HBase supported running on JDK 8, then an upgrade to a version that supports *Dependency Compatibility* will also run on JDK 8.\n\n<Callout type=\"tip\">\n  Previously, we tried to maintain dependency compatibility for the underly Hadoop service but over\n  the last few years this has proven untenable. While the HBase project attempts to maintain support\n  for older versions of Hadoop, we drop the \"supported\" designator for minor versions that fail to\n  continue to see releases. Additionally, the Hadoop project has its own set of compatibility\n  guidelines, which means in some cases having to update to a newer supported minor release might\n  break some of our compatibility promises.\n</Callout>\n\n#### Operational Compatibility \\[!toc]\n\n* Metric changes\n* Behavioral changes of services\n* JMX APIs exposed via the `/jmx/` endpoint\n\n#### Summary \\[!toc]\n\n* A patch upgrade is a drop-in replacement. Any change that is not Java binary and source compatible would not be allowed. Downgrading versions within patch releases may not be compatible. [^2]\n* A minor upgrade requires no application/client code modification. Ideally it would be a drop-in replacement but client code, coprocessors, filters, etc might have to be recompiled if new jars are used.\n* A major upgrade allows the HBase community to make breaking changes.\n\n#### Compatibility Matrix: \\[!toc]\n\n|                                           |  Major | Minor | Patch |\n| ----------------------------------------- | :----: | :---: | :---: |\n| Client-Server wire Compatibility          |    N   |   Y   |   Y   |\n| Server-Server Compatibility               |    N   |   Y   |   Y   |\n| File Format Compatibility                 | N [^1] |   Y   |   Y   |\n| Client API Compatibility                  |    N   |   Y   |   Y   |\n| Client Binary Compatibility               |    N   |   N   |   Y   |\n| **Server-Side Limited API Compatibility** |        |       |       |\n| → Stable                                  |    N   |   Y   |   Y   |\n| → Evolving                                |    N   |   N   |   Y   |\n| → Unstable                                |    N   |   N   |   N   |\n| Dependency Compatibility                  |    N   |   Y   |   Y   |\n| Operational Compatibility                 |    N   |   N   |   Y   |\n\n<Callout type=\"warn\">\n  HBase 1.7.0 release violated client-server wire compatibility guarantees and was subsequently\n  withdrawn after the incompatibilities were reported and fixed in 1.7.1. If you are considering an\n  upgrade to 1.7.x line, see [Upgrading to 1.7.1+](/docs/upgrading/paths#upgrading-to-171).\n</Callout>\n\n## HBase API Surface\n\nHBase has a lot of API points, but for the compatibility matrix above, we differentiate between Client API, Limited Private API, and Private API. HBase uses [Apache Yetus Audience Annotations](https://yetus.apache.org/documentation/in-progress/interface-classification/) to guide downstream expectations for stability.\n\n* InterfaceAudience ([javadocs](https://yetus.apache.org/documentation/in-progress/javadocs/org/apache/yetus/audience/InterfaceAudience.html)): captures the intended audience, possible values include:\n  * Public: safe for end users and external projects\n  * LimitedPrivate: used for internals we expect to be pluggable, such as coprocessors\n  * Private: strictly for use within HBase itself Classes which are defined as `IA.Private` may be used as parameters or return values for interfaces which are declared `IA.LimitedPrivate`. Treat the `IA.Private` object as opaque; do not try to access its methods or fields directly.\n* InterfaceStability ([javadocs](https://yetus.apache.org/documentation/in-progress/javadocs/org/apache/yetus/audience/InterfaceStability.html)): describes what types of interface changes are permitted. Possible values include:\n  * Stable: the interface is fixed and is not expected to change\n  * Evolving: the interface may change in future minor versions\n  * Unstable: the interface may change at any time\n\nPlease keep in mind the following interactions between the `InterfaceAudience` and `InterfaceStability` annotations within the HBase project:\n\n* `IA.Public` classes are inherently stable and adhere to our stability guarantees relating to the type of upgrade (major, minor, or patch).\n* `IA.LimitedPrivate` classes should always be annotated with one of the given `InterfaceStability` values. If they are not, you should presume they are `IS.Unstable`.\n* `IA.Private` classes should be considered implicitly unstable, with no guarantee of stability between releases.\n\n### HBase Client API\n\nHBase Client API consists of all the classes or methods that are marked with InterfaceAudience.Public interface. All main classes in hbase-client and dependent modules have either InterfaceAudience.Public, InterfaceAudience.LimitedPrivate, or InterfaceAudience.Private marker. Not all classes in other modules (hbase-server, etc) have the marker. If a class is not annotated with one of these, it is assumed to be a InterfaceAudience.Private class.\n\n### HBase LimitedPrivate API\n\nLimitedPrivate annotation comes with a set of target consumers for the interfaces. Those consumers are coprocessors, phoenix, replication endpoint implementations or similar. At this point, HBase only guarantees source and binary compatibility for these interfaces between patch versions.\n\n### HBase Private API\n\nAll classes annotated with InterfaceAudience.Private or all classes that do not have the annotation are for HBase internal use only. The interfaces and method signatures can change at any point in time. If you are relying on a particular interface that is marked Private, you should open a jira to propose changing the interface to be Public or LimitedPrivate, or an interface exposed for this purpose.\n\n### Binary Compatibility\n\nWhen we say two HBase versions are compatible, we mean that the versions are wire and binary compatible. Compatible HBase versions means that clients can talk to compatible but differently versioned servers. It means too that you can just swap out the jars of one version and replace them with the jars of another, compatible version and all will just work. Unless otherwise specified, HBase point versions are (mostly) binary compatible. You can safely do rolling upgrades between binary compatible versions; i.e. across maintenance releases: e.g. from 1.4.4 to 1.4.6. See \"Does compatibility between versions also mean binary compatibility?\" discussion on the HBase dev mailing list.\n\n[^1]: Running an offline upgrade tool without downgrade might be needed. We will typically only support migrating data from major version X to major version X+1.\n\n[^2]: See [http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html](http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html).\n\n## Rolling Upgrades\n\nA rolling upgrade is the process by which you update the servers in your cluster a server at a time. You can rolling upgrade across HBase versions if they are binary or wire compatible. See the \"Rolling Upgrade Between Versions that are Binary/Wire Compatible\" section below for more on what this means. Coarsely, a rolling upgrade is a graceful stop each server, update the software, and then restart. You do this for each server in the cluster. Usually you upgrade the Master first and then the RegionServers. See [Rolling Restart](/docs/operational-management/node#rolling-restart) for tools that can help use the rolling upgrade process.\n\nFor example, in the below, HBase was symlinked to the actual HBase install. On upgrade, before running a rolling restart over the cluster, we changed the symlink to point at the new HBase software version and then ran\n\n```bash\n$ HADOOP_HOME=~/hadoop-2.6.0-CRC-SNAPSHOT ~/hbase/bin/rolling-restart.sh --config ~/conf_hbase\n```\n\nThe rolling-restart script will first gracefully stop and restart the master, and then each of the RegionServers in turn. Because the symlink was changed, on restart the server will come up using the new HBase version. Check logs for errors as the rolling upgrade proceeds.\n\n#### Rolling Upgrade Between Versions that are Binary/Wire Compatible \\[!toc]\n\nUnless otherwise specified, HBase minor versions are binary compatible. You can do a rolling upgrades between HBase point versions. For example, you can go to 1.4.4 from 1.4.6 by doing a rolling upgrade across the cluster replacing the 1.4.4 binary with a 1.4.6 binary.\n\nIn the minor version-particular sections below, we call out where the versions are wire/protocol compatible and in this case, it is also possible to do a rolling upgrade.\n\n## Rollback\n\nSometimes things don't go as planned when attempting an upgrade. This section explains how to perform a *rollback* to an earlier HBase release. Note that this should only be needed between Major and some Minor releases. You should always be able to *downgrade* between HBase Patch releases within the same Minor version. These instructions may require you to take steps before you start the upgrade process, so be sure to read through this section beforehand.\n\n## Caveats\n\n### Rollback vs Downgrade\n\nThis section describes how to perform a *rollback* on an upgrade between HBase minor and major versions. In this document, rollback refers to the process of taking an upgraded cluster and restoring it to the old version *while losing all changes that have occurred since upgrade*. By contrast, a cluster *downgrade* would restore an upgraded cluster to the old version while maintaining any data written since the upgrade. We currently only offer instructions to rollback HBase clusters. Further, rollback only works when these instructions are followed prior to performing the upgrade.\n\nWhen these instructions talk about rollback vs downgrade of prerequisite cluster services (i.e. HDFS), you should treat leaving the service version the same as a degenerate case of downgrade.\n\n### Replication\n\nUnless you are doing an all-service rollback, the HBase cluster will lose any configured peers for HBase replication. If your cluster is configured for HBase replication, then prior to following these instructions you should document all replication peers. After performing the rollback you should then add each documented peer back to the cluster. Note also that data written to the cluster since the upgrade may or may not have already been replicated to any peers. Determining which, if any, peers have seen replication data as well as rolling back the data in those peers is out of the scope of this guide.\n\n### Data Locality\n\nUnless you are doing an all-service rollback, going through a rollback procedure will likely destroy all locality for Region Servers. You should expect degraded performance until after the cluster has had time to go through compactions to restore data locality. Optionally, you can force a compaction to speed this process up at the cost of generating cluster load.\n\n### Configurable Locations\n\nThe instructions below assume default locations for the HBase data directory and the HBase znode. Both of these locations are configurable and you should verify the value used in your cluster before proceeding. In the event that you have a different value, just replace the default with the one found in your configuration \\* HBase data directory is configured via the key 'hbase.rootdir' and has a default value of '/hbase'. \\* HBase znode is configured via the key 'zookeeper.znode.parent' and has a default value of '/hbase'.\n\n## All service rollback\n\nIf you will be performing a rollback of both the HDFS and ZooKeeper services, then HBase's data will be rolled back in the process.\n\n### Requirements\n\n* Ability to rollback HDFS and ZooKeeper\n\n### Before upgrade\n\nNo additional steps are needed pre-upgrade. As an extra precautionary measure, you may wish to use distcp to back up the HBase data off of the cluster to be upgraded. To do so, follow the steps in the 'Before upgrade' section of 'Rollback after HDFS downgrade' but copy to another HDFS instance instead of within the same instance.\n\n### Performing a rollback\n\n<Steps>\n  <Step>\n    Stop HBase\n  </Step>\n\n  <Step>\n    Perform a rollback for HDFS and ZooKeeper (HBase should remain stopped)\n  </Step>\n\n  <Step>\n    Change the installed version of HBase to the previous version\n  </Step>\n\n  <Step>\n    Start HBase\n  </Step>\n\n  <Step>\n    Verify HBase contents — use the HBase shell to list tables and scan some known values.\n  </Step>\n</Steps>\n\n## Rollback after HDFS rollback and ZooKeeper downgrade\n\nIf you will be rolling back HDFS but going through a ZooKeeper downgrade, then HBase will be in an inconsistent state. You must ensure the cluster is not started until you complete this process.\n\n### Requirements\n\n* Ability to rollback HDFS\n* Ability to downgrade ZooKeeper\n\n### Before upgrade\n\nNo additional steps are needed pre-upgrade. As an extra precautionary measure, you may wish to use distcp to back up the HBase data off of the cluster to be upgraded. To do so, follow the steps in the 'Before upgrade' section of 'Rollback after HDFS downgrade' but copy to another HDFS instance instead of within the same instance.\n\n### Performing a rollback\n\n<Steps>\n  <Step>\n    Stop HBase\n  </Step>\n\n  <Step>\n    Perform a rollback for HDFS and a downgrade for ZooKeeper (HBase should remain stopped)\n  </Step>\n\n  <Step>\n    Change the installed version of HBase to the previous version\n  </Step>\n\n  <Step>\n    Clean out ZooKeeper information related to HBase. WARNING: This step will permanently destroy all replication peers. Please see the section on HBase Replication under Caveats for more information.\n\n    **Clean HBase information out of ZooKeeper:**\n\n    ```bash\n    [hpnewton@gateway_node.example.com ~]$ zookeeper-client -server zookeeper1.example.com:2181,zookeeper2.example.com:2181,zookeeper3.example.com:2181\n    Welcome to ZooKeeper!\n    JLine support is disabled\n    rmr /hbase\n    quit\n    Quitting...\n    ```\n  </Step>\n\n  <Step>\n    Start HBase\n  </Step>\n\n  <Step>\n    Verify HBase contents—use the HBase shell to list tables and scan some known values.\n  </Step>\n</Steps>\n\n## Rollback after HDFS downgrade\n\nIf you will be performing an HDFS downgrade, then you'll need to follow these instructions regardless of whether ZooKeeper goes through rollback, downgrade, or reinstallation.\n\n### Requirements\n\n* Ability to downgrade HDFS\n* Pre-upgrade cluster must be able to run MapReduce jobs\n* HDFS super user access\n* Sufficient space in HDFS for at least two copies of the HBase data directory\n\n### Before upgrade\n\nBefore beginning the upgrade process, you must take a complete backup of HBase's backing data. The following instructions cover backing up the data within the current HDFS instance. Alternatively, you can use the distcp command to copy the data to another HDFS cluster.\n\n<Steps>\n  <Step>\n    Stop the HBase cluster\n  </Step>\n\n  <Step>\n    Copy the HBase data directory to a backup location using the [distcp command](https://hadoop.apache.org/docs/current/hadoop-distcp/DistCp.html) as the HDFS super user (shown below on a security enabled cluster)\n\n    **Using distcp to backup the HBase data directory:**\n\n    ```bash\n    [hpnewton@gateway_node.example.com ~]$ kinit -k -t hdfs.keytab hdfs@EXAMPLE.COM\n    [hpnewton@gateway_node.example.com ~]$ hadoop distcp /hbase /hbase-pre-upgrade-backup\n    ```\n  </Step>\n\n  <Step>\n    Distcp will launch a mapreduce job to handle copying the files in a distributed fashion. Check the output of the distcp command to ensure this job completed successfully.\n  </Step>\n</Steps>\n\n### Performing a rollback\n\n<Steps>\n  <Step>\n    Stop HBase\n  </Step>\n\n  <Step>\n    Perform a downgrade for HDFS and a downgrade/rollback for ZooKeeper (HBase should remain stopped)\n  </Step>\n\n  <Step>\n    Change the installed version of HBase to the previous version\n  </Step>\n\n  <Step>\n    Restore the HBase data directory from prior to the upgrade. Restore the HBase data directory from prior to the upgrade as the HDFS super user (shown below on a security enabled cluster). If you backed up your data on another HDFS cluster instead of locally, you will need to use the distcp command to copy it back to the current HDFS cluster.\n\n    **Restore the HBase data directory:**\n\n    ```bash\n    [hpnewton@gateway_node.example.com ~]$ kinit -k -t hdfs.keytab hdfs@EXAMPLE.COM\n    [hpnewton@gateway_node.example.com ~]$ hdfs dfs -mv /hbase /hbase-upgrade-rollback\n    [hpnewton@gateway_node.example.com ~]$ hdfs dfs -mv /hbase-pre-upgrade-backup /hbase\n    ```\n  </Step>\n\n  <Step>\n    Clean out ZooKeeper information related to HBase. WARNING: This step will permanently destroy all replication peers. Please see the section on HBase Replication under Caveats for more information.\n\n    **Clean HBase information out of ZooKeeper:**\n\n    ```bash\n    [hpnewton@gateway_node.example.com ~]$ zookeeper-client -server zookeeper1.example.com:2181,zookeeper2.example.com:2181,zookeeper3.example.com:2181\n    Welcome to ZooKeeper!\n    JLine support is disabled\n    rmr /hbase\n    quit\n    Quitting...\n    ```\n  </Step>\n\n  <Step>\n    Start HBase\n  </Step>\n\n  <Step>\n    Verify HBase contents–use the HBase shell to list tables and scan some known values.\n  </Step>\n</Steps>\n\n## Upgrade Paths\n\n## Upgrade from 2.x to 3.x\n\nThe RegionServer Grouping feature has been reimplemented. See section [Migrating From Old Implementation](/docs/operational-management/region-and-capacity#migrating-from-old-implementation) in [Apache HBase Operational Management](/docs/operational-management) for more details.\n\nThe `hbase:namespace` table has been removed and fold into `hbase:meta`. See [Data Model](/docs/datamodel) for more details.\n\nThere is no special consideration upgrading to hbase-2.4.x from 2.3.x. And for earlier versions, just follow the [Upgrade from 2.0.x-2.2.x to 2.3+](/docs/upgrading/paths#upgrade-from-20x-22x-to-23) guide. In general, 2.2.x should be rolling upgradeable, for 2.1.x or 2.0.x, you will need to clear the [Upgrade from 2.0 or 2.1 to 2.2+](/docs/upgrading/paths#upgrade-from-20-or-21-to-22) hurdle first.\n\n## Upgrade from 2.0.x-2.2.x to 2.3+\n\nThere is no special consideration upgrading to hbase-2.3.x from earlier versions. From 2.2.x, it should be rolling upgradeable. From 2.1.x or 2.0.x, you will need to clear the [Upgrade from 2.0 or 2.1 to 2.2+](/docs/upgrading/paths#upgrade-from-20-or-21-to-22) hurdle first.\n\n### Upgraded ZooKeeper Dependency Version\n\nOur dependency on Apache ZooKeeper has been upgraded to 3.5.7 ([HBASE-24132](https://issues.apache.org/jira/browse/HBASE-24132)), as 3.4.x is EOL. The newer 3.5.x client is compatible with the older 3.4.x server. However, if you're using HBase in stand-alone mode and perform an in-place upgrade, there are some upgrade steps [documented by the ZooKeeper community](https://cwiki.apache.org/confluence/display/ZOOKEEPER/Upgrade+FAQ). This doesn't impact a production deployment, but would impact a developer's local environment.\n\n### New In-Master Procedure Store\n\nOf note, HBase 2.3.0 changes the in-Master Procedure Store implementation. It was a dedicated custom store to instead use a standard HBase Region ([HBASE-23326](https://issues.apache.org/jira/browse/HBASE-23326)). The migration from the old to new format is automatic run by the new 2.3.0 Master on startup. The old *MasterProcWALs* dir which hosted the old custom implementation files in *$\\{hbase.rootdir}* is deleted on successful migration. A new *MasterProc* sub-directory replaces it to host the Store files and WALs for the new Procedure Store in-Master Region. The in-Master Region is unusual in that it writes to an alternate location at *$\\{hbase.rootdir}/MasterProc* rather than under *$\\{hbase.rootdir}/data* in the filesystem and the special Procedure Store in-Master Region is hidden from all clients other than the active Master itself. Otherwise, it is like any other with the Master process running flushes and compactions, archiving WALs when over-flushed, and so on. Its files are readable by standard Region and Store file tooling for triage and analysis as long as they are pointed to the appropriate location in the filesystem.\n\nNotice that, after the migration, you should make sure to not start an active master with old code, as it can not recognize the new procedure store. So it is suggested to upgrade backup master(s) to new 2.3 first, and then upgrade the active master. And unless explicitly mentioned, this is the suggested way for all upgrading, i.e, upgrading backup master(s) first, then active master, and then region servers.\n\n## Upgrade from 2.0 or 2.1 to 2.2+\n\nHBase 2.2+ uses a new Procedure form assigning/unassigning/moving Regions. It does not process HBase 2.1 and 2.0's Unassign/Assign Procedure types. Upgrade requires that we first drain the Master Procedure Store of old style Procedures before starting the new 2.2 Master. So you need to make sure that before you kill the old version (2.0 or 2.1) Master, there is no region in transition. And once the new version (2.2+) Master is up, you can rolling upgrade RegionServers one by one.\n\nAnd there is a more safer way if you are running 2.1.1+ or 2.0.3+ cluster. It need four steps to upgrade Master.\n\n1. Shutdown both active and standby Masters (Your cluster will continue to server reads and writes without interruption).\n2. Set the property hbase.procedure.upgrade-to-2-2 to true in hbase-site.xml for the Master, and start only one Master, still using the 2.1.1+ (or 2.0.3+) version.\n3. Wait until the Master quits. Confirm that there is a 'UPGRADE OK: All existed procedures have been finished, quit...' message in the Master log as the cause of the shutdown. The Procedure Store is now empty.\n4. Start new Masters with the new 2.2+ version.\n\nThen you can rolling upgrade RegionServers one by one. See [HBASE-21075](https://issues.apache.org/jira/browse/HBASE-21075) for more details.\n\nIn case these steps are not done, on starting 2.2+ master, you would see the following exception in the master logs:\n\n`org.apache.hadoop.hbase.HBaseIOException: Unsupported procedure type class org.apache.hadoop.hbase.master.assignment.UnassignProcedure found`\n\n## Upgrading from 1.x to 2.x\n\nIn this section we will first call out significant changes compared to the prior stable HBase release and then go over the upgrade process. Be sure to read the former with care so you avoid surprises.\n\n### Changes of Note!\n\nFirst we'll cover deployment / operational changes that you might hit when upgrading to HBase 2.0+. After that we'll call out changes for downstream applications. Please note that Coprocessors are covered in the operational section. Also note that this section is not meant to convey information about new features that may be of interest to you. For a complete summary of changes, please see the CHANGES.txt file in the source release artifact for the version you are planning to upgrade to.\n\n#### Update to basic prerequisite minimums in HBase 2.0+ \\[!toc]\n\nAs noted in the [Basic Prerequisites](/docs/configuration/basic-prerequisites) section, HBase 2.0+ requires a minimum of Java 8 and Hadoop 2.6. The HBase community recommends ensuring you have already completed any needed upgrades in prerequisites prior to upgrading your HBase version.\n\n#### HBCK must match HBase server version \\[!toc]\n\nYou **must not** use an HBase 1.x version of HBCK against an HBase 2.0+ cluster. HBCK is strongly tied to the HBase server version. Using the HBCK tool from an earlier release against an HBase 2.0+ cluster will destructively alter said cluster in unrecoverable ways.\n\nAs of HBase 2.0, HBCK (A.K.A *HBCK1* or *hbck1*) is a read-only tool that can report the status of some non-public system internals but will often misread state because it does not understand the workings of hbase2.\n\nTo read about HBCK's replacement, see [Operations and Management](/docs/operational-management) documentation.\n\n<Callout type=\"warn\">\n  Related, before you upgrade, ensure that *hbck1* reports no `INCONSISTENCIES`. Fixing hbase1-type\n  inconsistencies post-upgrade is an involved process.\n</Callout>\n\n#### Configuration settings no longer in HBase 2.0+ \\[!toc]\n\nThe following configuration settings are no longer applicable or available. For details, please see the detailed release notes.\n\n* hbase.config.read.zookeeper.config (see [upgrade2.0.zkconfig](/docs/upgrading/paths#zookeeper-configs-no-longer-read-from-zoocfg-toc) for migration details)\n* hbase.zookeeper.useMulti (HBase now always uses ZK's multi functionality)\n* hbase.rpc.client.threads.max\n* hbase.rpc.client.nativetransport\n* hbase.fs.tmp.dir\n* hbase.bucketcache.combinedcache.enabled\n* hbase.bucketcache.ioengine no longer supports the 'heap' value.\n* hbase.bulkload.staging.dir\n* hbase.balancer.tablesOnMaster wasn't removed, strictly speaking, but its meaning has fundamentally changed and users should not set it. See the section [upgrade2.0.regions.on.master](/docs/upgrading/paths#master-hosting-regions-feature-broken-and-unsupported-toc) for details.\n* hbase.master.distributed.log.replay See the section [upgrade2.0.distributed.log.replay](/docs/upgrading/paths#distributed-log-replay-feature-broken-and-removed-toc) for details\n* hbase.regionserver.disallow\\.writes.when.recovering See the section [upgrade2.0.distributed.log.replay](/docs/upgrading/paths#distributed-log-replay-feature-broken-and-removed-toc) for details\n* hbase.regionserver.wal.logreplay.batch.size See the section [upgrade2.0.distributed.log.replay](/docs/upgrading/paths#distributed-log-replay-feature-broken-and-removed-toc) for details\n* hbase.master.catalog.timeout\n* hbase.regionserver.catalog.timeout\n* hbase.metrics.exposeOperationTimes\n* hbase.metrics.showTableName\n* hbase.online.schema.update.enable (HBase now always supports this)\n* hbase.thrift.htablepool.size.max\n\n#### Configuration properties that were renamed in HBase 2.0+ \\[!toc]\n\nThe following properties have been renamed. Attempts to set the old property will be ignored at run time.\n\n| Old name                                            | New name                                                |\n| --------------------------------------------------- | ------------------------------------------------------- |\n| hbase.rpc.server.nativetransport                    | hbase.netty.nativetransport                             |\n| hbase.netty.rpc.server.worker.count                 | hbase.netty.worker.count                                |\n| hbase.hfile.compactions.discharger.interval         | hbase.hfile.compaction.discharger.interval              |\n| hbase.hregion.percolumnfamilyflush.size.lower.bound | hbase.hregion.percolumnfamilyflush.size.lower.bound.min |\n\n#### Configuration settings with different defaults in HBase 2.0+ \\[!toc]\n\nThe following configuration settings changed their default value. Where applicable, the value to set to restore the behavior of HBase 1.2 is given.\n\n* hbase.security.authorization now defaults to false. set to true to restore same behavior as previous default.\n* hbase.client.retries.number is now set to 10. Previously it was 35. Downstream users are advised to use client timeouts as described in [Configuration](/docs/configuration/default#timeout-settings) instead.\n* hbase.client.serverside.retries.multiplier is now set to 3. Previously it was 10. Downstream users are advised to use client timeouts as described in [Configuration](/docs/configuration/default#timeout-settings) instead.\n* hbase.master.fileSplitTimeout is now set to 10 minutes. Previously it was 30 seconds.\n* hbase.regionserver.logroll.multiplier is now set to 0.5. Previously it was 0.95. This change is tied with the following doubling of block size. Combined, these two configuration changes should make for WALs of about the same size as those in hbase-1.x but there should be less incidence of small blocks because we fail to roll the WAL before we hit the blocksize threshold. See [HBASE-19148](https://issues.apache.org/jira/browse/HBASE-19148) for discussion.\n* hbase.regionserver.hlog.blocksize defaults to 2x the HDFS default block size for the WAL dir. Previously it was equal to the HDFS default block size for the WAL dir.\n* hbase.client.start.log.errors.counter changed to 5. Previously it was 9.\n* hbase.ipc.server.callqueue.type changed to 'fifo'. In HBase versions 1.0 - 1.2 it was 'deadline'. In prior and later 1.x versions it already defaults to 'fifo'.\n* hbase.hregion.memstore.chunkpool.maxsize is 1.0 by default. Previously it was 0.0. Effectively, this means previously we would not use a chunk pool when our memstore is onheap and now we will. See the section [Long GC pauses](/docs/performance#long-gc-pauses) for more information about the MSLAB chunk pool.\n* hbase.master.cleaner.interval is now set to 10 minutes. Previously it was 1 minute.\n* hbase.master.procedure.threads will now default to 1/4 of the number of available CPUs, but not less than 16 threads. Previously it would be number of threads equal to number of CPUs.\n* hbase.hstore.blockingStoreFiles is now 16. Previously it was 10.\n* hbase.http.max.threads is now 16. Previously it was 10.\n* hbase.client.max.perserver.tasks is now 2. Previously it was 5.\n* hbase.normalizer.period is now 5 minutes. Previously it was 30 minutes.\n* hbase.regionserver.region.split.policy is now SteppingSplitPolicy. Previously it was IncreasingToUpperBoundRegionSplitPolicy.\n* replication.source.ratio is now 0.5. Previously it was 0.1.\n\n#### \"Master hosting regions\" feature broken and unsupported \\[!toc]\n\nThe feature \"Master acts as region server\" and associated follow-on work available in HBase 1.y is non-functional in HBase 2.y and should not be used in a production setting due to deadlock on Master initialization. Downstream users are advised to treat related configuration settings as experimental and the feature as inappropriate for production settings.\n\nA brief summary of related changes:\n\n* Master no longer carries regions by default\n* hbase.balancer.tablesOnMaster is a boolean, default false (if it holds an HBase 1.x list of tables, will default to false)\n* hbase.balancer.tablesOnMaster.systemTablesOnly is boolean to keep user tables off master. default false\n* those wishing to replicate old list-of-servers config should deploy a stand-alone RegionServer process and then rely on Region Server Groups\n\n#### \"Distributed Log Replay\" feature broken and removed \\[!toc]\n\nThe Distributed Log Replay feature was broken and has been removed from HBase 2.y+. As a consequence all related configs, metrics, RPC fields, and logging have also been removed. Note that this feature was found to be unreliable in the run up to HBase 1.0, defaulted to being unused, and was effectively removed in HBase 1.2.0 when we started ignoring the config that turns it on ([HBASE-14465](https://issues.apache.org/jira/browse/HBASE-14465)). If you are currently using the feature, be sure to perform a clean shutdown, ensure all DLR work is complete, and disable the feature prior to upgrading.\n\n#### *prefix-tree* encoding removed \\[!toc]\n\nThe prefix-tree encoding was removed from HBase 2.0.0 ([HBASE-19179](https://issues.apache.org/jira/browse/HBASE-19179)). It was (late!) deprecated in hbase-1.2.7, hbase-1.4.0, and hbase-1.3.2.\n\nThis feature was removed because it as not being actively maintained. If interested in reviving this sweet facility which improved random read latencies at the expensive of slowed writes, write the HBase developers list at *dev at hbase dot apache dot org*.\n\nThe prefix-tree encoding needs to be removed from all tables before upgrading to HBase 2.0+. To do that first you need to change the encoding from PREFIX\\_TREE to something else that is supported in HBase 2.0. After that you have to major compact the tables that were using PREFIX\\_TREE encoding before. To check which column families are using incompatible data block encoding you can use [Pre-Upgrade Validator](/docs/operational-management/tools#pre-upgrade-validator).\n\n#### Changed metrics \\[!toc]\n\nThe following metrics have changed names:\n\n* Metrics previously published under the name \"AssignmentManger\" \\[sic] are now published under the name \"AssignmentManager\"\n\nThe following metrics have changed their meaning:\n\n* The metric 'blockCacheEvictionCount' published on a per-region server basis no longer includes blocks removed from the cache due to the invalidation of the hfiles they are from (e.g. via compaction).\n* The metric 'totalRequestCount' increments once per request; previously it incremented by the number of `Actions` carried in the request; e.g. if a request was a `multi` made of four Gets and two Puts, we'd increment 'totalRequestCount' by six; now we increment by one regardless. Expect to see lower values for this metric in hbase-2.0.0.\n* The 'readRequestCount' now counts reads that return a non-empty row where in older hbases, we'd increment 'readRequestCount' whether a Result or not. This change will flatten the profile of the read-requests graphs if requests for non-existent rows. A YCSB read-heavy workload can do this dependent on how the database was loaded.\n\nThe following metrics have been removed:\n\n* Metrics related to the Distributed Log Replay feature are no longer present. They were previously found in the region server context under the name 'replay'. See the section [\"Distributed Log Replay\" feature broken and removed](/docs/upgrading/paths#distributed-log-replay-feature-broken-and-removed-toc) for details.\n\nThe following metrics have been added:\n\n* 'totalRowActionRequestCount' is a count of region row actions summing reads and writes.\n\n#### Changed logging \\[!toc]\n\nHBase-2.0.0 now uses [slf4j](https://www.slf4j.org/) as its logging frontend. Previously, we used [log4j (1.2)](http://logging.apache.org/log4j/1.2/). For most the transition should be seamless; slf4j does a good job interpreting *log4j.properties* logging configuration files such that you should not notice any difference in your log system emissions.\n\nThat said, your *log4j.properties* may need freshening. See [HBASE-20351](https://issues.apache.org/jira/browse/HBASE-20351) for example, where a stale log configuration file manifest as netty configuration being dumped at DEBUG level as preamble on every shell command invocation.\n\n#### ZooKeeper configs no longer read from zoo.cfg \\[!toc]\n\nHBase no longer optionally reads the 'zoo.cfg' file for ZooKeeper related configuration settings. If you previously relied on the 'hbase.config.read.zookeeper.config' config for this functionality, you should migrate any needed settings to the hbase-site.xml file while adding the prefix 'hbase.zookeeper.property.' to each property name.\n\n#### Changes in permissions \\[!toc]\n\nThe following permission related changes either altered semantics or defaults:\n\n* Permissions granted to a user now merge with existing permissions for that user, rather than over-writing them. (see [the release note on HBASE-17472](https://issues.apache.org/jira/browse/HBASE-17472) for details)\n* Region Server Group commands (added in 1.4.0) now require admin privileges.\n\n#### Most Admin APIs don't work against an HBase 2.0+ cluster from pre-HBase 2.0 clients \\[!toc]\n\nA number of admin commands are known to not work when used from a pre-HBase 2.0 client. This includes an HBase Shell that has the library jars from pre-HBase 2.0. You will need to plan for an outage of use of admin APIs and commands until you can also update to the needed client version.\n\nThe following client operations do not work against HBase 2.0+ cluster when executed from a pre-HBase 2.0 client:\n\n* list\\_procedures\n* split\n* merge\\_region\n* list\\_quotas\n* enable\\_table\\_replication\n* disable\\_table\\_replication\n* Snapshot related commands\n\n#### Deprecated in 1.0 admin commands have been removed. \\[!toc]\n\nThe following commands that were deprecated in 1.0 have been removed. Where applicable the replacement command is listed.\n\n* The 'hlog' command has been removed. Downstream users should rely on the 'wal' command instead.\n\n#### Region Server memory consumption changes. \\[!toc]\n\nUsers upgrading from versions prior to HBase 1.4 should read the instructions in section [Region Server memory consumption changes.](/docs/upgrading/paths#region-server-memory-consumption-changes).\n\nAdditionally, HBase 2.0 has changed how memstore memory is tracked for flushing decisions. Previously, both the data size and overhead for storage were used to calculate utilization against the flush threshold. Now, only data size is used to make these per-region decisions. Globally the addition of the storage overhead is used to make decisions about forced flushes.\n\n#### Web UI for splitting and merging operate on row prefixes \\[!toc]\n\nPreviously, the Web UI included functionality on table status pages to merge or split based on an encoded region name. In HBase 2.0, instead this functionality works by taking a row prefix.\n\n#### Special upgrading for Replication users from pre-HBase 1.4 \\[!toc]\n\nUser running versions of HBase prior to the 1.4.0 release that make use of replication should be sure to read the instructions in the section [Replication peer's TableCFs config](/docs/upgrading/paths#replication-peers-tablecfs-config).\n\n#### HBase shell changes \\[!toc]\n\nThe HBase shell command relies on a bundled JRuby instance. This bundled JRuby been updated from version 1.6.8 to version 9.1.10.0. The represents a change from Ruby 1.8 to Ruby 2.3.3, which introduces non-compatible language changes for user scripts.\n\nThe HBase shell command now ignores the '--return-values' flag that was present in early HBase 1.4 releases. Instead the shell always behaves as though that flag were passed. If you wish to avoid having expression results printed in the console you should alter your IRB configuration.\n\n#### Coprocessor APIs have changed in HBase 2.0+ \\[!toc]\n\nAll Coprocessor APIs have been refactored to improve supportability around binary API compatibility for future versions of HBase. If you or applications you rely on have custom HBase coprocessors, you should read [the release notes for HBASE-18169](https://issues.apache.org/jira/browse/HBASE-18169) for details of changes you will need to make prior to upgrading to HBase 2.0+.\n\nFor example, if you had a BaseRegionObserver in HBase 1.2 then at a minimum you will need to update it to implement both RegionObserver and RegionCoprocessor and add the method\n\n```java\n...\n  @Override\n  public Optional<RegionObserver> getRegionObserver() {\n    return Optional.of(this);\n  }\n...\n```\n\nFor more information, see [Upgrading Coprocessors to 2.0](/docs/upgrading/paths#upgrading-coprocessors-to-20).\n\n#### HBase 2.0+ can no longer write HFile v2 files. \\[!toc]\n\nHBase has simplified our internal HFile handling. As a result, we can no longer write HFile versions earlier than the default of version 3. Upgrading users should ensure that hfile.format.version is not set to 2 in hbase-site.xml before upgrading. Failing to do so will cause Region Server failure. HBase can still read HFiles written in the older version 2 format.\n\n#### HBase 2.0+ can no longer read Sequence File based WAL file. \\[!toc]\n\nHBase can no longer read the deprecated WAL files written in the Apache Hadoop Sequence File format. The hbase.regionserver.hlog.reader.impl and hbase.regionserver.hlog.writer.impl configuration entries should be set to use the Protobuf based WAL reader / writer classes. This implementation has been the default since HBase 0.96, so legacy WAL files should not be a concern for most downstream users.\n\nStarting from 2.6.0, the hbase.regionserver.hlog.reader.impl and hbase.regionserver.hlog.writer.impl configuration entries are removed since the only valid values are protobuf based reader/writer. Setting them in *hbase-site.xml* will have no real effect.\n\nA clean cluster shutdown should ensure there are no WAL files. If you are unsure of a given WAL file's format you can use the `hbase wal` command to parse files while the HBase cluster is offline. In HBase 2.0+, this command will not be able to read a Sequence File based WAL.\n\n#### Change in behavior for filters \\[!toc]\n\nThe Filter ReturnCode NEXT\\_ROW has been redefined as skipping to next row in current family, not to next row in all family. it's more reasonable, because ReturnCode is a concept in store level, not in region level.\n\n#### Downstream HBase 2.0+ users should use the shaded client \\[!toc]\n\nDownstream users are strongly urged to rely on the Maven coordinates org.apache.hbase:hbase-shaded-client for their runtime use. This artifact contains all the needed implementation details for talking to an HBase cluster while minimizing the number of third party dependencies exposed.\n\nNote that this artifact exposes some classes in the org.apache.hadoop package space (e.g. o.a.h.configuration.Configuration) so that we can maintain source compatibility with our public API. Those classes are included so that they can be altered to use the same relocated third party dependencies as the rest of the HBase client code. In the event that you need to **also** use Hadoop in your code, you should ensure all Hadoop related jars precede the HBase client jar in your classpath.\n\n#### Downstream HBase 2.0+ users of MapReduce must switch to new artifact \\[!toc]\n\nDownstream users of HBase's integration for Apache Hadoop MapReduce must switch to relying on the org.apache.hbase:hbase-shaded-mapreduce module for their runtime use. Historically, downstream users relied on either the org.apache.hbase:hbase-server or org.apache.hbase:hbase-shaded-server artifacts for these classes. Both uses are no longer supported and in the vast majority of cases will fail at runtime.\n\nNote that this artifact exposes some classes in the org.apache.hadoop package space (e.g. o.a.h.configuration.Configuration) so that we can maintain source compatibility with our public API. Those classes are included so that they can be altered to use the same relocated third party dependencies as the rest of the HBase client code. In the event that you need to **also** use Hadoop in your code, you should ensure all Hadoop related jars precede the HBase client jar in your classpath.\n\n#### Significant changes to runtime classpath \\[!toc]\n\nA number of internal dependencies for HBase were updated or removed from the runtime classpath. Downstream client users who do not follow the guidance in [Downstream HBase 2.0+ users should use the shaded client](/docs/upgrading/paths#downstream-hbase-20-users-should-use-the-shaded-client-toc) will have to examine the set of dependencies Maven pulls in for impact. Downstream users of LimitedPrivate Coprocessor APIs will need to examine the runtime environment for impact.\n\n#### Multiple breaking changes to source and binary compatibility for client API \\[!toc]\n\nThe Java client API for HBase has a number of changes that break both source and binary compatibility for details see the Compatibility Check Report for the release you'll be upgrading to.\n\n#### Tracing implementation changes \\[!toc]\n\nThe backing implementation of HBase's tracing features was updated from Apache HTrace 3 to HTrace 4, which includes several breaking changes. While HTrace 3 and 4 can coexist in the same runtime, they will not integrate with each other, leading to disjoint trace information.\n\nThe internal changes to HBase during this upgrade were sufficient for compilation, but it has not been confirmed that there are no regressions in tracing functionality. Please consider this feature experimental for the immediate future.\n\nIf you previously relied on client side tracing integrated with HBase operations, it is recommended that you upgrade your usage to HTrace 4 as well.\n\nAfter the Apache HTrace project moved to the Attic/retired, the traces in HBase are left broken and unmaintained since HBase 2.0. A new project [HBASE-22120](https://issues.apache.org/jira/browse/HBASE-22120) will replace HTrace with OpenTelemetry. It will be shipped in 3.0.0 release. Please see the [Tracing](/docs/tracing) documentation for more details.\n\n#### HFile lose forward compatibility \\[!toc]\n\nHFiles generated by 2.0.0, 2.0.1, 2.1.0 are not forward compatible to 1.4.6-, 1.3.2.1-, 1.2.6.1-, and other inactive releases. Why HFile lose compatibility is hbase in new versions (2.0.0, 2.0.1, 2.1.0) use protobuf to serialize/deserialize TimeRangeTracker (TRT) while old versions use DataInput/DataOutput. To solve this, We have to put [HBASE-21012](https://issues.apache.org/jira/browse/HBASE-21012) to 2.x and put [HBASE-21013](https://issues.apache.org/jira/browse/HBASE-21013) in 1.x. For more information, please check [HBASE-21008](https://issues.apache.org/jira/browse/HBASE-21008).\n\n#### Performance \\[!toc]\n\nYou will likely see a change in the performance profile on upgrade to hbase-2.0.0 given read and write paths have undergone significant change. On release, writes may be slower with reads about the same or much better, dependent on context. Be prepared to spend time re-tuning (See [Performance](/docs/performance)). Performance is also an area that is now under active review so look forward to improvement in coming releases (See [HBASE-20188 TESTING Performance](https://issues.apache.org/jira/browse/HBASE-20188)).\n\n#### Integration Tests and Kerberos \\[!toc]\n\nIntegration Tests (`IntegrationTests*`) used to rely on the Kerberos credential cache for authentication against secured clusters. This used to lead to tests failing due to authentication failures when the tickets in the credential cache expired. As of hbase-2.0.0 (and hbase-1.3.0+), the integration test clients will make use of the configuration properties `hbase.client.keytab.file` and `hbase.client.kerberos.principal`. They are required. The clients will perform a login from the configured keytab file and automatically refresh the credentials in the background for the process lifetime (See [HBASE-16231](https://issues.apache.org/jira/browse/HBASE-16231)).\n\n#### Default Compaction Throughput \\[!toc]\n\nHBase 2.x comes with default limits to the speed at which compactions can execute. This limit is defined per RegionServer. In previous versions of HBase earlier than 1.5, there was no limit to the speed at which a compaction could run by default. Applying a limit to the throughput of a compaction should ensure more stable operations from RegionServers.\n\nTake care to notice that this limit is *per RegionServer*, not *per compaction*.\n\nThe throughput limit is defined as a range of bytes written per second, and is allowed to vary within the given lower and upper bound. RegionServers observe the current throughput of a compaction and apply a linear formula to adjust the allowed throughput, within the lower and upper bound, with respect to external pressure. For compactions, external pressure is defined as the number of store files with respect to the maximum number of allowed store files. The more store files, the higher the compaction pressure.\n\nConfiguration of this throughput is governed by the following properties.\n\n* The lower bound is defined by `hbase.hstore.compaction.throughput.lower.bound` and defaults to 50 MB/s (`52428800`).\n* The upper bound is defined by `hbase.hstore.compaction.throughput.higher.bound` and defaults to 100 MB/s (`104857600`).\n\nTo revert this behavior to the unlimited compaction throughput of earlier versions of HBase, please set the following property to the implementation that applies no limits to compactions.\n\n`hbase.regionserver.throughput.controller=org.apache.hadoop.hbase.regionserver.throttle.NoLimitThroughputController`\n\n### Upgrading Coprocessors to 2.0\n\nCoprocessors have changed substantially in 2.0 ranging from top level design changes in class hierarchies to changed/removed methods, interfaces, etc. (Parent jira: [HBASE-18169 Coprocessor fix and cleanup before 2.0.0 release](https://issues.apache.org/jira/browse/HBASE-18169)). Some of the reasons for such widespread changes:\n\n1. Pass Interfaces instead of Implementations; e.g. TableDescriptor instead of HTableDescriptor and Region instead of HRegion ([HBASE-18241](https://issues.apache.org/jira/browse/HBASE-18241) Change client.Table and client.Admin to not use HTableDescriptor).\n2. Design refactor so implementers need to fill out less boilerplate and so we can do more compile-time checking ([HBASE-17732](https://issues.apache.org/jira/browse/HBASE-17732))\n3. Purge Protocol Buffers from Coprocessor API ([HBASE-18859](https://issues.apache.org/jira/browse/HBASE-18859), [HBASE-16769](https://issues.apache.org/jira/browse/HBASE-16769), etc)\n4. Cut back on what we expose to Coprocessors removing hooks on internals that were too private to expose (for eg. [HBASE-18453](https://issues.apache.org/jira/browse/HBASE-18453) CompactionRequest should not be exposed to user directly; [HBASE-18298](https://issues.apache.org/jira/browse/HBASE-18298) RegionServerServices Interface cleanup for CP expose; etc)\n\nTo use coprocessors in 2.0, they should be rebuilt against new API otherwise they will fail to load and HBase processes will die.\n\nSuggested order of changes to upgrade the coprocessors:\n\n1. Directly implement observer interfaces instead of extending Base\\*Observer classes. Change `Foo extends BaseXXXObserver` to `Foo implements XXXObserver`. ([HBASE-17312](https://issues.apache.org/jira/browse/HBASE-17312)).\n2. Adapt to design change from Inheritence to Composition ([HBASE-17732](https://issues.apache.org/jira/browse/HBASE-17732)) by following [this example](https://github.com/apache/hbase/blob/master/dev-support/design-docs/Coprocessor_Design_Improvements-Use_composition_instead_of_inheritance-HBASE-17732.adoc#migrating-existing-cps-to-new-design).\n3. getTable() has been removed from the CoprocessorEnvrionment, coprocessors should self-manage Table instances.\n\nSome examples of writing coprocessors with new API can be found in hbase-example module [here](https://github.com/apache/hbase/tree/branch-2.0/hbase-examples/src/main/java/org/apache/hadoop/hbase/coprocessor/example).\n\nLastly, if an api has been changed/removed that breaks you in an irreparable way, and if there's a good justification to add it back, bring it our notice [dev@hbase.apache.org](mailto:dev@hbase.apache.org).\n\n### Rolling Upgrade from 1.x to 2.x\n\nRolling upgrades are currently an experimental feature. They have had limited testing. There are likely corner cases as yet uncovered in our limited experience so you should be careful if you go this route. The stop/upgrade/start described in the next section, [Upgrade process from 1.x to 2.x](/docs/upgrading/paths#upgrade-process-from-1x-to-2x), is the safest route.\n\nThat said, the below is a prescription for a rolling upgrade of a 1.4 cluster.\n\n#### Pre-Requirements\n\n* Upgrade to the latest 1.4.x release. Pre 1.4 releases may also work but are not tested, so please upgrade to 1.4.3+ before upgrading to 2.x, unless you are an expert and familiar with the region assignment and crash processing. See the section [Upgrading from pre-1.4 to 1.4+](/docs/upgrading/paths#upgrading-from-pre-14-to-14) on how to upgrade to 1.4.x.\n* Make sure that the zk-less assignment is enabled, i.e, set `hbase.assignment.usezk` to `false`. This is the most important thing. It allows the 1.x master to assign/unassign regions to/from 2.x region servers. See the release note section of [HBASE-11059](https://issues.apache.org/jira/browse/HBASE-11059) on how to migrate from zk based assignment to zk less assignment.\n* Before you upgrade, ensure that *hbck1* reports no `INCONSISTENCIES`. Fixing hbase1-type inconsistencies post-upgrade is an involved process.\n* We have tested rolling upgrading from 1.4.3 to 2.1.0, but it should also work if you want to upgrade to 2.0.x.\n\n#### Instructions\n\n1. Unload a region server and upgrade it to 2.1.0. With [HBASE-17931](https://issues.apache.org/jira/browse/HBASE-17931) in place, the meta region and regions for other system tables will be moved to this region server immediately. If not, please move them manually to the new region server. This is very important because\n   * The schema of meta region is hard coded, if meta is on an old region server, then the new region servers can not access it as it does not have some families, for example, table state.\n   * Client with lower version can communicate with server with higher version, but not vice versa. If the meta region is on an old region server, the new region server will use a client with higher version to communicate with a server with lower version, this may introduce strange problems.\n2. Rolling upgrade all other region servers.\n3. Upgrading masters.\n\nIt is OK that during the rolling upgrading there are region server crashes. The 1.x master can assign regions to both 1.x and 2.x region servers, and [HBASE-19166](https://issues.apache.org/jira/browse/HBASE-19166) fixed a problem so that 1.x region server can also read the WALs written by 2.x region server and split them.\n\n<Callout type=\"info\">\n  Please read the [Changes of Note!](/docs/upgrading/paths#changes-of-note) section carefully before\n  rolling upgrading. Make sure that you do not use the removed features in 2.0, for example, the\n  prefix-tree encoding, the old hfile format, etc. They could both fail the upgrading and leave the\n  cluster in an intermediate state and hard to recover.\n</Callout>\n\n<Callout type=\"info\">\n  If you have success running this prescription, please notify the dev list with a note on your\n  experience and/or update the above with any deviations you may have taken so others going this\n  route can benefit from your efforts.\n</Callout>\n\n### Upgrade process from 1.x to 2.x\n\nTo upgrade an existing HBase 1.x cluster, you should:\n\n* Ensure that *hbck1* reports no `INCONSISTENCIES`. Fixing hbase1-type inconsistencies post-upgrade is an involved process. Fix all *hbck1* complaints before proceeding.\n* Clean shutdown of existing 1.x cluster\n* Update coprocessors\n* Upgrade Master roles first\n* Upgrade RegionServers\n* (Eventually) Upgrade Clients\n\n## Upgrading to 1.7.1+\n\nHBase release 1.7.0 introduced an incompatible table metadata serialization format that broke the minor release compatibility guarantees. The issue was reported in [HBASE-26021](https://issues.apache.org/jira/browse/HBASE-26021) and the problematic serialization patch was reverted in HBase 1.7.1. Some important notes about 1.7.x upgrades below.\n\n* If you are considering an upgrade to 1.7.x version, skip 1.7.0 completely and upgrade to 1.7.1+ version. 1.7.0 was withdrawn and removed from the Apache sites.\n* If you already installed a 1.7.0 cluster from scratch and are looking to migrate to 1.7.1+, you cannot follow the regular rolling upgrade procedures due to broken compatibility contracts. Instead shutdown the cluster and reboot with 1.7.1+ binaries. Newer versions detect any existing tables with incompatible serialization and rewrite them using the correct format at bootstrap.\n* If you are already on 1.7.1+ version, everything is good and no additional steps need to be performed.\n\n## Upgrading from pre-1.4 to 1.4+\n\n### Region Server memory consumption changes.\n\nUsers upgrading from versions prior to HBase 1.4 should be aware that the estimates of heap usage by the memstore objects (KeyValue, object and array header sizes, etc) have been made more accurate for heap sizes up to 32G (using CompressedOops), resulting in them dropping by 10-50% in practice. This also results in less number of flushes and compactions due to \"fatter\" flushes. YMMV. As a result, the actual heap usage of the memstore before being flushed may increase by up to 100%. If configured memory limits for the region server had been tuned based on observed usage, this change could result in worse GC behavior or even OutOfMemory errors. Set the environment property (not hbase-site.xml) \"hbase.memorylayout.use.unsafe\" to false to disable.\n\n### Replication peer's TableCFs config\n\nBefore 1.4, the table name can't include namespace for replication peer's TableCFs config. It was fixed by add TableCFs to ReplicationPeerConfig which was stored on Zookeeper. So when upgrade to 1.4, you have to update the original ReplicationPeerConfig data on Zookeeper firstly. There are four steps to upgrade when your cluster have a replication peer with TableCFs config.\n\n* Disable the replication peer.\n* If master has permission to write replication peer znode, then rolling update master directly. If not, use TableCFsUpdater tool to update the replication peer's config.\n  ```bash\n  $ bin/hbase org.apache.hadoop.hbase.replication.master.TableCFsUpdater update\n  ```\n* Rolling update regionservers.\n* Enable the replication peer.\n\nNotes:\n\n* Can't use the old client(before 1.4) to change the replication peer's config. Because the client will write config to Zookeeper directly, the old client will miss TableCFs config. And the old client write TableCFs config to the old tablecfs znode, it will not work for new version regionserver.\n\n### Raw scan now ignores TTL\n\nDoing a raw scan will now return results that have expired according to TTL settings.\n\n## Upgrading from pre-1.3 to 1.3+\n\nIf running Integration Tests under Kerberos, see [upgrade2.0.it.kerberos](/docs/upgrading/paths#integration-tests-and-kerberos-toc).\n\n## Upgrading to 1.x\n\nPlease consult the documentation published specifically for the version of HBase that you are upgrading to for details on the upgrade process.\n\n***\n\n# The Apache HBase Shell\n\nThe Apache HBase Shell is [(J)Ruby](http://jruby.org)'s IRB with some HBase particular commands added.\nAnything you can do in IRB, you should be able to do in the HBase Shell.\n\nTo run the HBase shell, do as follows:\n\n```bash\n$ ./bin/hbase shell\n```\n\nType `help` and then `<RETURN>` to see a listing of shell commands and options.\nBrowse at least the paragraphs at the end of the help output for the gist of how variables and command arguments are entered into the HBase shell; in particular note how table names, rows, and columns, etc., must be quoted.\n\nSee [shell exercises](/docs/getting-started#procedure-use-hbase-for-the-first-time) for example basic shell operation.\n\nHere is a nicely formatted listing of [all shell commands](http://learnhbase.wordpress.com/2013/03/02/hbase-shell-commands/) by Rajeshbabu Chintaguntla.\n\n## Scripting with Ruby\n\nFor examples scripting Apache HBase, look in the HBase *bin* directory.\nLook at the files that end in *\\*.rb*.\nTo run one of these files, do as follows:\n\n```bash\n$ ./bin/hbase org.jruby.Main PATH_TO_SCRIPT\n```\n\n## Running the Shell in Non-Interactive Mode\n\nA new non-interactive mode has been added to the HBase Shell ([HBASE-11658](https://issues.apache.org/jira/browse/HBASE-11658)).\nNon-interactive mode captures the exit status (success or failure) of HBase Shell commands and passes that status back to the command interpreter.\nIf you use the normal interactive mode, the HBase Shell will only ever return its own exit status, which will nearly always be `0` for success.\n\nTo invoke non-interactive mode, pass the `-n` or `--non-interactive` option to HBase Shell.\n\n## HBase Shell in OS Scripts\n\nYou can use the HBase shell from within operating system script interpreters like the Bash shell which is the default command interpreter for most Linux and UNIX distributions.\nThe following guidelines use Bash syntax, but could be adjusted to work with C-style shells such as csh or tcsh, and could probably be modified to work with the Microsoft Windows script interpreter as well. Submissions are welcome.\n\n<Callout type=\"info\">\n  Spawning HBase Shell commands in this way is slow, so keep that in mind when you are deciding when\n  combining HBase operations with the operating system command line is appropriate.\n</Callout>\n\n### Passing Commands to the HBase Shell\n\nYou can pass commands to the HBase Shell in non-interactive mode (see [hbase.shell.noninteractive](/docs/shell#hbase-shell-in-os-scripts)) using the `echo` command and the `|` (pipe) operator.\nBe sure to escape characters in the HBase commands which would otherwise be interpreted by the shell.\nSome debug-level output has been truncated from the example below.\n\n```bash\n$ echo \"describe 'test1'\" | ./hbase shell -n\n\nVersion 0.98.3-hadoop2, rd5e65a9144e315bb0a964e7730871af32f5018d5, Sat May 31 19:56:09 PDT 2014\n\ndescribe 'test1'\n\nDESCRIPTION                                          ENABLED\n 'test1', {NAME => 'cf', DATA_BLOCK_ENCODING => 'NON true\n E', BLOOMFILTER => 'ROW', REPLICATION_SCOPE => '0',\n  VERSIONS => '1', COMPRESSION => 'NONE', MIN_VERSIO\n NS => '0', TTL => 'FOREVER', KEEP_DELETED_CELLS =>\n 'false', BLOCKSIZE => '65536', IN_MEMORY => 'false'\n , BLOCKCACHE => 'true'}\n1 row(s) in 3.2410 seconds\n```\n\nTo suppress all output, echo it to */dev/null:*\n\n```bash\n$ echo \"describe 'test'\" | ./hbase shell -n > /dev/null 2>&1\n```\n\n### Checking the Result of a Scripted Command\n\nSince scripts are not designed to be run interactively, you need a way to check whether your command failed or succeeded.\nThe HBase shell uses the standard convention of returning a value of `0` for successful commands, and some non-zero value for failed commands.\nBash stores a command's return value in a special environment variable called `$?`.\nBecause that variable is overwritten each time the shell runs any command, you should store the result in a different, script-defined variable.\n\nThis is a naive script that shows one way to store the return value and make a decision based upon it.\n\n```bash\n#!/bin/bash\n\necho \"describe 'test'\" | ./hbase shell -n > /dev/null 2>&1\nstatus=$?\necho \"The status was \" $status\nif ($status == 0); then\n  echo \"The command succeeded\"\nelse\n  echo \"The command may have failed.\"\nfi\nreturn $status\n```\n\n### Checking for Success or Failure In Scripts\n\nGetting an exit code of `0` means that the command you scripted definitely succeeded.\nHowever, getting a non-zero exit code does not necessarily mean the command failed.\nThe command could have succeeded, but the client lost connectivity, or some other event obscured its success.\nThis is because RPC commands are stateless.\nThe only way to be sure of the status of an operation is to check.\nFor instance, if your script creates a table, but returns a non-zero exit value, you should check whether the table was actually created before trying again to create it.\n\n## Read HBase Shell Commands from a Command File\n\nYou can enter HBase Shell commands into a text file, one command per line, and pass that file to the HBase Shell.\n\n### Example Command File\n\n```ruby\ncreate 'test', 'cf'\nlist 'test'\nput 'test', 'row1', 'cf:a', 'value1'\nput 'test', 'row2', 'cf:b', 'value2'\nput 'test', 'row3', 'cf:c', 'value3'\nput 'test', 'row4', 'cf:d', 'value4'\nscan 'test'\nget 'test', 'row1'\ndisable 'test'\nenable 'test'\n```\n\n### Directing HBase Shell to Execute the Commands\n\nPass the path to the command file as the only argument to the `hbase shell` command.\nEach command is executed and its output is shown.\nIf you do not include the `exit` command in your script, you are returned to the HBase shell prompt.\nThere is no way to programmatically check each individual command for success or failure.\nAlso, though you see the output for each command, the commands themselves are not echoed to the screen so it can be difficult to line up the command with its output.\n\n```bash\n$ ./hbase shell ./sample_commands.txt\n0 row(s) in 3.4170 seconds\n\nTABLE\ntest\n1 row(s) in 0.0590 seconds\n\n0 row(s) in 0.1540 seconds\n\n0 row(s) in 0.0080 seconds\n\n0 row(s) in 0.0060 seconds\n\n0 row(s) in 0.0060 seconds\n\nROW                   COLUMN+CELL\n row1                 column=cf:a, timestamp=1407130286968, value=value1\n row2                 column=cf:b, timestamp=1407130286997, value=value2\n row3                 column=cf:c, timestamp=1407130287007, value=value3\n row4                 column=cf:d, timestamp=1407130287015, value=value4\n4 row(s) in 0.0420 seconds\n\nCOLUMN                CELL\n cf:a                 timestamp=1407130286968, value=value1\n1 row(s) in 0.0110 seconds\n\n0 row(s) in 1.5630 seconds\n\n0 row(s) in 0.4360 seconds\n```\n\n## Passing VM Options to the Shell\n\nYou can pass VM options to the HBase Shell using the `HBASE_SHELL_OPTS` environment variable.\nYou can set this in your environment, for instance by editing *\\~/.bashrc*, or set it as part of the command to launch HBase Shell.\nThe following example sets several garbage-collection-related variables, just for the lifetime of the VM running the HBase Shell.\nThe command should be run all on a single line, but is broken by the `\\` character, for readability.\n\n```bash\n$ HBASE_SHELL_OPTS=\"-verbose:gc -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps \\\n  -XX:+PrintGCDetails -Xloggc:$HBASE_HOME/logs/gc-hbase.log\" ./bin/hbase shell\n```\n\n## Overriding configuration starting the HBase Shell\n\nAs of hbase-2.0.5/hbase-2.1.3/hbase-2.2.0/hbase-1.4.10/hbase-1.5.0, you can\npass or override hbase configuration as specified in `hbase-*.xml` by passing\nyour key/values prefixed with `-D` on the command-line as follows:\n\n```bash\n$ ./bin/hbase shell -Dhbase.zookeeper.quorum=ZK0.remote.cluster.example.org,ZK1.remote.cluster.example.org,ZK2.remote.cluster.example.org -Draining=false\n...\nhbase(main):001:0> @shell.hbase.configuration.get(\"hbase.zookeeper.quorum\")\n=> \"ZK0.remote.cluster.example.org,ZK1.remote.cluster.example.org,ZK2.remote.cluster.example.org\"\nhbase(main):002:0> @shell.hbase.configuration.get(\"raining\")\n=> \"false\"\n```\n\n## Shell Tricks\n\n### Table variables\n\nHBase 0.95 adds shell commands that provides jruby-style object-oriented references for tables.\nPreviously all of the shell commands that act upon a table have a procedural style that always took the name of the table as an argument.\nHBase 0.95 introduces the ability to assign a table to a jruby variable.\nThe table reference can be used to perform data read write operations such as puts, scans, and gets well as admin functionality such as disabling, dropping, describing tables.\n\nFor example, previously you would always specify a table name:\n\n```ruby\nhbase(main):000:0> create 't', 'f'\n0 row(s) in 1.0970 seconds\nhbase(main):001:0> put 't', 'rold', 'f', 'v'\n0 row(s) in 0.0080 seconds\n\nhbase(main):002:0> scan 't'\nROW                                COLUMN+CELL\n rold                              column=f:, timestamp=1378473207660, value=v\n1 row(s) in 0.0130 seconds\n\nhbase(main):003:0> describe 't'\nDESCRIPTION                                                                           ENABLED\n 't', {NAME => 'f', DATA_BLOCK_ENCODING => 'NONE', BLOOMFILTER => 'ROW', REPLICATION_ true\n SCOPE => '0', VERSIONS => '1', COMPRESSION => 'NONE', MIN_VERSIONS => '0', TTL => '2\n 147483647', KEEP_DELETED_CELLS => 'false', BLOCKSIZE => '65536', IN_MEMORY => 'false\n ', BLOCKCACHE => 'true'}\n1 row(s) in 1.4430 seconds\n\nhbase(main):004:0> disable 't'\n0 row(s) in 14.8700 seconds\n\nhbase(main):005:0> drop 't'\n0 row(s) in 23.1670 seconds\n\nhbase(main):006:0>\n```\n\nNow you can assign the table to a variable and use the results in jruby shell code.\n\n```ruby\nhbase(main):007 > t = create 't', 'f'\n0 row(s) in 1.0970 seconds\n\n=> Hbase::Table - t\nhbase(main):008 > t.put 'r', 'f', 'v'\n0 row(s) in 0.0640 seconds\nhbase(main):009 > t.scan\nROW                           COLUMN+CELL\n r                            column=f:, timestamp=1331865816290, value=v\n1 row(s) in 0.0110 seconds\nhbase(main):010:0> t.describe\nDESCRIPTION                                                                           ENABLED\n 't', {NAME => 'f', DATA_BLOCK_ENCODING => 'NONE', BLOOMFILTER => 'ROW', REPLICATION_ true\n SCOPE => '0', VERSIONS => '1', COMPRESSION => 'NONE', MIN_VERSIONS => '0', TTL => '2\n 147483647', KEEP_DELETED_CELLS => 'false', BLOCKSIZE => '65536', IN_MEMORY => 'false\n ', BLOCKCACHE => 'true'}\n1 row(s) in 0.0210 seconds\nhbase(main):038:0> t.disable\n0 row(s) in 6.2350 seconds\nhbase(main):039:0> t.drop\n0 row(s) in 0.2340 seconds\n```\n\nIf the table has already been created, you can assign a Table to a variable by using the get\\_table method:\n\n```ruby\nhbase(main):011 > create 't','f'\n0 row(s) in 1.2500 seconds\n\n=> Hbase::Table - t\nhbase(main):012:0> tab = get_table 't'\n0 row(s) in 0.0010 seconds\n\n=> Hbase::Table - t\nhbase(main):013:0> tab.put 'r1' ,'f', 'v'\n0 row(s) in 0.0100 seconds\nhbase(main):014:0> tab.scan\nROW                                COLUMN+CELL\n r1                                column=f:, timestamp=1378473876949, value=v\n1 row(s) in 0.0240 seconds\nhbase(main):015:0>\n```\n\nThe list functionality has also been extended so that it returns a list of table names as strings.\nYou can then use jruby to script table operations based on these names.\nThe list\\_snapshots command also acts similarly.\n\n```ruby\nhbase(main):016 > tables = list('t.*')\nTABLE\nt\n1 row(s) in 0.1040 seconds\n\n=> [\"t\"]\nhbase(main):017:0> tables.map { |t| disable t ; drop  t}\n0 row(s) in 2.2510 seconds\n\n=> [nil]\nhbase(main):018:0>\n```\n\n### *irbrc*\n\nCreate an *.irbrc* file for yourself in your home directory.\nAdd customizations.\nA useful one is command history so commands are save across Shell invocations:\n\n```bash\n$ more .irbrc\nrequire 'irb/ext/save-history'\nIRB.conf[:SAVE_HISTORY] = 100\nIRB.conf[:HISTORY_FILE] = \"#{ENV['HOME']}/.irb-save-history\"\n```\n\nIf you'd like to avoid printing the result of evaluting each expression to stderr, for example the array of tables returned from the \"list\" command:\n\n```bash\n$ echo \"IRB.conf[:ECHO] = false\" >>~/.irbrc\n```\n\nSee the `ruby` documentation of *.irbrc* to learn about other possible configurations.\n\n### LOG data to timestamp\n\nTo convert the date '08/08/16 20:56:29' from an hbase log into a timestamp, do:\n\n```ruby\nhbase(main):021:0> import java.text.SimpleDateFormat\nhbase(main):022:0> import java.text.ParsePosition\nhbase(main):023:0> SimpleDateFormat.new(\"yy/MM/dd HH:mm:ss\").parse(\"08/08/16 20:56:29\", ParsePosition.new(0)).getTime() => 1218920189000\n```\n\nTo go the other direction:\n\n```ruby\nhbase(main):021:0> import java.util.Date\nhbase(main):022:0> Date.new(1218920189000).toString() => \"Sat Aug 16 20:56:29 UTC 2008\"\n```\n\nTo output in a format that is exactly like that of the HBase log format will take a little messing with [SimpleDateFormat](http://download.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html).\n\n### Query Shell Configuration\n\n```ruby\nhbase(main):001:0> @shell.hbase.configuration.get(\"hbase.rpc.timeout\")\n=> \"60000\"\n```\n\nTo set a config in the shell:\n\n```ruby\nhbase(main):005:0> @shell.hbase.configuration.setInt(\"hbase.rpc.timeout\", 61010)\nhbase(main):006:0> @shell.hbase.configuration.get(\"hbase.rpc.timeout\")\n=> \"61010\"\n```\n\n### Pre-splitting tables with the HBase Shell\n\nYou can use a variety of options to pre-split tables when creating them via the HBase Shell `create` command.\n\nThe simplest approach is to specify an array of split points when creating the table. Note that when specifying string literals as split points, these will create split points based on the underlying byte representation of the string. So when specifying a split point of '10', we are actually specifying the byte split point '\\x31\\30'.\n\nThe split points will define `n+1` regions where `n` is the number of split points. The lowest region will contain all keys from the lowest possible key up to but not including the first split point key.\nThe next region will contain keys from the first split point up to, but not including the next split point key.\nThis will continue for all split points up to the last. The last region will be defined from the last split point up to the maximum possible key.\n\n```ruby\nhbase>create 't1','f',SPLITS => ['10','20','30']\n```\n\nIn the above example, the table 't1' will be created with column family 'f', pre-split to four regions. Note the first region will contain all keys from '\\x00' up to '\\x30' (as '\\x31' is the ASCII code for '1').\n\nYou can pass the split points in a file using following variation. In this example, the splits are read from a file corresponding to the local path on the local filesystem. Each line in the file specifies a split point key.\n\n```ruby\nhbase>create 't14','f',SPLITS_FILE=>'splits.txt'\n```\n\nThe other options are to automatically compute splits based on a desired number of regions and a splitting algorithm.\nHBase supplies algorithms for splitting the key range based on uniform splits or based on hexadecimal keys, but you can provide your own splitting algorithm to subdivide the key range.\n\n```ruby\n# create table with four regions based on random bytes keys\nhbase>create 't2','f1', { NUMREGIONS => 4 , SPLITALGO => 'UniformSplit' }\n\n# create table with five regions based on hex keys\nhbase>create 't3','f1', { NUMREGIONS => 5, SPLITALGO => 'HexStringSplit' }\n```\n\nAs the HBase Shell is effectively a Ruby environment, you can use simple Ruby scripts to compute splits algorithmically.\n\n```ruby\n# generate splits for long (Ruby fixnum) key range from start to end key\nhbase(main):070:0> def gen_splits(start_key,end_key,num_regions)\nhbase(main):071:1>   results=[]\nhbase(main):072:1>   range=end_key-start_key\nhbase(main):073:1>   incr=(range/num_regions).floor\nhbase(main):074:1>   for i in 1 .. num_regions-1\nhbase(main):075:2>     results.push([i*incr+start_key].pack(\"N\"))\nhbase(main):076:2>   end\nhbase(main):077:1>   return results\nhbase(main):078:1> end\nhbase(main):079:0>\nhbase(main):080:0> splits=gen_splits(1,2000000,10)\n=> [\"\\000\\003\\r@\", \"\\000\\006\\032\\177\", \"\\000\\t'\\276\", \"\\000\\f4\\375\", \"\\000\\017B<\", \"\\000\\022O{\", \"\\000\\025\\\\\\272\", \"\\000\\030i\\371\", \"\\000\\ew8\"]\nhbase(main):081:0> create 'test_splits','f',SPLITS=>splits\n0 row(s) in 0.2670 seconds\n\n=> Hbase::Table - test_splits\n```\n\nNote that the HBase Shell command `truncate` effectively drops and recreates the table with default options which will discard any pre-splitting.\nIf you need to truncate a pre-split table, you must drop and recreate the table explicitly to re-specify custom split options.\n\n### Debug\n\n#### Shell debug switch\n\nYou can set a debug switch in the shell to see more output — e.g.\nmore of the stack trace on exception — when you run a command:\n\n```\nhbase> debug <RETURN>\n```\n\n#### DEBUG log level\n\nTo enable DEBUG level logging in the shell, launch it with the `-d` option.\n\n```bash\n$ ./bin/hbase shell -d\n```\n\n### Commands\n\n#### count\n\nCount command returns the number of rows in a table.\nIt's quite fast when configured with the right CACHE\n\n```ruby\nhbase> count '<tablename>', CACHE => 1000\n```\n\nThe above count fetches 1000 rows at a time.\nSet CACHE lower if your rows are big.\nDefault is to fetch one row at a time.\n\n***\n\n# Data Model\n\n## HBase Data Model Terminology\n\n#### Table \\[!toc]\n\nAn HBase table consists of multiple rows.\n\n#### Row \\[!toc]\n\nA row in HBase consists of a row key and one or more columns with values associated with them.\nRows are sorted alphabetically by the row key as they are stored.\nFor this reason, the design of the row key is very important.\nThe goal is to store data in such a way that related rows are near each other.\nA common row key pattern is a website domain.\nIf your row keys are domains, you should probably store them in reverse (org.apache.www, org.apache.mail, org.apache.jira). This way, all of the Apache domains are near each other in the table, rather than being spread out based on the first letter of the subdomain.\n\n#### Column \\[!toc]\n\nA column in HBase consists of a column family and a column qualifier, which are delimited by a `:` (colon) character.\n\n#### Column Family \\[!toc]\n\nColumn families physically colocate a set of columns and their values, often for performance reasons.\nEach column family has a set of storage properties, such as whether its values should be cached in memory, how its data is compressed or its row keys are encoded, and others.\nEach row in a table has the same column families, though a given row might not store anything in a given column family.\n\n#### Column Qualifier \\[!toc]\n\nA column qualifier is added to a column family to provide the index for a given piece of data.\nGiven a column family `content`, a column qualifier might be `content:html`, and another might be `content:pdf`.\nThough column families are fixed at table creation, column qualifiers are mutable and may differ greatly between rows.\n\n#### Cell \\[!toc]\n\nA cell is a combination of row, column family, and column qualifier, and contains a value and a timestamp, which represents the value's version.\n\n#### Timestamp \\[!toc]\n\nA timestamp is written alongside each value, and is the identifier for a given version of a value.\nBy default, the timestamp represents the time on the RegionServer when the data was written, but you can specify a different timestamp value when you put data into the cell.\n\n## Conceptual View\n\nYou can read a very understandable explanation of the HBase data model in the blog post [Understanding HBase and BigTable](https://dzone.com/articles/understanding-hbase-and-bigtab) by Jim R. Wilson.\nAnother good explanation is available in the PDF [Introduction to Basic Schema Design](http://0b4af6cdc2f0c5998459-c0245c5c937c5dedcca3f1764ecc9b2f.r43.cf2.rackcdn.com/9353-login1210_khurana.pdf) by Amandeep Khurana.\n\nIt may help to read different perspectives to get a solid understanding of HBase schema design.\nThe linked articles cover the same ground as the information in this section.\n\nThe following example is a slightly modified form of the one on page 2 of the [BigTable](http://research.google.com/archive/bigtable.html) paper.\nThere is a table called `webtable` that contains two rows (`com.cnn.www` and `com.example.www`) and three column families named `contents`, `anchor`, and `people`.\nIn this example, for the first row (`com.cnn.www`), `anchor` contains two columns (`anchor:cssnsi.com`, `anchor:my.look.ca`) and `contents` contains one column (`contents:html`). This example contains 5 versions of the row with the row key `com.cnn.www`, and one version of the row with the row key `com.example.www`.\nThe `contents:html` column qualifier contains the entire HTML of a given website.\nQualifiers of the `anchor` column family each contain the external site which links to the site represented by the row, along with the text it used in the anchor of its link.\nThe `people` column family represents people associated with the site.\n\n<Callout type=\"info\" title=\"Column Names\">\n  By convention, a column name is made of its column family prefix and a *qualifier*. For example,\n  the column *contents:html* is made up of the column family `contents` and the `html` qualifier.\n  The colon character (`:`) delimits the column family from the column family *qualifier*.\n</Callout>\n\n#### Table `webtable` \\[!toc]\n\n| Row Key           | Time Stamp | ColumnFamily `contents`      | ColumnFamily `anchor`         | ColumnFamily `people`      |\n| ----------------- | ---------- | ---------------------------- | ----------------------------- | -------------------------- |\n| \"com.cnn.www\"     | t9         |                              | anchor:cnnsi.com = \"CNN\"      |                            |\n| \"com.cnn.www\"     | t8         |                              | anchor:my.look.ca = \"CNN.com\" |                            |\n| \"com.cnn.www\"     | t6         | contents:html = \"\\<html>...\" |                               |                            |\n| \"com.cnn.www\"     | t5         | contents:html = \"\\<html>...\" |                               |                            |\n| \"com.cnn.www\"     | t3         | contents:html = \"\\<html>...\" |                               |                            |\n| \"com.example.www\" | t5         | contents:html = \"\\<html>...\" |                               | people:author = \"John Doe\" |\n\nCells in this table that appear to be empty do not take space, or in fact exist, in HBase.\nThis is what makes HBase \"sparse.\" A tabular view is not the only possible way to look at data in HBase, or even the most accurate.\nThe following represents the same information as a multi-dimensional map.\nThis is only a mock-up for illustrative purposes and may not be strictly accurate.\n\n```json\n{\n  \"com.cnn.www\": {\n    contents: {\n      t6: contents:html: \"<html>...\"\n      t5: contents:html: \"<html>...\"\n      t3: contents:html: \"<html>...\"\n    }\n    anchor: {\n      t9: anchor:cnnsi.com = \"CNN\"\n      t8: anchor:my.look.ca = \"CNN.com\"\n    }\n    people: {}\n  }\n  \"com.example.www\": {\n    contents: {\n      t5: contents:html: \"<html>...\"\n    }\n    anchor: {}\n    people: {\n      t5: people:author: \"John Doe\"\n    }\n  }\n}\n```\n\n## Physical View\n\nAlthough at a conceptual level tables may be viewed as a sparse set of rows, they are physically stored by column family.\nA new column qualifier (column\\_family:column\\_qualifier) can be added to an existing column family at any time.\n\n#### ColumnFamily `anchor` \\[!toc]\n\n| Row Key       | Time Stamp | Column Family `anchor`          |\n| ------------- | ---------- | ------------------------------- |\n| \"com.cnn.www\" | t9         | `anchor:cnnsi.com = \"CNN\"`      |\n| \"com.cnn.www\" | t8         | `anchor:my.look.ca = \"CNN.com\"` |\n\n#### ColumnFamily `contents` \\[!toc]\n\n| Row Key       | Time Stamp | ColumnFamily `contents:`     |\n| ------------- | ---------- | ---------------------------- |\n| \"com.cnn.www\" | t6         | contents:html = \"\\<html>...\" |\n| \"com.cnn.www\" | t5         | contents:html = \"\\<html>...\" |\n| \"com.cnn.www\" | t3         | contents:html = \"\\<html>...\" |\n\nThe empty cells shown in the conceptual view are not stored at all.\nThus a request for the value of the `contents:html` column at time stamp `t8` would return no value.\nSimilarly, a request for an `anchor:my.look.ca` value at time stamp `t9` would return no value.\nHowever, if no timestamp is supplied, the most recent value for a particular column would be returned.\nGiven multiple versions, the most recent is also the first one found, since timestamps are stored in descending order.\nThus a request for the values of all columns in the row `com.cnn.www` if no timestamp is specified would be: the value of `contents:html` from timestamp `t6`, the value of `anchor:cnnsi.com` from timestamp `t9`, the value of `anchor:my.look.ca` from timestamp `t8`.\n\nFor more information about the internals of how Apache HBase stores data, see [regions.arch](/docs/architecture/regions).\n\n## Namespace\n\nA namespace is a logical grouping of tables analogous to a database in relation database systems.\nThis abstraction lays the groundwork for upcoming multi-tenancy related features:\n\n* Quota Management ([HBASE-8410](https://issues.apache.org/jira/browse/HBASE-8410)) - Restrict the amount of resources (i.e. regions, tables) a namespace can consume.\n* Namespace Security Administration ([HBASE-9206](https://issues.apache.org/jira/browse/HBASE-9206)) - Provide another level of security administration for tenants.\n* Region server groups ([HBASE-6721](https://issues.apache.org/jira/browse/HBASE-6721)) - A namespace/table can be pinned onto a subset of RegionServers thus guaranteeing a coarse level of isolation.\n\n### Namespace management\n\nA namespace can be created, removed or altered.\nNamespace membership is determined during table creation by specifying a fully-qualified table name of the form:\n\n```xml\n<table namespace>:<table qualifier>\n```\n\n#### Examples\n\n```bash\n#Create a namespace\ncreate_namespace 'my_ns'\n```\n\n```bash\n#create my_table in my_ns namespace\ncreate 'my_ns:my_table', 'fam'\n```\n\n```bash\n#drop namespace\ndrop_namespace 'my_ns'\n```\n\n```bash\n#alter namespace\nalter_namespace 'my_ns', {METHOD => 'set', 'PROPERTY_NAME' => 'PROPERTY_VALUE'}\n```\n\n### Predefined namespaces\n\nThere are two predefined special namespaces:\n\n* hbase - system namespace, used to contain HBase internal tables\n* default - tables with no explicit specified namespace will automatically fall into this namespace\n\n#### Examples #datamodel-predefined-namespaces-examples\n\n```bash\n#namespace=foo and table qualifier=bar\ncreate 'foo:bar', 'fam'\n\n#namespace=default and table qualifier=bar\ncreate 'bar', 'fam'\n```\n\n### About hbase:namespace table\n\nWe used to have a system table called `hbase:namespace` for storing the namespace information.\n\nIt introduced some painful bugs in the past, especially that it may hang the master startup thus\nhang the whole cluster. This is because meta table also has a namespace, so it depends on namespace\ntable. But namespace table also depends on meta table as meta table stores the location of all\nregions. This is a cyclic dependency so sometimes namespace and meta table will wait for each other\nto online and hang the master start up.\n\nIt is not easy to fix so in 3.0.0, we decided to completely remove the `hbase:namespace` table and\nfold its content into the `ns` family in `hbase:meta` table. When upgrading from 2.x to 3.x, the\nmigration will be done automatically and the `hbase:namespace` table will be disabled after the\nmigration is done. You are free to leave it there for sometime and finally drop it.\n\nFor more tails, please see [https://issues.apache.org/jira/browse/HBASE-21154](https://issues.apache.org/jira/browse/HBASE-21154).\n\n## Table\n\nTables are declared up front at schema definition time.\n\n## Row\n\nRow keys are uninterpreted bytes.\nRows are lexicographically sorted with the lowest order appearing first in a table.\nThe empty byte array is used to denote both the start and end of a tables' namespace.\n\n## Column Family\n\nColumns in Apache HBase are grouped into *column families*.\nAll column members of a column family have the same prefix.\nFor example, the columns *courses:history* and *courses:math* are both members of the *courses* column family.\nThe colon character (`:`) delimits the column family from the column family qualifier.\nThe column family prefix must be composed of *printable* characters.\nThe qualifying tail, the column family *qualifier*, can be made of any arbitrary bytes.\nColumn families must be declared up front at schema definition time whereas columns do not need to be defined at schema time but can be conjured on the fly while the table is up and running.\n\nPhysically, all column family members are stored together on the filesystem.\nBecause tunings and storage specifications are done at the column family level, it is advised that all column family members have the same general access pattern and size characteristics.\n\n## Cells\n\nA *\\{row, column, version}* tuple exactly specifies a `cell` in HBase.\nCell content is uninterpreted bytes\n\n## Data Model Operations\n\nThe four primary data model operations are Get, Put, Scan, and Delete.\nOperations are applied via [Table](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html) instances.\n\n### Get\n\n[Get](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html) returns attributes for a specified row.\nGets are executed via [Table.get](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#get\\(org.apache.hadoop.hbase.client.Get\\))\n\n### Put\n\n[Put](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Put.html) either adds new rows to a table (if the key is new) or can update existing rows (if the key already exists). Puts are executed via [Table.put](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#put\\(org.apache.hadoop.hbase.client.Put\\)) (non-writeBuffer) or [Table.batch](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#batch\\(java.util.List,java.lang.Object%5B%5D\\)) (non-writeBuffer)\n\n### Scans\n\n[Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) allow iteration over multiple rows for specified attributes.\n\nThe following is an example of a Scan on a Table instance.\nAssume that a table is populated with rows with keys \"row1\", \"row2\", \"row3\", and then another set of rows with the keys \"abc1\", \"abc2\", and \"abc3\". The following example shows how to set a Scan instance to return the rows beginning with \"row\".\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\n\nTable table = ...      // instantiate a Table instance\n\nScan scan = new Scan();\nscan.addColumn(CF, ATTR);\nscan.setStartStopRowForPrefixScan(Bytes.toBytes(\"row\"));\nResultScanner rs = table.getScanner(scan);\ntry {\n  for (Result r = rs.next(); r != null; r = rs.next()) {\n    // process result...\n  }\n} finally {\n  rs.close();  // always close the ResultScanner!\n}\n```\n\nNote that generally the easiest way to specify a specific stop point for a scan is by using the [InclusiveStopFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/InclusiveStopFilter.html) class.\n\n### Delete\n\n[Delete](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Delete.html) removes a row from a table.\nDeletes are executed via [Table.delete](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#delete\\(org.apache.hadoop.hbase.client.Delete\\)).\n\nHBase does not modify data in place, and so deletes are handled by creating new markers called *tombstones*.\nThese tombstones, along with the dead values, are cleaned up on major compactions.\n\nSee [version.delete](/docs/datamodel#delete-toc) for more information on deleting versions of columns, and see [compaction](/docs/architecture/regions#compaction) for more information on compactions.\n\n## Versions\n\nA *\\{row, column, version}* tuple exactly specifies a `cell` in HBase.\nIt's possible to have an unbounded number of cells where the row and column are the same but the cell address differs only in its version dimension.\n\nWhile rows and column keys are expressed as bytes, the version is specified using a long integer.\nTypically this long contains time instances such as those returned by `java.util.Date.getTime()` or `System.currentTimeMillis()`, that is: *the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC*.\n\nThe HBase version dimension is stored in decreasing order, so that when reading from a store file, the most recent values are found first.\n\nThere is a lot of confusion over the semantics of `cell` versions, in HBase.\nIn particular:\n\n* If multiple writes to a cell have the same version, only the last written is fetchable.\n* It is OK to write cells in a non-increasing version order.\n\nBelow we describe how the version dimension in HBase currently works.\nSee [HBASE-2406](https://issues.apache.org/jira/browse/HBASE-2406) for discussion of HBase versions. [Bending time in HBase](https://web.archive.org/web/20160909085951/https://www.ngdata.com/bending-time-in-hbase/) makes for a good read on the version, or time, dimension in HBase.\nIt has more detail on versioning than is provided here.\n\nAs of this writing, the limitation *Overwriting values at existing timestamps* mentioned in the article no longer holds in HBase.\nThis section is basically a synopsis of this article by Bruno Dumon.\n\n### Specifying the Number of Versions to Store\n\nThe maximum number of versions to store for a given column is part of the column schema and is specified at table creation, or via an `alter` command, via `HColumnDescriptor.DEFAULT_VERSIONS`.\nPrior to HBase 0.96, the default number of versions kept was `3`, but in 0.96 and newer has been changed to `1`.\n\n#### Example: Modify the Maximum Number of Versions for a Column Family \\[!toc]\n\nThis example uses HBase Shell to keep a maximum of 5 versions of all columns in column family `f1`.\nYou could also use [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html).\n\n```bash\nhbase> alter 't1', NAME => 'f1', VERSIONS => 5\n```\n\n#### Example: Modify the Minimum Number of Versions for a Column Family \\[!toc]\n\nYou can also specify the minimum number of versions to store per column family.\nBy default, this is set to 0, which means the feature is disabled.\nThe following example sets the minimum number of versions on all columns in column family `f1` to `2`, via HBase Shell.\nYou could also use [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html).\n\n```bash\nhbase> alter 't1', NAME => 'f1', MIN_VERSIONS => 2\n```\n\nStarting with HBase 0.98.2, you can specify a global default for the maximum number of versions kept for all newly-created columns, by setting `hbase.column.max.version` in *hbase-site.xml*.\nSee [hbase.column.max.version](/docs/configuration/default#hbasecolumnmaxversion-toc).\n\n### Versions and HBase Operations\n\nIn this section we look at the behavior of the version dimension for each of the core HBase operations.\n\n#### Get/Scan\n\nGets are implemented on top of Scans.\nThe below discussion of [Get](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html) applies equally to [Scans](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html).\n\nBy default, i.e. if you specify no explicit version, when doing a `get`, the cell whose version has the largest value is returned (which may or may not be the latest one written, see later). The default behavior can be modified in the following ways:\n\n* to return more than one version, see [Get.readVersions(int)](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html#readVersions\\(int\\))\n* to return versions other than the latest, see [Get.setTimeRange(long,long)](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html#setTimeRange\\(long,long\\))\n\nTo retrieve the latest version that is less than or equal to a given value, thus giving the 'latest' state of the record at a certain point in time, just use a range from 0 to the desired version and set the max versions to 1.\n\n#### Default Get Example\n\nThe following Get will only retrieve the current version of the row\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\nGet get = new Get(Bytes.toBytes(\"row1\"));\nResult r = table.get(get);\nbyte[] b = r.getValue(CF, ATTR);  // returns current version of value\n```\n\n#### Versioned Get Example\n\nThe following Get will return the last 3 versions of the row.\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\nGet get = new Get(Bytes.toBytes(\"row1\"));\nget.setMaxVersions(3);  // will return last 3 versions of row\nResult r = table.get(get);\nbyte[] b = r.getValue(CF, ATTR);  // returns current version of value\nList<Cell> cells = r.getColumnCells(CF, ATTR);  // returns all versions of this column\n```\n\n#### Put\n\nDoing a put always creates a new version of a `cell`, at a certain timestamp.\nBy default the system uses the server's `currentTimeMillis`, but you can specify the version (= the long integer) yourself, on a per-column level.\nThis means you could assign a time in the past or the future, or use the long value for non-time purposes.\n\nTo overwrite an existing value, do a put at exactly the same row, column, and version as that of the cell you want to overwrite.\n\n#### Implicit Version Example \\[!toc]\n\nThe following Put will be implicitly versioned by HBase with the current time.\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\nPut put = new Put(Bytes.toBytes(row));\nput.add(CF, ATTR, Bytes.toBytes( data));\ntable.put(put);\n```\n\n#### Explicit Version Example\n\nThe following Put has the version timestamp explicitly set.\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\nPut put = new Put( Bytes.toBytes(row));\nlong explicitTimeInMs = 555;  // just an example\nput.add(CF, ATTR, explicitTimeInMs, Bytes.toBytes(data));\ntable.put(put);\n```\n\nCaution: the version timestamp is used internally by HBase for things like time-to-live calculations.\nIt's usually best to avoid setting this timestamp yourself.\nPrefer using a separate timestamp attribute of the row, or have the timestamp as a part of the row key, or both.\n\n#### Cell Version Example \\[!toc]\n\nThe following Put uses a method getCellBuilder() to get a CellBuilder instance\nthat already has relevant Type and Row set.\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\n\nPut put = new Put(Bytes.toBytes(row));\nput.add(put.getCellBuilder().setQualifier(ATTR)\n   .setFamily(CF)\n   .setValue(Bytes.toBytes(data))\n   .build());\ntable.put(put);\n```\n\n#### Delete \\[!toc]\n\nThere are three different types of internal delete markers.\nSee Lars Hofhansl's blog for discussion of his attempt adding another, [Scanning in HBase: Prefix Delete Marker](http://hadoop-hbase.blogspot.com/2012/01/scanning-in-hbase.html).\n\n* Delete: for a specific version of a column.\n* Delete column: for all versions of a column.\n* Delete family: for all columns of a particular ColumnFamily\n\nWhen deleting an entire row, HBase will internally create a tombstone for each ColumnFamily (i.e., not each individual column).\n\nDeletes work by creating *tombstone* markers.\nFor example, let's suppose we want to delete a row.\nFor this you can specify a version, or else by default the `currentTimeMillis` is used.\nWhat this means is *delete all cells where the version is less than or equal to this version*.\nHBase never modifies data in place, so for example a delete will not immediately delete (or mark as deleted) the entries in the storage file that correspond to the delete condition.\nRather, a so-called *tombstone* is written, which will mask the deleted values.\nWhen HBase does a major compaction, the tombstones are processed to actually remove the dead values, together with the tombstones themselves.\nIf the version you specified when deleting a row is larger than the version of any value in the row, then you can consider the complete row to be deleted.\n\nFor an informative discussion on how deletes and versioning interact, see the thread [Put w/timestamp -> Deleteall -> Put w/ timestamp fails](https://lists.apache.org/thread/g6s0fkx74hbmc0pplnf5r3gq5xn4vkyt) up on the user mailing list.\n\nAlso see [keyvalue](/docs/architecture/regions#keyvalue) for more information on the internal KeyValue format.\n\nDelete markers are purged during the next major compaction of the store, unless the `KEEP_DELETED_CELLS` option is set in the column family (See [Keeping Deleted Cells](/docs/regionserver-sizing#keeping-deleted-cells)).\nTo keep the deletes for a configurable amount of time, you can set the delete TTL via the `hbase.hstore.time.to.purge.deletes` property in *hbase-site.xml*.\nIf `hbase.hstore.time.to.purge.deletes` is not set, or set to 0, all delete markers, including those with timestamps in the future, are purged during the next major compaction.\nOtherwise, a delete marker with a timestamp in the future is kept until the major compaction which occurs after the time represented by the marker's timestamp plus the value of `hbase.hstore.time.to.purge.deletes`, in milliseconds.\n\n<Callout type=\"info\">\n  This behavior represents a fix for an unexpected change that was introduced in HBase 0.94, and was\n  fixed in [HBASE-10118](https://issues.apache.org/jira/browse/HBASE-10118). The change has been\n  backported to HBase 0.94 and newer branches.\n</Callout>\n\n### Optional New Version and Delete behavior in HBase-2.0.0\n\nIn `hbase-2.0.0`, the operator can specify an alternate version and\ndelete treatment by setting the column descriptor property\n`NEW_VERSION_BEHAVIOR` to true (To set a property on a column family\ndescriptor, you must first disable the table and then alter the\ncolumn family descriptor; see [Keeping Deleted Cells](/docs/regionserver-sizing#keeping-deleted-cells) for an example\nof editing an attribute on a column family descriptor).\n\nThe 'new version behavior', undoes the limitations listed below\nwhereby a `Delete` ALWAYS overshadows a `Put` if at the same\nlocation — i.e. same row, column family, qualifier and timestamp\n\\-- regardless of which arrived first. Version accounting is also\nchanged as deleted versions are considered toward total version count.\nThis is done to ensure results are not changed should a major\ncompaction intercede. See `HBASE-15968` and linked issues for\ndiscussion.\n\nRunning with this new configuration currently costs; we factor\nthe Cell MVCC on every compare so we burn more CPU. The slow\ndown will depend. In testing we've seen between 0% and 25%\ndegradation.\n\nIf replicating, it is advised that you run with the new\nserial replication feature (See `HBASE-9465`; the serial\nreplication feature did NOT make it into `hbase-2.0.0` but\nshould arrive in a subsequent hbase-2.x release) as now\nthe order in which Mutations arrive is a factor.\n\n### Current Limitations\n\nThe below limitations are addressed in hbase-2.0.0. See\nthe section above, [Optional New Version and Delete behavior in HBase-2.0.0](/docs/datamodel#optional-new-version-and-delete-behavior-in-hbase-200).\n\n#### Deletes mask Puts\n\nDeletes mask puts, even puts that happened after the delete was entered.\nSee [HBASE-2256](https://issues.apache.org/jira/browse/HBASE-2256).\nRemember that a delete writes a tombstone, which only disappears after then next major compaction has run.\nSuppose you do a delete of everything `<= T`.\nAfter this you do a new put with a timestamp `<= T`.\nThis put, even if it happened after the delete, will be masked by the delete tombstone.\nPerforming the put will not fail, but when you do a get you will notice the put did have no effect.\nIt will start working again after the major compaction has run.\nThese issues should not be a problem if you use always-increasing versions for new puts to a row.\nBut they can occur even if you do not care about time: just do delete and put immediately after each other, and there is some chance they happen within the same millisecond.\n\n#### Major compactions change query results\n\n*...create three cell versions at t1, t2 and t3, with a maximum-versions\nsetting of 2. So when getting all versions, only the values at t2 and t3 will be\nreturned. But if you delete the version at t2 or t3, the one at t1 will appear again.\nObviously, once a major compaction has run, such behavior will not be the case\nanymore...* (See *Garbage Collection* in [Bending time in HBase](https://web.archive.org/web/20160909085951/https://www.ngdata.com/bending-time-in-hbase/).)\n\n## Sort Order\n\nAll data model operations HBase return data in sorted order.\nFirst by row, then by ColumnFamily, followed by column qualifier, and finally timestamp (sorted in reverse, so newest records are returned first).\n\n## Column Metadata\n\nThere is no store of column metadata outside of the internal KeyValue instances for a ColumnFamily.\nThus, while HBase can support not only a wide number of columns per row, but a heterogeneous set of columns between rows as well, it is your responsibility to keep track of the column names.\n\nThe only way to get a complete set of columns that exist for a ColumnFamily is to process all the rows.\nFor more information about how HBase stores data internally, see [keyvalue](/docs/architecture/regions#keyvalue).\n\n## Joins\n\nWhether HBase supports joins is a common question on the dist-list, and there is a simple answer: it doesn't, at not least in the way that RDBMS' support them (e.g., with equi-joins or outer-joins in SQL). As has been illustrated in this chapter, the read data model operations in HBase are Get and Scan.\n\nHowever, that doesn't mean that equivalent join functionality can't be supported in your application, but you have to do it yourself.\nThe two primary strategies are either denormalizing the data upon writing to HBase, or to have lookup tables and do the join between HBase tables in your application or MapReduce code (and as RDBMS' demonstrate, there are several strategies for this depending on the size of the tables, e.g., nested loops vs.\nhash-joins). So which is the best approach? It depends on what you are trying to do, and as such there isn't a single answer that works for every use case.\n\n## ACID\n\nSee [ACID Semantics](/acid-semantics).\nLars Hofhansl has also written a note on [ACID in HBase](http://hadoop-hbase.blogspot.com/2012/03/acid-in-hbase.html).\n\n***\n\n# HBase and Schema Design\n\nA good introduction on the strength and weaknesses modelling on the various non-rdbms datastores is to be found in Ian Varley's Master thesis, [No Relation: The Mixed Blessings of Non-Relational Databases](http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf). It is a little dated now but a good background read if you have a moment on how HBase schema modeling differs from how it is done in an RDBMS. Also, read [keyvalue](/docs/architecture/regions#keyvalue) for how HBase stores data internally, and the section on [schema.casestudies](/docs/regionserver-sizing#schema-design-case-studies).\n\nThe documentation on the Cloud Bigtable website, [Designing Your Schema](https://cloud.google.com/bigtable/docs/schema-design), is pertinent and nicely done and lessons learned there equally apply here in HBase land; just divide any quoted values by \\~10 to get what works for HBase: e.g. where it says individual values can be \\~10MBs in size, HBase can do similar — perhaps best to go smaller if you can — and where it says a maximum of 100 column families in Cloud Bigtable, think \\~10 when modeling on HBase.\n\nSee also Robert Yokota's [HBase Application Archetypes](https://blogs.apache.org/hbase/entry/hbase-application-archetypes-redux) (an update on work done by other HBasers), for a helpful categorization of use cases that do well on top of the HBase model.\n\n## Schema Creation\n\nHBase schemas can be created or updated using the [Apache HBase Shell](/docs/shell) or by using [Admin](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Admin.html) in the Java API.\n\nTables must be disabled when making ColumnFamily modifications, for example:\n\n```java\nConfiguration config = HBaseConfiguration.create();\nAdmin admin = new Admin(conf);\nTableName table = TableName.valueOf(\"myTable\");\n\nadmin.disableTable(table);\n\nHColumnDescriptor cf1 = ...;\nadmin.addColumn(table, cf1);      // adding new ColumnFamily\nHColumnDescriptor cf2 = ...;\nadmin.modifyColumn(table, cf2);    // modifying existing ColumnFamily\n\nadmin.enableTable(table);\n```\n\nSee [client dependencies](/docs/configuration/default#client-configuration-and-dependencies-connecting-to-an-hbase-cluster) for more information about configuring client connections.\n\n<Callout type=\"info\">\n  Online schema changes are supported in the 0.92.x codebase, but the 0.90.x codebase requires the\n  table to be disabled.\n</Callout>\n\n### Schema Updates\n\nWhen changes are made to either Tables or ColumnFamilies (e.g. region size, block size), these changes take effect the next time there is a major compaction and the StoreFiles get re-written.\n\nSee [store](/docs/architecture/regions#store) for more information on StoreFiles.\n\n## Table Schema Rules Of Thumb\n\nThere are many different data sets, with different access patterns and service-level expectations. Therefore, these rules of thumb are only an overview. Read the rest of this chapter to get more details after you have gone through this list.\n\n* Aim to have regions sized between 10 and 50 GB.\n* Aim to have cells no larger than 10 MB, or 50 MB if you use [mob](/docs/architecture/hbase-mob). Otherwise, consider storing your cell data in HDFS and store a pointer to the data in HBase.\n* A typical schema has between 1 and 3 column families per table. HBase tables should not be designed to mimic RDBMS tables.\n* Around 50-100 regions is a good number for a table with 1 or 2 column families. Remember that a region is a contiguous segment of a column family.\n* Keep your column family names as short as possible. The column family names are stored for every value (ignoring prefix encoding). They should not be self-documenting and descriptive like in a typical RDBMS.\n* If you are storing time-based machine data or logging information, and the row key is based on device ID or service ID plus time, you can end up with a pattern where older data regions never have additional writes beyond a certain age. In this type of situation, you end up with a small number of active regions and a large number of older regions which have no new writes. For these situations, you can tolerate a larger number of regions because your resource consumption is driven by the active regions only.\n* If only one column family is busy with writes, only that column family accomulates memory. Be aware of write patterns when allocating resources.\n\n***\n\n# RegionServer Sizing Rules of Thumb\n\nLars Hofhansl wrote a great [blog post](http://hadoop-hbase.blogspot.com/2013/01/hbase-region-server-memory-sizing.html) about RegionServer memory sizing. The upshot is that you probably need more memory than you think you need. He goes into the impact of region size, memstore size, HDFS replication factor, and other things to check.\n\n> Personally I would place the maximum disk space per machine that can be served exclusively with HBase around 6T, unless you have a very read-heavy workload. In that case the Java heap should be 32GB (20G regions, 128M memstores, the rest defaults).\n>\n> — Lars Hofhansl [http://hadoop-hbase.blogspot.com/2013/01/hbase-region-server-memory-sizing.html](http://hadoop-hbase.blogspot.com/2013/01/hbase-region-server-memory-sizing.html)\n\n## On the number of column families\n\nHBase currently does not do well with anything above two or three column families so keep the number of column families in your schema low. Currently, flushing is done on a per Region basis so if one column family is carrying the bulk of the data bringing on flushes, the adjacent families will also be flushed even though the amount of data they carry is small. When many column families exist the flushing interaction can make for a bunch of needless i/o (To be addressed by changing flushing to work on a per column family basis). In addition, compactions triggered at table/region level will happen per store too.\n\nTry to make do with one column family if you can in your schemas. Only introduce a second and third column family in the case where data access is usually column scoped; i.e. you query one column family or the other but usually not both at the one time.\n\n### Cardinality of ColumnFamilies\n\nWhere multiple ColumnFamilies exist in a single table, be aware of the cardinality (i.e., number of rows). If ColumnFamilyA has 1 million rows and ColumnFamilyB has 1 billion rows, ColumnFamilyA's data will likely be spread across many, many regions (and RegionServers). This makes mass scans for ColumnFamilyA less efficient.\n\n## Rowkey Design\n\n### Hotspotting\n\nRows in HBase are sorted lexicographically by row key. This design optimizes for scans, allowing you to store related rows, or rows that will be read together, near each other. However, poorly designed row keys are a common source of **hotspotting**. Hotspotting occurs when a large amount of client traffic is directed at one node, or only a few nodes, of a cluster. This traffic may represent reads, writes, or other operations. The traffic overwhelms the single machine responsible for hosting that region, causing performance degradation and potentially leading to region unavailability. This can also have adverse effects on other regions hosted by the same region server as that host is unable to service the requested load. It is important to design data access patterns such that the cluster is fully and evenly utilized.\n\nTo prevent hotspotting on writes, design your row keys such that rows that truly do need to be in the same region are, but in the bigger picture, data is being written to multiple regions across the cluster, rather than one at a time. Some common techniques for avoiding hotspotting are described below, along with some of their advantages and drawbacks.\n\n#### Salting \\[!toc]\n\nSalting in this sense has nothing to do with cryptography, but refers to adding random data to the start of a row key. In this case, salting refers to adding a randomly-assigned prefix to the row key to cause it to sort differently than it otherwise would. The number of possible prefixes correspond to the number of regions you want to spread the data across. Salting can be helpful if you have a few \"hot\" row key patterns which come up over and over amongst other more evenly-distributed rows. Consider the following example, which shows that salting can spread write load across multiple RegionServers, and illustrates some of the negative implications for reads.\n\n#### Salting Example: \\[!toc]\n\nSuppose you have the following list of row keys, and your table is split such that there is one region for each letter of the alphabet. Prefix 'a' is one region, prefix 'b' is another. In this table, all rows starting with 'f' are in the same region. This example focuses on rows with keys like the following:\n\n```text\nfoo0001\nfoo0002\nfoo0003\nfoo0004\n```\n\nNow, imagine that you would like to spread these across four different regions. You decide to use four different salts: `a`, `b`, `c`, and `d`. In this scenario, each of these letter prefixes will be on a different region. After applying the salts, you have the following rowkeys instead. Since you can now write to four separate regions, you theoretically have four times the throughput when writing that you would have if all the writes were going to the same region.\n\n```text\na-foo0003\nb-foo0001\nc-foo0004\nd-foo0002\n```\n\nThen, if you add another row, it will randomly be assigned one of the four possible salt values and end up near one of the existing rows.\n\n```text\na-foo0003\nb-foo0001\nc-foo0003\nc-foo0004\nd-foo0002\n```\n\nSince this assignment will be random, you will need to do more work if you want to retrieve the rows in lexicographic order. In this way, salting attempts to increase throughput on writes, but has a cost during reads.\n\n#### Hashing \\[!toc]\n\nInstead of a random assignment, you could use a one-way **hash** that would cause a given row to always be \"salted\" with the same prefix, in a way that would spread the load across the RegionServers, but allow for predictability during reads. Using a deterministic hash allows the client to reconstruct the complete rowkey and use a Get operation to retrieve that row as normal.\n\n#### Hashing Example: \\[!toc]\n\nGiven the same situation in the salting example above, you could instead apply a one-way hash that would cause the row with key `foo0003` to always, and predictably, receive the `a` prefix. Then, to retrieve that row, you would already know the key. You could also optimize things so that certain pairs of keys were always in the same region, for instance.\n\n#### Reversing the Key \\[!toc]\n\nA third common trick for preventing hotspotting is to reverse a fixed-width or numeric row key so that the part that changes the most often (the least significant digit) is first. This effectively randomizes row keys, but sacrifices row ordering properties.\n\nSee [https://communities.intel.com/community/itpeernetwork/datastack/blog/2013/11/10/discussion-on-designing-hbase-tables](https://communities.intel.com/community/itpeernetwork/datastack/blog/2013/11/10/discussion-on-designing-hbase-tables), and [article on Salted Tables](https://phoenix.apache.org/salted.html) from the Phoenix project, and the discussion in the comments of [HBASE-11682](https://issues.apache.org/jira/browse/HBASE-11682) for more information about avoiding hotspotting.\n\n### Monotonically Increasing Row Keys/Timeseries Data\n\nIn the HBase chapter of Tom White's book [Hadoop: The Definitive Guide](http://oreilly.com/catalog/9780596521981) (O'Reilly) there is a an optimization note on watching out for a phenomenon where an import process walks in lock-step with all clients in concert pounding one of the table's regions (and thus, a single node), then moving onto the next region, etc. With monotonically increasing row-keys (i.e., using a timestamp), this will happen. See this comic by IKai Lan on why monotonically increasing row keys are problematic in BigTable-like datastores: [monotonically increasing values are bad](http://ikaisays.com/2011/01/25/app-engine-datastore-tip-monotonically-increasing-values-are-bad/). The pile-up on a single region brought on by monotonically increasing keys can be mitigated by randomizing the input records to not be in sorted order, but in general it's best to avoid using a timestamp or a sequence (e.g. 1, 2, 3) as the row-key.\n\nIf you do need to upload time series data into HBase, you should study [OpenTSDB](http://opentsdb.net/) as a successful example. It has a page describing the [schema](http://opentsdb.net/schema.html) it uses in HBase. The key format in OpenTSDB is effectively \\[metric\\_type]\\[event\\_timestamp], which would appear at first glance to contradict the previous advice about not using a timestamp as the key. However, the difference is that the timestamp is not in the *lead* position of the key, and the design assumption is that there are dozens or hundreds (or more) of different metric types. Thus, even with a continual stream of input data with a mix of metric types, the Puts are distributed across various points of regions in the table.\n\nSee [schema.casestudies](/docs/regionserver-sizing#schema-design-case-studies) for some rowkey design examples.\n\n### Try to minimize row and column sizes\n\nIn HBase, values are always freighted with their coordinates; as a cell value passes through the system, it'll be accompanied by its row, column name, and timestamp - always. If your rows and column names are large, especially compared to the size of the cell value, then you may run up against some interesting scenarios. One such is the case described by Marc Limotte at the tail of [HBASE-3551](https://issues.apache.org/jira/browse/HBASE-3551?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel\\&focusedCommentId=13005272#comment-13005272) (recommended!). Therein, the indices that are kept on HBase storefiles (see [HFile Format](/docs/hfile-format)) to facilitate random access may end up occupying large chunks of the HBase allotted RAM because the cell value coordinates are large. Mark in the above cited comment suggests upping the block size so entries in the store file index happen at a larger interval or modify the table schema so it makes for smaller rows and column names. Compression will also make for larger indices. See the thread [a question storefileIndexSize](https://lists.apache.org/thread.html/b158eae5d8888d3530be378298bca90c17f80982fdcdfa01d0844c3d%401306240189%40%3Cuser.hbase.apache.org%3E) up on the user mailing list.\n\nMost of the time small inefficiencies don't matter all that much. Unfortunately, this is a case where they do. Whatever patterns are selected for ColumnFamilies, attributes, and rowkeys they could be repeated several billion times in your data.\n\nSee [keyvalue](/docs/architecture/regions#keyvalue) for more information on HBase stores data internally to see why this is important.\n\n#### Column Families\n\nTry to keep the ColumnFamily names as small as possible, preferably one character (e.g. \"d\" for data/default).\n\nSee [KeyValue](/docs/architecture/regions#keyvalue) for more information on how HBase stores data internally.\n\n#### Attributes\n\nAlthough verbose attribute names (e.g., \"myVeryImportantAttribute\") are easier to read, prefer shorter attribute names (e.g., \"via\") to store in HBase.\n\nSee [keyvalue](/docs/architecture/regions#keyvalue) for more information on HBase stores data internally to see why this is important.\n\n#### Rowkey Length\n\nKeep them as short as is reasonable such that they can still be useful for required data access (e.g. Get vs. Scan). A short key that is useless for data access is not better than a longer key with better get/scan properties. Expect tradeoffs when designing rowkeys.\n\n#### Byte Patterns\n\nA long is 8 bytes. You can store an unsigned number up to 18,446,744,073,709,551,615 in those eight bytes. If you stored this number as a String — presuming a byte per character — you need nearly 3x the bytes.\n\nNot convinced? Below is some sample code that you can run on your own.\n\n```java\n// long\n//\nlong l = 1234567890L;\nbyte[] lb = Bytes.toBytes(l);\nSystem.out.println(\"long bytes length: \" + lb.length);   // returns 8\n\nString s = String.valueOf(l);\nbyte[] sb = Bytes.toBytes(s);\nSystem.out.println(\"long as string length: \" + sb.length);    // returns 10\n\n// hash\n//\nMessageDigest md = MessageDigest.getInstance(\"MD5\");\nbyte[] digest = md.digest(Bytes.toBytes(s));\nSystem.out.println(\"md5 digest bytes length: \" + digest.length);    // returns 16\n\nString sDigest = new String(digest);\nbyte[] sbDigest = Bytes.toBytes(sDigest);\nSystem.out.println(\"md5 digest as string length: \" + sbDigest.length);    // returns 26\n```\n\nUnfortunately, using a binary representation of a type will make your data harder to read outside of your code. For example, this is what you will see in the shell when you increment a value:\n\n```bash\nhbase(main):001:0> incr 't', 'r', 'f:q', 1\nCOUNTER VALUE = 1\n\nhbase(main):002:0> get 't', 'r'\nCOLUMN                                        CELL\n f:q                                          timestamp=1369163040570, value=\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\n1 row(s) in 0.0310 seconds\n```\n\nThe shell makes a best effort to print a string, and it this case it decided to just print the hex. The same will happen to your row keys inside the region names. It can be okay if you know what's being stored, but it might also be unreadable if arbitrary data can be put in the same cells. This is the main trade-off.\n\n### Reverse Timestamps\n\n<Callout type=\"info\">\n  [HBASE-4811](https://issues.apache.org/jira/browse/HBASE-4811) implements an API to scan a table\n  or a range within a table in reverse, reducing the need to optimize your schema for forward or\n  reverse scanning. This feature is available in HBase 0.98 and later. See\n  [Scan.setReversed()](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html#setReversed\\(boolean\\))\n  for more information.\n</Callout>\n\nA common problem in database processing is quickly finding the most recent version of a value. A technique using reverse timestamps as a part of the key can help greatly with a special case of this problem. Also found in the HBase chapter of Tom White's book Hadoop: The Definitive Guide (O'Reilly), the technique involves appending (`Long.MAX_VALUE - timestamp`) to the end of any key, e.g. \\[key]\\[reverse\\_timestamp].\n\nThe most recent value for \\[key] in a table can be found by performing a Scan for \\[key] and obtaining the first record. Since HBase keys are in sorted order, this key sorts before any older row-keys for \\[key] and thus is first.\n\nThis technique would be used instead of using [Number of Versions](/docs/regionserver-sizing#number-of-versions) where the intent is to hold onto all versions \"forever\" (or a very long time) and at the same time quickly obtain access to any other version by using the same Scan technique.\n\n### Rowkeys and ColumnFamilies\n\nRowkeys are scoped to ColumnFamilies. Thus, the same rowkey could exist in each ColumnFamily that exists in a table without collision.\n\n### Immutability of Rowkeys\n\nRowkeys cannot be changed. The only way they can be \"changed\" in a table is if the row is deleted and then re-inserted. This is a fairly common question on the HBase dist-list so it pays to get the rowkeys right the first time (and/or before you've inserted a lot of data).\n\n### Relationship Between RowKeys and Region Splits\n\nIf you pre-split your table, it is *critical* to understand how your rowkey will be distributed across the region boundaries. As an example of why this is important, consider the example of using displayable hex characters as the lead position of the key (e.g., \"0000000000000000\" to \"ffffffffffffffff\"). Running those key ranges through `Bytes.split` (which is the split strategy used when creating regions in `Admin.createTable(byte[] startKey, byte[] endKey, numRegions)` for 10 regions will generate the following splits...\n\n```text\n48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48                                // 0\n54 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10                 // 6\n61 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -68                 // =\n68 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -126  // D\n75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 72                                // K\n82 18 18 18 18 18 18 18 18 18 18 18 18 18 18 14                                // R\n88 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -44                 // X\n95 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -102                // _\n102 102 102 102 102 102 102 102 102 102 102 102 102 102 102 102                // f\n```\n\n(note: the lead byte is listed to the right as a comment.) Given that the first split is a '0' and the last split is an 'f', everything is great, right? Not so fast.\n\nThe problem is that all the data is going to pile up in the first 2 regions and the last region thus creating a \"lumpy\" (and possibly \"hot\") region problem. To understand why, refer to an [ASCII Table](http://www.asciitable.com). '0' is byte 48, and 'f' is byte 102, but there is a huge gap in byte values (bytes 58 to 96) that will *never appear in this keyspace* because the only values are \\[0-9] and \\[a-f]. Thus, the middle regions will never be used. To make pre-splitting work with this example keyspace, a custom definition of splits (i.e., and not relying on the built-in split method) is required.\n\nLesson #1: Pre-splitting tables is generally a best practice, but you need to pre-split them in such a way that all the regions are accessible in the keyspace. While this example demonstrated the problem with a hex-key keyspace, the same problem can happen with *any* keyspace. Know your data.\n\nLesson #2: While generally not advisable, using hex-keys (and more generally, displayable data) can still work with pre-split tables as long as all the created regions are accessible in the keyspace.\n\nTo conclude this example, the following is an example of how appropriate splits can be pre-created for hex-keys:\n\n```java\npublic static boolean createTable(Admin admin, HTableDescriptor table, byte[][] splits)\nthrows IOException {\n  try {\n    admin.createTable( table, splits );\n    return true;\n  } catch (TableExistsException e) {\n    logger.info(\"table \" + table.getNameAsString() + \" already exists\");\n    // the table already exists...\n    return false;\n  }\n}\n\npublic static byte[][] getHexSplits(String startKey, String endKey, int numRegions) {\n  byte[][] splits = new byte[numRegions-1][];\n  BigInteger lowestKey = new BigInteger(startKey, 16);\n  BigInteger highestKey = new BigInteger(endKey, 16);\n  BigInteger range = highestKey.subtract(lowestKey);\n  BigInteger regionIncrement = range.divide(BigInteger.valueOf(numRegions));\n  lowestKey = lowestKey.add(regionIncrement);\n  for(int i=0; i < numRegions-1;i++) {\n    BigInteger key = lowestKey.add(regionIncrement.multiply(BigInteger.valueOf(i)));\n    byte[] b = String.format(\"%016x\", key).getBytes();\n    splits[i] = b;\n  }\n  return splits;\n}\n```\n\n## Number of Versions\n\n### Maximum Number of Versions\n\nThe maximum number of row versions to store is configured per column family via [HColumnDescriptor](https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html). The default for max versions is 1. This is an important parameter because as described in [Data Model](/docs/datamodel) section HBase does *not* overwrite row values, but rather stores different values per row by time (and qualifier). Excess versions are removed during major compactions. The number of max versions may need to be increased or decreased depending on application needs.\n\nIt is not recommended setting the number of max versions to an exceedingly high level (e.g., hundreds or more) unless those old values are very dear to you because this will greatly increase StoreFile size.\n\n### Minimum Number of Versions\n\nLike maximum number of row versions, the minimum number of row versions to keep is configured per column family via [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html). The default for min versions is 0, which means the feature is disabled. The minimum number of row versions parameter is used together with the time-to-live parameter and can be combined with the number of row versions parameter to allow configurations such as \"keep the last T minutes worth of data, at most N versions, *but keep at least M versions around*\" (where M is the value for minimum number of row versions, M\\<N). This parameter should only be set when time-to-live is enabled for a column family and must be less than the number of row versions.\n\n## Supported Datatypes\n\nHBase supports a \"bytes-in/bytes-out\" interface via [Put](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Put.html) and [Result](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Result.html), so anything that can be converted to an array of bytes can be stored as a value. Input could be strings, numbers, complex objects, or even images as long as they can rendered as bytes.\n\nThere are practical limits to the size of values (e.g., storing 10-50MB objects in HBase would probably be too much to ask); search the mailing list for conversations on this topic. All rows in HBase conform to the [Data Model](/docs/datamodel), and that includes versioning. Take that into consideration when making your design, as well as block size for the ColumnFamily.\n\n### Counters\n\nOne supported datatype that deserves special mention are \"counters\" (i.e., the ability to do atomic increments of numbers). See [Increment](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#increment\\(org.apache.hadoop.hbase.client.Increment\\)) in `Table`.\n\nSynchronization on counters are done on the RegionServer, not in the client.\n\n## Joins\n\nIf you have multiple tables, don't forget to factor in the potential for [Joins](/docs/datamodel#datamodel-joins) into the schema design.\n\n## Time To Live (TTL)\n\nColumnFamilies can set a TTL length in seconds, and HBase will automatically delete rows once the expiration time is reached. This applies to *all* versions of a row - even the current one. The TTL time encoded in the HBase for the row is specified in UTC.\n\nStore files which contains only expired rows are deleted on minor compaction. Setting `hbase.store.delete.expired.storefile` to `false` disables this feature. Setting minimum number of versions to other than 0 also disables this.\n\nSee [HColumnDescriptor](https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html) for more information.\n\nRecent versions of HBase also support setting time to live on a per cell basis. See [HBASE-10560](https://issues.apache.org/jira/browse/HBASE-10560) for more information. Cell TTLs are submitted as an attribute on mutation requests (Appends, Increments, Puts, etc.) using Mutation#setTTL. If the TTL attribute is set, it will be applied to all cells updated on the server by the operation. There are two notable differences between cell TTL handling and ColumnFamily TTLs:\n\n* Cell TTLs are expressed in units of milliseconds instead of seconds.\n\n* A cell TTLs cannot extend the effective lifetime of a cell beyond a ColumnFamily level TTL setting.\n\n## Keeping Deleted Cells\n\nBy default, delete markers extend back to the beginning of time. Therefore, [Get](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html) or [Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) operations will not see a deleted cell (row or column), even when the Get or Scan operation indicates a time range before the delete marker was placed.\n\nColumnFamilies can optionally keep deleted cells. In this case, deleted cells can still be retrieved, as long as these operations specify a time range that ends before the timestamp of any delete that would affect the cells. This allows for point-in-time queries even in the presence of deletes.\n\nDeleted cells are still subject to TTL and there will never be more than \"maximum number of versions\" deleted cells. A new \"raw\" scan options returns all deleted rows and the delete markers.\n\n#### Change the Value of `KEEP_DELETED_CELLS` Using HBase Shell: \\[!toc]\n\n```bash\nhbase> hbase> alter 't1', NAME => 'f1', KEEP_DELETED_CELLS => true\n```\n\n#### Change the Value of `KEEP_DELETED_CELLS` Using the API: \\[!toc]\n\n```java\n...\nHColumnDescriptor.setKeepDeletedCells(true);\n...\n```\n\nLet us illustrate the basic effect of setting the `KEEP_DELETED_CELLS` attribute on a table.\n\nFirst, without:\n\n```bash\ncreate 'test', {NAME=>'e', VERSIONS=>2147483647}\nput 'test', 'r1', 'e:c1', 'value', 10\nput 'test', 'r1', 'e:c1', 'value', 12\nput 'test', 'r1', 'e:c1', 'value', 14\ndelete 'test', 'r1', 'e:c1',  11\n\nhbase(main):017:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                              COLUMN+CELL\n r1                                              column=e:c1, timestamp=14, value=value\n r1                                              column=e:c1, timestamp=12, value=value\n r1                                              column=e:c1, timestamp=11, type=DeleteColumn\n r1                                              column=e:c1, timestamp=10, value=value\n1 row(s) in 0.0120 seconds\n\nhbase(main):018:0> flush 'test'\n0 row(s) in 0.0350 seconds\n\nhbase(main):019:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                              COLUMN+CELL\n r1                                              column=e:c1, timestamp=14, value=value\n r1                                              column=e:c1, timestamp=12, value=value\n r1                                              column=e:c1, timestamp=11, type=DeleteColumn\n1 row(s) in 0.0120 seconds\n\nhbase(main):020:0> major_compact 'test'\n0 row(s) in 0.0260 seconds\n\nhbase(main):021:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                              COLUMN+CELL\n r1                                              column=e:c1, timestamp=14, value=value\n r1                                              column=e:c1, timestamp=12, value=value\n1 row(s) in 0.0120 seconds\n```\n\nNotice how delete cells are let go.\n\nNow let's run the same test only with `KEEP_DELETED_CELLS` set on the table (you can do table or per-column-family):\n\n```bash\nhbase(main):005:0> create 'test', {NAME=>'e', VERSIONS=>2147483647, KEEP_DELETED_CELLS => true}\n0 row(s) in 0.2160 seconds\n\n=> Hbase::Table - test\nhbase(main):006:0> put 'test', 'r1', 'e:c1', 'value', 10\n0 row(s) in 0.1070 seconds\n\nhbase(main):007:0> put 'test', 'r1', 'e:c1', 'value', 12\n0 row(s) in 0.0140 seconds\n\nhbase(main):008:0> put 'test', 'r1', 'e:c1', 'value', 14\n0 row(s) in 0.0160 seconds\n\nhbase(main):009:0> delete 'test', 'r1', 'e:c1',  11\n0 row(s) in 0.0290 seconds\n\nhbase(main):010:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                                                                          COLUMN+CELL\n r1                                                                                          column=e:c1, timestamp=14, value=value\n r1                                                                                          column=e:c1, timestamp=12, value=value\n r1                                                                                          column=e:c1, timestamp=11, type=DeleteColumn\n r1                                                                                          column=e:c1, timestamp=10, value=value\n1 row(s) in 0.0550 seconds\n\nhbase(main):011:0> flush 'test'\n0 row(s) in 0.2780 seconds\n\nhbase(main):012:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                                                                          COLUMN+CELL\n r1                                                                                          column=e:c1, timestamp=14, value=value\n r1                                                                                          column=e:c1, timestamp=12, value=value\n r1                                                                                          column=e:c1, timestamp=11, type=DeleteColumn\n r1                                                                                          column=e:c1, timestamp=10, value=value\n1 row(s) in 0.0620 seconds\n\nhbase(main):013:0> major_compact 'test'\n0 row(s) in 0.0530 seconds\n\nhbase(main):014:0> scan 'test', {RAW=>true, VERSIONS=>1000}\nROW                                                                                          COLUMN+CELL\n r1                                                                                          column=e:c1, timestamp=14, value=value\n r1                                                                                          column=e:c1, timestamp=12, value=value\n r1                                                                                          column=e:c1, timestamp=11, type=DeleteColumn\n r1                                                                                          column=e:c1, timestamp=10, value=value\n1 row(s) in 0.0650 seconds\n```\n\nKEEP*DELETED\\_CELLS is to avoid removing Cells from HBase when the \\_only* reason to remove them is the delete marker. So with KEEP\\_DELETED\\_CELLS enabled deleted cells would get removed if either you write more versions than the configured max, or you have a TTL and Cells are in excess of the configured timeout, etc.\n\n## Secondary Indexes and Alternate Query Paths\n\nThis section could also be titled \"what if my table rowkey looks like *this* but I also want to query my table like *that*.\" A common example on the dist-list is where a row-key is of the format \"user-timestamp\" but there are reporting requirements on activity across users for certain time ranges. Thus, selecting by user is easy because it is in the lead position of the key, but time is not.\n\nThere is no single answer on the best way to handle this because it depends on...\n\n* Number of users\n* Data size and data arrival rate\n* Flexibility of reporting requirements (e.g., completely ad-hoc date selection vs. pre-configured ranges)\n* Desired execution speed of query (e.g., 90 seconds may be reasonable to some for an ad-hoc report, whereas it may be too long for others)\n\nand solutions are also influenced by the size of the cluster and how much processing power you have to throw at the solution. Common techniques are in sub-sections below. This is a comprehensive, but not exhaustive, list of approaches.\n\nIt should not be a surprise that secondary indexes require additional cluster space and processing. This is precisely what happens in an RDBMS because the act of creating an alternate index requires both space and processing cycles to update. RDBMS products are more advanced in this regard to handle alternative index management out of the box. However, HBase scales better at larger data volumes, so this is a feature trade-off.\n\nPay attention to [Apache HBase Performance Tuning](/docs/performance) when implementing any of these approaches.\n\nAdditionally, see the David Butler response in this dist-list thread [HBase, mail # user - Stargate+hbase](https://lists.apache.org/thread.html/b0ca33407f010d5b1be67a20d1708e8d8bb1e147770f2cb7182a2e37%401300972712%40%3Cuser.hbase.apache.org%3E)\n\n### Filter Query\n\nDepending on the case, it may be appropriate to use [Client Request Filters](/docs/architecture/client-request-filters). In this case, no secondary index is created. However, don't try a full-scan on a large table like this from an application (i.e., single-threaded client).\n\n### Periodic-Update Secondary Index\n\nA secondary index could be created in another table which is periodically updated via a MapReduce job. The job could be executed intra-day, but depending on load-strategy it could still potentially be out of sync with the main data table.\n\nSee [mapreduce.example.readwrite](/docs/mapreduce#hbase-mapreduce-read-example) for more information.\n\n### Dual-Write Secondary Index\n\nAnother strategy is to build the secondary index while publishing data to the cluster (e.g., write to data table, write to index table). If this is approach is taken after a data table already exists, then bootstrapping will be needed for the secondary index with a MapReduce job (see [secondary.indexes.periodic](/docs/regionserver-sizing#periodic-update-secondary-index)).\n\n### Summary Tables\n\nWhere time-ranges are very wide (e.g., year-long report) and where the data is voluminous, summary tables are a common approach. These would be generated with MapReduce jobs into another table.\n\nSee [mapreduce.example.summary](/docs/mapreduce#hbase-mapreduce-summary-to-hbase-example) for more information.\n\n### Coprocessor Secondary Index\n\nCoprocessors act like RDBMS triggers. These were added in 0.92. For more information, see [coprocessors](/docs/cp)\n\n## Constraints\n\nHBase currently supports 'constraints' in traditional (SQL) database parlance. The advised usage for Constraints is in enforcing business rules for attributes in the table (e.g. make sure values are in the range 1-10). Constraints could also be used to enforce referential integrity, but this is strongly discouraged as it will dramatically decrease the write throughput of the tables where integrity checking is enabled. Extensive documentation on using Constraints can be found at [Constraint](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/constraint/Constraint.html) since version 0.94.\n\n## Schema Design Case Studies\n\nThe following will describe some typical data ingestion use-cases with HBase, and how the rowkey design and construction can be approached. Note: this is just an illustration of potential approaches, not an exhaustive list. Know your data, and know your processing requirements.\n\nIt is highly recommended that you read the rest of the [HBase and Schema Design](/docs/schema-design) first, before reading these case studies.\n\nThe following case studies are described:\n\n* Log Data / Timeseries Data\n* Log Data / Timeseries on Steroids\n* Customer/Order\n* Tall/Wide/Middle Schema Design\n* List Data\n\n### Case Study - Log Data and Timeseries Data\n\nAssume that the following data elements are being collected.\n\n* Hostname\n* Timestamp\n* Log event\n* Value/message\n\nWe can store them in an HBase table called LOG\\_DATA, but what will the rowkey be? From these attributes the rowkey will be some combination of hostname, timestamp, and log-event - but what specifically?\n\n#### Timestamp In The Rowkey Lead Position\n\nThe rowkey `[timestamp][hostname][log-event]` suffers from the monotonically increasing rowkey problem described in [Monotonically Increasing Row Keys/Timeseries Data](/docs/regionserver-sizing#monotonically-increasing-row-keystimeseries-data).\n\nThere is another pattern frequently mentioned in the dist-lists about \"bucketing\" timestamps, by performing a mod operation on the timestamp. If time-oriented scans are important, this could be a useful approach. Attention must be paid to the number of buckets, because this will require the same number of scans to return results.\n\n```java\nlong bucket = timestamp % numBuckets;\n```\n\nto construct:\n\n```text\n[bucket][timestamp][hostname][log-event]\n```\n\nAs stated above, to select data for a particular timerange, a Scan will need to be performed for each bucket. 100 buckets, for example, will provide a wide distribution in the keyspace but it will require 100 Scans to obtain data for a single timestamp, so there are trade-offs.\n\n#### Host In The Rowkey Lead Position\n\nThe rowkey `[hostname][log-event][timestamp]` is a candidate if there is a large-ish number of hosts to spread the writes and reads across the keyspace. This approach would be useful if scanning by hostname was a priority.\n\n#### Timestamp, or Reverse Timestamp?\n\nIf the most important access path is to pull most recent events, then storing the timestamps as reverse-timestamps (e.g., `timestamp = Long.MAX_VALUE – timestamp`) will create the property of being able to do a Scan on `[hostname][log-event]` to obtain the most recently captured events.\n\nNeither approach is wrong, it just depends on what is most appropriate for the situation.\n\n<Callout type=\"info\">\n  [HBASE-4811](https://issues.apache.org/jira/browse/HBASE-4811) implements an API to scan a table\n  or a range within a table in reverse, reducing the need to optimize your schema for forward or\n  reverse scanning. This feature is available in HBase 0.98 and later. See\n  [Scan.setReversed()](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html#setReversed\\(boolean\\))\n  for more information.\n</Callout>\n\n#### Variable Length or Fixed Length Rowkeys?\n\nIt is critical to remember that rowkeys are stamped on every column in HBase. If the hostname is `a` and the event type is `e1` then the resulting rowkey would be quite small. However, what if the ingested hostname is `myserver1.mycompany.com` and the event type is `com.package1.subpackage2.subsubpackage3.ImportantService`?\n\nIt might make sense to use some substitution in the rowkey. There are at least two approaches: hashed and numeric. In the Hostname In The Rowkey Lead Position example, it might look like this:\n\nComposite Rowkey With Hashes:\n\n* \\[MD5 hash of hostname] = 16 bytes\n* \\[MD5 hash of event-type] = 16 bytes\n* \\[timestamp] = 8 bytes\n\nComposite Rowkey With Numeric Substitution:\n\nFor this approach another lookup table would be needed in addition to LOG\\_DATA, called LOG\\_TYPES. The rowkey of LOG\\_TYPES would be:\n\n* `[type]` (e.g., byte indicating hostname vs. event-type)\n* `[bytes]` variable length bytes for raw hostname or event-type.\n\nA column for this rowkey could be a long with an assigned number, which could be obtained by using an [HBase counter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#incrementColumnValue\\(byte%5B%5D,byte%5B%5D,byte%5B%5D,long\\))\n\nSo the resulting composite rowkey would be:\n\n* \\[substituted long for hostname] = 8 bytes\n* \\[substituted long for event type] = 8 bytes\n* \\[timestamp] = 8 bytes\n\nIn either the Hash or Numeric substitution approach, the raw values for hostname and event-type can be stored as columns.\n\n### Case Study - Log Data and Timeseries Data on Steroids\n\nThis effectively is the OpenTSDB approach. What OpenTSDB does is re-write data and pack rows into columns for certain time-periods. For a detailed explanation, see: [http://opentsdb.net/schema.html](http://opentsdb.net/schema.html), and [Lessons Learned from OpenTSDB](https://www.slideshare.net/cloudera/4-opentsdb-hbasecon) from HBaseCon2012.\n\nBut this is how the general concept works: data is ingested, for example, in this manner...\n\n```text\n[hostname][log-event][timestamp1]\n[hostname][log-event][timestamp2]\n[hostname][log-event][timestamp3]\n```\n\nwith separate rowkeys for each detailed event, but is re-written like this...\n\n```text\n[hostname][log-event][timerange]\n```\n\nand each of the above events are converted into columns stored with a time-offset relative to the beginning timerange (e.g., every 5 minutes). This is obviously a very advanced processing technique, but HBase makes this possible.\n\n### Case Study - Customer/Order\n\nAssume that HBase is used to store customer and order information. There are two core record-types being ingested: a Customer record type, and Order record type.\n\nThe Customer record type would include all the things that you'd typically expect:\n\n* Customer number\n* Customer name\n* Address (e.g., city, state, zip)\n* Phone numbers, etc.\n\nThe Order record type would include things like:\n\n* Customer number\n* Order number\n* Sales date\n* A series of nested objects for shipping locations and line-items (see [Order Object Design](/docs/regionserver-sizing#order-object-design) for details)\n\nAssuming that the combination of customer number and sales order uniquely identify an order, these two attributes will compose the rowkey, and specifically a composite key such as:\n\n```text\n[customer number][order number]\n```\n\nfor an ORDER table. However, there are more design decisions to make: are the *raw* values the best choices for rowkeys?\n\nThe same design questions in the Log Data use-case confront us here. What is the keyspace of the customer number, and what is the format (e.g., numeric? alphanumeric?) As it is advantageous to use fixed-length keys in HBase, as well as keys that can support a reasonable spread in the keyspace, similar options appear:\n\nComposite Rowkey With Hashes:\n\n* \\[MD5 of customer number] = 16 bytes\n* \\[MD5 of order number] = 16 bytes\n\nComposite Numeric/Hash Combo Rowkey:\n\n* \\[substituted long for customer number] = 8 bytes\n* \\[MD5 of order number] = 16 bytes\n\n#### Single Table? Multiple Tables?\n\nA traditional design approach would have separate tables for CUSTOMER and SALES. Another option is to pack multiple record types into a single table (e.g., CUSTOMER++).\n\nCustomer Record Type Rowkey:\n\n* \\[customer-id]\n* \\[type] = type indicating `1` for customer record type\n\nOrder Record Type Rowkey:\n\n* \\[customer-id]\n* \\[type] = type indicating `2` for order record type\n* \\[order]\n\nThe advantage of this particular CUSTOMER++ approach is that organizes many different record-types by customer-id (e.g., a single scan could get you everything about that customer). The disadvantage is that it's not as easy to scan for a particular record-type.\n\n#### Order Object Design\n\nNow we need to address how to model the Order object. Assume that the class structure is as follows:\n\n#### Order \\[!toc]\n\nan Order can have multiple ShippingLocations\n\n#### LineItem \\[!toc]\n\na ShippingLocation can have multiple LineItems\n\nthere are multiple options on storing this data.\n\n##### Completely Normalized\n\nWith this approach, there would be separate tables for ORDER, SHIPPING\\_LOCATION, and LINE\\_ITEM.\n\nThe ORDER table's rowkey was described above: [schema.casestudies.custorder](/docs/regionserver-sizing#case-study---customerorder)\n\nThe SHIPPING\\_LOCATION's composite rowkey would be something like this:\n\n* `[order-rowkey]`\n* `[shipping location number]` (e.g., 1st location, 2nd, etc.)\n\nThe LINE\\_ITEM table's composite rowkey would be something like this:\n\n* `[order-rowkey]`\n* `[shipping location number]` (e.g., 1st location, 2nd, etc.)\n* `[line item number]` (e.g., 1st lineitem, 2nd, etc.)\n\nSuch a normalized model is likely to be the approach with an RDBMS, but that's not your only option with HBase. The cons of such an approach is that to retrieve information about any Order, you will need:\n\n* Get on the ORDER table for the Order\n* Scan on the SHIPPING\\_LOCATION table for that order to get the ShippingLocation instances\n* Scan on the LINE\\_ITEM for each ShippingLocation\n\ngranted, this is what an RDBMS would do under the covers anyway, but since there are no joins in HBase you're just more aware of this fact.\n\n#### Single Table With Record Types\n\nWith this approach, there would exist a single table ORDER that would contain\n\nThe Order rowkey was described above: [schema.casestudies.custorder](/docs/regionserver-sizing#case-study---customerorder)\n\n* `[order-rowkey]`\n* `[ORDER record type]`\n\nThe ShippingLocation composite rowkey would be something like this:\n\n* `[order-rowkey]`\n* `[SHIPPING record type]`\n* `[shipping location number]` (e.g., 1st location, 2nd, etc.)\n\nThe LineItem composite rowkey would be something like this:\n\n* `[order-rowkey]`\n* `[LINE record type]`\n* `[shipping location number]` (e.g., 1st location, 2nd, etc.)\n* `[line item number]` (e.g., 1st lineitem, 2nd, etc.)\n\n#### Denormalized\n\nA variant of the Single Table With Record Types approach is to denormalize and flatten some of the object hierarchy, such as collapsing the ShippingLocation attributes onto each LineItem instance.\n\nThe LineItem composite rowkey would be something like this:\n\n* `[order-rowkey]`\n* `[LINE record type]`\n* `[line item number]` (e.g., 1st lineitem, 2nd, etc., care must be taken that there are unique across the entire order)\n\nand the LineItem columns would be something like this:\n\n* itemNumber\n* quantity\n* price\n* shipToLine1 (denormalized from ShippingLocation)\n* shipToLine2 (denormalized from ShippingLocation)\n* shipToCity (denormalized from ShippingLocation)\n* shipToState (denormalized from ShippingLocation)\n* shipToZip (denormalized from ShippingLocation)\n\nThe pros of this approach include a less complex object hierarchy, but one of the cons is that updating gets more complicated in case any of this information changes.\n\n#### Object BLOB\n\nWith this approach, the entire Order object graph is treated, in one way or another, as a BLOB. For example, the ORDER table's rowkey was described above: [schema.casestudies.custorder](/docs/regionserver-sizing#case-study---customerorder), and a single column called \"order\" would contain an object that could be deserialized that contained a container Order, ShippingLocations, and LineItems.\n\nThere are many options here: JSON, XML, Java Serialization, Avro, Hadoop Writables, etc. All of them are variants of the same approach: encode the object graph to a byte-array. Care should be taken with this approach to ensure backward compatibility in case the object model changes such that older persisted structures can still be read back out of HBase.\n\nPros are being able to manage complex object graphs with minimal I/O (e.g., a single HBase Get per Order in this example), but the cons include the aforementioned warning about backward compatibility of serialization, language dependencies of serialization (e.g., Java Serialization only works with Java clients), the fact that you have to deserialize the entire object to get any piece of information inside the BLOB, and the difficulty in getting frameworks like Hive to work with custom objects like this.\n\n### Case Study - \"Tall/Wide/Middle\" Schema Design Smackdown\n\nThis section will describe additional schema design questions that appear on the dist-list, specifically about tall and wide tables. These are general guidelines and not laws - each application must consider its own needs.\n\n#### Rows vs. Versions\n\nA common question is whether one should prefer rows or HBase's built-in-versioning. The context is typically where there are \"a lot\" of versions of a row to be retained (e.g., where it is significantly above the HBase default of 1 max versions). The rows-approach would require storing a timestamp in some portion of the rowkey so that they would not overwrite with each successive update.\n\nPreference: Rows (generally speaking).\n\n#### Rows vs. Columns\n\nAnother common question is whether one should prefer rows or columns. The context is typically in extreme cases of wide tables, such as having 1 row with 1 million attributes, or 1 million rows with 1 columns apiece.\n\nPreference: Rows (generally speaking). To be clear, this guideline is in the context is in extremely wide cases, not in the standard use-case where one needs to store a few dozen or hundred columns. But there is also a middle path between these two options, and that is \"Rows as Columns.\"\n\n#### Rows as Columns\n\nThe middle path between Rows vs. Columns is packing data that would be a separate row into columns, for certain rows. OpenTSDB is the best example of this case where a single row represents a defined time-range, and then discrete events are treated as columns. This approach is often more complex, and may require the additional complexity of re-writing your data, but has the advantage of being I/O efficient. For an overview of this approach, see [schema.casestudies.log-steroids](#schema.casestudies.log_steroids).\n\n### Case Study - List Data\n\nThe following is an exchange from the user dist-list regarding a fairly common question: how to handle per-user list data in Apache HBase.\n\n* QUESTION \\*\n\nWe're looking at how to store a large amount of (per-user) list data in HBase, and we were trying to figure out what kind of access pattern made the most sense. One option is store the majority of the data in a key, so we could have something like:\n\n```text\n<FixedWidthUserName><FixedWidthValueId1>:\"\" (no value)\n<FixedWidthUserName><FixedWidthValueId2>:\"\" (no value)\n<FixedWidthUserName><FixedWidthValueId3>:\"\" (no value)\n```\n\nThe other option we had was to do this entirely using:\n\n```text\n<FixedWidthUserName><FixedWidthPageNum0>:<FixedWidthLength><FixedIdNextPageNum><ValueId1><ValueId2><ValueId3>...\n<FixedWidthUserName><FixedWidthPageNum1>:<FixedWidthLength><FixedIdNextPageNum><ValueId1><ValueId2><ValueId3>...\n```\n\nwhere each row would contain multiple values. So in one case reading the first thirty values would be:\n\n```bash\nscan { STARTROW => 'FixedWidthUsername' LIMIT => 30}\n```\n\nAnd in the second case it would be\n\n```bash\nget 'FixedWidthUserName\\x00\\x00\\x00\\x00'\n```\n\nThe general usage pattern would be to read only the first 30 values of these lists, with infrequent access reading deeper into the lists. Some users would have ⇐ 30 total values in these lists, and some users would have millions (i.e. power-law distribution)\n\nThe single-value format seems like it would take up more space on HBase, but would offer some improved retrieval / pagination flexibility. Would there be any significant performance advantages to be able to paginate via gets vs paginating with scans?\n\nMy initial understanding was that doing a scan should be faster if our paging size is unknown (and caching is set appropriately), but that gets should be faster if we'll always need the same page size. I've ended up hearing different people tell me opposite things about performance. I assume the page sizes would be relatively consistent, so for most use cases we could guarantee that we only wanted one page of data in the fixed-page-length case. I would also assume that we would have infrequent updates, but may have inserts into the middle of these lists (meaning we'd need to update all subsequent rows).\n\nThanks for help / suggestions / follow-up questions.\n\n* ANSWER \\*\n\nIf I understand you correctly, you're ultimately trying to store triples in the form \"user, valueid, value\", right? E.g., something like:\n\n```text\n\"user123, firstname, Paul\",\n\"user234, lastname, Smith\"\n```\n\n(But the usernames are fixed width, and the valueids are fixed width).\n\nAnd, your access pattern is along the lines of: \"for user X, list the next 30 values, starting with valueid Y\". Is that right? And these values should be returned sorted by valueid?\n\nThe tl;dr version is that you should probably go with one row per user+value, and not build a complicated intra-row pagination scheme on your own unless you're really sure it is needed.\n\nYour two options mirror a common question people have when designing HBase schemas: should I go \"tall\" or \"wide\"? Your first schema is \"tall\": each row represents one value for one user, and so there are many rows in the table for each user; the row key is user + valueid, and there would be (presumably) a single column qualifier that means \"the value\". This is great if you want to scan over rows in sorted order by row key (thus my question above, about whether these ids are sorted correctly). You can start a scan at any user+valueid, read the next 30, and be done. What you're giving up is the ability to have transactional guarantees around all the rows for one user, but it doesn't sound like you need that. Doing it this way is generally recommended (see [here](/docs/regionserver-sizing#case-study---tallwidemiddle-schema-design-smackdown)).\n\nYour second option is \"wide\": you store a bunch of values in one row, using different qualifiers (where the qualifier is the valueid). The simple way to do that would be to just store ALL values for one user in a single row. I'm guessing you jumped to the \"paginated\" version because you're assuming that storing millions of columns in a single row would be bad for performance, which may or may not be true; as long as you're not trying to do too much in a single request, or do things like scanning over and returning all of the cells in the row, it shouldn't be fundamentally worse. The client has methods that allow you to get specific slices of columns.\n\nNote that neither case fundamentally uses more disk space than the other; you're just \"shifting\" part of the identifying information for a value either to the left (into the row key, in option one) or to the right (into the column qualifiers in option 2). Under the covers, every key/value still stores the whole row key, and column family name. (If this is a bit confusing, take an hour and watch Lars George's excellent video about understanding HBase schema design: [http://www.youtube.com/watch?v=\\_HLoH\\_PgrLk](http://www.youtube.com/watch?v=_HLoH_PgrLk)).\n\nA manually paginated version has lots more complexities, as you note, like having to keep track of how many things are in each page, re-shuffling if new values are inserted, etc. That seems significantly more complex. It might have some slight speed advantages (or disadvantages!) at extremely high throughput, and the only way to really know that would be to try it out. If you don't have time to build it both ways and compare, my advice would be to start with the simplest option (one row per user+value). Start simple and iterate! :)\n\n## Operational and Performance Configuration Options\n\n### Tune HBase Server RPC Handling\n\n* Set `hbase.regionserver.handler.count` (in `hbase-site.xml`) to cores x spindles for concurrency.\n* Optionally, split the call queues into separate read and write queues for differentiated service. The parameter `hbase.ipc.server.callqueue.handler.factor` specifies the number of call queues:\n  * `0` means a single shared queue\n  * `1` means one queue for each handler.\n  * A value between `0` and `1` allocates the number of queues proportionally to the number of handlers. For instance, a value of `.5` shares one queue between each two handlers.\n* Use `hbase.ipc.server.callqueue.read.ratio` (`hbase.ipc.server.callqueue.read.share` in 0.98) to split the call queues into read and write queues:\n  * `0.5` means there will be the same number of read and write queues\n  * `< 0.5` for more write than read\n  * `> 0.5` for more read than write\n* Set `hbase.ipc.server.callqueue.scan.ratio` (HBase 1.0+) to split read call queues into small-read and long-read queues:\n  * 0.5 means that there will be the same number of short-read and long-read queues\n  * `< 0.5` for more short-read\n  * `> 0.5` for more long-read\n\n### Disable Nagle for RPC\n\nDisable Nagle's algorithm. Delayed ACKs can add up to \\~200ms to RPC round trip time. Set the following parameters:\n\n* In Hadoop's `core-site.xml`:\n  * `ipc.server.tcpnodelay = true`\n  * `ipc.client.tcpnodelay = true`\n* In HBase's `hbase-site.xml`:\n  * `hbase.ipc.client.tcpnodelay = true`\n  * `hbase.ipc.server.tcpnodelay = true`\n\n### Limit Server Failure Impact\n\nDetect regionserver failure as fast as reasonable. Set the following parameters:\n\n* In `hbase-site.xml`, set `zookeeper.session.timeout` to 30 seconds or less to bound failure detection (20-30 seconds is a good start).\n  * Note: Zookeeper clients negotiate a session timeout with the server during client init. Server enforces this timeout to be in the range \\[`minSessionTimeout`, `maxSessionTimeout`] and both these timeouts (measured in milliseconds) are configurable in Zookeeper service configuration. If not configured, these default to 2 \\* `tickTime` and 20 \\* `tickTime` respectively (`tickTime` is the basic time unit used by ZooKeeper, as measured in milliseconds. It is used to regulate heartbeats, timeouts etc.). Refer to Zookeeper documentation for additional details.\n* Detect and avoid unhealthy or failed HDFS DataNodes: in `hdfs-site.xml` and `hbase-site.xml`, set the following parameters:\n  * `dfs.namenode.avoid.read.stale.datanode = true`\n  * `dfs.namenode.avoid.write.stale.datanode = true`\n\n### Optimize on the Server Side for Low Latency\n\nSkip the network for local blocks when the RegionServer goes to read from HDFS by exploiting HDFS's [Short-Circuit Local Reads](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/ShortCircuitLocalReads.html) facility. Note how setup must be done both at the datanode and on the dfsclient ends of the conneciton — i.e. at the RegionServer and how both ends need to have loaded the hadoop native `.so` library. After configuring your hadoop setting *dfs.client.read.shortcircuit* to *true* and configuring the *dfs.domain.socket.path* path for the datanode and dfsclient to share and restarting, next configure the regionserver/dfsclient side.\n\n* In `hbase-site.xml`, set the following parameters:\n  * `dfs.client.read.shortcircuit = true`\n  * `dfs.client.read.shortcircuit.skip.checksum = true` so we don't double checksum (HBase does its own checksumming to save on i/os).\n  * `dfs.domain.socket.path` to match what was set for the datanodes.\n  * `dfs.client.read.shortcircuit.buffer.size = 131072` Important to avoid OOME — hbase has a default it uses if unset, see `hbase.dfs.client.read.shortcircuit.buffer.size`; its default is 131072.\n* Ensure data locality. In `hbase-site.xml`, set `hbase.hstore.min.locality.to.skip.major.compact = 0.7` (Meaning that 0.7 \\<= n \\<= 1)\n* Make sure DataNodes have enough handlers for block transfers. In `hdfs-site.xml`, set the following parameters:\n  * `dfs.datanode.max.xcievers >= 8192`\n  * `dfs.datanode.handler.count =` number of spindles\n\nCheck the RegionServer logs after restart. You should only see complaint if misconfiguration. Otherwise, shortcircuit read operates quietly in background. It does not provide metrics so no optics on how effective it is but read latencies should show a marked improvement, especially if good data locality, lots of random reads, and dataset is larger than available cache.\n\nOther advanced configurations that you might play with, especially if shortcircuit functionality is complaining in the logs, include `dfs.client.read.shortcircuit.streams.cache.size` and `dfs.client.socketcache.capacity`. Documentation is sparse on these options. You'll have to read source code.\n\nRegionServer metric system exposes HDFS short circuit read metrics `shortCircuitBytesRead`. Other HDFS read metrics, including `totalBytesRead` (The total number of bytes read from HDFS), `localBytesRead` (The number of bytes read from the local HDFS DataNode), `zeroCopyBytesRead` (The number of bytes read through HDFS zero copy) are available and can be used to troubleshoot short-circuit read issues.\n\nFor more on short-circuit reads, see Colin's old blog on rollout, [How Improved Short-Circuit Local Reads Bring Better Performance and Security to Hadoop](http://blog.cloudera.com/blog/2013/08/how-improved-short-circuit-local-reads-bring-better-performance-and-security-to-hadoop/). The [HDFS-347](https://issues.apache.org/jira/browse/HDFS-347) issue also makes for an interesting read showing the HDFS community at its best (caveat a few comments).\n\n### JVM Tuning\n\n#### Tune JVM GC for low collection latencies\n\n* Use the CMS collector: `-XX:+UseConcMarkSweepGC`\n* Keep eden space as small as possible to minimize average collection time. Example:\n  ```text\n  -XX:CMSInitiatingOccupancyFraction=70\n  ```\n* Optimize for low collection latency rather than throughput: `-Xmn512m`\n* Collect eden in parallel: `-XX:+UseParNewGC`\n* Avoid collection under pressure: `-XX:+UseCMSInitiatingOccupancyOnly`\n* Limit per request scanner result sizing so everything fits into survivor space but doesn't tenure. In `hbase-site.xml`, set `hbase.client.scanner.max.result.size` to 1/8th of eden space (with -`Xmn512m` this is \\~51MB )\n* Set `max.result.size` x `handler.count` less than survivor space\n\n#### OS-Level Tuning\n\n* Turn transparent huge pages (THP) off:\n  ```bash\n  echo never > /sys/kernel/mm/transparent_hugepage/enabled\n  echo never > /sys/kernel/mm/transparent_hugepage/defrag\n  ```\n* Set `vm.swappiness = 0`\n* Set `vm.min_free_kbytes` to at least 1GB (8GB on larger memory systems)\n* Disable NUMA zone reclaim with `vm.zone_reclaim_mode = 0`\n\n## Special Cases\n\n### For applications where failing quickly is better than waiting\n\n* In `hbase-site.xml` on the client side, set the following parameters:\n  * Set `hbase.client.pause = 1000`\n  * Set `hbase.client.retries.number = 3`\n  * If you want to ride over splits and region moves, increase `hbase.client.retries.number` substantially (>= 20)\n  * Set the RecoverableZookeeper retry count: `zookeeper.recovery.retry = 1` (no retry)\n* In `hbase-site.xml` on the server side, set the Zookeeper session timeout for detecting server failures: `zookeeper.session.timeout` ⇐ 30 seconds (20-30 is good).\n\n### For applications that can tolerate slightly out of date information\n\n**HBase timeline consistency (HBASE-10070)** With read replicas enabled, read-only copies of regions (replicas) are distributed over the cluster. One RegionServer services the default or primary replica, which is the only replica that can service writes. Other RegionServers serve the secondary replicas, follow the primary RegionServer, and only see committed updates. The secondary replicas are read-only, but can serve reads immediately while the primary is failing over, cutting read availability blips from seconds to milliseconds. Phoenix supports timeline consistency as of 4.4.0 Tips:\n\n* Deploy HBase 1.0.0 or later.\n* Enable timeline consistent replicas on the server side.\n* Use one of the following methods to set timeline consistency:\n  * Use `ALTER SESSION SET CONSISTENCY = 'TIMELINE'`\n  * Set the connection property `Consistency` to `timeline` in the JDBC connect string\n\n### More Information\n\nSee the Performance section [perf.schema](/docs/case-studies#case-studies-schema-design) for more information about operational and performance schema design options, such as Bloom Filters, Table-configured regionsizes, compression, and blocksizes.\n\n***\n\n# HBase and MapReduce\n\nApache MapReduce is a software framework used to analyze large amounts of data. It is provided by [Apache Hadoop](https://hadoop.apache.org/).\nMapReduce itself is out of the scope of this document.\nA good place to get started with MapReduce is [https://hadoop.apache.org/docs/r2.6.0/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html](https://hadoop.apache.org/docs/r2.6.0/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html).\nMapReduce version 2 (MR2)is now part of [YARN](https://hadoop.apache.org/docs/r2.6.0/hadoop-yarn/hadoop-yarn-site/).\n\nThis chapter discusses specific configuration steps you need to take to use MapReduce on data within HBase.\nIn addition, it discusses other interactions and issues between HBase and MapReduce jobs.\n\n<Callout type=\"info\" title=\"mapred and mapreduce\">\n  There are two mapreduce packages in HBase as in MapReduce itself: *org.apache.hadoop.hbase.mapred*\n  and *org.apache.hadoop.hbase.mapreduce*. The former does old-style API and the latter the new\n  mode. The latter has more facility though you can usually find an equivalent in the older package.\n  Pick the package that goes with your MapReduce deploy. When in doubt or starting over, pick\n  *org.apache.hadoop.hbase.mapreduce*. In the notes below, we refer to *o.a.h.h.mapreduce* but\n  replace with *o.a.h.h.mapred* if that is what you are using.\n</Callout>\n\n## HBase, MapReduce, and the CLASSPATH\n\nBy default, MapReduce jobs deployed to a MapReduce cluster do not have access to\neither the HBase configuration under `$HBASE_CONF_DIR` or the HBase classes.\n\nTo give the MapReduce jobs the access they need, you could add \\_hbase-site.xml\\_to \\_\\$HADOOP*HOME/conf* and add HBase jars to the *\\$HADOOP\\_HOME/lib* directory.\nYou would then need to copy these changes across your cluster. Or you could edit *\\$HADOOP\\_HOME/conf/hadoop-env.sh* and add hbase dependencies to the `HADOOP_CLASSPATH` variable.\nNeither of these approaches is recommended because it will pollute your Hadoop install with HBase references.\nIt also requires you restart the Hadoop cluster before Hadoop can use the HBase data.\n\nThe recommended approach is to let HBase add its dependency jars and use `HADOOP_CLASSPATH` or `-libjars`.\n\nSince HBase `0.90.x`, HBase adds its dependency JARs to the job configuration itself.\nThe dependencies only need to be available on the local `CLASSPATH` and from here they'll be picked\nup and bundled into the fat job jar deployed to the MapReduce cluster. A basic trick just passes\nthe full hbase classpath — all hbase and dependent jars as well as configurations — to the mapreduce\njob runner letting hbase utility pick out from the full-on classpath what it needs adding them to the\nMapReduce job configuration (See the source at `TableMapReduceUtil#addDependencyJars(org.apache.hadoop.mapreduce.Job)` for how this is done).\n\nThe following example runs the bundled HBase [RowCounter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html) MapReduce job against a table named `usertable`.\nIt sets into `HADOOP_CLASSPATH` the jars hbase needs to run in an MapReduce context (including configuration files such as hbase-site.xml).\nBe sure to use the correct version of the HBase JAR for your system; replace the VERSION string in the below command line w/ the version of\nyour local hbase install. The backticks (\\`\\`\\`) cause the shell to execute the sub-commands, setting the output of `hbase classpath` into `HADOOP_CLASSPATH`.\nThis example assumes you use a BASH-compatible shell.\n\n```bash\n$ HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` \\\n  ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/lib/hbase-mapreduce-VERSION.jar \\\n  org.apache.hadoop.hbase.mapreduce.RowCounter usertable\n```\n\nThe above command will launch a row counting mapreduce job against the hbase cluster that is pointed to by your local configuration on a cluster that the hadoop configs are pointing to.\n\nThe main for the `hbase-mapreduce.jar` is a Driver that lists a few basic mapreduce tasks that ship with hbase.\nFor example, presuming your install is hbase `2.0.0-SNAPSHOT`:\n\n```bash\n$ HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` \\\n  ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/lib/hbase-mapreduce-2.0.0-SNAPSHOT.jar\nAn example program must be given as the first argument.\nValid program names are:\n  CellCounter: Count cells in HBase table.\n  WALPlayer: Replay WAL files.\n  completebulkload: Complete a bulk data load.\n  copytable: Export a table from local cluster to peer cluster.\n  export: Write table data to HDFS.\n  exportsnapshot: Export the specific snapshot to a given FileSystem.\n  import: Import data written by Export.\n  importtsv: Import data in TSV format.\n  rowcounter: Count rows in HBase table.\n  verifyrep: Compare the data from tables in two different clusters. WARNING: It doesn't work for incrementColumnValues'd cells since the timestamp is changed after being appended to the log.\n```\n\nYou can use the above listed shortnames for mapreduce jobs as in the below re-run of the row counter job (again, presuming your install is hbase `2.0.0-SNAPSHOT`):\n\n```bash\n$ HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` \\\n  ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/lib/hbase-mapreduce-2.0.0-SNAPSHOT.jar \\\n  rowcounter usertable\n```\n\nYou might find the more selective `hbase mapredcp` tool output of interest; it lists the minimum set of jars needed\nto run a basic mapreduce job against an hbase install. It does not include configuration. You'll probably need to add\nthese if you want your MapReduce job to find the target cluster. You'll probably have to also add pointers to extra jars\nonce you start to do anything of substance. Just specify the extras by passing the system propery `-Dtmpjars` when\nyou run `hbase mapredcp`.\n\nFor jobs that do not package their dependencies or call `TableMapReduceUtil#addDependencyJars`, the following command structure is necessary:\n\n```bash\n$ HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase mapredcp`:${HBASE_HOME}/conf hadoop jar MyApp.jar MyJobMainClass -libjars $(${HBASE_HOME}/bin/hbase mapredcp | tr ':' ',') ...\n```\n\n<Callout type=\"info\">\n  The example may not work if you are running HBase from its build directory rather than an installed location.\n  You may see an error like the following:\n\n  ```text\n  java.lang.RuntimeException: java.lang.ClassNotFoundException: org.apache.hadoop.hbase.mapreduce.RowCounter$RowCounterMapper\n  ```\n\n  If this occurs, try modifying the command as follows, so that it uses the HBase JARs from the *target/* directory within the build environment.\n\n  ```bash\n  $ HADOOP_CLASSPATH=${HBASE_BUILD_HOME}/hbase-mapreduce/target/hbase-mapreduce-VERSION-SNAPSHOT.jar:`${HBASE_BUILD_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_BUILD_HOME}/hbase-mapreduce/target/hbase-mapreduce-VERSION-SNAPSHOT.jar rowcounter usertable\n  ```\n</Callout>\n\n<Callout type=\"warn\" title=\"Notice to MapReduce users of HBase between 0.96.1 and 0.98.4\">\n  Some MapReduce jobs that use HBase fail to launch.\n  The symptom is an exception similar to the following:\n\n  ```text\n  Exception in thread \"main\" java.lang.IllegalAccessError: class\n      com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass\n      com.google.protobuf.LiteralByteString\n      at java.lang.ClassLoader.defineClass1(Native Method)\n      at java.lang.ClassLoader.defineClass(ClassLoader.java:792)\n      at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n      at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)\n      at java.net.URLClassLoader.access$100(URLClassLoader.java:71)\n      at java.net.URLClassLoader$1.run(URLClassLoader.java:361)\n      at java.net.URLClassLoader$1.run(URLClassLoader.java:355)\n      at java.security.AccessController.doPrivileged(Native Method)\n      at java.net.URLClassLoader.findClass(URLClassLoader.java:354)\n      at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n      at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n      at\n      org.apache.hadoop.hbase.protobuf.ProtobufUtil.toScan(ProtobufUtil.java:818)\n      at\n      org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.convertScanToString(TableMapReduceUtil.java:433)\n      at\n      org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:186)\n      at\n      org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:147)\n      at\n      org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:270)\n      at\n      org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:100)\n  ...\n  ```\n\n  This is caused by an optimization introduced in [HBASE-9867](https://issues.apache.org/jira/browse/HBASE-9867) that inadvertently introduced a classloader dependency.\n\n  This affects both jobs using the `-libjars` option and \"fat jar,\" those which package their runtime dependencies in a nested `lib` folder.\n\n  In order to satisfy the new classloader requirements, `hbase-protocol.jar` must be included in Hadoop's classpath.\n  See [HBase, MapReduce, and the CLASSPATH](/docs/mapreduce#hbase-mapreduce-and-the-classpath) for current recommendations for resolving classpath errors.\n  The following is included for historical purposes.\n\n  This can be resolved system-wide by including a reference to the `hbase-protocol.jar` in Hadoop's lib directory, via a symlink or by copying the jar into the new location.\n\n  This can also be achieved on a per-job launch basis by including it in the `HADOOP_CLASSPATH` environment variable at job submission time.\n  When launching jobs that package their dependencies, all three of the following job launching commands satisfy this requirement:\n\n  ```bash\n  $ HADOOP_CLASSPATH=/path/to/hbase-protocol.jar:/path/to/hbase/conf hadoop jar MyJob.jar MyJobMainClass\n  $ HADOOP_CLASSPATH=$(hbase mapredcp):/path/to/hbase/conf hadoop jar MyJob.jar MyJobMainClass\n  $ HADOOP_CLASSPATH=$(hbase classpath) hadoop jar MyJob.jar MyJobMainClass\n  ```\n\n  For jars that do not package their dependencies, the following command structure is necessary:\n\n  ```bash\n  $ HADOOP_CLASSPATH=$(hbase mapredcp):/etc/hbase/conf hadoop jar MyApp.jar MyJobMainClass -libjars $(hbase mapredcp | tr ':' ',') ...\n  ```\n\n  See also [HBASE-10304](https://issues.apache.org/jira/browse/HBASE-10304) for further discussion of this issue.\n</Callout>\n\n## MapReduce Scan Caching\n\nTableMapReduceUtil now restores the option to set scanner caching (the number of rows which are cached before returning the result to the client) on the Scan object that is passed in.\nThis functionality was lost due to a bug in HBase 0.95 ([HBASE-11558](https://issues.apache.org/jira/browse/HBASE-11558)), which is fixed for HBase 0.98.5 and 0.96.3.\nThe priority order for choosing the scanner caching is as follows:\n\n1. Caching settings which are set on the scan object.\n2. Caching settings which are specified via the configuration option `hbase.client.scanner.caching`, which can either be set manually in *hbase-site.xml* or via the helper method `TableMapReduceUtil.setScannerCaching()`.\n3. The default value `HConstants.DEFAULT_HBASE_CLIENT_SCANNER_CACHING`, which is set to `100`.\n\nOptimizing the caching settings is a balance between the time the client waits for a result and the number of sets of results the client needs to receive.\nIf the caching setting is too large, the client could end up waiting for a long time or the request could even time out.\nIf the setting is too small, the scan needs to return results in several pieces.\nIf you think of the scan as a shovel, a bigger cache setting is analogous to a bigger shovel, and a smaller cache setting is equivalent to more shoveling in order to fill the bucket.\n\nThe list of priorities mentioned above allows you to set a reasonable default, and override it for specific operations.\n\nSee the API documentation for [Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) for more details.\n\n## Bundled HBase MapReduce Jobs\n\nThe HBase JAR also serves as a Driver for some bundled MapReduce jobs.\nTo learn about the bundled MapReduce jobs, run the following command.\n\n```bash\n$ ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-mapreduce-VERSION.jar\nAn example program must be given as the first argument.\nValid program names are:\n  copytable: Export a table from local cluster to peer cluster\n  completebulkload: Complete a bulk data load.\n  export: Write table data to HDFS.\n  import: Import data written by Export.\n  importtsv: Import data in TSV format.\n  rowcounter: Count rows in HBase table\n```\n\nEach of the valid program names are bundled MapReduce jobs.\nTo run one of the jobs, model your command after the following example.\n\n```bash\n$ ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-mapreduce-VERSION.jar rowcounter myTable\n```\n\n## HBase as a MapReduce Job Data Source and Data Sink\n\nHBase can be used as a data source, [TableInputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html), and data sink, [TableOutputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html) or [MultiTableOutputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/MultiTableOutputFormat.html), for MapReduce jobs.\nWriting MapReduce jobs that read or write HBase, it is advisable to subclass [TableMapper](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html) and/or [TableReducer](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableReducer.html).\nSee the do-nothing pass-through classes [IdentityTableMapper](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/IdentityTableMapper.html) and [IdentityTableReducer](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/IdentityTableReducer.html) for basic usage.\nFor a more involved example, see [RowCounter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html) or review the `org.apache.hadoop.hbase.mapreduce.TestTableMapReduce` unit test.\n\nIf you run MapReduce jobs that use HBase as source or sink, need to specify source and sink table and column names in your configuration.\n\nWhen you read from HBase, the `TableInputFormat` requests the list of regions from HBase and makes a map, which is either a `map-per-region` or `mapreduce.job.maps` map, whichever is smaller.\nIf your job only has two maps, raise `mapreduce.job.maps` to a number greater than the number of regions.\nMaps will run on the adjacent TaskTracker/NodeManager if you are running a TaskTracer/NodeManager and RegionServer per node.\nWhen writing to HBase, it may make sense to avoid the Reduce step and write back into HBase from within your map.\nThis approach works when your job does not need the sort and collation that MapReduce does on the map-emitted data.\nOn insert, HBase 'sorts' so there is no point double-sorting (and shuffling data around your MapReduce cluster) unless you need to.\nIf you do not need the Reduce, your map might emit counts of records processed for reporting at the end of the job, or set the number of Reduces to zero and use TableOutputFormat.\nIf running the Reduce step makes sense in your case, you should typically use multiple reducers so that load is spread across the HBase cluster.\n\nA new HBase partitioner, the [HRegionPartitioner](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/HRegionPartitioner.html), can run as many reducers the number of existing regions.\nThe HRegionPartitioner is suitable when your table is large and your upload will not greatly alter the number of existing regions upon completion.\nOtherwise use the default partitioner.\n\n## Writing HFiles Directly During Bulk Import\n\nIf you are importing into a new table, you can bypass the HBase API and write your content directly to the filesystem, formatted into HBase data files (HFiles). Your import will run faster, perhaps an order of magnitude faster.\nFor more on how this mechanism works, see [Bulk Load](/docs/architecture/bulk-loading).\n\n## RowCounter Example\n\nThe included [RowCounter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html) MapReduce job uses `TableInputFormat` and does a count of all rows in the specified table.\nTo run it, use the following command:\n\n```bash\n$ ./bin/hadoop jar hbase-X.X.X.jar\n```\n\nThis will invoke the HBase MapReduce Driver class.\nSelect `rowcounter` from the choice of jobs offered.\nThis will print rowcounter usage advice to standard output.\nSpecify the tablename, column to count, and output directory.\nIf you have classpath errors, see [HBase, MapReduce, and the CLASSPATH](/docs/mapreduce#hbase-mapreduce-and-the-classpath).\n\n## Map-Task Splitting\n\n### The Default HBase MapReduce Splitter\n\nWhen [TableInputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html) is used to source an HBase table in a MapReduce job, its splitter will make a map task for each region of the table.\nThus, if there are 100 regions in the table, there will be 100 map-tasks for the job - regardless of how many column families are selected in the Scan.\n\n### Custom Splitters\n\nFor those interested in implementing custom splitters, see the method `getSplits` in [TableInputFormatBase](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormatBase.html).\nThat is where the logic for map-task assignment resides.\n\n## HBase MapReduce Examples\n\n### HBase MapReduce Read Example\n\nThe following is an example of using HBase as a MapReduce source in read-only manner.\nSpecifically, there is a Mapper instance but no Reducer, and nothing is being emitted from the Mapper.\nThe job would be defined as follows...\n\n```java\nConfiguration config = HBaseConfiguration.create();\nJob job = new Job(config, \"ExampleRead\");\njob.setJarByClass(MyReadJob.class);     // class that contains mapper\n\nScan scan = new Scan();\nscan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs\nscan.setCacheBlocks(false);  // don't set to true for MR jobs\n// set other scan attrs\n...\n\nTableMapReduceUtil.initTableMapperJob(\n  tableName,        // input HBase table name\n  scan,             // Scan instance to control CF and attribute selection\n  MyMapper.class,   // mapper\n  null,             // mapper output key\n  null,             // mapper output value\n  job);\njob.setOutputFormatClass(NullOutputFormat.class);   // because we aren't emitting anything from mapper\n\nboolean b = job.waitForCompletion(true);\nif (!b) {\n  throw new IOException(\"error with job!\");\n}\n```\n\n...and the mapper instance would extend [TableMapper](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html)...\n\n```java\npublic static class MyMapper extends TableMapper<Text, Text> {\n\n  public void map(ImmutableBytesWritable row, Result value, Context context) throws InterruptedException, IOException {\n    // process data for the row from the Result instance.\n   }\n}\n```\n\n### HBase MapReduce Read/Write Example\n\nThe following is an example of using HBase both as a source and as a sink with MapReduce.\nThis example will simply copy data from one table to another.\n\n```java\nConfiguration config = HBaseConfiguration.create();\nJob job = new Job(config,\"ExampleReadWrite\");\njob.setJarByClass(MyReadWriteJob.class);    // class that contains mapper\n\nScan scan = new Scan();\nscan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs\nscan.setCacheBlocks(false);  // don't set to true for MR jobs\n// set other scan attrs\n\nTableMapReduceUtil.initTableMapperJob(\n  sourceTable,      // input table\n  scan,             // Scan instance to control CF and attribute selection\n  MyMapper.class,   // mapper class\n  null,             // mapper output key\n  null,             // mapper output value\n  job);\nTableMapReduceUtil.initTableReducerJob(\n  targetTable,      // output table\n  null,             // reducer class\n  job);\njob.setNumReduceTasks(0);\n\nboolean b = job.waitForCompletion(true);\nif (!b) {\n  throw new IOException(\"error with job!\");\n}\n```\n\nAn explanation is required of what `TableMapReduceUtil` is doing, especially with the reducer. [TableOutputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html) is being used as the outputFormat class, and several parameters are being set on the config (e.g., `TableOutputFormat.OUTPUT_TABLE`), as well as setting the reducer output key to `ImmutableBytesWritable` and reducer value to `Writable`.\nThese could be set by the programmer on the job and conf, but `TableMapReduceUtil` tries to make things easier.\n\nThe following is the example mapper, which will create a `Put` and matching the input `Result` and emit it.\nNote: this is what the CopyTable utility does.\n\n```java\npublic static class MyMapper extends TableMapper<ImmutableBytesWritable, Put>  {\n\n  public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {\n    // this example is just copying the data from the source table...\n      context.write(row, resultToPut(row,value));\n    }\n\n    private static Put resultToPut(ImmutableBytesWritable key, Result result) throws IOException {\n      Put put = new Put(key.get());\n      for (Cell cell : result.listCells()) {\n        put.add(cell);\n      }\n      return put;\n    }\n}\n```\n\nThere isn't actually a reducer step, so `TableOutputFormat` takes care of sending the `Put` to the target table.\n\nThis is just an example, developers could choose not to use `TableOutputFormat` and connect to the target table themselves.\n\n### HBase MapReduce Read/Write Example With Multi-Table Output\n\nTODO: example for `MultiTableOutputFormat`.\n\n### HBase MapReduce Summary to HBase Example\n\nThe following example uses HBase as a MapReduce source and sink with a summarization step.\nThis example will count the number of distinct instances of a value in a table and write those summarized counts in another table.\n\n```java\nConfiguration config = HBaseConfiguration.create();\nJob job = new Job(config,\"ExampleSummary\");\njob.setJarByClass(MySummaryJob.class);     // class that contains mapper and reducer\n\nScan scan = new Scan();\nscan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs\nscan.setCacheBlocks(false);  // don't set to true for MR jobs\n// set other scan attrs\n\nTableMapReduceUtil.initTableMapperJob(\n  sourceTable,        // input table\n  scan,               // Scan instance to control CF and attribute selection\n  MyMapper.class,     // mapper class\n  Text.class,         // mapper output key\n  IntWritable.class,  // mapper output value\n  job);\nTableMapReduceUtil.initTableReducerJob(\n  targetTable,        // output table\n  MyTableReducer.class,    // reducer class\n  job);\njob.setNumReduceTasks(1);   // at least one, adjust as required\n\nboolean b = job.waitForCompletion(true);\nif (!b) {\n  throw new IOException(\"error with job!\");\n}\n```\n\nIn this example mapper a column with a String-value is chosen as the value to summarize upon.\nThis value is used as the key to emit from the mapper, and an `IntWritable` represents an instance counter.\n\n```java\npublic static class MyMapper extends TableMapper<Text, IntWritable>  {\n  public static final byte[] CF = \"cf\".getBytes();\n  public static final byte[] ATTR1 = \"attr1\".getBytes();\n\n  private final IntWritable ONE = new IntWritable(1);\n  private Text text = new Text();\n\n  public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {\n    String val = new String(value.getValue(CF, ATTR1));\n    text.set(val);     // we can only emit Writables...\n    context.write(text, ONE);\n  }\n}\n```\n\nIn the reducer, the \"ones\" are counted (just like any other MR example that does this), and then emits a `Put`.\n\n```java\npublic static class MyTableReducer extends TableReducer<Text, IntWritable, ImmutableBytesWritable>  {\n  public static final byte[] CF = \"cf\".getBytes();\n  public static final byte[] COUNT = \"count\".getBytes();\n\n  public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n    int i = 0;\n    for (IntWritable val : values) {\n      i += val.get();\n    }\n    Put put = new Put(Bytes.toBytes(key.toString()));\n    put.add(CF, COUNT, Bytes.toBytes(i));\n\n    context.write(null, put);\n  }\n}\n```\n\n### HBase MapReduce Summary to File Example\n\nThis very similar to the summary example above, with exception that this is using HBase as a MapReduce source but HDFS as the sink.\nThe differences are in the job setup and in the reducer.\nThe mapper remains the same.\n\n```java\nConfiguration config = HBaseConfiguration.create();\nJob job = new Job(config,\"ExampleSummaryToFile\");\njob.setJarByClass(MySummaryFileJob.class);     // class that contains mapper and reducer\n\nScan scan = new Scan();\nscan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs\nscan.setCacheBlocks(false);  // don't set to true for MR jobs\n// set other scan attrs\n\nTableMapReduceUtil.initTableMapperJob(\n  sourceTable,        // input table\n  scan,               // Scan instance to control CF and attribute selection\n  MyMapper.class,     // mapper class\n  Text.class,         // mapper output key\n  IntWritable.class,  // mapper output value\n  job);\njob.setReducerClass(MyReducer.class);    // reducer class\njob.setNumReduceTasks(1);    // at least one, adjust as required\nFileOutputFormat.setOutputPath(job, new Path(\"/tmp/mr/mySummaryFile\"));  // adjust directories as required\n\nboolean b = job.waitForCompletion(true);\nif (!b) {\n  throw new IOException(\"error with job!\");\n}\n```\n\nAs stated above, the previous Mapper can run unchanged with this example.\nAs for the Reducer, it is a \"generic\" Reducer instead of extending TableMapper and emitting Puts.\n\n```java\npublic static class MyReducer extends Reducer<Text, IntWritable, Text, IntWritable>  {\n\n  public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n    int i = 0;\n    for (IntWritable val : values) {\n      i += val.get();\n    }\n    context.write(key, new IntWritable(i));\n  }\n}\n```\n\n### HBase MapReduce Summary to HBase Without Reducer\n\nIt is also possible to perform summaries without a reducer - if you use HBase as the reducer.\n\nAn HBase target table would need to exist for the job summary.\nThe Table method `incrementColumnValue` would be used to atomically increment values.\nFrom a performance perspective, it might make sense to keep a Map of values with their values to be incremented for each map-task, and make one update per key at during the `cleanup` method of the mapper.\nHowever, your mileage may vary depending on the number of rows to be processed and unique keys.\n\nIn the end, the summary results are in HBase.\n\n### HBase MapReduce Summary to RDBMS\n\nSometimes it is more appropriate to generate summaries to an RDBMS.\nFor these cases, it is possible to generate summaries directly to an RDBMS via a custom reducer.\nThe `setup` method can connect to an RDBMS (the connection information can be passed via custom parameters in the context) and the cleanup method can close the connection.\n\nIt is critical to understand that number of reducers for the job affects the summarization implementation, and you'll have to design this into your reducer.\nSpecifically, whether it is designed to run as a singleton (one reducer) or multiple reducers.\nNeither is right or wrong, it depends on your use-case.\nRecognize that the more reducers that are assigned to the job, the more simultaneous connections to the RDBMS will be created - this will scale, but only to a point.\n\n```java\npublic static class MyRdbmsReducer extends Reducer<Text, IntWritable, Text, IntWritable>  {\n\n  private Connection c = null;\n\n  public void setup(Context context) {\n    // create DB connection...\n  }\n\n  public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n    // do summarization\n    // in this example the keys are Text, but this is just an example\n  }\n\n  public void cleanup(Context context) {\n    // close db connection\n  }\n\n}\n```\n\nIn the end, the summary results are written to your RDBMS table/s.\n\n## Accessing Other HBase Tables in a MapReduce Job\n\nAlthough the framework currently allows one HBase table as input to a MapReduce job, other HBase tables can be accessed as lookup tables, etc., in a MapReduce job via creating an Table instance in the setup method of the Mapper.\n\n```java\npublic class MyMapper extends TableMapper<Text, LongWritable> {\n  private Table myOtherTable;\n\n  public void setup(Context context) {\n    // In here create a Connection to the cluster and save it or use the Connection\n    // from the existing table\n    myOtherTable = connection.getTable(\"myOtherTable\");\n  }\n\n  public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {\n    // process Result...\n    // use 'myOtherTable' for lookups\n  }\n```\n\n## Speculative Execution\n\nIt is generally advisable to turn off speculative execution for MapReduce jobs that use HBase as a source.\nThis can either be done on a per-Job basis through properties, or on the entire cluster.\nEspecially for longer running jobs, speculative execution will create duplicate map-tasks which will double-write your data to HBase; this is probably not what you want.\n\nSee [Speculative Execution](/docs/configuration/important#configuration-important-recommended-configurations-speculative-execution) for more information.\n\n***\n\n# Security\n\n<Callout type=\"error\">\n  **Reporting Security Bugs**\n\n  HBase adheres to the Apache Software Foundation's policy on reported vulnerabilities, available at [http://apache.org/security/](http://apache.org/security/).\n\n  If you wish to send an encrypted report, you can use the GPG details provided for the general ASF security list. This will likely increase the response time to your report.\n</Callout>\n\n<Callout type=\"info\">\n  To protect existing HBase installations from exploitation, please **do not** use JIRA to report\n  security-related bugs. Instead, send your report to the mailing list `private@hbase.apache.org`,\n  which allows anyone to send messages, but restricts who can read them. Someone on that list will\n  contact you to follow up on your report.\n</Callout>\n\n## Web UI Security\n\n## Using Secure HTTP (HTTPS) for the Web UI\n\nA default HBase install uses insecure HTTP connections for Web UIs for the master and region servers. To enable secure HTTP (HTTPS) connections instead, set `hbase.ssl.enabled` to `true` in *hbase-site.xml*(Please prepare SSL certificate and ssl configuration file in advance). This does not change the port used by the Web UI. To change the port for the web UI for a given HBase component, configure that port's setting in hbase-site.xml. These settings are:\n\n* `hbase.master.info.port`\n* `hbase.regionserver.info.port`\n\n<Callout type=\"info\">\n  If you enable secure HTTP, clients should connect to HBase using the `https://` URL. Clients using the `http://` URL will receive an HTTP response of `200`, but will not receive any data. The following exception is logged:\n\n  ```text\n  javax.net.ssl.SSLException: Unrecognized SSL message, plaintext connection?\n  ```\n\n  This is because the same port is used for HTTP and HTTPS.\n\n  HBase uses Jetty for the Web UI. Without modifying Jetty itself, it does not seem possible to configure Jetty to redirect one port to another on the same host. See Nick Dimiduk's contribution on this [Stack Overflow](http://stackoverflow.com/questions/20611815/redirect-from-http-to-https-in-jetty) thread for more information. If you know how to fix this without opening a second port for HTTPS, patches are appreciated.\n</Callout>\n\n## Disable cache in HBase UI\n\nSet the following configuration in hbase-site to set max age to zero and disable cache for the web UI:\n\n```xml\n<property>\n  <name>hbase.http.filter.no-store.enable</name>\n  <value>true</value>\n</property>\n```\n\n## Using SPNEGO for Kerberos authentication with Web UIs\n\nKerberos-authentication to HBase Web UIs can be enabled via configuring SPNEGO with the `hbase.security.authentication.ui` property in *hbase-site.xml*. Enabling this authentication requires that HBase is also configured to use Kerberos authentication for RPCs (e.g `hbase.security.authentication` = `kerberos`).\n\n```xml\n<property>\n  <name>hbase.security.authentication.ui</name>\n  <value>kerberos</value>\n  <description>Controls what kind of authentication should be used for the HBase web UIs.</description>\n</property>\n<property>\n  <name>hbase.security.authentication</name>\n  <value>kerberos</value>\n  <description>The Kerberos keytab file to use for SPNEGO authentication by the web server.</description>\n</property>\n```\n\nA number of properties exist to configure SPNEGO authentication for the web server:\n\n```xml\n<property>\n  <name>hbase.security.authentication.spnego.kerberos.principal</name>\n  <value>HTTP/_HOST@EXAMPLE.COM</value>\n  <description>Required for SPNEGO, the Kerberos principal to use for SPNEGO authentication by the\n  web server. The _HOST keyword will be automatically substituted with the node's\n  hostname.</description>\n</property>\n<property>\n  <name>hbase.security.authentication.spnego.kerberos.keytab</name>\n  <value>/etc/security/keytabs/spnego.service.keytab</value>\n  <description>Required for SPNEGO, the Kerberos keytab file to use for SPNEGO authentication by the\n  web server.</description>\n</property>\n<property>\n  <name>hbase.security.authentication.spnego.kerberos.name.rules</name>\n  <value></value>\n  <description>Optional, Hadoop-style `auth_to_local` rules which will be parsed and used in the\n  handling of Kerberos principals</description>\n</property>\n<property>\n  <name>hbase.security.authentication.signature.secret.file</name>\n  <value></value>\n  <description>Optional, a file whose contents will be used as a secret to sign the HTTP cookies\n  as a part of the SPNEGO authentication handshake. If this is not provided, Java's `Random` library\n  will be used for the secret.</description>\n</property>\n```\n\n## Defining administrators of the Web UI with SPNEGO\n\nIn the previous section, we cover how to enable authentication for the Web UI via SPNEGO. However, some portions of the Web UI could be used to impact the availability and performance of an HBase cluster. As such, it is desirable to ensure that only those with proper authority can interact with these sensitive endpoints.\n\nHBase allows the adminstrators to be defined via a list of usernames or groups in hbase-site.xml\n\n```xml\n<property>\n  <name>hbase.security.authentication.spnego.admin.users</name>\n  <value></value>\n</property>\n<property>\n  <name>hbase.security.authentication.spnego.admin.groups</name>\n  <value></value>\n</property>\n```\n\nThe usernames are those which the Kerberos identity maps to, given the Hadoop `auth_to_local` rules in core-site.xml. The groups here are the Unix groups associated with the mapped usernames.\n\nConsider the following scenario to describe how the configuration properties operate. Consider three users which are defined in the Kerberos KDC:\n\n* `alice@COMPANY.COM`\n* `bob@COMPANY.COM`\n* `charlie@COMPANY.COM`\n\nThe default Hadoop `auth_to_local` rules map these principals to the \"shortname\":\n\n* `alice`\n* `bob`\n* `charlie`\n\nUnix groups membership define that `alice` is a member of the group `admins`. `bob` and `charlie` are not members of the `admins` group.\n\n```xml\n<property>\n  <name>hbase.security.authentication.spnego.admin.users</name>\n  <value>charlie</value>\n</property>\n<property>\n  <name>hbase.security.authentication.spnego.admin.groups</name>\n  <value>admins</value>\n</property>\n```\n\nGiven the above configuration, `alice` is allowed to access sensitive endpoints in the Web UI as she is a member of the `admins` group. `charlie` is also allowed to access sensitive endpoints because he is explicitly listed as an admin in the configuration. `bob` is not allowed to access sensitive endpoints because he is not a member of the `admins` group nor is listed as an explicit admin user via `hbase.security.authentication.spnego.admin.users`, but can still use any non-sensitive endpoints in the Web UI.\n\nIf it doesn't go without saying: non-authenticated users cannot access any part of the Web UI.\n\n## Using LDAP authentication with Web UIs\n\nLDAP authentication to HBase Web UIs can be enabled via configuring LDAP with the `hbase.security.authentication.ui` property in *hbase-site.xml*. The `hbase.http.filter.initializers` property also needs to have the `AuthenticationFilterInitializer` class.\n\n**IMPORTANT:** A LDAP server must be configured and running. When TLS is enabled for communication with LDAP server (either via ldaps scheme or ‘start TLS' extension), configure the public certificate of the LDAP server in the local truststore. The LDAP authentication mechanism uses HTTP Basic authentication scheme to verify user specified credentials against a configured LDAP (or Active Directory) server. The authentication filter must be configured with the following init parameters:\n\n```xml\n<property>\n  <name>hbase.security.authentication.ui</name>\n  <value>ldap</value>\n  <description>Controls what kind of authentication should be used for the HBase web UIs.</description>\n</property>\n<property>\n  <name>hbase.http.filter.initializers</name>\n  <value>org.apache.hadoop.hbase.http.lib.AuthenticationFilterInitializer</value>\n  <description>Comma separated class names corresponding to the Filters that will be initialized.\n  Then, the Filters will be applied to all user facing jsp and servlet web pages.</description>\n</property>\n<property>\n  <name>hadoop.http.authentication.type</name>\n  <value>ldap</value>\n  <description>Defines authentication used for the HTTP web-consoles in Hadoop ecosystem.</description>\n</property>\n```\n\nA number of properties exist to configure LDAP authentication for the web server:\n\n```xml\n<property>\n  <name>hadoop.http.authentication.ldap.binddomain</name>\n  <value>EXAMPLE.COM</value>\n  <description>The LDAP bind domain value to be used with the LDAP server. This property is optional\n   and useful only in case of Active Directory server (e.g. example.com).</description>\n</property>\n<property>\n  <name>hadoop.http.authentication.ldap.providerurl</name>\n  <value>ldap://ldap-server-host:8920</value>\n  <description>The url of the LDAP server.</description>\n</property>\n<property>\n  <name>hadoop.http.authentication.ldap.enablestarttls</name>\n  <value>false</value>\n  <description>A boolean value used to define if the LDAP server supports ‘StartTLS' extension.</description>\n</property>\n<property>\n  <name>hadoop.http.authentication.ldap.basedn</name>\n  <value>ou=users,dc=example,dc=com</value>\n  <description>The base distinguished name (DN) to be used with the LDAP server. This value is\n  appended to the provided user id for authentication purpose. This property is not useful in case\n  of Active Directory server.</description>\n</property>\n```\n\n## Defining Administrators of the Web UI with LDAP\n\nIn the previous section, we discussed enabling authentication for the Web UI via LDAP. Certain portions of the Web UI can impact the availability and performance of an HBase cluster. To safeguard these sensitive endpoints, it is essential to restrict access to authorized administrators only.\n\nHBase provides a mechanism to define administrators for the Web UI through a list of usernames in the `hbase-site.xml` configuration file.\n\nTo specify the administrators, use the following property in `hbase-site.xml`:\n\n```xml\n<property>\n  <name>hbase.security.authentication.ldap.admin.users</name>\n  <value>admin1,admin2,admin3</value>\n</property>\n```\n\nThe usernames listed in the above property should correspond to the LDAP usernames of the administrators.\n\n### Notes\n\n* This feature is supported by only versions of HBase having [HBASE-29244](https://issues.apache.org/jira/browse/HBASE-29244)\n* Ensure that the LDAP server is properly configured and running. See the previous section for details.\n* Only users explicitly listed in the `hbase.security.authentication.ldap.admin.users` property will have access to sensitive endpoints.\n* Non-administrative users can still access non-sensitive endpoints, provided they are authenticated.\n\nBy defining administrators in this way, you can ensure that only authorized personnel can interact with critical Web UI functionalities, thereby enhancing the security and stability of your HBase cluster.\n\n## Other UI security-related configuration\n\nWhile it is a clear anti-pattern for HBase developers, the developers acknowledge that the HBase configuration (including Hadoop configuration files) may contain sensitive information. As such, a user may find that they do not want to expose the HBase service-level configuration to all authenticated users. They may configure HBase to require a user must be an admin to access the service-level configuration via the HBase UI. This configuration is **false** by default (any authenticated user may access the configuration).\n\nUsers who wish to change this would set the following in their hbase-site.xml:\n\n```xml\n<property>\n  <name>hbase.security.authentication.ui.config.protected</name>\n  <value>true</value>\n</property>\n```\n\nTo disable showing stack traces in HBase UI for hiding sensitive information, set the following in hbase-site:\n\n```xml\n<property>\n  <name>hbase.ui.show-stack-traces</name>\n  <value>false</value>\n</property>\n```\n\n## Secure Client Access to Apache HBase\n\nNewer releases of Apache HBase (>= 0.92) support optional SASL authentication of clients. See also Matteo Bertozzi's article on [Understanding User Authentication and Authorization in Apache HBase](https://blog.cloudera.com/blog/2012/09/understanding-user-authentication-and-authorization-in-apache-hbase/).\n\nThis describes how to set up Apache HBase and clients for connection to secure HBase resources.\n\n## Prerequisites\n\n#### Hadoop Authentication Configuration \\[!toc]\n\nTo run HBase RPC with strong authentication, you must set `hbase.security.authentication` to `kerberos`. In this case, you must also set `hadoop.security.authentication` to `kerberos` in core-site.xml. Otherwise, you would be using strong authentication for HBase but not for the underlying HDFS, which would cancel out any benefit.\n\n#### Kerberos KDC \\[!toc]\n\nYou need to have a working Kerberos KDC.\n\n## Server-side Configuration for Secure Operation\n\nFirst, refer to [security.prerequisites](/docs/security/client-access#security-client-access-prerequisites) and ensure that your underlying HDFS configuration is secure.\n\nAdd the following to the `hbase-site.xml` file on every server machine in the cluster:\n\n```xml\n<property>\n  <name>hbase.security.authentication</name>\n  <value>kerberos</value>\n</property>\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n<name>hbase.coprocessor.region.classes</name>\n  <value>org.apache.hadoop.hbase.security.token.TokenProvider</value>\n</property>\n```\n\nA full shutdown and restart of HBase service is required when deploying these configuration changes.\n\n## Client-side Configuration for Secure Operation\n\nFirst, refer to [Prerequisites](/docs/security/client-access#security-client-access-prerequisites) and ensure that your underlying HDFS configuration is secure.\n\nAdd the following to the `hbase-site.xml` file on every client:\n\n```xml\n<property>\n  <name>hbase.security.authentication</name>\n  <value>kerberos</value>\n</property>\n```\n\nBefore 2.2.0 version, the client environment must be logged in to Kerberos from KDC or keytab via the `kinit` command before communication with the HBase cluster will be possible.\n\nSince 2.2.0, client can specify the following configurations in `hbase-site.xml`:\n\n```xml\n<property>\n  <name>hbase.client.keytab.file</name>\n  <value>/local/path/to/client/keytab</value>\n</property>\n\n<property>\n  <name>hbase.client.keytab.principal</name>\n  <value>foo@EXAMPLE.COM</value>\n</property>\n```\n\nThen application can automatically do the login and credential renewal jobs without client interference.\n\nIt's optional feature, client, who upgrades to 2.2.0, can still keep their login and credential renewal logic already did in older version, as long as keeping `hbase.client.keytab.file` and `hbase.client.keytab.principal` are unset.\n\nBe advised that if the `hbase.security.authentication` in the client- and server-side site files do not match, the client will not be able to communicate with the cluster.\n\nOnce HBase is configured for secure RPC it is possible to optionally configure encrypted communication. To do so, add the following to the `hbase-site.xml` file on every client:\n\n```xml\n<property>\n  <name>hbase.rpc.protection</name>\n  <value>privacy</value>\n</property>\n```\n\nThis configuration property can also be set on a per-connection basis. Set it in the `Configuration` supplied to `Table`:\n\n```java\nConfiguration conf = HBaseConfiguration.create();\nConnection connection = ConnectionFactory.createConnection(conf);\nconf.set(\"hbase.rpc.protection\", \"privacy\");\ntry (Connection connection = ConnectionFactory.createConnection(conf);\n     Table table = connection.getTable(TableName.valueOf(tablename))) {\n  .... do your stuff\n}\n```\n\nExpect a \\~10% performance penalty for encrypted communication.\n\n## Client-side Configuration for Secure Operation - Thrift Gateway\n\nAdd the following to the `hbase-site.xml` file for every Thrift gateway:\n\n```xml\n<property>\n  <name>hbase.thrift.keytab.file</name>\n  <value>/etc/hbase/conf/hbase.keytab</value>\n</property>\n<property>\n  <name>hbase.thrift.kerberos.principal</name>\n  <value>$USER/_HOST@HADOOP.LOCALDOMAIN</value>\n  <!-- TODO: This may need to be  HTTP/_HOST@<REALM> and _HOST may not work.\n   You may have  to put the concrete full hostname.\n   -->\n</property>\n<!-- Add these if you need to configure a different DNS interface from the default -->\n<property>\n  <name>hbase.thrift.dns.interface</name>\n  <value>default</value>\n</property>\n<property>\n  <name>hbase.thrift.dns.nameserver</name>\n  <value>default</value>\n</property>\n```\n\nSubstitute the appropriate credential and keytab for *\\$USER* and *\\$KEYTAB* respectively.\n\nIn order to use the Thrift API principal to interact with HBase, it is also necessary to add the `hbase.thrift.kerberos.principal` to the `acl` table. For example, to give the Thrift API principal, `thrift_server`, administrative access, a command such as this one will suffice:\n\n```sql\ngrant 'thrift_server', 'RWCA'\n```\n\nFor more information about ACLs, please see the [Access Control Labels (ACLs)](/docs/security/data-access#access-control-labels-acls) section\n\nThe Thrift gateway will authenticate with HBase using the supplied credential. No authentication will be performed by the Thrift gateway itself. All client access via the Thrift gateway will use the Thrift gateway's credential and have its privilege.\n\n## Configure the Thrift Gateway to Authenticate on Behalf of the Client\n\n[Client-side Configuration for Secure Operation - Thrift Gateway](/docs/security/client-access#client-side-configuration-for-secure-operation---thrift-gateway) describes how to authenticate a Thrift client to HBase using a fixed user. As an alternative, you can configure the Thrift gateway to authenticate to HBase on the client's behalf, and to access HBase using a proxy user. This was implemented in [HBASE-11349](https://issues.apache.org/jira/browse/HBASE-11349) for Thrift 1, and [HBASE-11474](https://issues.apache.org/jira/browse/HBASE-11474) for Thrift 2.\n\n<Callout type=\"info\">\n  If you use framed transport, you cannot yet take advantage of this feature, because SASL does not\n  work with Thrift framed transport at this time.\n</Callout>\n\nTo enable it, do the following.\n\n1. Be sure Thrift is running in secure mode, by following the procedure described in [Client-side Configuration for Secure Operation - Thrift Gateway](/docs/security/client-access#client-side-configuration-for-secure-operation---thrift-gateway).\n2. Be sure that HBase is configured to allow proxy users, as described in [REST Gateway Impersonation Configuration](/docs/security/client-access#rest-gateway-impersonation-configuration).\n3. In *hbase-site.xml* for each cluster node running a Thrift gateway, set the property `hbase.thrift.security.qop` to one of the following three values:\n   * `privacy` - authentication, integrity, and confidentiality checking.\n   * `integrity` - authentication and integrity checking\n   * `authentication` - authentication checking only\n4. Restart the Thrift gateway processes for the changes to take effect. If a node is running Thrift, the output of the `jps` command will list a `ThriftServer` process. To stop Thrift on a node, run the command `bin/hbase-daemon.sh stop thrift`. To start Thrift on a node, run the command `bin/hbase-daemon.sh start thrift`.\n\n## Configure the Thrift Gateway to Use the `doAs` Feature\n\n[Configure the Thrift Gateway to Authenticate on Behalf of the Client](/docs/security/client-access#configure-the-thrift-gateway-to-authenticate-on-behalf-of-the-client) describes how to configure the Thrift gateway to authenticate to HBase on the client's behalf, and to access HBase using a proxy user. The limitation of this approach is that after the client is initialized with a particular set of credentials, it cannot change these credentials during the session. The `doAs` feature provides a flexible way to impersonate multiple principals using the same client. This feature was implemented in [HBASE-12640](https://issues.apache.org/jira/browse/HBASE-12640) for Thrift 1, but is currently not available for Thrift 2.\n\n**To enable the `doAs` feature**, add the following to the *hbase-site.xml* file for every Thrift gateway:\n\n```xml\n<property>\n  <name>hbase.regionserver.thrift.http</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.thrift.support.proxyuser</name>\n  <value>true</value>\n</property>\n```\n\n**To allow proxy users** when using `doAs` impersonation, add the following to the *hbase-site.xml* file for every HBase node:\n\n```xml\n<property>\n  <name>hadoop.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hadoop.proxyuser.$USER.groups</name>\n  <value>$GROUPS</value>\n</property>\n<property>\n  <name>hadoop.proxyuser.$USER.hosts</name>\n  <value>$GROUPS</value>\n</property>\n```\n\nTake a look at the [demo client](https://github.com/apache/hbase/blob/master/hbase-examples/src/main/java/org/apache/hadoop/hbase/thrift/HttpDoAsClient.java) to get an overall idea of how to use this feature in your client.\n\n## Client-side Configuration for Secure Operation - REST Gateway\n\nAdd the following to the `hbase-site.xml` file for every REST gateway:\n\n```xml\n<property>\n  <name>hbase.rest.keytab.file</name>\n  <value>$KEYTAB</value>\n</property>\n<property>\n  <name>hbase.rest.kerberos.principal</name>\n  <value>$USER/_HOST@HADOOP.LOCALDOMAIN</value>\n</property>\n```\n\nSubstitute the appropriate credential and keytab for *\\$USER* and *\\$KEYTAB* respectively.\n\nThe REST gateway will authenticate with HBase using the supplied credential.\n\nIn order to use the REST API principal to interact with HBase, it is also necessary to add the `hbase.rest.kerberos.principal` to the `acl` table. For example, to give the REST API principal, `rest_server`, administrative access, a command such as this one will suffice:\n\n```sql\ngrant 'rest_server', 'RWCA'\n```\n\nFor more information about ACLs, please see the [Access Control Labels (ACLs)](/docs/security/data-access#access-control-labels-acls) section\n\nHBase REST gateway supports [SPNEGO HTTP authentication](https://hadoop.apache.org/docs/stable/hadoop-auth/index.html) for client access to the gateway. To enable REST gateway Kerberos authentication for client access, add the following to the `hbase-site.xml` file for every REST gateway.\n\n```xml\n<property>\n  <name>hbase.rest.support.proxyuser</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.rest.authentication.type</name>\n  <value>kerberos</value>\n</property>\n<property>\n  <name>hbase.rest.authentication.kerberos.principal</name>\n  <value>HTTP/_HOST@HADOOP.LOCALDOMAIN</value>\n</property>\n<property>\n  <name>hbase.rest.authentication.kerberos.keytab</name>\n  <value>$KEYTAB</value>\n</property>\n<!-- Add these if you need to configure a different DNS interface from the default -->\n<property>\n  <name>hbase.rest.dns.interface</name>\n  <value>default</value>\n</property>\n<property>\n  <name>hbase.rest.dns.nameserver</name>\n  <value>default</value>\n</property>\n```\n\nSubstitute the keytab for HTTP for *\\$KEYTAB*.\n\nHBase REST gateway supports different 'hbase.rest.authentication.type': simple, kerberos. You can also implement a custom authentication by implementing Hadoop AuthenticationHandler, then specify the full class name as 'hbase.rest.authentication.type' value. For more information, refer to [SPNEGO HTTP authentication](https://hadoop.apache.org/docs/stable/hadoop-auth/index.html).\n\n## REST Gateway Impersonation Configuration\n\nBy default, the REST gateway doesn't support impersonation. It accesses the HBase on behalf of clients as the user configured as in the previous section. To the HBase server, all requests are from the REST gateway user. The actual users are unknown. You can turn on the impersonation support. With impersonation, the REST gateway user is a proxy user. The HBase server knows the actual/real user of each request. So it can apply proper authorizations.\n\nTo turn on REST gateway impersonation, we need to configure HBase servers (masters and region servers) to allow proxy users; configure REST gateway to enable impersonation.\n\nTo allow proxy users, add the following to the `hbase-site.xml` file for every HBase server:\n\n```xml\n<property>\n  <name>hadoop.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hadoop.proxyuser.$USER.groups</name>\n  <value>$GROUPS</value>\n</property>\n<property>\n  <name>hadoop.proxyuser.$USER.hosts</name>\n  <value>$GROUPS</value>\n</property>\n```\n\nSubstitute the REST gateway proxy user for *\\$USER*, and the allowed group list for *\\$GROUPS*.\n\nTo enable REST gateway impersonation, add the following to the `hbase-site.xml` file for every REST gateway.\n\n```xml\n<property>\n  <name>hbase.rest.authentication.type</name>\n  <value>kerberos</value>\n</property>\n<property>\n  <name>hbase.rest.authentication.kerberos.principal</name>\n  <value>HTTP/_HOST@HADOOP.LOCALDOMAIN</value>\n</property>\n<property>\n  <name>hbase.rest.authentication.kerberos.keytab</name>\n  <value>$KEYTAB</value>\n</property>\n```\n\nSubstitute the keytab for HTTP for *\\$KEYTAB*.\n\n## Simple User Access to Apache HBase\n\nNewer releases of Apache HBase (>= 0.92) support optional SASL authentication of clients. See also Matteo Bertozzi's article on [Understanding User Authentication and Authorization in Apache HBase](https://blog.cloudera.com/blog/2012/09/understanding-user-authentication-and-authorization-in-apache-hbase/).\n\nThis describes how to set up Apache HBase and clients for simple user access to HBase resources.\n\n## Simple versus Secure Access\n\nThe following section shows how to set up simple user access. Simple user access is not a secure method of operating HBase. This method is used to prevent users from making mistakes. It can be used to mimic the Access Control using on a development system without having to set up Kerberos.\n\nThis method is not used to prevent malicious or hacking attempts. To make HBase secure against these types of attacks, you must configure HBase for secure operation. Refer to the section [Secure Client Access to Apache HBase](/docs/security/client-access) and complete all of the steps described there.\n\n## Prerequisites\n\nNone\n\n## Server-side Configuration for Simple User Access Operation\n\nAdd the following to the `hbase-site.xml` file on every server machine in the cluster:\n\n```xml\n<property>\n  <name>hbase.security.authentication</name>\n  <value>simple</value>\n</property>\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.coprocessor.master.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n<property>\n  <name>hbase.coprocessor.region.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n<property>\n  <name>hbase.coprocessor.regionserver.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n```\n\nFor 0.94, add the following to the `hbase-site.xml` file on every server machine in the cluster:\n\n```xml\n<property>\n  <name>hbase.rpc.engine</name>\n  <value>org.apache.hadoop.hbase.ipc.SecureRpcEngine</value>\n</property>\n<property>\n  <name>hbase.coprocessor.master.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n<property>\n  <name>hbase.coprocessor.region.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n```\n\nA full shutdown and restart of HBase service is required when deploying these configuration changes.\n\n## Client-side Configuration for Simple User Access Operation\n\nAdd the following to the `hbase-site.xml` file on every client:\n\n```xml\n<property>\n  <name>hbase.security.authentication</name>\n  <value>simple</value>\n</property>\n```\n\nFor 0.94, add the following to the `hbase-site.xml` file on every server machine in the cluster:\n\n```xml\n<property>\n  <name>hbase.rpc.engine</name>\n  <value>org.apache.hadoop.hbase.ipc.SecureRpcEngine</value>\n</property>\n```\n\nBe advised that if the `hbase.security.authentication` in the client- and server-side site files do not match, the client will not be able to communicate with the cluster.\n\n### Client-side Configuration for Simple User Access Operation - Thrift Gateway\n\nThe Thrift gateway user will need access. For example, to give the Thrift API user, `thrift_server`, administrative access, a command such as this one will suffice:\n\n```sql\ngrant 'thrift_server', 'RWCA'\n```\n\nFor more information about ACLs, please see the [Access Control Labels (ACLs)](/docs/security/data-access#access-control-labels-acls) section\n\nThe Thrift gateway will authenticate with HBase using the supplied credential. No authentication will be performed by the Thrift gateway itself. All client access via the Thrift gateway will use the Thrift gateway's credential and have its privilege.\n\n### Client-side Configuration for Simple User Access Operation - REST Gateway\n\nThe REST gateway will authenticate with HBase using the supplied credential. No authentication will be performed by the REST gateway itself. All client access via the REST gateway will use the REST gateway's credential and have its privilege.\n\nThe REST gateway user will need access. For example, to give the REST API user, `rest_server`, administrative access, a command such as this one will suffice:\n\n```sql\ngrant 'rest_server', 'RWCA'\n```\n\nFor more information about ACLs, please see the [Access Control Labels (ACLs)](/docs/security/data-access#access-control-labels-acls) section\n\nIt should be possible for clients to authenticate with the HBase cluster through the REST gateway in a pass-through manner via SPNEGO HTTP authentication. This is future work.\n\n## Transport Level Security (TLS) in HBase RPC communication\n\nSince version `2.6.0` HBase supports TLS encryption in server-client and Master-RegionServer communication. [Transport Layer Security (TLS)](https://en.wikipedia.org/wiki/Transport_Layer_Security) is a standard cryptographic protocol designed to provide communications security over a computer network. HBase TLS implementation works exactly how secure websites are accessed via **https** prefix in a web browser: once established all communication on the channel will be securely hidden from malicious access.\n\nThe encryption works at the transport level which means it's independent of the configured authentication method. Secure client access mentioned in the previous section requires Kerberos to be configured and used in HBase authentication, while TLS can be configured with any other SASL mechanism or even with simple client access methods, effectively preventing attackers from eavesdropping the communication. No Kerberos KDC or other complicated infrastructure required.\n\nHBase TLS is based on the Netty library therefore it only works with Netty client and server RPC implementations. Netty's powerful SSL implementation is a great foundation for highly secure and performant communication providing the latest and greatest cryptographic solution at all times.\n\nSince Region Servers effectively work as clients from Master's perspective, TLS supports encrypted communication between cluster members too.\n\n<Callout type=\"info\">\n  From version 2.6.0 HBase supports the [Hadoop CredentialProvider API](https://hadoop.apache.org/docs/r3.3.4/hadoop-project-dist/hadoop-common/CredentialProviderAPI.html) to avoid storing sensitive information in HBase configuration files. The recommended way of storing keystore / truststore passwords is to use one of the supported credential providers e.g. the local jceks file provider. You can find more information about how to setup credential providers in the Hadoop documentation.\n\n  The CLI interface for accessing the Hadoop Credential Shell is also available in HBase CLI. Type `hbase credential` to get help.\n</Callout>\n\n## Server side configuration\n\nWe need to set up Java key store for the server. Key store is the list of private keys that a server can use to configure TLS encryption. See [TLS wikipedia page](https://en.wikipedia.org/wiki/Transport_Layer_Security) for further details of the protocol. Add the following configuration to `hbase-site.xml` on Master, Region Servers and HBase clients:\n\n```xml\n<property>\n  <name>hbase.server.netty.tls.enabled</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.rpc.tls.keystore.location</name>\n  <value>/path/to/keystore.jks</value>\n</property>\n```\n\nUse `hbase.rpc.tls.keystore.password` alias to retrieve key store password from Hadoop credential provider.\n\n<Callout type=\"info\">\n  The supported storefile formats are based on the registered security providers and the loader can\n  be autodetected from the file extension. If needed, the file format can be explicitly specified\n  with the `hbase.rpc.tls.keystore.type` property.\n</Callout>\n\n## Client side configuration\n\nWe need to configure trust store for the client. Trust store contains the list of certificates that the client should trust when doing the handshake with the server. Add the following to `hbase-site.xml`.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.enabled</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.rpc.tls.truststore.location</name>\n  <value>/path/to/truststore.jks</value>\n</property>\n```\n\nUse `hbase.rpc.tls.truststore.password` alias to retrieve trust store password from Hadoop credential provider.\n\n<Callout type=\"info\">\n  The supported storefile formats are based on the registered security providers and the loader can\n  be autodetected from the file extension. If needed, the file format can be explicitly specified\n  with the `hbase.rpc.tls.truststore.type` property.\n</Callout>\n\nHowever, specifying a trust store is not always required. Standard JDK implementations are shipped with a standard list of trusted certificates (the certificates of Certificate Authorities) and if your private key is provided by one of them, you don't need to configure your clients to trust it. Similarly to an internet browser, you don't need to set up the certificates of every single website you're planning to visit. Later in this documentation we'll walk through the steps of creating self-signed certificates which requires a trust store setup.\n\nYou can check the list of public certificate authorities shipped with your JDK implementation:\n\n```bash\nkeytool -keystore $JAVA_HOME/jre/lib/security/cacerts -list\n```\n\nPassword is empty by default.\n\n## Creating self-signed certificates\n\nWhile obtaining globally trusted certificates from Certificate Authorities is convenient, it's perfectly valid to generate your own private/public keypairs and set them up specifically for the HBase cluster. Especially if you don't want to enable public access to the cluster, paying money for a certificate doesn't make sense.\n\nFollow the following steps to generate self-signed certificates.\n\n1. Create SSL key store JKS to store local credentials\n\n   Please note that the alias (-alias) and the distinguished name (-dname) must match the hostname of the machine that is associated with, otherwise hostname verification won't work.\n\n   ```bash\n   keytool -genkeypair -alias $(hostname -f) -keyalg RSA -keysize 2048 -dname \"cn=$(hostname -f)\" -keypass password -keystore keystore.jks -storepass password\n   ```\n\n   At the end of this operation you'll have as many key store files as many servers you have in your cluster. Each cluster member will have its own key store.\n\n2. Extract the signed public key (certificate) from each key store\n\n   ```bash\n   keytool -exportcert -alias $(hostname -f) -keystore keystore.jks -file $(hostname -f).cer -rfc\n   ```\n\n3. Create SSL trust store JKS containing certificates for the clients\n\n   The same truststore (storing all accepted certs) should be shared on participants of the cluster. You need to use different aliases to store multiple certificates in the same truststore. Name of the aliases doesn't matter.\n\n   ```bash\n   keytool -importcert -alias [host1..3] -file [host1..3].cer -keystore truststore.jks -storepass password\n   ```\n\n## Upgrading existing non-TLS cluster with no downtime\n\nHere are the steps needed to upgrade an already running HBase cluster to TLS without downtime by taking advantage of port unification functionality. There's a property on server side called `hbase.server.netty.tls.supportplaintext` which makes possible to accept TLS and plaintext connections on the same socket port.\n\n<Steps>\n  <Step>\n    Create the necessary key stores and trust stores for all server participants as described in the previous section.\n  </Step>\n\n  <Step>\n    Enable secure communication on the Master node in *server-only* mode with plaintext support\n\n    ```xml\n    <property>\n      <name>hbase.client.netty.tls.enabled</name>\n      <value>false</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.supportplaintext</name>\n      <value>true</value>\n    </property>\n    ...keystore / truststore setup ...\n    ```\n\n    Restart the Master. Master now accepts both TLS/non-TLS connections and works with non-TLS in client mode.\n  </Step>\n\n  <Step>\n    Enable secure communication on the Region Servers in both *server and client* mode with plaintext support\n\n    Client mode here will ensure that RegionServer's communication to Master is encrypted.\n\n    <Callout type=\"warn\">\n      **Replication**\n\n      If you have read replicas enabled in your cluster or replication between two different clusters, you have to break this into two steps. Secure communication has to be enabled on the *server side* first with plaintext support and once all Region Servers are upgraded you can repeat the upgrade by enabling *client side* as well.\n\n      You have to prepare all Region Servers for secure communication before upgrading the client side.\n    </Callout>\n\n    ```xml\n    <property>\n      <name>hbase.client.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.supportplaintext</name>\n      <value>true</value>\n    </property>\n    ...keystore / truststore setup ...\n    ```\n\n    Restart Region Servers in rolling restart fashion. They send requests with TLS and accept both TLS and non-TLS communication.\n  </Step>\n\n  <Step>\n    Enable secure communication on the clients\n\n    ```xml\n    <property>\n      <name>hbase.client.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    ...truststore setup ...\n    ```\n  </Step>\n\n  <Step>\n    Enable client-mode TLS on master and disable plaintext mode\n\n    ```xml\n    <property>\n      <name>hbase.client.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.enabled</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.server.netty.tls.supportplaintext</name>\n      <value>false</value>\n    </property>\n    ```\n\n    Restart Master.\n  </Step>\n\n  <Step>\n    Disable plaintext communication on the Region Servers\n\n    Disable plaintext communication on the Region Servers by removing `supportplaintext` property. Restart RSs in rolling restart fashion.\n\n    <Callout type=\"warn\">\n      Once `hbase.client.netty.tls.enabled` is enabled on the server side, the cluster will only be able\n      to communicate with other clusters which have TLS enabled. For example, this would impact\n      inter-cluster replication.\n    </Callout>\n  </Step>\n</Steps>\n\n## Enable automatic certificate reloading\n\nCertificates usually expire after some time to improve security. In this case we need to replace them by modifying Keystore / Truststore files and HBase processes have to be restarted. In order to avoid that you can enable automatic file change detection and certificate reloading with the following option. Default: false.\n\n```xml\n<property>\n  <name>hbase.rpc.tls.certReload</name>\n  <value>true</value>\n</property>\n```\n\n## Additional configuration\n\n### Enabled protocols\n\nComma-separated list of TLS protocol versions to enable. Default is empty.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.enabledProtocols</name>\n  <value>TLSv1.2,TLSv1.3</value>\n</property>\n```\n\n### Default protocol\n\nSet the default TLS protocol version to use. Default is TLSv1.2. Use this protocol if enabled protocols is not defined.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.protocol</name>\n  <value>TLSv1.2</value>\n</property>\n```\n\n### Enabled cipher suites\n\nList of enabled cipher suites in TLS protocol. Useful when you want to disable certain cipher suites due to recent security concerns. Default value is a mix of CBC and GCM ciphers. Due to performance reasons we prefer CBC ciphers for Java 8 and GCM ciphers for Java 9+.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.ciphersuites</name>\n  <value>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</value>\n</property>\n```\n\n### Certificate Revocation Checking\n\nThere's a built-in mechanism in JDK's TrustManager which automatically checks certificates for revocation. See [Managing Server Certificates](https://docs.oracle.com/cd/E19263-01/817-5215/ssl.html#wp19807). Disabled by default.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.clr</name>\n  <value>false</value>\n</property>\n```\n\n### Online Certificate Status Protocol\n\nEnables [OCSP](https://en.wikipedia.org/wiki/OCSP_stapling) stapling. Please note that not all `SSLProvider` implementations support OCSP stapling and an exception will be thrown upon. Disabled by default.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.ocsp</name>\n  <value>false</value>\n</property>\n```\n\n### Client handshake timeout\n\nSet the TLS client handshake timeout is milliseconds. Default is 5 seconds.\n\n```xml\n<property>\n  <name>hbase.client.netty.tls.handshaketimeout</name>\n  <value>5000</value>\n</property>\n```\n\n## Securing Access to HDFS and ZooKeeper\n\n## Securing ZooKeeper Data\n\nZooKeeper has a pluggable authentication mechanism to enable access from clients using different methods. ZooKeeper even allows authenticated and un-authenticated clients at the same time. The access to znodes can be restricted by providing Access Control Lists (ACLs) per znode. An ACL contains two components, the authentication method and the principal. ACLs are NOT enforced hierarchically. See [ZooKeeper Programmers Guide](https://zookeeper.apache.org/doc/r3.3.6/zookeeperProgrammers.html#sc_ZooKeeperPluggableAuthentication) for details.\n\nHBase daemons authenticate to ZooKeeper via SASL and kerberos (See [ZooKeeper](/docs/zookeeper)). HBase sets up the znode ACLs so that only the HBase user and the configured hbase superuser (`hbase.superuser`) can access and modify the data. In cases where ZooKeeper is used for service discovery or sharing state with the client, the znodes created by HBase will also allow anyone (regardless of authentication) to read these znodes (clusterId, master address, meta location, etc), but only the HBase user can modify them.\n\n## Securing File System (HDFS) Data\n\nAll of the data under management is kept under the root directory in the file system (`hbase.rootdir`). Access to the data and WAL files in the filesystem should be restricted so that users cannot bypass the HBase layer, and peek at the underlying data files from the file system. HBase assumes the filesystem used (HDFS or other) enforces permissions hierarchically. If sufficient protection from the file system (both authorization and authentication) is not provided, HBase level authorization control (ACLs, visibility labels, etc) is meaningless since the user can always access the data from the file system.\n\nHBase enforces the posix-like permissions 700 (`rwx------`) to its root directory. It means that only the HBase user can read or write the files in FS. The default setting can be changed by configuring `hbase.rootdir.perms` in hbase-site.xml. A restart of the active master is needed so that it changes the used permissions. For versions before 1.2.0, you can check whether HBASE-13780 is committed, and if not, you can manually set the permissions for the root directory if needed. Using HDFS, the command would be:\n\n```bash\nsudo -u hdfs hadoop fs -chmod 700 /hbase\n```\n\nYou should change `/hbase` if you are using a different `hbase.rootdir`.\n\n## Securing Access To Your Data\n\nAfter you have configured secure authentication between HBase client and server processes and gateways, you need to consider the security of your data itself. HBase provides several strategies for securing your data:\n\n* Role-based Access Control (RBAC) controls which users or groups can read and write to a given HBase resource or execute a coprocessor endpoint, using the familiar paradigm of roles.\n* Visibility Labels which allow you to label cells and control access to labelled cells, to further restrict who can read or write to certain subsets of your data. Visibility labels are stored as tags. See [hbase.tags](/docs/security/data-access#tags) for more information.\n* Transparent encryption of data at rest on the underlying filesystem, both in HFiles and in the WAL. This protects your data at rest from an attacker who has access to the underlying filesystem, without the need to change the implementation of the client. It can also protect against data leakage from improperly disposed disks, which can be important for legal and regulatory compliance.\n\nServer-side configuration, administration, and implementation details of each of these features are discussed below, along with any performance trade-offs. An example security configuration is given at the end, to show these features all used together, as they might be in a real-world scenario.\n\n<Callout type=\"error\">\n  All aspects of security in HBase are in active development and evolving rapidly. Any strategy you\n  employ for security of your data should be thoroughly tested. In addition, some of these features\n  are still in the experimental stage of development. To take advantage of many of these features,\n  you must be running HBase 0.98+ and using the HFile v3 file format.\n</Callout>\n\n<Callout type=\"warn\">\n  Several procedures in this section require you to copy files between cluster nodes. When copying\n  keys, configuration files, or other files containing sensitive strings, use a secure method, such\n  as `ssh`, to avoid leaking sensitive data.\n</Callout>\n\n#### Procedure: Basic Server-Side Configuration\n\n<Steps>\n  <Step>\n    Enable HFile v3, by setting `hfile.format.version` to 3 in *hbase-site.xml*. This is the default for HBase 1.0 and newer.\n\n    ```xml\n    <property>\n      <name>hfile.format.version</name>\n      <value>3</value>\n    </property>\n    ```\n  </Step>\n\n  <Step>\n    Enable SASL and Kerberos authentication for RPC and ZooKeeper, as described in [security.prerequisites](/docs/security/client-access#security-client-access-prerequisites) and [ZooKeeper](/docs/zookeeper).\n  </Step>\n</Steps>\n\n## Tags\n\n*Tags* are a feature of HFile v3. A tag is a piece of metadata which is part of a cell, separate from the key, value, and version. Tags are an implementation detail which provides a foundation for other security-related features such as cell-level ACLs and visibility labels. Tags are stored in the HFiles themselves. It is possible that in the future, tags will be used to implement other HBase features. You don't need to know a lot about tags in order to use the security features they enable.\n\n### Implementation Details\n\nEvery cell can have zero or more tags. Every tag has a type and the actual tag byte array.\n\nJust as row keys, column families, qualifiers and values can be encoded (see [data.block.encoding.types](/docs/compression#data-block-encoding-types)), tags can also be encoded as well. You can enable or disable tag encoding at the level of the column family, and it is enabled by default. Use the `HColumnDescriptor#setCompressionTags(boolean compressTags)` method to manage encoding settings on a column family. You also need to enable the DataBlockEncoder for the column family, for encoding of tags to take effect.\n\nYou can enable compression of each tag in the WAL, if WAL compression is also enabled, by setting the value of `hbase.regionserver.wal.tags.enablecompression` to `true` in *hbase-site.xml*. Tag compression uses dictionary encoding.\n\nCoprocessors that run server-side on RegionServers can perform get and set operations on cell Tags. Tags are stripped out at the RPC layer before the read response is sent back, so clients do not see these tags. Tag compression is not supported when using WAL encryption.\n\n## Access Control Labels (ACLs)\n\n### How It Works\n\nACLs in HBase are based upon a user's membership in or exclusion from groups, and a given group's permissions to access a given resource. ACLs are implemented as a coprocessor called AccessController.\n\nHBase does not maintain a private group mapping, but relies on a ***Hadoop group mapper***, which maps between entities in a directory such as LDAP or Active Directory, and HBase users. Any supported Hadoop group mapper will work. Users are then granted specific permissions (Read, Write, Execute, Create, Admin) against resources (global, namespaces, tables, cells, or endpoints).\n\n<Callout type=\"info\">\n  With Kerberos and Access Control enabled, client access to HBase is authenticated and user data is\n  private unless access has been explicitly granted.\n</Callout>\n\nHBase has a simpler security model than relational databases, especially in terms of client operations. No distinction is made between an insert (new record) and update (of existing record), for example, as both collapse down into a Put.\n\n#### Understanding Access Levels\n\nHBase access levels are granted independently of each other and allow for different types of operations at a given scope.\n\n* *Read (R)* - can read data at the given scope\n* *Write (W)* - can write data at the given scope\n* *Execute (X)* - can execute coprocessor endpoints at the given scope\n* *Create (C)* - can create tables or drop tables (even those they did not create) at the given scope\n* *Admin (A)* - can perform cluster operations such as balancing the cluster or assigning regions at the given scope\n\nThe possible scopes are:\n\n* *Superuser* - superusers can perform any operation available in HBase, to any resource. The user who runs HBase on your cluster is a superuser, as are any principals assigned to the configuration property `hbase.superuser` in *hbase-site.xml* on the HMaster.\n* *Global* - permissions granted at *global* scope allow the admin to operate on all tables of the cluster.\n* *Namespace* - permissions granted at *namespace* scope apply to all tables within a given namespace.\n* *Table* - permissions granted at *table* scope apply to data or metadata within a given table.\n* *ColumnFamily* - permissions granted at *ColumnFamily* scope apply to cells within that ColumnFamily.\n* *Cell* - permissions granted at *cell* scope apply to that exact cell coordinate (key, value, timestamp). This allows for policy evolution along with data.\n  To change an ACL on a specific cell, write an updated cell with new ACL to the precise coordinates of the original.\\\n  If you have a multi-versioned schema and want to update ACLs on all visible versions, you need to write new cells for all visible versions. The application has complete control over policy evolution.\\\n  The exception to the above rule is `append` and `increment` processing. Appends and increments can carry an ACL in the operation. If one is included in the operation, then it will be applied to the result of the `append` or `increment`. Otherwise, the ACL of the existing cell you are appending to or incrementing is preserved.\n\nThe combination of access levels and scopes creates a matrix of possible access levels that can be granted to a user. In a production environment, it is useful to think of access levels in terms of what is needed to do a specific job. The following list describes appropriate access levels for some common types of HBase users. It is important not to grant more access than is required for a given user to perform their required tasks.\n\n* *Superusers* - In a production system, only the HBase user should have superuser access. In a development environment, an administrator may need superuser access in order to quickly control and manage the cluster. However, this type of administrator should usually be a Global Admin rather than a superuser.\n* *Global Admins* - A global admin can perform tasks and access every table in HBase. In a typical production environment, an admin should not have Read or Write permissions to data within tables.\n* A global admin with Admin permissions can perform cluster-wide operations on the cluster, such as balancing, assigning or unassigning regions, or calling an explicit major compaction. This is an operations role.\n* A global admin with Create permissions can create or drop any table within HBase. This is more of a DBA-type role.\n  In a production environment, it is likely that different users will have only one of Admin and Create permissions.\n  <Callout type=\"warn\">\n    In the current implementation, a Global Admin with `Admin` permission can grant himself `Read`\n    and `Write` permissions on a table and gain access to that table's data. For this reason, only\n    grant `Global Admin` permissions to trusted user who actually need them. Also be aware that a\n    `Global Admin` with `Create` permission can perform a `Put` operation on the ACL table,\n    simulating a `grant` or `revoke` and circumventing the authorization check for `Global Admin`\n    permissions. Due to these issues, be cautious with granting `Global Admin` privileges.\n  </Callout>\n* *Namespace Admins* - a namespace admin with `Create` permissions can create or drop tables within that namespace, and take and restore snapshots. A namespace admin with `Admin` permissions can perform operations such as splits or major compactions on tables within that namespace.\n* *Table Admins* - A table admin can perform administrative operations only on that table. A table admin with `Create` permissions can create snapshots from that table or restore that table from a snapshot. A table admin with `Admin` permissions can perform operations such as splits or major compactions on that table.\n* *Users* - Users can read or write data, or both. Users can also execute coprocessor endpoints, if given `Executable` permissions.\n\n#### Real-World Example of Access Levels \\[!toc]\n\n| Job Title            | Scope  | Permissions    | Description                                                     |\n| -------------------- | ------ | -------------- | --------------------------------------------------------------- |\n| Senior Administrator | Global | Access, Create | Manages the cluster and gives access to Junior Administrators.  |\n| Junior Administrator | Global | Create         | Creates tables and gives access to Table Administrators.        |\n| Table Administrator  | Table  | Access         | Maintains a table from an operations point of view.             |\n| Data Analyst         | Table  | Read           | Creates reports from HBase data.                                |\n| Web Application      | Table  | Read, Write    | Puts data into HBase and uses HBase data to perform operations. |\n\n#### ACL Matrix \\[!toc]\n\nFor more details on how ACLs map to specific HBase operations and tasks, see [appendix acl matrix](/docs/acl-matrix).\n\n#### Implementation Details\n\nCell-level ACLs are implemented using tags (see [Tags](/docs/security/data-access#tags)). In order to use cell-level ACLs, you must be using HFile v3 and HBase 0.98 or newer.\n\n1. Files created by HBase are owned by the operating system user running the HBase process. To interact with HBase files, you should use the API or bulk load facility.\n2. HBase does not model \"roles\" internally in HBase. Instead, group names can be granted permissions. This allows external modeling of roles via group membership. Groups are created and manipulated externally to HBase, via the Hadoop group mapping service.\n\n#### Server-Side Configuration\n\n<Steps>\n  <Step>\n    As a prerequisite, perform the steps in [Procedure: Basic Server-Side Configuration](/docs/security/data-access#procedure-basic-server-side-configuration).\n  </Step>\n\n  <Step>\n    Install and configure the AccessController coprocessor, by setting the following properties in *hbase-site.xml*. These properties take a list of classes.\n\n    <Callout type=\"info\">\n      If you use the AccessController along with the VisibilityController, the AccessController must\n      come first in the list, because with both components active, the VisibilityController will\n      delegate access control on its system tables to the AccessController. For an example of using both\n      together, see [Security Configuration Example](/docs/security/example).\n    </Callout>\n\n    ```xml\n    <property>\n      <name>hbase.security.authorization</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.region.classes</name>\n      <value>\n        org.apache.hadoop.hbase.security.access.AccessController,\n        org.apache.hadoop.hbase.security.token.TokenProvider\n      </value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.master.classes</name>\n      <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.regionserver.classes</name>\n      <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n    </property>\n    <property>\n      <name>hbase.security.exec.permission.checks</name>\n      <value>true</value>\n    </property>\n    ```\n\n    Optionally, you can enable transport security, by setting `hbase.rpc.protection` to\n    `privacy`. This requires HBase 0.98.4 or newer.\n  </Step>\n\n  <Step>\n    Set up the Hadoop group mapper in the Hadoop namenode's *core-site.xml*. This is a Hadoop file, not an HBase file. Customize it to your site's needs. Following is an example.\n\n    ```xml\n    <property>\n      <name>hadoop.security.group.mapping</name>\n      <value>org.apache.hadoop.security.LdapGroupsMapping</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.url</name>\n      <value>ldap://server</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.bind.user</name>\n      <value>Administrator@example-ad.local</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.bind.password</name>\n      <value>****</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.base</name>\n      <value>dc=example-ad,dc=local</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.filter.user</name>\n      <value>(&amp;(objectClass=user)(sAMAccountName={0}))</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.filter.group</name>\n      <value>(objectClass=group)</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.attr.member</name>\n      <value>member</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.attr.group.name</name>\n      <value>cn</value>\n    </property>\n    ```\n  </Step>\n\n  <Step>\n    Optionally, enable the early-out evaluation strategy. Prior to HBase 0.98.0, if a user was not granted access to a column family, or at least a column qualifier, an AccessDeniedException would be thrown. HBase 0.98.0 removed this exception in order to allow cell-level exceptional grants. To restore the old behavior in HBase 0.98.0-0.98.6, set `hbase.security.access.early_out` to `true` in *hbase-site.xml*. In HBase 0.98.6, the default has been returned to `true`.\n  </Step>\n\n  <Step>\n    Distribute your configuration and restart your cluster for changes to take effect.\n  </Step>\n\n  <Step>\n    To test your configuration, log into HBase Shell as a given user and use the `whoami` command to report the groups your user is part of. In this example, the user is reported as being a member of the `services` group.\n\n    ```ruby\n    hbase> whoami\n    service (auth:KERBEROS)\n        groups: services\n    ```\n  </Step>\n</Steps>\n\n#### Administration\n\nAdministration tasks can be performed from HBase Shell or via an API.\n\n<Callout type=\"error\">\n  Many of the API examples below are taken from source files *hbase-server/src/test/java/org/apache/hadoop/hbase/security/access/TestAccessController.java* and *hbase-server/src/test/java/org/apache/hadoop/hbase/security/access/SecureTestUtil.java*.\n\n  Neither the examples, nor the source files they are taken from, are part of the public HBase API, and are provided for illustration only. Refer to the official API for usage instructions.\n</Callout>\n\n<Steps>\n  <Step>\n    As a prerequisite, perform the steps in [Procedure: Basic Server-Side Configuration.](/docs/security/data-access#procedure-basic-server-side-configuration).\n  </Step>\n\n  <Step>\n    Install and configure the AccessController coprocessor, by setting the following properties in *hbase-site.xml*. These properties take a list of classes.\n\n    <Callout type=\"info\">\n      If you use the AccessController along with the VisibilityController, the AccessController must\n      come first in the list, because with both components active, the VisibilityController will\n      delegate access control on its system tables to the AccessController. For an example of using both\n      together, see [Security Configuration Example](/docs/security/example).\n    </Callout>\n\n    ```xml\n    <property>\n      <name>hbase.security.authorization</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.region.classes</name>\n      <value>\n        org.apache.hadoop.hbase.security.access.AccessController,\n        org.apache.hadoop.hbase.security.token.TokenProvider\n      </value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.master.classes</name>\n      <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.regionserver.classes</name>\n      <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n    </property>\n    <property>\n      <name>hbase.security.exec.permission.checks</name>\n      <value>true</value>\n    </property>\n    ```\n\n    Optionally, you can enable transport security, by setting `hbase.rpc.protection` to\n    `privacy`. This requires HBase 0.98.4 or newer.\n  </Step>\n\n  <Step>\n    Set up the Hadoop group mapper in the Hadoop namenode's *core-site.xml*. This is a Hadoop file, not an HBase file. Customize it to your site's needs. Following is an example.\n\n    ```xml\n    <property>\n      <name>hadoop.security.group.mapping</name>\n      <value>org.apache.hadoop.security.LdapGroupsMapping</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.url</name>\n      <value>ldap://server</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.bind.user</name>\n      <value>Administrator@example-ad.local</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.bind.password</name>\n      <value>****</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.base</name>\n      <value>dc=example-ad,dc=local</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.filter.user</name>\n      <value>(&amp;(objectClass=user)(sAMAccountName={0}))</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.filter.group</name>\n      <value>(objectClass=group)</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.attr.member</name>\n      <value>member</value>\n    </property>\n\n    <property>\n      <name>hadoop.security.group.mapping.ldap.search.attr.group.name</name>\n      <value>cn</value>\n    </property>\n    ```\n  </Step>\n\n  <Step>\n    Optionally, enable the early-out evaluation strategy. Prior to HBase 0.98.0, if a user was not granted access to a column family, or at least a column qualifier, an AccessDeniedException would be thrown. HBase 0.98.0 removed this exception in order to allow cell-level exceptional grants. To restore the old behavior in HBase 0.98.0-0.98.6, set `hbase.security.access.early_out` to `true` in *hbase-site.xml*. In HBase 0.98.6, the default has been returned to `true`.\n  </Step>\n\n  <Step>\n    Distribute your configuration and restart your cluster for changes to take effect.\n  </Step>\n\n  <Step>\n    To test your configuration, log into HBase Shell as a given user and use the `whoami` command to report the groups your user is part of. In this example, the user is reported as being a member of the `services` group.\n\n    ```ruby\n    hbase> whoami\n    service (auth:KERBEROS)\n        groups: services\n    ```\n  </Step>\n</Steps>\n\n#### API example:\n\n```java\npublic static void verifyAllowed(User user, AccessTestAction action, int count) throws Exception {\n  try {\n    Object obj = user.runAs(action);\n    if (obj != null && obj instanceof List<?>) {\n      List<?> results = (List<?>) obj;\n      if (results != null && results.isEmpty()) {\n        fail(\"Empty non null results from action for user '\" + user.getShortName() + \"'\");\n      }\n      assertEquals(count, results.size());\n    }\n  } catch (AccessDeniedException ade) {\n    fail(\"Expected action to pass for user '\" + user.getShortName() + \"' but was denied\");\n  }\n}\n```\n\n## Visibility Labels\n\nVisibility labels control can be used to only permit users or principals associated with a given label to read or access cells with that label. For instance, you might label a cell `top-secret`, and only grant access to that label to the `managers` group. Visibility labels are implemented using Tags, which are a feature of HFile v3, and allow you to store metadata on a per-cell basis. A label is a string, and labels can be combined into expressions by using logical operators (&, |, or !), and using parentheses for grouping. HBase does not do any kind of validation of expressions beyond basic well-formedness. Visibility labels have no meaning on their own, and may be used to denote sensitivity level, privilege level, or any other arbitrary semantic meaning.\n\nIf a user's labels do not match a cell's label or expression, the user is denied access to the cell.\n\nIn HBase 0.98.6 and newer, UTF-8 encoding is supported for visibility labels and expressions. When creating labels using the `addLabels(conf, labels)` method provided by the `org.apache.hadoop.hbase.security.visibility.VisibilityClient` class and passing labels in Authorizations via Scan or Get, labels can contain UTF-8 characters, as well as the logical operators normally used in visibility labels, with normal Java notations, without needing any escaping method. However, when you pass a CellVisibility expression via a Mutation, you must enclose the expression with the `CellVisibility.quote()` method if you use UTF-8 characters or logical operators. See `TestExpressionParser` and the source file *hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestScan.java*.\n\nA user adds visibility expressions to a cell during a Put operation. In the default configuration, the user does not need to have access to a label in order to label cells with it. This behavior is controlled by the configuration option `hbase.security.visibility.mutations.checkauths`. If you set this option to `true`, the labels the user is modifying as part of the mutation must be associated with the user, or the mutation will fail. Whether a user is authorized to read a labelled cell is determined during a Get or Scan, and results which the user is not allowed to read are filtered out. This incurs the same I/O penalty as if the results were returned, but reduces load on the network.\n\nVisibility labels can also be specified during Delete operations. For details about visibility labels and Deletes, see [HBASE-10885](https://issues.apache.org/jira/browse/HBASE-10885).\n\nThe user's effective label set is built in the RPC context when a request is first received by the RegionServer. The way that users are associated with labels is pluggable. The default plugin passes through labels specified in Authorizations added to the Get or Scan and checks those against the calling user's authenticated labels list. When the client passes labels for which the user is not authenticated, the default plugin drops them. You can pass a subset of user authenticated labels via the `Get#setAuthorizations(Authorizations(String,...))` and `Scan#setAuthorizations(Authorizations(String,...));` methods.\n\nGroups can be granted visibility labels the same way as users. Groups are prefixed with an @ symbol. When checking visibility labels of a user, the server will include the visibility labels of the groups of which the user is a member, together with the user's own labels. When the visibility labels are retrieved using API `VisibilityClient#getAuths` or Shell command `get_auths` for a user, we will return labels added specifically for that user alone, not the group level labels.\n\nVisibility label access checking is performed by the VisibilityController coprocessor. You can use interface `VisibilityLabelService` to provide a custom implementation and/or control the way that visibility labels are stored with cells. See the source file *hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsWithCustomVisLabService.java* for one example.\n\nVisibility labels can be used in conjunction with ACLs.\n\n<Callout type=\"info\">\n  The labels have to be explicitly defined before they can be used in visibility labels. See below\n  for an example of how this can be done.\n</Callout>\n\n<Callout type=\"info\">\n  There is currently no way to determine which labels have been applied to a cell. See\n  [HBASE-12470](https://issues.apache.org/jira/browse/HBASE-12470) for details.\n</Callout>\n\n<Callout type=\"info\">\n  Visibility labels are not currently applied for superusers.\n</Callout>\n\n### Examples of Visibility Expressions\n\n| Expression                                | Interpretation                                                                                                             |\n| ----------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| `fulltime`                                | Allow access to users associated with the fulltime label.                                                                  |\n| `!public`                                 | Allow access to users not associated with the public label.                                                                |\n| `( secret \\| topsecret ) & !probationary` | Allow access to users associated with either the secret or topsecret label and not associated with the probationary label. |\n\n### Server-Side Configuration\n\n<Steps>\n  <Step>\n    As a prerequisite, perform the steps in [Procedure: Basic Server-Side Configuration.](/docs/security/data-access#procedure-basic-server-side-configuration).\n  </Step>\n\n  <Step>\n    Install and configure the VisibilityController coprocessor by setting the following properties in *hbase-site.xml*. These properties take a list of class names.\n\n    ```xml\n    <property>\n      <name>hbase.security.authorization</name>\n      <value>true</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.region.classes</name>\n      <value>org.apache.hadoop.hbase.security.visibility.VisibilityController</value>\n    </property>\n    <property>\n      <name>hbase.coprocessor.master.classes</name>\n      <value>org.apache.hadoop.hbase.security.visibility.VisibilityController</value>\n    </property>\n    ```\n\n    <Callout type=\"info\">\n      If you use the AccessController and VisibilityController coprocessors together, the\n      AccessController must come first in the list, because with both components active, the\n      VisibilityController will delegate access control on its system tables to the AccessController.\n    </Callout>\n  </Step>\n\n  <Step>\n    Adjust Configuration\n\n    By default, users can label cells with any label, including labels they are not associated with, which means that a user can Put data that he cannot read. For example, a user could label a cell with the (hypothetical) 'topsecret' label even if the user is not associated with that label. If you only want users to be able to label cells with labels they are associated with, set `hbase.security.visibility.mutations.checkauths` to `true`. In that case, the mutation will fail if it makes use of labels the user is not associated with.\n  </Step>\n\n  <Step>\n    Distribute your configuration and restart your cluster for changes to take effect.\n  </Step>\n</Steps>\n\n### Administration\n\nAdministration tasks can be performed using the HBase Shell or the Java API. For defining the list of visibility labels and associating labels with users, the HBase Shell is probably simpler.\n\n<Callout type=\"error\">\n  Many of the Java API examples in this section are taken from the source file *hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabels.java*. Refer to that file or the API documentation for more context.\n\n  Neither these examples, nor the source file they were taken from, are part of the public HBase API, and are provided for illustration only. Refer to the official API for usage instructions.\n</Callout>\n\n<Steps>\n  <Step>\n    Define the List of Visibility Labels\n\n    **HBase Shell:**\n\n    ```ruby\n    hbase> add_labels [ 'admin', 'service', 'developer', 'test' ]\n    ```\n\n    **Java API:**\n\n    ```java\n    public static void addLabels() throws Exception {\n      PrivilegedExceptionAction<VisibilityLabelsResponse> action = new PrivilegedExceptionAction<VisibilityLabelsResponse>() {\n        public VisibilityLabelsResponse run() throws Exception {\n          String[] labels = { SECRET, TOPSECRET, CONFIDENTIAL, PUBLIC, PRIVATE, COPYRIGHT, ACCENT,\n              UNICODE_VIS_TAG, UC1, UC2 };\n          try {\n            VisibilityClient.addLabels(conf, labels);\n          } catch (Throwable t) {\n            throw new IOException(t);\n          }\n          return null;\n        }\n      };\n      SUPERUSER.runAs(action);\n    }\n    ```\n  </Step>\n\n  <Step>\n    Associate Labels with Users\n\n    **HBase Shell:**\n\n    ```ruby\n    hbase> set_auths 'service', [ 'service' ]\n    hbase> set_auths 'testuser', [ 'test' ]\n    hbase> set_auths 'qa', [ 'test', 'developer' ]\n    hbase> set_auths '@qagroup', [ 'test' ]\n    ```\n\n    **Java API:**\n\n    ```java\n    public void testSetAndGetUserAuths() throws Throwable {\n      final String user = \"user1\";\n      PrivilegedExceptionAction<Void> action = new PrivilegedExceptionAction<Void>() {\n        public Void run() throws Exception {\n          String[] auths = { SECRET, CONFIDENTIAL };\n          try {\n            VisibilityClient.setAuths(conf, auths, user);\n          } catch (Throwable e) {\n          }\n          return null;\n        }\n        ...\n    ```\n  </Step>\n\n  <Step>\n    Clear Labels From Users\n\n    **HBase Shell:**\n\n    ```ruby\n    hbase> clear_auths 'service', [ 'service' ]\n    hbase> clear_auths 'testuser', [ 'test' ]\n    hbase> clear_auths 'qa', [ 'test', 'developer' ]\n    hbase> clear_auths '@qagroup', [ 'test', 'developer' ]\n    ```\n\n    **Java API:**\n\n    ```java\n    ...\n    auths = new String[] { SECRET, PUBLIC, CONFIDENTIAL };\n    VisibilityLabelsResponse response = null;\n    try {\n      response = VisibilityClient.clearAuths(conf, auths, user);\n    } catch (Throwable e) {\n      fail(\"Should not have failed\");\n      ...\n    }\n    ```\n  </Step>\n\n  <Step>\n    Apply a Label or Expression to a Cell\n\n    The label is only applied when data is written. The label is associated with a given version of the cell.\n\n    **HBase Shell:**\n\n    ```ruby\n    hbase> set_visibility 'user', 'admin|service|developer', { COLUMNS => 'i' }\n    hbase> set_visibility 'user', 'admin|service', { COLUMNS => 'pii' }\n    hbase> set_visibility 'user', 'test', { COLUMNS => [ 'i', 'pii' ], FILTER => \"(PrefixFilter ('test'))\" }\n    ```\n\n    <Callout type=\"info\">\n      HBase Shell support for applying labels or permissions to cells is for testing and verification\n      support, and should not be employed for production use because it won't apply the labels to cells\n      that don't exist yet. The correct way to apply cell level labels is to do so in the application\n      code when storing the values.\n    </Callout>\n\n    **Java API example:**\n\n    ```java\n    static Table createTableAndWriteDataWithLabels(TableName tableName, String... labelExps)\n        throws Exception {\n      Configuration conf = HBaseConfiguration.create();\n      Connection connection = ConnectionFactory.createConnection(conf);\n      Table table = NULL;\n          try {\n            table = TEST_UTIL.createTable(tableName, fam);\n            int i = 1;\n            List<Put> puts = new ArrayList<Put>();\n            for (String labelExp : labelExps) {\n              Put put = new Put(Bytes.toBytes(\"row\" + i));\n              put.add(fam, qual, HConstants.LATEST_TIMESTAMP, value);\n              put.setCellVisibility(new CellVisibility(labelExp));\n              puts.add(put);\n              i++;\n            }\n            table.put(puts);\n          } finally {\n            if (table != null) {\n              table.flushCommits();\n            }\n          }\n        }\n    ```\n  </Step>\n</Steps>\n\n### Reading Cells with Labels\n\nWhen you issue a Scan or Get, HBase uses your default set of authorizations to filter out cells that you do not have access to. A superuser can set the default set of authorizations for a given user by using the `set_auths` HBase Shell command or the [VisibilityClient.setAuths()](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/security/visibility/VisibilityClient.html#setAuths\\(org.apache.hadoop.hbase.client.Connection,java.lang.String%5B%5D,java.lang.String\\)) method.\n\nYou can specify a different authorization during the Scan or Get, by passing the AUTHORIZATIONS option in HBase Shell, or the [Scan.setAuthorizations()](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html#setAuthorizations\\(org.apache.hadoop.hbase.security.visibility.Authorizations\\)) method if you use the API. This authorization will be combined with your default set as an additional filter. It will further filter your results, rather than giving you additional authorization.\n\n#### HBase Shell: \\[!toc]\n\n```ruby\nhbase> get_auths 'myUser'\nhbase> scan 'table1', AUTHORIZATIONS => ['private']\n```\n\n#### Java API: \\[!toc]\n\n```java\n...\npublic Void run() throws Exception {\n  String[] auths1 = { SECRET, CONFIDENTIAL };\n  GetAuthsResponse authsResponse = null;\n  try {\n    VisibilityClient.setAuths(conf, auths1, user);\n    try {\n      authsResponse = VisibilityClient.getAuths(conf, user);\n    } catch (Throwable e) {\n      fail(\"Should not have failed\");\n    }\n  } catch (Throwable e) {\n  }\n  List<String> authsList = new ArrayList<String>();\n  for (ByteString authBS : authsResponse.getAuthList()) {\n    authsList.add(Bytes.toString(authBS.toByteArray()));\n  }\n  assertEquals(2, authsList.size());\n  assertTrue(authsList.contains(SECRET));\n  assertTrue(authsList.contains(CONFIDENTIAL));\n  return null;\n}\n...\n```\n\n### Implementing Your Own Visibility Label Algorithm\n\nInterpreting the labels authenticated for a given get/scan request is a pluggable algorithm.\n\nYou can specify a custom plugin or plugins by using the property `hbase.regionserver.scan.visibility.label.generator.class`. The output for the first `ScanLabelGenerator` will be the input for the next one, until the end of the list.\n\nThe default implementation, which was implemented in [HBASE-12466](https://issues.apache.org/jira/browse/HBASE-12466), loads two plugins, `FeedUserAuthScanLabelGenerator` and `DefinedSetFilterScanLabelGenerator`. See [Reading Cells with Labels](/docs/security/data-access#reading-cells-with-labels).\n\n### Replicating Visibility Tags as Strings\n\nAs mentioned in the above sections, the interface `VisibilityLabelService` could be used to implement a different way of storing the visibility expressions in the cells. Clusters with replication enabled also must replicate the visibility expressions to the peer cluster. If `DefaultVisibilityLabelServiceImpl` is used as the implementation for `VisibilityLabelService`, all the visibility expression are converted to the corresponding expression based on the ordinals for each visibility label stored in the labels table. During replication, visible cells are also replicated with the ordinal-based expression intact. The peer cluster may not have the same `labels` table with the same ordinal mapping for the visibility labels. In that case, replicating the ordinals makes no sense. It would be better if the replication occurred with the visibility expressions transmitted as strings. To replicate the visibility expression as strings to the peer cluster, create a `RegionServerObserver` configuration which works based on the implementation of the `VisibilityLabelService` interface. The configuration below enables replication of visibility expressions to peer clusters as strings. See [HBASE-11639](https://issues.apache.org/jira/browse/HBASE-11639) for more details.\n\n```xml\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.coprocessor.regionserver.classes</name>\n  <value>org.apache.hadoop.hbase.security.visibility.VisibilityController$VisibilityReplication</value>\n</property>\n```\n\n## Transparent Encryption of Data At Rest\n\nHBase provides a mechanism for protecting your data at rest, in HFiles and the WAL, which reside within HDFS or another distributed filesystem. A two-tier architecture is used for flexible and non-intrusive key rotation. \"Transparent\" means that no implementation changes are needed on the client side. When data is written, it is encrypted. When it is read, it is decrypted on demand.\n\n### How It Works\n\nThe administrator provisions a master key for the cluster, which is stored in a key provider accessible to every trusted HBase process, including the HMaster, RegionServers, and clients (such as HBase Shell) on administrative workstations. The default key provider is integrated with the Java KeyStore API and any key management systems with support for it. Other custom key provider implementations are possible. The key retrieval mechanism is configured in the *hbase-site.xml* configuration file. The master key may be stored on the cluster servers, protected by a secure KeyStore file, or on an external keyserver, or in a hardware security module. This master key is resolved as needed by HBase processes through the configured key provider.\n\nNext, encryption use can be specified in the schema, per column family, by creating or modifying a column descriptor to include two additional attributes: the name of the encryption algorithm to use (currently only \"AES\" is supported), and optionally, a data key wrapped (encrypted) with the cluster master key. If a data key is not explicitly configured for a ColumnFamily, HBase will create a random data key per HFile. This provides an incremental improvement in security over the alternative. Unless you need to supply an explicit data key, such as in a case where you are generating encrypted HFiles for bulk import with a given data key, only specify the encryption algorithm in the ColumnFamily schema metadata and let HBase create data keys on demand. Per Column Family keys facilitate low impact incremental key rotation and reduce the scope of any external leak of key material. The wrapped data key is stored in the ColumnFamily schema metadata, and in each HFile for the Column Family, encrypted with the cluster master key. After the Column Family is configured for encryption, any new HFiles will be written encrypted. To ensure encryption of all HFiles, trigger a major compaction after enabling this feature.\n\nWhen the HFile is opened, the data key is extracted from the HFile, decrypted with the cluster master key, and used for decryption of the remainder of the HFile. The HFile will be unreadable if the master key is not available. If a remote user somehow acquires access to the HFile data because of some lapse in HDFS permissions, or from inappropriately discarded media, it will not be possible to decrypt either the data key or the file data.\n\nIt is also possible to encrypt the WAL. Even though WALs are transient, it is necessary to encrypt the WALEdits to avoid circumventing HFile protections for encrypted column families, in the event that the underlying filesystem is compromised. When WAL encryption is enabled, all WALs are encrypted, regardless of whether the relevant HFiles are encrypted.\n\n### Enable or disable the feature.\n\nThe \"Transparent Encryption of Data At Rest\" feature is enabled by default, meaning the users can define tables with column families where the HFiles and WAL files will be encrypted by HBase, assuming the feature is properly configured (see [Server-Side Configuration](/docs/security/data-access#security-data-access-transparent-encryption-of-data-at-test-server-side-configuration)).\n\nIn some cases (e.g. due to custom security policies), the operator of the HBase cluster might wish to only rely on an encryption at rest mechanism outside of HBase (e.g. those offered by HDFS) and wants to ensure that HBase's encryption at rest system is inactive. Since [HBASE-25181](https://issues.apache.org/jira/browse/HBASE-25181) it is possible to explicitly disable HBase's own encryption by setting `hbase.crypto.enabled` to `false`. This configuration is `true` by default. If it is set to `false`, the users won't be able to create any table (column family) with HFile and WAL file encryption and the related create table shell (or API) commands will fail if they try.\n\n### Server-Side Configuration\n\nThis procedure assumes you are using the default Java keystore implementation. If you are using a custom implementation, check its documentation and adjust accordingly.\n\n<Steps>\n  <Step>\n    Create a secret key of appropriate length for AES encryption, using the `keytool` utility.\n\n    ```bash\n    $ keytool -keystore /path/to/hbase/conf/hbase.jks \\\n      -storetype jceks -storepass **** \\\n      -genseckey -keyalg AES -keysize 128 \\\n      -alias <alias>\n    ```\n\n    Replace \\*\\*\\*\\* with the password for the keystore file and \\<alias> with the username of the HBase service account, or an arbitrary string. If you use an arbitrary string, you will need to configure HBase to use it, and that is covered below. Specify a keysize that is appropriate. Do not specify a separate password for the key, but press `Return` when prompted.\n  </Step>\n\n  <Step>\n    Set appropriate permissions on the keyfile and distribute it to all the HBase servers.\n\n    The previous command created a file called *hbase.jks* in the HBase *conf/* directory. Set the permissions and ownership on this file such that only the HBase service account user can read the file, and securely distribute the key to all HBase servers.\n  </Step>\n\n  <Step>\n    Configure the HBase daemons.\n\n    Set the following properties in *hbase-site.xml* on the region servers, to configure HBase daemons to use a key provider backed by the KeyStore file or retrieving the cluster master key. In the example below, replace \\*\\*\\*\\* with the password.\n\n    ```xml\n    <property>\n      <name>hbase.crypto.keyprovider</name>\n      <value>org.apache.hadoop.hbase.io.crypto.KeyStoreKeyProvider</value>\n    </property>\n    <property>\n      <name>hbase.crypto.keyprovider.parameters</name>\n      <value>jceks:///path/to/hbase/conf/hbase.jks?password=****</value>\n    </property>\n    ```\n\n    By default, the HBase service account name will be used to resolve the cluster master key. However, you can store it with an arbitrary alias (in the `keytool` command). In that case, set the following property to the alias you used.\n\n    ```xml\n    <property>\n      <name>hbase.crypto.master.key.name</name>\n      <value>my-alias</value>\n    </property>\n    ```\n\n    You also need to be sure your HFiles use HFile v3, in order to use transparent encryption. This is the default configuration for HBase 1.0 onward. For previous versions, set the following property in your *hbase-site.xml* file.\n\n    ```xml\n    <property>\n      <name>hfile.format.version</name>\n      <value>3</value>\n    </property>\n    ```\n\n    Optionally, you can use a different cipher provider, either a Java Cryptography Encryption (JCE) algorithm provider or a custom HBase cipher implementation.\n\n    * JCE:\n      * Install a signed JCE provider (supporting `AES/CTR/NoPadding` mode with 128 bit keys)\n      * Add it with highest preference to the JCE site configuration file *\\$JAVA\\_HOME/lib/security/java.security*.\n      * Update `hbase.crypto.algorithm.aes.provider` and `hbase.crypto.algorithm.rng.provider` options in *hbase-site.xml*.\n    * Custom HBase Cipher:\n      * Implement `org.apache.hadoop.hbase.io.crypto.CipherProvider`.\n      * Add the implementation to the server classpath.\n      * Update `hbase.crypto.cipherprovider` in *hbase-site.xml*.\n  </Step>\n\n  <Step>\n    Configure WAL encryption.\n\n    Configure WAL encryption in every RegionServer's *hbase-site.xml*, by setting the following properties. You can include these in the HMaster's *hbase-site.xml* as well, but the HMaster does not have a WAL and will not use them.\n\n    ```xml\n    <property>\n      <name>hbase.regionserver.hlog.reader.impl</name>\n      <value>org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogReader</value>\n    </property>\n    <property>\n      <name>hbase.regionserver.hlog.writer.impl</name>\n      <value>org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogWriter</value>\n    </property>\n    <property>\n      <name>hbase.regionserver.wal.encryption</name>\n      <value>true</value>\n    </property>\n    ```\n\n    <Callout type=\"info\">\n      Starting from 2.6.0, the hbase.regionserver.hlog.reader.impl and\n      hbase.regionserver.hlog.writer.impl configurations are removed, you do not need to specify them\n      any more. Just set hbase.regionserver.wal.encryption to true is enough to enable WAL encryption.\n    </Callout>\n  </Step>\n\n  <Step>\n    (Optional) Configure encryption key hash algorithm.\n\n    Since [HBASE-25181](https://issues.apache.org/jira/browse/HBASE-25181) it is possible to use custom encryption key hash algorithm instead of the default MD5 algorithm. This hash is needed to verify the secret key during decryption. The MD5 algorithm is considered weak, and can not be used in some (e.g. FIPS compliant) clusters.\n\n    The hash is set via the configuration option `hbase.crypto.key.hash.algorithm`. It should be set to a JDK `MessageDigest` algorithm like \"MD5\", \"SHA-384\" or \"SHA-512\". The default is \"MD5\" for backward compatibility. An example of this configuration parameter on a FIPS-compliant cluster:\n\n    ```xml\n    <property>\n      <name>hbase.crypto.key.hash.algorithm</name>\n      <value>SHA-384</value>\n    </property>\n    ```\n  </Step>\n\n  <Step>\n    Configure permissions on the *hbase-site.xml* file.\n\n    Because the keystore password is stored in the hbase-site.xml, you need to ensure that only the HBase user can read the *hbase-site.xml* file, using file ownership and permissions.\n  </Step>\n\n  <Step>\n    Restart your cluster.\n\n    Distribute the new configuration file to all nodes and restart your cluster.\n  </Step>\n</Steps>\n\n### Administration\n\nAdministrative tasks can be performed in HBase Shell or the Java API.\n\n<Callout type=\"error\">\n  Java API examples in this section are taken from the source file *hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestHBaseFsckEncryption.java*. .\n\n  Neither these examples, nor the source files they are taken from, are part of the public HBase API, and are provided for illustration only. Refer to the official API for usage instructions.\n</Callout>\n\n#### Enable Encryption on a Column Family\n\nTo enable encryption on a column family, you can either use HBase Shell or the Java API. After enabling encryption, trigger a major compaction. When the major compaction completes, the compacted new HFiles will be encrypted. However, depending on the compaction settings, it is possible that not all the HFiles will be rewritten during a major compaction and there still might remain some old unencrypted HFiles. Also please note, that the snapshots are immutable. So the snapshots taken before you enabled the encryption will still contain the unencrypted HFiles.\n\n#### Rotate the Data Key\n\nTo rotate the data key, first change the ColumnFamily key in the column descriptor, then trigger a major compaction. Until the compaction completes, the old HFiles will still be readable using the old key. During compaction, the compacted HFiles will be re-encrypted using the new data key. However, depending on the compaction settings, it is possible that not all the HFiles will be rewritten during a major compaction and there still might remain some old HFiles encrypted with the old key. Also please note, that the snapshots are immutable. So the snapshots taken before the changing of the encryption key will still contain the HFiles written using the old key.\n\n#### Switching Between Using a Random Data Key and Specifying A Key\n\nIf you configured a column family to use a specific key and you want to return to the default behavior of using a randomly-generated key for that column family, use the Java API to alter the `HColumnDescriptor` so that no value is sent with the key `ENCRYPTION_KEY`.\n\n#### Rotate the Master Key\n\nTo rotate the master key, first generate and distribute the new key. Then update the KeyStore to contain a new master key, and keep the old master key in the KeyStore using a different alias. Next, configure fallback to the old master key in the *hbase-site.xml* file.\n\n## Secure Enable\n\nAfter hbase-2.x, the default 'hbase.security.authorization' changed. Before hbase-2.x, it defaulted to true, in later HBase versions, the default became false. So to enable hbase authorization, the following propertie must be configured in *hbase-site.xml*. See [HBASE-19483](https://issues.apache.org/jira/browse/HBASE-19483);\n\n```xml\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n</property>\n```\n\n## Security Configuration Example\n\n#### Example Security Settings in *hbase-site.xml*\n\n```xml\n<!-- HFile v3 Support -->\n<property>\n  <name>hfile.format.version</name>\n  <value>3</value>\n</property>\n<!-- HBase Superuser -->\n<property>\n  <name>hbase.superuser</name>\n  <value>hbase,admin,@superuser-group</value>\n</property>\n<!-- Coprocessors for ACLs and Visibility Tags -->\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.coprocessor.region.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController,\n  org.apache.hadoop.hbase.security.visibility.VisibilityController,\n  org.apache.hadoop.hbase.security.token.TokenProvider</value>\n</property>\n<property>\n  <name>hbase.coprocessor.master.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController,\n  org.apache.hadoop.hbase.security.visibility.VisibilityController</value>\n</property>\n<property>\n  <name>hbase.coprocessor.regionserver.classes</name>\n  <value>org.apache.hadoop.hbase.security.access.AccessController</value>\n</property>\n<!-- Executable ACL for Coprocessor Endpoints -->\n<property>\n  <name>hbase.security.exec.permission.checks</name>\n  <value>true</value>\n</property>\n<!-- Whether a user needs authorization for a visibility tag to set it on a cell -->\n<property>\n  <name>hbase.security.visibility.mutations.checkauth</name>\n  <value>false</value>\n</property>\n<!-- Secure RPC Transport -->\n<property>\n  <name>hbase.rpc.protection</name>\n  <value>privacy</value>\n </property>\n <!-- Transparent Encryption -->\n<property>\n  <name>hbase.crypto.keyprovider</name>\n  <value>org.apache.hadoop.hbase.io.crypto.KeyStoreKeyProvider</value>\n</property>\n<property>\n  <name>hbase.crypto.keyprovider.parameters</name>\n  <value>jceks:///path/to/hbase/conf/hbase.jks?password=***</value>\n</property>\n<property>\n  <name>hbase.crypto.master.key.name</name>\n  <value>hbase</value>\n</property>\n<!-- WAL Encryption -->\n<property>\n  <name>hbase.regionserver.hlog.reader.impl</name>\n  <value>org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogReader</value>\n</property>\n<property>\n  <name>hbase.regionserver.hlog.writer.impl</name>\n  <value>org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogWriter</value>\n</property>\n<property>\n  <name>hbase.regionserver.wal.encryption</name>\n  <value>true</value>\n</property>\n<!-- For key rotation -->\n<property>\n  <name>hbase.crypto.master.alternate.key.name</name>\n  <value>hbase.old</value>\n</property>\n```\n\n<Callout type=\"info\">\n  Starting from 2.6.0, the hbase.regionserver.hlog.reader.impl and\n  hbase.regionserver.hlog.writer.impl configurations are removed, you do not need to specify them\n  any more. Just set hbase.regionserver.wal.encryption to true is enough to enable WAL encryption.\n</Callout>\n\n#### Example Group Mapper in Hadoop *core-site.xml*\n\nAdjust these settings to suit your environment.\n\n```xml\n<property>\n  <name>hadoop.security.group.mapping</name>\n  <value>org.apache.hadoop.security.LdapGroupsMapping</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.url</name>\n  <value>ldap://server</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.bind.user</name>\n  <value>Administrator@example-ad.local</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.bind.password</name>\n  <value>****</value> <!-- Replace with the actual password -->\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.base</name>\n  <value>dc=example-ad,dc=local</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.search.filter.user</name>\n  <value>(&amp;(objectClass=user)(sAMAccountName={0}))</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.search.filter.group</name>\n  <value>(objectClass=group)</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.search.attr.member</name>\n  <value>member</value>\n</property>\n<property>\n  <name>hadoop.security.group.mapping.ldap.search.attr.group.name</name>\n  <value>cn</value>\n</property>\n```\n\n***\n\n# Architecture\n\n## Resources\n\n1. More information about the design and implementation can be found at the jira issue: [HBASE-10070](https://issues.apache.org/jira/browse/HBASE-10070)\n\n2. HBaseCon 2014 talk: [HBase Read High Availability Using Timeline-Consistent Region Replicas](https://hbase.apache.org/www.hbasecon.com/#2014-PresentationsRecordings) also contains some details and [slides](http://www.slideshare.net/enissoz/hbase-high-availability-for-reads-with-time).\n\n## Overview\n\n## NoSQL?\n\nHBase is a type of \"NoSQL\" database. \"NoSQL\" is a general term meaning that the database isn't an RDBMS which supports SQL as its primary access language, but there are many types of NoSQL databases: BerkeleyDB is an example of a local NoSQL database, whereas HBase is very much a distributed database. Technically speaking, HBase is really more a \"Data Store\" than \"Data Base\" because it lacks many of the features you find in an RDBMS, such as typed columns, secondary indexes, triggers, and advanced query languages, etc.\n\nHowever, HBase has many features which supports both linear and modular scaling. HBase clusters expand by adding RegionServers that are hosted on commodity class servers. If a cluster expands from 10 to 20 RegionServers, for example, it doubles both in terms of storage and as well as processing capacity. An RDBMS can scale well, but only up to a point - specifically, the size of a single database server - and for the best performance requires specialized hardware and storage devices. HBase features of note are:\n\n* Strongly consistent reads/writes: HBase is not an \"eventually consistent\" DataStore. This makes it very suitable for tasks such as high-speed counter aggregation.\n* Automatic sharding: HBase tables are distributed on the cluster via regions, and regions are automatically split and re-distributed as your data grows.\n* Automatic RegionServer failover\n* Hadoop/HDFS Integration: HBase supports HDFS out of the box as its distributed file system.\n* MapReduce: HBase supports massively parallelized processing via MapReduce for using HBase as both source and sink.\n* Java Client API: HBase supports an easy to use Java API for programmatic access.\n* Thrift/REST API: HBase also supports Thrift and REST for non-Java front-ends.\n* Block Cache and Bloom Filters: HBase supports a Block Cache and Bloom Filters for high volume query optimization.\n* Operational Management: HBase provides build-in web-pages for operational insight as well as JMX metrics.\n\n## When Should I Use HBase?\n\nHBase isn't suitable for every problem.\n\nFirst, make sure you have enough data. If you have hundreds of millions or billions of rows, then HBase is a good candidate. If you only have a few thousand/million rows, then using a traditional RDBMS might be a better choice due to the fact that all of your data might wind up on a single node (or two) and the rest of the cluster may be sitting idle.\n\nSecond, make sure you can live without all the extra features that an RDBMS provides (e.g., typed columns, secondary indexes, transactions, advanced query languages, etc.) An application built against an RDBMS cannot be \"ported\" to HBase by simply changing a JDBC driver, for example. Consider moving from an RDBMS to HBase as a complete redesign as opposed to a port.\n\nThird, make sure you have enough hardware. Even HDFS doesn't do well with anything less than 5 DataNodes (due to things such as HDFS block replication which has a default of 3), plus a NameNode.\n\nHBase can run quite well stand-alone on a laptop - but this should be considered a development configuration only.\n\n## What Is The Difference Between HBase and Hadoop/HDFS?\n\n[HDFS](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) is a distributed file system that is well suited for the storage of large files. Its documentation states that it is not, however, a general purpose file system, and does not provide fast individual record lookups in files. HBase, on the other hand, is built on top of HDFS and provides fast record lookups (and updates) for large tables. This can sometimes be a point of conceptual confusion. HBase internally puts your data in indexed \"StoreFiles\" that exist on HDFS for high-speed lookups. See the [Data Model](/docs/datamodel) and the rest of this chapter for more information on how HBase achieves its goals.\n\n## Catalog Tables\n\nThe catalog table `hbase:meta` exists as an HBase table and is filtered out of the HBase shell's `list` command, but is in fact a table just like any other.\n\n## hbase:meta\n\nThe `hbase:meta` table (previously called `.META.`) keeps a list of all regions in the system, and the location of `hbase:meta` is stored in ZooKeeper.\n\nThe `hbase:meta` table structure is as follows:\n\n**Key:**\n\n* Region key of the format (`[table],[region start key],[region id]`)\n\n**Values:**\n\n* `info:regioninfo` (serialized [RegionInfo](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/RegionInfo.html) instance for this region)\n* `info:server` (server:port of the RegionServer containing this region)\n* `info:serverstartcode` (start-time of the RegionServer process containing this region)\n\nWhen a table is in the process of splitting, two other columns will be created, called `info:splitA` and `info:splitB`. These columns represent the two daughter regions. The values for these columns are also serialized HRegionInfo instances. After the region has been split, eventually this row will be deleted.\n\n<Callout type=\"info\" title=\"Note on HRegionInfo\">\n  The empty key is used to denote table start and table end. A region with an empty start key is the\n  first region in a table. If a region has both an empty start and an empty end key, it is the only\n  region in the table\n</Callout>\n\nIn the (hopefully unlikely) event that programmatic processing of catalog metadata is required, see the [RegionInfo.parseFrom](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/RegionInfo.html#parseFrom\\(byte%5B%5D\\)) utility.\n\n## Startup Sequencing\n\nFirst, the location of `hbase:meta` is looked up in ZooKeeper. Next, `hbase:meta` is updated with server and startcode values.\n\nFor information on region-RegionServer assignment, see [Region-RegionServer Assignment](/docs/architecture/regions#region-regionserver-assignment).\n\n## Client\n\nThe HBase client finds the RegionServers that are serving the particular row range of interest. It does this by querying the `hbase:meta` table. See [hbase:meta](/docs/architecture/catalog-tables#hbasemeta) for details. After locating the required region(s), the client contacts the RegionServer serving that region, rather than going through the master, and issues the read or write request. This information is cached in the client so that subsequent requests need not go through the lookup process. Should a region be reassigned either by the master load balancer or because a RegionServer has died, the client will requery the catalog tables to determine the new location of the user region.\n\nSee [Runtime Impact](/docs/architecture/master#runtime-impact) for more information about the impact of the Master on HBase Client communication.\n\nAdministrative functions are done via an instance of [Admin](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Admin.html)\n\n## Cluster Connections\n\nThe API changed in HBase 1.0. For connection configuration information, see [Client configuration and dependencies connecting to an HBase cluster](/docs/configuration/default#client-configuration-and-dependencies-connecting-to-an-hbase-cluster).\n\n### API as of HBase 1.0.0\n\nIt's been cleaned up and users are returned Interfaces to work against rather than particular types. In HBase 1.0, obtain a `Connection` object from `ConnectionFactory` and thereafter, get from it instances of `Table`, `Admin`, and `RegionLocator` on an as-need basis. When done, close the obtained instances. Finally, be sure to cleanup your `Connection` instance before exiting. `Connections` are heavyweight objects but thread-safe so you can create one for your application and keep the instance around. `Table`, `Admin` and `RegionLocator` instances are lightweight. Create as you go and then let go as soon as you are done by closing them. See the [Client Package Javadoc Description](https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/package-summary.html) for example usage of the new HBase 1.0 API.\n\n### API before HBase 1.0.0\n\nInstances of `HTable` are the way to interact with an HBase cluster earlier than 1.0.0. *[Table](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html) instances are not thread-safe*. Only one thread can use an instance of Table at any given time. When creating Table instances, it is advisable to use the same [HBaseConfiguration](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/HBaseConfiguration) instance. This will ensure sharing of ZooKeeper and socket instances to the RegionServers which is usually what you want. For example, this is preferred:\n\n```java\nHBaseConfiguration conf = HBaseConfiguration.create();\nHTable table1 = new HTable(conf, \"myTable\");\nHTable table2 = new HTable(conf, \"myTable\");\n```\n\nas opposed to this:\n\n```java\nHBaseConfiguration conf1 = HBaseConfiguration.create();\nHTable table1 = new HTable(conf1, \"myTable\");\nHBaseConfiguration conf2 = HBaseConfiguration.create();\nHTable table2 = new HTable(conf2, \"myTable\");\n```\n\nFor more information about how connections are handled in the HBase client, see [ConnectionFactory](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ConnectionFactory.html).\n\n#### Connection Pooling\n\nFor applications which require high-end multithreaded access (e.g., web-servers or application servers that may serve many application threads in a single JVM), you can pre-create a `Connection`, as shown in the following example:\n\n**Example 24. Pre-Creating a `Connection`**\n\n```java\n// Create a connection to the cluster.\nConfiguration conf = HBaseConfiguration.create();\ntry (Connection connection = ConnectionFactory.createConnection(conf);\n     Table table = connection.getTable(TableName.valueOf(tablename))) {\n  // use table as needed, the table returned is lightweight\n}\n```\n\n<Callout type=\"warn\" title=\"HTablePool is Deprecated\">\n  Previous versions of this guide discussed `HTablePool`, which was deprecated in HBase 0.94, 0.95,\n  and 0.96, and removed in 0.98.1, by\n  [HBASE-6580](https://issues.apache.org/jira/browse/HBASE-6580), or `HConnection`, which is\n  deprecated in HBase 1.0 by `Connection`. Please use\n  [Connection](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Connection.html)\n  instead.\n</Callout>\n\n## WriteBuffer and Batch Methods\n\nIn HBase 1.0 and later, [HTable](https://hbase.apache.org/1.4/devapidocs/org/apache/hadoop/hbase/client/HTable.html) is deprecated in favor of [Table](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html). `Table` does not use autoflush. To do buffered writes, use the BufferedMutator class.\n\nIn HBase 2.0 and later, [HTable](https://hbase.apache.org/2.6/devapidocs/org/apache/hadoop/hbase/client/HTable.html) does not use BufferedMutator to execute the `Put` operation. Refer to [HBASE-18500](https://issues.apache.org/jira/browse/HBASE-18500) for more information.\n\nFor additional information on write durability, review the [ACID semantics](/acid-semantics) page.\n\nFor fine-grained control of batching of `Put`s or `Delete`s, see the [batch](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#batch\\(java.util.List,java.lang.Object%5B%5D\\)) methods on Table.\n\n## Asynchronous Client\n\nIt is a new API introduced in HBase 2.0 which aims to provide the ability to access HBase asynchronously.\n\nYou can obtain an `AsyncConnection` from `ConnectionFactory`, and then get a asynchronous table instance from it to access HBase. When done, close the `AsyncConnection` instance(usually when your program exits).\n\nFor the asynchronous table, most methods have the same meaning with the old `Table` interface, expect that the return value is wrapped with a CompletableFuture usually. We do not have any buffer here so there is no close method for asynchronous table, you do not need to close it. And it is thread safe.\n\nThere are several differences for scan:\n\n* There is still a `getScanner` method which returns a `ResultScanner`. You can use it in the old way and it works like the old `ClientAsyncPrefetchScanner`.\n* There is a `scanAll` method which will return all the results at once. It aims to provide a simpler way for small scans which you want to get the whole results at once usually.\n* The Observer Pattern. There is a scan method which accepts a `ScanResultConsumer` as a parameter. It will pass the results to the consumer.\n\nNotice that `AsyncTable` interface is templatized. The template parameter specifies the type of `ScanResultConsumerBase` used by scans, which means the observer style scan APIs are different. The two types of scan consumers are - `ScanResultConsumer` and `AdvancedScanResultConsumer`.\n\n`ScanResultConsumer` needs a separate thread pool which is used to execute the callbacks registered to the returned CompletableFuture. Because the use of separate thread pool frees up RPC threads, callbacks are free to do anything. Use this if the callbacks are not quick, or when in doubt.\n\n`AdvancedScanResultConsumer` executes callbacks inside the framework thread. It is not allowed to do time consuming work in the callbacks else it will likely block the framework threads and cause very bad performance impact. As its name, it is designed for advanced users who want to write high performance code. See `org.apache.hadoop.hbase.client.example.HttpProxyExample` for how to write fully asynchronous code with it.\n\n## Asynchronous Admin\n\nYou can obtain an `AsyncConnection` from `ConnectionFactory`, and then get a `AsyncAdmin` instance from it to access HBase. Notice that there are two `getAdmin` methods to get a `AsyncAdmin` instance. One method has one extra thread pool parameter which is used to execute callbacks. It is designed for normal users. Another method doesn't need a thread pool and all the callbacks are executed inside the framework thread so it is not allowed to do time consuming works in the callbacks. It is designed for advanced users.\n\nThe default `getAdmin` methods will return a `AsyncAdmin` instance which use default configs. If you want to customize some configs, you can use `getAdminBuilder` methods to get a `AsyncAdminBuilder` for creating `AsyncAdmin` instance. Users are free to only set the configs they care about to create a new `AsyncAdmin` instance.\n\nFor the `AsyncAdmin` interface, most methods have the same meaning with the old `Admin` interface, expect that the return value is wrapped with a CompletableFuture usually.\n\nFor most admin operations, when the returned CompletableFuture is done, it means the admin operation has also been done. But for compact operation, it only means the compact request was sent to HBase and may need some time to finish the compact operation. For `rollWALWriter` method, it only means the rollWALWriter request was sent to the region server and may need some time to finish the `rollWALWriter` operation.\n\nFor region name, we only accept `byte[]` as the parameter type and it may be a full region name or a encoded region name. For server name, we only accept `ServerName` as the parameter type. For table name, we only accept `TableName` as the parameter type. For `list*` operations, we only accept `Pattern` as the parameter type if you want to do regex matching.\n\n## External Clients\n\nInformation on non-Java clients and custom protocols is covered in [Apache HBase External APIs](/docs/external-apis)\n\n## Master Registry (new as of 2.3.0)\n\nStarting from 2.5.0, MasterRegistry is deprecated. It's functionality is completely superseded by the RpcConnectionRegistry. Please see [Rpc Connection Registry (new as of 2.5.0)](/docs/architecture/client#rpc-connection-registry-new-as-of-250) for more details.\n\nClient internally works with a *connection registry* to fetch the metadata needed by connections. This connection registry implementation is responsible for fetching the following metadata.\n\n* Active master address\n* Current meta region(s) locations\n* Cluster ID (unique to this cluster)\n\nThis information is needed as a part of various client operations like connection set up, scans, gets, etc. Traditionally, the connection registry implementation has been based on ZooKeeper as the source of truth and clients fetched the metadata directly from the ZooKeeper quorum. HBase 2.3.0 introduces a new connection registry implementation based on direct communication with the Masters. With this implementation, clients now fetch required metadata via master RPC end points instead of maintaining connections to ZooKeeper. This change was done for the following reasons.\n\n* Reduce load on ZooKeeper since that is critical for cluster operation.\n* Holistic client timeout and retry configurations since the new registry brings all the client operations under HBase rpc framework.\n* Remove the ZooKeeper client dependency on HBase client library.\n\nThis means:\n\n* At least a single active or stand by master is needed for cluster connection setup. Refer to [Runtime Impact](/docs/architecture/master#runtime-impact) for more details.\n* Master can be in a critical path of read/write operations, especially if the client metadata cache is empty or stale.\n* There is higher connection load on the masters that before since the clients talk directly to HMasters instead of ZooKeeper ensemble\\`\n\nTo reduce hot-spotting on a single master, all the masters (active & stand-by) expose the needed service to fetch the connection metadata. This lets the client connect to any master (not just active). Both ZooKeeper-based and Master-based connection registry implementations are available in 2.3+. For 2.x and earlier, the ZooKeeper-based implementation remains the default configuration. For 3.0.0, RpcConnectionRegistry becomes the default configuration, as the alternate to MasterRegistry.\n\nChange the connection registry implementation by updating the value configured for `hbase.client.registry.impl`. To explicitly enable the ZooKeeper-based registry, use\n\n```xml\n<property>\n  <name>hbase.client.registry.impl</name>\n  <value>org.apache.hadoop.hbase.client.ZKConnectionRegistry</value>\n</property>\n```\n\nTo explicitly enable the Master-based registry, use\n\n```xml\n<property>\n  <name>hbase.client.registry.impl</name>\n  <value>org.apache.hadoop.hbase.client.MasterRegistry</value>\n</property>\n```\n\n### MasterRegistry RPC hedging\n\nMasterRegistry implements hedging of connection registry RPCs across active and stand-by masters. This lets the client make the same request to multiple servers and which ever responds first is returned back to the client immediately. This improves performance, especially when a subset of servers are under load. The hedging fan out size is configurable, meaning the number of requests that are hedged in a single attempt, using the configuration key *hbase.client.master\\_registry.hedged.fanout* in the client configuration. It defaults to 2. With this default, the RPCs are tried in batches of 2. The hedging policy is still primitive and does not adapt to any sort of live rpc performance metrics.\n\n### Additional Notes\n\n* Clients hedge the requests in a randomized order to avoid hot-spotting a single master.\n* Cluster internal connections (masters ↔ regionservers) still use ZooKeeper based connection registry.\n* Cluster internal state is still tracked in Zookeeper, hence ZK availability requirements are same as before.\n* Inter cluster replication still uses ZooKeeper based connection registry to simplify configuration management.\n\nFor more implementation details, please refer to the [design doc](https://github.com/apache/hbase/tree/master/dev-support/design-docs) and [HBASE-18095](https://issues.apache.org/jira/browse/HBASE-18095).\n\n## Rpc Connection Registry (new as of 2.5.0)\n\nAs said in the [Master Registry (new as of 2.3.0)](/docs/architecture/client#masterregistry-rpc-hedging) section, there are some disadvantages and limitations for MasterRegistry, especially that it puts master in the critical path of read/write operations. In order to address these problems, we introduced a more generic RpcConnectionRegistry.\n\nIt is also rpc based, like MasterRegistry, with several differences\n\n1. Region server also implements the necessary rpc service, so you can config any nodes in the cluster as bootstrap nodes, not only masters\n2. Support refreshing bootstrap nodes, for spreading loads across the nodes in the cluster, and also remove the dead nodes in bootstrap nodes.\n\nTo explicitly enable the rpc-based registry, use\n\n```xml\n<property>\n  <name>hbase.client.registry.impl</name>\n  <value>org.apache.hadoop.hbase.client.RpcConnectionRegistry</value>\n</property>\n```\n\nTo configure the bootstrap nodes, use\n\n```xml\n<property>\n  <name>hbase.client.bootstrap.servers</name>\n  <value>server1:16020,server2:16020,server3:16020</value>\n</property>\n```\n\nIf not configured, we will fallback to use master addresses as the bootstrap nodes.\n\nRpcConnectionRegistry is available in 2.5+, and becomes the default client registry implementation in 3.0.0.\n\n### RpcConnectionRegistry RPC hedging\n\nHedged read is still supported, the configuration key is now *hbase.client.bootstrap.hedged.fanout*, and its default value is still 2.\n\n### RpcConnectionRegistry bootstrap nodes refreshing\n\nThere are basically two reasons for us to refresh the bootstrap nodes\n\n* Periodically. This is for spreading loads across the nodes in the cluster. There are two configurations\n  1. *hbase.client.bootstrap.refresh\\_interval\\_secs*: the refresh interval in seconds, default 300. A value less than or equal to zero means disable refreshing.\n  2. *hbase.client.bootstrap.initial\\_refresh\\_delay\\_secs*: the initial refresh interval in seconds, the default value is 1/10 of *hbase.client.bootstrap.refresh\\_interval\\_secs*. The reason why we want to introduce a separated configuration for the delay for first refreshing is that, as end users could configure any nodes in a cluster as the initial bootstrap nodes, it is possible that different end users will configure the same machine which makes the machine over load. So we should have a shorter delay for the initial refresh, to let users quickly switch to the bootstrap nodes we want them to connect to.\n\n* When there is a connection error while requesting the nodes, we will refresh immediately, to remove the dead nodes. To avoid putting too much pressure to the cluster, there is a configuration *hbase.client.bootstrap.min\\_secs\\_between\\_refreshes*, to control the minimum interval between two refreshings. The default value is 60, but notice that, if you change *hbase.client.bootstrap.refresh\\_interval\\_secs* to a small value, you need to make sure to also change *hbase.client.bootstrap.min\\_secs\\_between\\_refreshes* to a value smaller than *hbase.client.bootstrap.refresh\\_interval\\_secs*, otherwise an IllegalArgumentException will be thrown.\n\n<Callout type=\"info\">\n  (Advanced) In case of any issues with the rpc/master based registry, use the following\n  configuration to fallback to the ZooKeeper based connection registry implementation.\n</Callout>\n\n```xml\n<property>\n  <name>hbase.client.registry.impl</name>\n  <value>org.apache.hadoop.hbase.client.ZKConnectionRegistry</value>\n</property>\n```\n\n## Connection URI\n\nStarting from 2.7.0, we add the support for specifying the connection information for a HBase cluster through an URI, which we call a \"connection URI\". And we've added several methods in *ConnectionFactory* to let you get a connection to the cluster specified by the URI. It looks like:\n\n```java\nURI uri = new URI(\"hbase+rpc://server1:16020,server2:16020,server3:16020\");\ntry (Connection conn = ConnectionFactory.createConnection(uri)) {\n  ...\n}\n```\n\n### Supported Schemes\n\nCurrently there are two schemes supported, *hbase+rpc* for *RpcConnectionRegistry* and *hbase+zk* for *ZKConnectionRegistry*. *MasterRegistry* is deprecated so we do not expose it through connection URI.\n\nFor *hbase+rpc*, it looks like\n\n```shell\nhbase+rpc://server1:16020,server2:16020,server3:16020\n```\n\nThe authority part *server1:16020,server2:16020,server3:16020* specifies the bootstrap nodes and their rpc ports, i.e, the configuration value for *hbase.client.bootstrap.servers* in the past.\n\nFor *hbase+zk*, it looks like\n\n```shell\nhbase+zk://zk1:2181,zk2:2181,zk3:2181/hbase\n```\n\nThe authority part *zk1:2181,zk2:2181,zk3:2181* is the zk quorum, i.e, the configuration value for *hbase.zookeeper.quorum* in the past. The path part */hbase* is the znode parent, i.e, the configuration value for *zookeeper.znode.parent* in the past.\n\n### Specify Configuration through URI Queries\n\nTo let users fully specify the connection information through a connection URI, we support specifying configuration values through URI Queries. It looks like:\n\n```shell\nhbase+rpc://server1:16020?hbase.client.operation.timeout=10000\n```\n\nIn this way you can set the operation timeout to 10 seconds. Notice that, the configuration values specified in the connection URI will override the ones in the configuration file.\n\n### Implement Your Own Connection Registry\n\nWe use *ServiceLoader* to load different connection registry implementations, the entry point is *org.apache.hadoop.hbase.client.ConnectionRegistryURIFactory*. So if you implement your own *ConnectionRegistryURIFactory* which has a different scheme, and register it in the services file, we can load it at runtime.\n\nConnection URI is still a very new feature which has not been used extensively in production, so we do not want to expose the ability to customize *ConnectionRegistryURIFactory* yet as the API may be changed frequently in the beginning.\n\nIf you really want to implement your own connection registry, you can use the above way but take your own risk.\n\n## Client Request Filters\n\n[Get](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Get.html) and [Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) instances can be optionally configured with [filters](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/Filter.html) which are applied on the RegionServer.\n\nFilters can be confusing because there are many different types, and it is best to approach them by understanding the groups of Filter functionality.\n\n## Structural\n\nStructural Filters contain other Filters.\n\n### FilterList\n\n[FilterList](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/FilterList.html) represents a list of Filters with a relationship of `FilterList.Operator.MUST_PASS_ALL` or `FilterList.Operator.MUST_PASS_ONE` between the Filters. The following example shows an 'or' between two Filters (checking for either 'my value' or 'my other value' on the same attribute).\n\n```java\nFilterList list = new FilterList(FilterList.Operator.MUST_PASS_ONE);\nSingleColumnValueFilter filter1 = new SingleColumnValueFilter(\n  cf,\n  column,\n  CompareOperator.EQUAL,\n  Bytes.toBytes(\"my value\")\n  );\nlist.add(filter1);\nSingleColumnValueFilter filter2 = new SingleColumnValueFilter(\n  cf,\n  column,\n  CompareOperator.EQUAL,\n  Bytes.toBytes(\"my other value\")\n  );\nlist.add(filter2);\nscan.setFilter(list);\n```\n\n## Column Value\n\n### SingleColumnValueFilter\n\nA SingleColumnValueFilter (see: [https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.html](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.html)) can be used to test column values for equivalence (`CompareOperaor.EQUAL`), inequality (`CompareOperaor.NOT_EQUAL`), or ranges (e.g., `CompareOperaor.GREATER`). The following is an example of testing equivalence of a column to a String value \"my value\"...\n\n```java\nSingleColumnValueFilter filter = new SingleColumnValueFilter(\n  cf,\n  column,\n  CompareOperaor.EQUAL,\n  Bytes.toBytes(\"my value\")\n  );\nscan.setFilter(filter);\n```\n\n### ColumnValueFilter\n\nIntroduced in HBase-2.0.0 version as a complementation of SingleColumnValueFilter, ColumnValueFilter gets matched cell only, while SingleColumnValueFilter gets the entire row (has other columns and values) to which the matched cell belongs. Parameters of constructor of ColumnValueFilter are the same as SingleColumnValueFilter.\n\n```java\nColumnValueFilter filter = new ColumnValueFilter(\n  cf,\n  column,\n  CompareOperaor.EQUAL,\n  Bytes.toBytes(\"my value\")\n  );\nscan.setFilter(filter);\n```\n\nNote. For simple query like \"equals to a family:qualifier:value\", we highly recommend to use the following way instead of using SingleColumnValueFilter or ColumnValueFilter:\n\n```java\nScan scan = new Scan();\nscan.addColumn(Bytes.toBytes(\"family\"), Bytes.toBytes(\"qualifier\"));\nValueFilter vf = new ValueFilter(CompareOperator.EQUAL,\n  new BinaryComparator(Bytes.toBytes(\"value\")));\nscan.setFilter(vf);\n...\n```\n\nThis scan will restrict to the specified column 'family:qualifier', avoiding scan of unrelated families and columns, which has better performance, and `ValueFilter` is the condition used to do the value filtering.\n\nBut if query is much more complicated beyond this book, then please make your good choice case by case.\n\n## Column Value Comparators\n\nThere are several Comparator classes in the Filter package that deserve special mention. These Comparators are used in concert with other Filters, such as [SingleColumnValueFilter](/docs/architecture/client-request-filters#singlecolumnvaluefilter).\n\n### RegexStringComparator\n\n[RegexStringComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/RegexStringComparator.html) supports regular expressions for value comparisons.\n\n```java\nRegexStringComparator comp = new RegexStringComparator(\"my.\");   // any value that starts with 'my'\nSingleColumnValueFilter filter = new SingleColumnValueFilter(\n  cf,\n  column,\n  CompareOperaor.EQUAL,\n  comp\n  );\nscan.setFilter(filter);\n```\n\nSee the Oracle JavaDoc for [supported RegEx patterns in Java](http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html).\n\n### SubstringComparator\n\n[SubstringComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/SubstringComparator.html) can be used to determine if a given substring exists in a value. The comparison is case-insensitive.\n\n```java\nSubstringComparator comp = new SubstringComparator(\"y val\");   // looking for 'my value'\nSingleColumnValueFilter filter = new SingleColumnValueFilter(\n  cf,\n  column,\n  CompareOperaor.EQUAL,\n  comp\n  );\nscan.setFilter(filter);\n```\n\n### BinaryPrefixComparator\n\nSee [BinaryPrefixComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/BinaryPrefixComparator.html).\n\n### BinaryComparator\n\nSee [BinaryComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/BinaryComparator.html).\n\n### BinaryComponentComparator\n\n[BinaryComponentComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/BinaryComponentComparator.html) can be used to compare specific value at specific location with in the cell value. The comparison can be done for both ascii and binary data.\n\n```java\nbyte[] partialValue = Bytes.toBytes(\"partial_value\");\nint partialValueOffset = 0;\nFilter partialValueFilter = new ValueFilter(CompareFilter.CompareOp.GREATER,\n        new BinaryComponentComparator(partialValue,partialValueOffset));\n```\n\nSee [HBASE-22969](https://issues.apache.org/jira/browse/HBASE-22969) for other use cases and details.\n\n## KeyValue Metadata\n\nAs HBase stores data internally as KeyValue pairs, KeyValue Metadata Filters evaluate the existence of keys (i.e., ColumnFamily:Column qualifiers) for a row, as opposed to values the previous section.\n\n### FamilyFilter\n\n[FamilyFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/FamilyFilter.html) can be used to filter on the ColumnFamily. It is generally a better idea to select ColumnFamilies in the Scan than to do it with a Filter.\n\n### QualifierFilter\n\n[QualifierFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/QualifierFilter.html) can be used to filter based on Column (aka Qualifier) name.\n\n### ColumnPrefixFilter\n\n[ColumnPrefixFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.html) can be used to filter based on the lead portion of Column (aka Qualifier) names.\n\nA ColumnPrefixFilter seeks ahead to the first column matching the prefix in each row and for each involved column family. It can be used to efficiently get a subset of the columns in very wide rows.\n\nNote: The same column qualifier can be used in different column families. This filter returns all matching columns.\n\nExample: Find all columns in a row and family that start with \"abc\"\n\n```java\nTable t = ...;\nbyte[] row = ...;\nbyte[] family = ...;\nbyte[] prefix = Bytes.toBytes(\"abc\");\nScan scan = new Scan(row, row); // (optional) limit to one row\nscan.addFamily(family); // (optional) limit to one family\nFilter f = new ColumnPrefixFilter(prefix);\nscan.setFilter(f);\nscan.setBatch(10); // set this if there could be many columns returned\nResultScanner rs = t.getScanner(scan);\nfor (Result r = rs.next(); r != null; r = rs.next()) {\n  for (Cell cell : result.listCells()) {\n    // each cell represents a column\n  }\n}\nrs.close();\n```\n\n### MultipleColumnPrefixFilter\n\n[MultipleColumnPrefixFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.html) behaves like ColumnPrefixFilter but allows specifying multiple prefixes.\n\nLike ColumnPrefixFilter, MultipleColumnPrefixFilter efficiently seeks ahead to the first column matching the lowest prefix and also seeks past ranges of columns between prefixes. It can be used to efficiently get discontinuous sets of columns from very wide rows.\n\nExample: Find all columns in a row and family that start with \"abc\" or \"xyz\"\n\n```java\nTable t = ...;\nbyte[] row = ...;\nbyte[] family = ...;\nbyte[][] prefixes = new byte[][] {Bytes.toBytes(\"abc\"), Bytes.toBytes(\"xyz\")};\nScan scan = new Scan(row, row); // (optional) limit to one row\nscan.addFamily(family); // (optional) limit to one family\nFilter f = new MultipleColumnPrefixFilter(prefixes);\nscan.setFilter(f);\nscan.setBatch(10); // set this if there could be many columns returned\nResultScanner rs = t.getScanner(scan);\nfor (Result r = rs.next(); r != null; r = rs.next()) {\n  for (Cell cell : result.listCells()) {\n    // each cell represents a column\n  }\n}\nrs.close();\n```\n\n### ColumnRangeFilter\n\nA [ColumnRangeFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/ColumnRangeFilter.html) allows efficient intra row scanning.\n\nA ColumnRangeFilter can seek ahead to the first matching column for each involved column family. It can be used to efficiently get a 'slice' of the columns of a very wide row. i.e. you have a million columns in a row but you only want to look at columns bbbb-bbdd.\n\nNote: The same column qualifier can be used in different column families. This filter returns all matching columns.\n\nExample: Find all columns in a row and family between \"bbbb\" (inclusive) and \"bbdd\" (inclusive)\n\n```java\nTable t = ...;\nbyte[] row = ...;\nbyte[] family = ...;\nbyte[] startColumn = Bytes.toBytes(\"bbbb\");\nbyte[] endColumn = Bytes.toBytes(\"bbdd\");\nScan scan = new Scan(row, row); // (optional) limit to one row\nscan.addFamily(family); // (optional) limit to one family\nFilter f = new ColumnRangeFilter(startColumn, true, endColumn, true);\nscan.setFilter(f);\nscan.setBatch(10); // set this if there could be many columns returned\nResultScanner rs = t.getScanner(scan);\nfor (Result r = rs.next(); r != null; r = rs.next()) {\n  for (Cell cell : result.listCells()) {\n    // each cell represents a column\n  }\n}\nrs.close();\n```\n\nNote: Introduced in HBase 0.92\n\n## RowKey\n\n### RowFilter\n\nIt is generally a better idea to use the startRow/stopRow methods on Scan for row selection, however [RowFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/RowFilter.html) can also be used.\n\nYou can supplement a scan (both bounded and unbounded) with RowFilter constructed from [BinaryComponentComparator](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/BinaryComponentComparator.html) for further filtering out or filtering in rows. See [HBASE-22969](https://issues.apache.org/jira/browse/HBASE-22969) for use cases and other details.\n\n## Utility\n\n### FirstKeyOnlyFilter\n\nThis is primarily used for rowcount jobs. See [FirstKeyOnlyFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html).\n\n## Master\n\n`HMaster` is the implementation of the Master Server. The Master server is responsible for monitoring all RegionServer instances in the cluster, and is the interface for all metadata changes. In a distributed cluster, the Master typically runs on the [NameNode](/docs/architecture/hdfs#hdfs-namenode). J Mohamed Zahoor goes into some more detail on the Master Architecture in this blog posting, [HBase HMaster Architecture](https://web.archive.org/web/20191211053128/http://blog.zahoor.in/2012/08/hbase-hmaster-architecture/).\n\n## Startup Behavior\n\nIf run in a multi-Master environment, all Masters compete to run the cluster. If the active Master loses its lease in ZooKeeper (or the Master shuts down), then the remaining Masters jostle to take over the Master role.\n\n## Runtime Impact\n\nA common dist-list question involves what happens to an HBase cluster when the Master goes down. This information has changed starting 3.0.0.\n\n### Up until releases 2.x.y\n\nBecause the HBase client talks directly to the RegionServers, the cluster can still function in a \"steady state\". Additionally, per [Catalog Tables](/docs/architecture/catalog-tables), `hbase:meta` exists as an HBase table and is not resident in the Master. However, the Master controls critical functions such as RegionServer failover and completing region splits. So while the cluster can still run for a short time without the Master, the Master should be restarted as soon as possible.\n\n### Staring release 3.0.0\n\nAs mentioned in section [Master Registry (new as of 2.3.0)](/docs/architecture/client#masterregistry-rpc-hedging), the default connection registry for clients is now based on master rpc end points. Hence the requirements for masters' uptime are even tighter starting this release.\n\n* At least one active or stand by master is needed for a connection set up, unlike before when all the clients needed was a ZooKeeper ensemble.\n* Master is now in critical path for read/write operations. For example, if the meta region bounces off to a different region server, clients need master to fetch the new locations. Earlier this was done by fetching this information directly from ZooKeeper.\n* Masters will now have higher connection load than before. So, the server side configuration might need adjustment depending on the load.\n\nOverall, the master uptime requirements, when this feature is enabled, are even higher for the client operations to go through.\n\n## Interface\n\nThe methods exposed by `HMasterInterface` are primarily metadata-oriented methods:\n\n* Table (createTable, modifyTable, removeTable, enable, disable)\n* ColumnFamily (addColumn, modifyColumn, removeColumn)\n* Region (move, assign, unassign) For example, when the `Admin` method `disableTable` is invoked, it is serviced by the Master server.\n\n## Processes\n\nThe Master runs several background threads:\n\n### LoadBalancer\n\nPeriodically, and when there are no regions in transition, a load balancer will run and move regions around to balance the cluster's load. See [Balancer](/docs/configuration/important#balancer) for configuring this property.\n\nSee [Region-RegionServer Assignment](/docs/architecture/regions#region-regionserver-assignment) for more information on region assignment.\n\n### CatalogJanitor\n\nPeriodically checks and cleans up the `hbase:meta` table. See [hbase:meta](/docs/architecture/catalog-tables#hbasemeta) for more information on the meta table.\n\n## MasterProcWAL\n\n*MasterProcWAL is replaced in hbase-2.3.0 by an alternate Procedure Store implementation; see [in-master-procedure-store-region](/docs/upgrading/paths#new-in-master-procedure-store). This section pertains to hbase-2.0.0 through hbase-2.2.x*\n\nHMaster records administrative operations and their running states, such as the handling of a crashed server, table creation, and other DDLs, into a Procedure Store. The Procedure Store WALs are stored under the MasterProcWALs directory. The Master WALs are not like RegionServer WALs. Keeping up the Master WAL allows us to run a state machine that is resilient across Master failures. For example, if a HMaster was in the middle of creating a table encounters an issue and fails, the next active HMaster can take up where the previous left off and carry the operation to completion. Since hbase-2.0.0, a new AssignmentManager (A.K.A AMv2) was introduced and the HMaster handles region assignment operations, server crash processing, balancing, etc., all via AMv2 persisting all state and transitions into MasterProcWALs rather than up into ZooKeeper, as we do in hbase-1.x.\n\nSee [AMv2 Description for Devs](/docs/amv2) (and [Procedure Framework (Pv2): HBASE-12439](/docs/pv2) for its basis) if you would like to learn more about the new AssignmentManager.\n\n### Configurations for MasterProcWAL\n\nHere are the list of configurations that effect MasterProcWAL operation. You should not have to change your defaults.\n\n* **`hbase.procedure.store.wal.periodic.roll.msec`**\\\n  **Description:** Frequency of generating a new WAL\\\n  **Default:** `1h (3600000 in msec)`\n\n* **`hbase.procedure.store.wal.roll.threshold`**\\\n  **Description:** Threshold in size before the WAL rolls. Every time the WAL reaches this size or the above period, 1 hour, passes since last log roll, the HMaster will generate a new WAL.\\\n  **Default:** `32MB (33554432 in byte)`\n\n* **`hbase.procedure.store.wal.warn.threshold`**\\\n  **Description:** If the number of WALs goes beyond this threshold, the following message should appear in the HMaster log with WARN level when rolling.\n\n  ```\n  procedure WALs count=xx above the warning threshold 64. check running procedures to see if something is stuck.\n  ```\n\n  **Default:** `64`\n\n* **`hbase.procedure.store.wal.max.retries.before.roll`**\\\n  **Description:** Max number of retry when syncing slots (records) to its underlying storage, such as HDFS. Every attempt, the following message should appear in the HMaster log.\n\n  ```\n  unable to sync slots, retry=xx\n  ```\n\n  **Default:** `3`\n\n* **`hbase.procedure.store.wal.sync.failure.roll.max`**\\\n  **Description:** After the above 3 retrials, the log is rolled and the retry count is reset to 0, thereon a new set of retrial starts. This configuration controls the max number of attempts of log rolling upon sync failure. That is, HMaster is allowed to fail to sync 9 times in total. Once it exceeds, the following log should appear in the HMaster log.\n  ```\n  Sync slots after log roll failed, abort.\n  ```\n  **Default:** `3`\n\n## RegionServer\n\n`HRegionServer` is the RegionServer implementation. It is responsible for serving and managing regions. In a distributed cluster, a RegionServer runs on a [DataNode](/docs/architecture/hdfs#hdfs-datanode).\n\n## Interface\n\nThe methods exposed by `HRegionRegionInterface` contain both data-oriented and region-maintenance methods:\n\n* Data (get, put, delete, next, etc.)\n* Region (splitRegion, compactRegion, etc.) For example, when the `Admin` method `majorCompact` is invoked on a table, the client is actually iterating through all regions for the specified table and requesting a major compaction directly to each region.\n\n## Processes\n\nThe RegionServer runs a variety of background threads:\n\n### CompactSplitThread\n\nChecks for splits and handle minor compactions.\n\n### MajorCompactionChecker\n\nChecks for major compactions.\n\n### MemStoreFlusher\n\nPeriodically flushes in-memory writes in the MemStore to StoreFiles.\n\n### LogRoller\n\nPeriodically checks the RegionServer's WAL.\n\n## Coprocessors\n\nCoprocessors were added in 0.92. There is a thorough [Blog Overview of CoProcessors](https://blogs.apache.org/hbase/entry/coprocessor_introduction) posted. Documentation will eventually move to this reference guide, but the blog is the most current information available at this time.\n\n## Block Cache\n\nHBase provides two different BlockCache implementations to cache data read from HDFS: the default on-heap `LruBlockCache` and the `BucketCache`, which is (usually) off-heap. This section discusses benefits and drawbacks of each implementation, how to choose the appropriate option, and configuration options for each.\n\n<Callout type=\"info\" title=\"Block Cache Reporting: UI\">\n  See the RegionServer UI for detail on caching deploy. See configurations, sizings, current usage,\n  time-in-the-cache, and even detail on block counts and types.\n</Callout>\n\n### Cache Choices\n\n`LruBlockCache` is the original implementation, and is entirely within the Java heap. `BucketCache` is optional and mainly intended for keeping block cache data off-heap, although `BucketCache` can also be a file-backed cache. In file-backed we can either use it in the file mode or the mmaped mode. We also have pmem mode where the bucket cache resides on the persistent memory device.\n\nWhen you enable BucketCache, you are enabling a two tier caching system. We used to describe the tiers as \"L1\" and \"L2\" but have deprecated this terminology as of hbase-2.0.0. The \"L1\" cache referred to an instance of LruBlockCache and \"L2\" to an off-heap BucketCache. Instead, when BucketCache is enabled, all DATA blocks are kept in the BucketCache tier and meta blocks — INDEX and BLOOM blocks — are on-heap in the `LruBlockCache`. Management of these two tiers and the policy that dictates how blocks move between them is done by `CombinedBlockCache`.\n\n### General Cache Configurations\n\nApart from the cache implementation itself, you can set some general configuration options to control how the cache performs. See [CacheConfig](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html). After setting any of these options, restart or rolling restart your cluster for the configuration to take effect. Check logs for errors or unexpected behavior.\n\nSee also [Prefetch Option for Blockcache](/docs/performance#prefetch-option-for-blockcache), which discusses a new option introduced in [HBASE-9857](https://issues.apache.org/jira/browse/HBASE-9857).\n\n### LruBlockCache Design\n\nThe LruBlockCache is an LRU cache that contains three levels of block priority to allow for scan-resistance and in-memory ColumnFamilies:\n\n* Single access priority: The first time a block is loaded from HDFS it normally has this priority and it will be part of the first group to be considered during evictions. The advantage is that scanned blocks are more likely to get evicted than blocks that are getting more usage.\n* Multi access priority: If a block in the previous priority group is accessed again, it upgrades to this priority. It is thus part of the second group considered during evictions.\n* In-memory access priority: If the block's family was configured to be \"in-memory\", it will be part of this priority disregarding the number of times it was accessed. Catalog tables are configured like this. This group is the last one considered during evictions.\\\n  To mark a column family as in-memory, call\n  ```java\n  HColumnDescriptor.setInMemory(true);\n  ```\n  if creating a table from java, or set `IN_MEMORY ⇒ true` when creating or altering a table in the shell: e.g.\n  ```java\n  hbase(main):003:0> create  't', {NAME => 'f', IN_MEMORY => 'true'}\n  ```\n  For more information, see the LruBlockCache source\n\n### LruBlockCache Usage\n\nBlock caching is enabled by default for all the user tables which means that any read operation will load the LRU cache. This might be good for a large number of use cases, but further tunings are usually required in order to achieve better performance. An important concept is the [working set size](http://en.wikipedia.org/wiki/Working_set_size), or WSS, which is: \"the amount of memory needed to compute the answer to a problem\". For a website, this would be the data that's needed to answer the queries over a short amount of time.\n\nThe way to calculate how much memory is available in HBase for caching is:\n\n```java\nnumber of region servers * heap size * hfile.block.cache.size * 0.99\n```\n\nThe default value for the block cache is 0.4 which represents 40% of the available heap. The last value (99%) is the default acceptable loading factor in the LRU cache after which eviction is started. The reason it is included in this equation is that it would be unrealistic to say that it is possible to use 100% of the available memory since this would make the process blocking from the point where it loads new blocks. Here are some examples:\n\n* One region server with the heap size set to 1 GB and the default block cache size will have 405 MB of block cache available.\n* 20 region servers with the heap size set to 8 GB and a default block cache size will have 63.3 GB of block cache.\n* 100 region servers with the heap size set to 24 GB and a block cache size of 0.5 will have about 1.16 TB of block cache.\n\nYour data is not the only resident of the block cache. Here are others that you may have to take into account:\n\n* **Catalog Tables**\\\n  The `hbase:meta` table is forced into the block cache and have the in-memory priority which means that they are harder to evict.\n\n  <Callout type=\"info\">\n    The hbase:meta tables can occupy a few MBs depending on the number of regions.\n  </Callout>\n\n* **HFiles Indexes**\\\n  An *HFile* is the file format that HBase uses to store data in HDFS. It contains a multi-layered index which allows HBase to seek the data without having to read the whole file. The size of those indexes is a factor of the block size (64KB by default), the size of your keys and the amount of data you are storing. For big data sets it's not unusual to see numbers around 1GB per region server, although not all of it will be in cache because the LRU will evict indexes that aren't used.\n\n* **Keys**\\\n  The values that are stored are only half the picture, since each value is stored along with its keys (row key, family qualifier, and timestamp). See [Try to minimize row and column sizes](/docs/regionserver-sizing#try-to-minimize-row-and-column-sizes).\n\n* **Bloom Filters**\\\n  Just like the HFile indexes, those data structures (when enabled) are stored in the LRU.\n\nCurrently the recommended way to measure HFile indexes and bloom filters sizes is to look at the region server web UI and checkout the relevant metrics. For keys, sampling can be done by using the HFile command line tool and look for the average key size metric. Since HBase 0.98.3, you can view details on BlockCache stats and metrics in a special Block Cache section in the UI. As of HBase 2.4.14, you can estimate HFile indexes and bloom filters vs other DATA blocks using blockCacheCount and blockCacheDataBlockCount in JMX. The formula `(blockCacheCount - blockCacheDataBlockCount) * blockSize` will give you an estimate which can be useful when trying to enable the BucketCache. You should make sure the post-BucketCache config gives enough memory to the on-heap LRU cache to hold at least the same number of non-DATA blocks from pre-BucketCache. Once BucketCache is enabled, the L1 metrics like l1CacheSize, l1CacheCount, and l1CacheEvictionCount can help you further tune the size.\n\nIt's generally bad to use block caching when the WSS doesn't fit in memory. This is the case when you have for example 40GB available across all your region servers' block caches but you need to process 1TB of data. One of the reasons is that the churn generated by the evictions will trigger more garbage collections unnecessarily. Here are two use cases:\n\n* Fully random reading pattern: This is a case where you almost never access the same row twice within a short amount of time such that the chance of hitting a cached block is close to 0. Setting block caching on such a table is a waste of memory and CPU cycles, more so that it will generate more garbage to pick up by the JVM. For more information on monitoring GC, see [JVM Garbage Collection Logs](/docs/troubleshooting#jvm-garbage-collection-logs).\n* Mapping a table: In a typical MapReduce job that takes a table in input, every row will be read only once so there's no need to put them into the block cache. The Scan object has the option of turning this off via the setCacheBlocks method (set it to false). You can still keep block caching turned on on this table if you need fast random read access. An example would be counting the number of rows in a table that serves live traffic, caching every block of that table would create massive churn and would surely evict data that's currently in use.\n\n#### Caching META blocks only (DATA blocks in fscache)\n\nAn interesting setup is one where we cache META blocks only and we read DATA blocks in on each access. If the DATA blocks fit inside fscache, this alternative may make sense when access is completely random across a very large dataset. To enable this setup, alter your table and for each column family set `BLOCKCACHE ⇒ 'false'`. You are 'disabling' the BlockCache for this column family only. You can never disable the caching of META blocks. Since [HBASE-4683 Always cache index and bloom blocks](https://issues.apache.org/jira/browse/HBASE-4683), we will cache META blocks even if the BlockCache is disabled.\n\n### Off-heap Block Cache\n\n#### How to Enable BucketCache\n\nThe usual deployment of BucketCache is via a managing class that sets up two caching tiers: an on-heap cache implemented by LruBlockCache and a second cache implemented with BucketCache. The managing class is [CombinedBlockCache](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CombinedBlockCache.html) by default. The previous link describes the caching 'policy' implemented by CombinedBlockCache. In short, it works by keeping meta blocks — INDEX and BLOOM in the on-heap LruBlockCache tier — and DATA blocks are kept in the BucketCache tier.\n\n* **Pre-hbase-2.0.0 versions**\n\n  Fetching will always be slower when fetching from BucketCache in pre-hbase-2.0.0, as compared to the native on-heap LruBlockCache. However, latencies tend to be less erratic across time, because there is less garbage collection when you use BucketCache since it is managing BlockCache allocations, not the GC. If the BucketCache is deployed in off-heap mode, this memory is not managed by the GC at all. This is why you'd use BucketCache in pre-2.0.0, so your latencies are less erratic, to mitigate GCs and heap fragmentation, and so you can safely use more memory. See Nick Dimiduk's [BlockCache 101](http://www.n10k.com/blog/blockcache-101/) for comparisons running on-heap vs off-heap tests. Also see [Comparing BlockCache Deploys](https://web.archive.org/web/20231109025243/http://people.apache.org/~stack/bc/) which finds that if your dataset fits inside your LruBlockCache deploy, use it otherwise if you are experiencing cache churn (or you want your cache to exist beyond the vagaries of java GC), use BucketCache.\n\n  In pre-2.0.0, one can configure the BucketCache so it receives the `victim` of an LruBlockCache eviction. All Data and index blocks are cached in L1 first. When eviction happens from L1, the blocks (or `victims`) will get moved to L2. Set `cacheDataInL1` via `(HColumnDescriptor.setCacheDataInL1(true)` or in the shell, creating or amending column families setting `CACHE_DATA_IN_L1` to true: e.g.\n\n  ```java\n  hbase(main):003:0> create 't', {NAME => 't', CONFIGURATION => {CACHE_DATA_IN_L1 => 'true'}}\n  ```\n\n* **hbase-2.0.0+ versions**\n\n  HBASE-11425 changed the HBase read path so it could hold the read-data off-heap avoiding copying of cached data on to the java heap. See [Offheap read-path](/docs/offheap-read-write#offheap-read-path). In hbase-2.0.0, off-heap latencies approach those of on-heap cache latencies with the added benefit of NOT provoking GC.\n\n  From HBase 2.0.0 onwards, the notions of L1 and L2 have been deprecated. When BucketCache is turned on, the DATA blocks will always go to BucketCache and INDEX/BLOOM blocks go to on heap LRUBlockCache. `cacheDataInL1` support has been removed.\n\n#### BucketCache Deploy Modes\n\nThe BucketCache Block Cache can be deployed *offheap*, *file* or *mmaped* file mode.\n\nYou set which via the `hbase.bucketcache.ioengine` setting. Setting it to `offheap` will have BucketCache make its allocations off-heap, and an ioengine setting of `file:PATH_TO_FILE` will direct BucketCache to use file caching (Useful in particular if you have some fast I/O attached to the box such as SSDs). From 2.0.0, it is possible to have more than one file backing the BucketCache. This is very useful especially when the Cache size requirement is high. For multiple backing files, configure ioengine as `files:PATH_TO_FILE1,PATH_TO_FILE2,PATH_TO_FILE3`. BucketCache can be configured to use an mmapped file also. Configure ioengine as `mmap:PATH_TO_FILE` for this.\n\nIt is possible to deploy a tiered setup where we bypass the CombinedBlockCache policy and have BucketCache working as a strict L2 cache to the L1 LruBlockCache. For such a setup, set `hbase.bucketcache.combinedcache.enabled` to `false`. In this mode, on eviction from L1, blocks go to L2. When a block is cached, it is cached first in L1. When we go to look for a cached block, we look first in L1 and if none found, then search L2. Let us call this deploy format, *Raw L1+L2*. NOTE: This L1+L2 mode is removed from 2.0.0. When BucketCache is used, it will be strictly the DATA cache and the LruBlockCache will cache INDEX/META blocks.\n\nOther BucketCache configs include: specifying a location to persist cache to across restarts, how many threads to use writing the cache, etc. See the [CacheConfig.html](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html) class for configuration options and descriptions.\n\nTo check it enabled, look for the log line describing cache setup; it will detail how BucketCache has been deployed. Also see the UI. It will detail the cache tiering and their configuration.\n\n#### BucketCache Example Configuration\n\nThis sample provides a configuration for a 4 GB off-heap BucketCache with a 1 GB on-heap cache.\n\nConfiguration is performed on the RegionServer.\n\nSetting `hbase.bucketcache.ioengine` and `hbase.bucketcache.size` > 0 enables `CombinedBlockCache`. Let us presume that the RegionServer has been set to run with a 5G heap: i.e. `HBASE_HEAPSIZE=5g`.\n\n1. First, edit the RegionServer's *hbase-env.sh* and set `HBASE_OFFHEAPSIZE` to a value greater than the off-heap size wanted, in this case, 4 GB (expressed as 4G). Let's set it to 5G. That'll be 4G for our off-heap cache and 1G for any other uses of off-heap memory (there are other users of off-heap memory other than BlockCache; e.g. DFSClient in RegionServer can make use of off-heap memory). See Direct Memory Usage In HBase below.\n\n   ```java\n   HBASE_OFFHEAPSIZE=5G\n   ```\n\n2. Next, add the following configuration to the RegionServer's *hbase-site.xml*.\n\n   ```xml\n   <property>\n     <name>hbase.bucketcache.ioengine</name>\n     <value>offheap</value>\n   </property>\n   <property>\n     <name>hfile.block.cache.size</name>\n     <value>0.2</value>\n   </property>\n   <property>\n     <name>hbase.bucketcache.size</name>\n     <value>4196</value>\n   </property>\n   ```\n\n3. Restart or rolling restart your cluster, and check the logs for any issues.\n\nIn the above, we set the BucketCache to be 4G. We configured the on-heap LruBlockCache have 20% (0.2) of the RegionServer's heap size (0.2 \\* 5G = 1G). In other words, you configure the L1 LruBlockCache as you would normally (as if there were no L2 cache present).\n\n[HBASE-10641](https://issues.apache.org/jira/browse/HBASE-10641) introduced the ability to configure multiple sizes for the buckets of the BucketCache, in HBase 0.98 and newer. To configurable multiple bucket sizes, configure the new property `hbase.bucketcache.bucket.sizes` to a comma-separated list of block sizes, ordered from smallest to largest, with no spaces. The goal is to optimize the bucket sizes based on your data access patterns. The following example configures buckets of size 4096 and 8192.\n\n```xml\n<property>\n  <name>hbase.bucketcache.bucket.sizes</name>\n  <value>4096,8192</value>\n</property>\n```\n\n<Callout type=\"info\" title=\"Direct Memory Usage In HBase\">\n  The default maximum direct memory varies by JVM. Traditionally it is 64M or some relation to allocated heap size (-Xmx) or no limit at all (JDK7 apparently). HBase servers use direct memory, in particular short-circuit reading (See [Leveraging local data](/docs/performance#leveraging-local-data)), the hosted DFSClient will allocate direct memory buffers. How much the DFSClient uses is not easy to quantify; it is the number of open HFiles \\* `hbase.dfs.client.read.shortcircuit.buffer.size` where `hbase.dfs.client.read.shortcircuit.buffer.size` is set to 128k in HBase — see *hbase-default.xml* default configurations. If you do off-heap block caching, you'll be making use of direct memory. The RPCServer uses a ByteBuffer pool. From 2.0.0, these buffers are off-heap ByteBuffers. Starting your JVM, make sure the `-XX:MaxDirectMemorySize` setting in *conf/hbase-env.sh* considers off-heap BlockCache (`hbase.bucketcache.size`), DFSClient usage, RPC side ByteBufferPool max size. This has to be bit higher than sum of off heap BlockCache size and max ByteBufferPool size. Allocating an extra of 1-2 GB for the max direct memory size has worked in tests. Direct memory, which is part of the Java process heap, is separate from the object heap allocated by -Xmx. The value allocated by `MaxDirectMemorySize` must not exceed physical RAM, and is likely to be less than the total available RAM due to other memory requirements and system constraints.\n\n  You can see how much memory — on-heap and off-heap/direct — a RegionServer is configured to use and how much it is using at any one time by looking at the *Server Metrics: Memory* tab in the UI. It can also be gotten via JMX. In particular the direct memory currently used by the server can be found on the `java.nio.type=BufferPool,name=direct` bean. Terracotta has a [good write up](https://web.archive.org/web/20170907032911/http://terracotta.org/documentation/4.0/bigmemorygo/configuration/storage-options) on using off-heap memory in Java. It is for their product BigMemory but a lot of the issues noted apply in general to any attempt at going off-heap. Check it out.\n</Callout>\n\n<Callout type=\"info\" title=\"hbase.bucketcache.percentage.in.combinedcache\">\n  This is a pre-HBase 1.0 configuration removed because it was confusing. It was a float that you would set to some value between 0.0 and 1.0. Its default was 0.9. If the deploy was using CombinedBlockCache, then the LruBlockCache L1 size was calculated to be `(1 - hbase.bucketcache.percentage.in.combinedcache) * size-of-bucketcache` and the BucketCache size was `hbase.bucketcache.percentage.in.combinedcache * size-of-bucket-cache`. where size-of-bucket-cache itself is EITHER the value of the configuration `hbase.bucketcache.size` IF it was specified as Megabytes OR `hbase.bucketcache.size` \\* `-XX:MaxDirectMemorySize` if `hbase.bucketcache.size` is between 0 and 1.0.\n\n  In 1.0, it should be more straight-forward. Onheap LruBlockCache size is set as a fraction of java heap using `hfile.block.cache.size setting` (not the best name) and BucketCache is set as above in absolute Megabytes.\n</Callout>\n\n### Time Based Priority for BucketCache\n\n[HBASE-28463](https://issues.apache.org/jira/browse/HBASE-28463) introduced time based priority for blocks in BucketCache. It allows for defining an age threshold at individual column families' configuration, whereby blocks older than this configured threshold would be targeted first for eviction.\n\nBlocks from column families that don't define the age threshold wouldn't be evaluated by the time based priority, and would only be evicted following the LRU eviction logic.\n\nThis feature is mostly useful for use cases where most recent data is more frequently accessed, and therefore should get higher priority in the cache. Configuring Time Based Priority with the \"age\" of most accessed data would then give a finer control over blocks allocation in the BucketCache than the built-in LRU eviction logic.\n\nTime Based Priority for BucketCache provides three different strategies for defining data age:\n\n* Cell timestamps: Uses the timestamp portion of HBase cells for comparing the data age.\n* Custom cell qualifiers: Uses a custom-defined date qualifier for comparing the data age. It uses that value to tier the entire row containing the given qualifier value. This requires that the custom qualifier be a valid Java long timestamp.\n* Custom value provider: Allows for defining a pluggable implementation that contains the logic for identifying the date value to be used for comparison. This also provides additional flexibility for different use cases that might have the date stored in other formats or embedded with other data in various portions of a given row.\n\nFor use cases where priority is determined by the order of record ingestion in HBase (with the most recent being the most relevant), the built-in cell timestamp offers the most convenient and efficient method for configuring age-based priority. See [Using Cell timestamps for Time Based Priority](/docs/architecture/regionserver#using-cell-timestamps-for-time-based-priority).\n\nSome applications may utilize a custom date column to define the priority of table records. In such instances, a custom cell qualifier-based priority is advisable. See [Using Custom Cell Qualifiers for Time Based Priority](/docs/architecture/regionserver#using-custom-cell-qualifiers-for-time-based-priority).\n\nFinally, more intricate schemas may incorporate domain-specific logic for defining the age of each record. The custom value provider facilitates the integration of custom code to implement the appropriate parsing of the date value that should be used for the priority comparison. See [Using a Custom value provider for Time Based Priority](/docs/architecture/regionserver#using-a-custom-value-provider-for-time-based-priority).\n\nWith Time Based Priority for BucketCache, blocks age is evaluated when deciding if a block should be cached (i.e. during reads, writes, compaction and prefetch), as well as during the cache freeSpace run (mass eviction), prior to executing the LRU logic.\n\nBecause blocks don't hold any specific meta information other than type, it's necessary to group blocks of the same \"age group\" on separate files, using specialized compaction implementations (see more details in the configuration section below). The time range of all blocks in each file is then appended at the file meta info section, and is used for evaluating the age of blocks that should be considered in the Time Based Priority logic.\n\n#### Configuring Time Based Priority for BucketCache\n\nFinding the age of each block involves an extra overhead, therefore the feature is disabled by default at a global configuration level.\n\nTo enable it, the following configuration should be set on RegionServers' *hbase-site.xml*:\n\n```xml\n<property>\n  <name>hbase.regionserver.datatiering.enable</name>\n  <value>true</value>\n</property>\n```\n\nOnce enabled globally, it's necessary to define the desired strategy-specific settings at the individual column family level.\n\n#### Using Cell timestamps for Time Based Priority\n\nThis strategy is the most efficient to run, as it uses the timestamp portion of each cell containing the data for comparing the age of blocks. It requires DateTieredCompaction for splitting the blocks into separate files according to blocks' ages.\n\nThe example below sets the hot age threshold to one week (in milliseconds) for the column family 'cf1' in table 'orders':\n\n```java\nhbase(main):003:0> alter 'orders', {NAME => 'cf1',\n  CONFIGURATION => {'hbase.hstore.datatiering.type' => 'TIME_RANGE',\n    'hbase.hstore.datatiering.hot.age.millis' => '604800000',\n    'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine',\n    'hbase.hstore.blockingStoreFiles' => '60',\n    'hbase.hstore.compaction.min' => '2',\n    'hbase.hstore.compaction.max' => '60'\n  }\n}\n```\n\n<Callout type=\"info\" title=\"Date Tiered Compaction specific tunings\">\n  In the example above, the properties governing the number of windows and period of each window in the date tiered compaction were not set. With the default settings, the compaction will create initially four windows of six hours, then four windows of one day each, then another four windows of four days each and so on until the minimum timestamp among the selected files is covered. This can create a large number of files, therefore, additional changes to the 'hbase.hstore.blockingStoreFiles', 'hbase.hstore.compaction.min' and 'hbase.hstore.compaction.max' are recommended.\n\n  Alternatively, consider adjusting the initial window size to the same as the hot age threshold, and two windows only per tier:\n\n  ```java\n  hbase(main):003:0> alter 'orders', {NAME => 'cf1',\n    CONFIGURATION => {'hbase.hstore.datatiering.type' => 'TIME_RANGE',\n      'hbase.hstore.datatiering.hot.age.millis' => '604800000',\n      'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine',\n      'hbase.hstore.compaction.date.tiered.base.window.millis' => '604800000',\n      'hbase.hstore.compaction.date.tiered.windows.per.tier' => '2'\n    }\n  }\n  ```\n</Callout>\n\n#### Using Custom Cell Qualifiers for Time Based Priority\n\nThis strategy uses a new compaction implementation designed for Time Based Priority. It extends date tiered compaction, but instead of producing multiple tiers of various time windows, it simply splits files into two groups: the \"cold\" group, where all blocks are older than the defined threshold age, and the \"hot\" group, where all blocks are newer than the threshold age.\n\nThe example below defines a cell qualifier 'event\\_date' to be used for comparing the age of blocks within the custom cell qualifier strategy:\n\n```java\nhbase(main):003:0> alter 'orders', {NAME => 'cf1',\n  CONFIGURATION => {'hbase.hstore.datatiering.type' => 'CUSTOM',\n    'TIERING_CELL_QUALIFIER' => 'event_date',\n    'hbase.hstore.datatiering.hot.age.millis' => '604800000',\n    'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.CustomTieredStoreEngine',\n    'hbase.hstore.compaction.date.tiered.custom.age.limit.millis' => '604800000'\n  }\n}\n```\n\n<Callout type=\"info\" title=\"Time Based Priority x Compaction Age Threshold Configurations\">\n  Note that there are two different configurations for defining the hot age threshold. This is\n  because the Time Based Priority enforcer operates independently of the compaction implementation.\n</Callout>\n\n#### Using a Custom value provider for Time Based Priority\n\nIt's also possible to hook in domain-specific logic for defining the data age of each row to be used for comparing blocks priorities. The Custom Time Based Priority framework defines the `CustomTieredCompactor.TieringValueProvider` interface, which can be implemented to provide the specific date value to be used by compaction for grouping the blocks according to the threshold age.\n\nIn the following example, the `RowKeyPortionTieringValueProvider` implements the `getTieringValue` method. This method parses the date from a segment of the row key value, specifically between positions 14 and 29, using the \"yyyyMMddHHmmss\" format. The parsed date is then returned as a long timestamp, which is then used by custom tiered compaction to group the blocks based on the defined hot age threshold:\n\n```java\npublic class RowKeyPortionTieringValueProvider implements CustomTieredCompactor.TieringValueProvider {\n   private SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n   @Override\n   public void init(Configuration configuration) throws Exception {}\n\n   @Override\n   public long getTieringValue(Cell cell) {\n     byte[] rowArray = new byte[cell.getRowLength()];\n     System.arraycopy(cell.getRowArray(), cell.getRowOffset(), rowArray, 0, cell.getRowLength());\n     String datePortion = Bytes.toString(rowArray).substring(14, 29).trim();\n     try {\n       return sdf.parse(datePortion).getTime();\n     } catch (ParseException e) {\n       //handle error\n     }\n     return Long.MAX_VALUE;\n   }\n}\n```\n\nThe Tiering Value Provider above can then be configured for Time Based Priority as follows:\n\n```java\nhbase(main):003:0> alter 'orders', {NAME => 'cf1',\n  CONFIGURATION => {'hbase.hstore.datatiering.type' => 'CUSTOM',\n    'hbase.hstore.custom-tiering-value.provider.class' =>\n      'org.apache.hbase.client.example.RowKeyPortionTieringValueProvider',\n    'hbase.hstore.datatiering.hot.age.millis' => '604800000',\n    'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.CustomTieredStoreEngine',\n    'hbase.hstore.compaction.date.tiered.custom.age.limit.millis' => '604800000'\n  }\n}\n```\n\n<Callout type=\"info\">\n  Upon enabling Custom Time Based Priority (either the custom qualifier or custom value provider) in\n  the column family configuration, it is imperative that major compaction be executed twice on the\n  specified tables to ensure the effective application of the newly configured priorities within the\n  bucket cache.\n</Callout>\n\n<Callout type=\"info\">\n  Time Based Priority was originally implemented with the cell timestamp strategy only. The original design covering cell timestamp based strategy is available [here](https://docs.google.com/document/d/1Qd3kvZodBDxHTFCIRtoePgMbvyuUSxeydi2SEWQFQro/edit?tab=t.0#heading=h.gjdgxs).\n\n  The second phase including the two custom strategies mentioned above is detailed in [this separate design doc](https://docs.google.com/document/d/1uBGIO9IQ-FbSrE5dnUMRtQS23NbCbAmRVDkAOADcU_E/edit?tab=t.0).\n</Callout>\n\n### Compressed BlockCache\n\n[HBASE-11331](https://issues.apache.org/jira/browse/HBASE-11331) introduced lazy BlockCache decompression, more simply referred to as compressed BlockCache. When compressed BlockCache is enabled data and encoded data blocks are cached in the BlockCache in their on-disk format, rather than being decompressed and decrypted before caching.\n\nFor a RegionServer hosting more data than can fit into cache, enabling this feature with SNAPPY compression has been shown to result in 50% increase in throughput and 30% improvement in mean latency while, increasing garbage collection by 80% and increasing overall CPU load by 2%. See HBASE-11331 for more details about how performance was measured and achieved. For a RegionServer hosting data that can comfortably fit into cache, or if your workload is sensitive to extra CPU or garbage-collection load, you may receive less benefit.\n\nThe compressed BlockCache is disabled by default. To enable it, set `hbase.block.data.cachecompressed` to `true` in *hbase-site.xml* on all RegionServers.\n\n### Cache Aware Load Balancer\n\nDepending on the data size and the configured cache size, the cache warm up can take anywhere from a few minutes to a few hours. This becomes even more critical for HBase deployments over cloud storage, where compute is separated from storage. Doing this everytime the region server starts can be a very expensive process. To eliminate this, [HBASE-27313](https://issues.apache.org/jira/browse/HBASE-27313) implemented the cache persistence feature where the region servers periodically persist the blocks cached in the bucket cache. This persisted information is then used to resurrect the cache in the event of a region server restart because of normal restart or crash.\n\n[HBASE-27999](https://issues.apache.org/jira/browse/HBASE-27999) implements the cache aware load balancer, which adds to the load balancer the ability to consider the cache allocation of each region on region servers when calculating a new assignment plan, using the region/region server cache allocation information reported by region servers to calculate the percentage of HFiles cached for each region on the hosting server. This information is then used by the balancer as a factor when deciding on an optimal, new assignment plan.\n\nThe master node captures the caching information from all the region servers and uses this information to decide on new region assignments while ensuring a minimal impact on the current cache allocation. A region is assigned to the region server where it has a better cache ratio as compared to the region server where it is currently hosted.\n\nThe CacheAwareLoadBalancer uses two cost elements for deciding the region allocation. These are described below:\n\n1. **Cache Cost**\\\n   The cache cost is calculated as the percentage of data for a region cached on the region server where it is either currently hosted or was previously hosted. A region may have multiple HFiles, each of different sizes. A HFile is considered to be fully prefetched when all the data blocks in this file are in the cache. The region server hosting this region calculates the ratio of number of HFiles fully cached in the cache to the total number of HFiles in the region. This ratio will vary from 0 (region hosted on this server, but none of its HFiles are cached into the cache) to 1 (region hosted on this server and all the HFiles for this region are cached into the cache).\\\n   Every region server maintains this information for all the regions currently hosted there. In addition to that, this cache ratio is also maintained for the regions which were previously hosted on this region server giving historical information about the regions.\n2. Skewness Cost\n\nThe cache aware balancer will consider cache cost with the skewness cost to decide on the region assignment plan under following conditions:\n\n1. There is an idle server in the cluster. This can happen when an existing server is restarted or a new server is added to the cluster.\n2. When the cost of maintaining the balance in the cluster is greater than the minimum threshold defined by the configuration *hbase.master.balancer.stochastic.minCostNeedBalance*.\n\nThe CacheAwareLoadBalancer can be enabled in the cluster by setting the following configuration properties in the master master configuration:\n\n```xml\n<property>\n  <name>hbase.master.loadbalancer.class</name>\n  <value>org.apache.hadoop.hbase.master.balancer.CacheAwareLoadBalancer</value>\n</property>\n<property>\n  <name>hbase.bucketcache.persistent.path</name>\n  <value>/path/to/bucketcache_persistent_file</value>\n</property>\n```\n\nWithin HBASE-29168, the CacheAwareLoadBalancer implements region move throttling. This mitigates the impact of \"losing\" cache factor when balancing mainly due to region skewness, i.e. when new region servers are added to the cluster, a large bulk of cached regions may move to the new servers at once, which can cause noticeable read performance impacts for cache sensitive use cases. The throttling sleep time is determined by the **hbase.master.balancer.move.throttlingMillis** property, and it defaults to 60000 millis. If a region planned to be moved has a cache ratio on the target server above the thershold configurable by the **hbase.master.balancer.stochastic.throttling.cacheRatio** property (80% by default), no throttling will be applied in this region move.\n\n## RegionServer Splitting Implementation\n\nAs write requests are handled by the region server, they accumulate in an in-memory storage system called the *memstore*. Once the memstore fills, its content are written to disk as additional store files. This event is called a *memstore flush*. As store files accumulate, the RegionServer will [compact](/docs/architecture/regions#compaction) them into fewer, larger files. After each flush or compaction finishes, the amount of data stored in the region has changed. The RegionServer consults the region split policy to determine if the region has grown too large or should be split for another policy-specific reason. A region split request is enqueued if the policy recommends it.\n\nLogically, the process of splitting a region is simple. We find a suitable point in the keyspace of the region where we should divide the region in half, then split the region's data into two new regions at that point. The details of the process however are not simple. When a split happens, the newly created *daughter regions* do not rewrite all the data into new files immediately. Instead, they create small files similar to symbolic link files, named [Reference files](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/Reference.html), which point to either the top or bottom part of the parent store file according to the split point. The reference file is used just like a regular data file, but only half of the records are considered. The region can only be split if there are no more references to the immutable data files of the parent region. Those reference files are cleaned gradually by compactions, so that the region will stop referring to its parents files, and can be split further.\n\nAlthough splitting the region is a local decision made by the RegionServer, the split process itself must coordinate with many actors. The RegionServer notifies the Master before and after the split, updates the `.META.` table so that clients can discover the new daughter regions, and rearranges the directory structure and data files in HDFS. Splitting is a multi-task process. To enable rollback in case of an error, the RegionServer keeps an in-memory journal about the execution state. The steps taken by the RegionServer to execute the split are illustrated in the \"RegionServer Split Process\" schema below. Each step is labeled with its step number. Actions from RegionServers or Master are shown in red, while actions from the clients are shown in green.\n\n<img alt=\"Region Split Process\" src={__img0} placeholder=\"blur\" />\n\n1. The RegionServer decides locally to split the region, and prepares the split. **THE SPLIT TRANSACTION IS STARTED.** As a first step, the RegionServer acquires a shared read lock on the table to prevent schema modifications during the splitting process. Then it creates a znode in zookeeper under `/hbase/region-in-transition/region-name`, and sets the znode's state to `SPLITTING`.\n2. The Master learns about this znode, since it has a watcher for the parent `region-in-transition` znode.\n3. The RegionServer creates a sub-directory named `.splits` under the parent's `region` directory in HDFS.\n4. The RegionServer closes the parent region and marks the region as offline in its local data structures. **THE SPLITTING REGION IS NOW OFFLINE.** At this point, client requests coming to the parent region will throw `NotServingRegionException`. The client will retry with some backoff. The closing region is flushed.\n5. The RegionServer creates region directories under the `.splits` directory, for daughter regions A and B, and creates necessary data structures. Then it splits the store files, in the sense that it creates two Reference files per store file in the parent region. Those reference files will point to the parent region's files.\n6. The RegionServer creates the actual region directory in HDFS, and moves the reference files for each daughter.\n7. The RegionServer sends a `Put` request to the `.META.` table, to set the parent as offline in the `.META.` table and add information about daughter regions. At this point, there won't be individual entries in `.META.` for the daughters. Clients will see that the parent region is split if they scan `.META.`, but won't know about the daughters until they appear in `.META.`. Also, if this `Put` to `.META`. succeeds, the parent will be effectively split. If the RegionServer fails before this RPC succeeds, Master and the next Region Server opening the region will clean dirty state about the region split. After the `.META.` update, though, the region split will be rolled-forward by Master.\n8. The RegionServer opens daughters A and B in parallel.\n9. The RegionServer adds the daughters A and B to `.META.`, together with information that it hosts the regions. **THE SPLIT REGIONS (DAUGHTERS WITH REFERENCES TO PARENT) ARE NOW ONLINE.** After this point, clients can discover the new regions and issue requests to them. Clients cache the `.META.` entries locally, but when they make requests to the RegionServer or `.META.`, their caches will be invalidated, and they will learn about the new regions from `.META.`.\n10. The RegionServer updates znode `/hbase/region-in-transition/region-name` in ZooKeeper to state `SPLIT`, so that the master can learn about it. The balancer can freely re-assign the daughter regions to other region servers if necessary. **THE SPLIT TRANSACTION IS NOW FINISHED.**\n11. After the split, `.META.` and HDFS will still contain references to the parent region. Those references will be removed when compactions in daughter regions rewrite the data files. Garbage collection tasks in the master periodically check whether the daughter regions still refer to the parent region's files. If not, the parent region will be removed.\n\n## Write Ahead Log (WAL)\n\n### Purpose\n\nThe *Write Ahead Log (WAL)* records all changes to data in HBase, to file-based storage. Under normal operations, the WAL is not needed because data changes move from the MemStore to StoreFiles. However, if a RegionServer crashes or becomes unavailable before the MemStore is flushed, the WAL ensures that the changes to the data can be replayed. If writing to the WAL fails, the entire operation to modify the data fails.\n\nHBase uses an implementation of the [WAL](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/wal/WAL.html) interface. Usually, there is only one instance of a WAL per RegionServer. An exception is the RegionServer that is carrying *hbase:meta*; the *meta* table gets its own dedicated WAL. The RegionServer records Puts and Deletes to its WAL, before recording them these Mutations [MemStore](/docs/architecture/regions#memstore) for the affected [Store](/docs/architecture/regions#store).\n\n<Callout type=\"info\" title=\"The HLog\">\n  Prior to 2.0, the interface for WALs in HBase was named `HLog`. In 0.94, HLog was the name of the\n  implementation of the WAL. You will likely find references to the HLog in documentation tailored\n  to these older versions.\n</Callout>\n\nThe WAL resides in HDFS in the */hbase/WALs/* directory, with subdirectories per RegionServer.\n\nFor more general information about the concept of write ahead logs, see the Wikipedia [Write-Ahead Log](http://en.wikipedia.org/wiki/Write-ahead_logging) article.\n\n### WAL Providers\n\nIn HBase, there are a number of WAL implementations (or 'Providers'). Each is known by a short name label (that unfortunately is not always descriptive). You set the provider in *hbase-site.xml* passing the WAL provider short-name as the value on the *hbase.wal.provider* property (Set the provider for *hbase:meta* using the *hbase.wal.meta\\_provider* property, otherwise it uses the same provider configured by *hbase.wal.provider*).\n\n* *asyncfs*: The **default**. New since hbase-2.0.0 (HBASE-15536, HBASE-14790). This *AsyncFSWAL* provider, as it identifies itself in RegionServer logs, is built on a new non-blocking dfsclient implementation. It is currently resident in the hbase codebase but intent is to move it back up into HDFS itself. WALs edits are written concurrently (\"fan-out\") style to each of the WAL-block replicas on each DataNode rather than in a chained pipeline as the default client does. Latencies should be better. See [Apache HBase Improvements and Practices at Xiaomi](https://www.slideshare.net/HBaseCon/apache-hbase-improvements-and-practices-at-xiaomi) at slide 14 onward for more detail on implementation.\n* *filesystem*: This was the default in hbase-1.x releases. It is built on the blocking *DFSClient* and writes to replicas in classic *DFSCLient* pipeline mode. In logs it identifies as *FSHLog* or *FSHLogProvider*.\n* *multiwal*: This provider is made of multiple instances of *asyncfs* or *filesystem*. See the next section for more on *multiwal*.\n\nLook for the lines like the below in the RegionServer log to see which provider is in place (The below shows the default AsyncFSWALProvider):\n\n```java\n2018-04-02 13:22:37,983 INFO  [regionserver/ve0528:16020] wal.WALFactory: Instantiating WALProvider of type class org.apache.hadoop.hbase.wal.AsyncFSWALProvider\n```\n\n<Callout type=\"info\">\n  As the *AsyncFSWAL* hacks into the internal of DFSClient implementation, it will be easily broken\n  by upgrading the hadoop dependencies, even for a simple patch release. So if you do not specify\n  the wal provider explicitly, we will first try to use the *asyncfs*, if failed, we will fall back\n  to use *filesystem*. And notice that this may not always work, so if you still have problem\n  starting HBase due to the problem of starting *AsyncFSWAL*, please specify *filesystem* explicitly\n  in the config file.\n</Callout>\n\n<Callout type=\"info\">\n  EC support has been added to hadoop-3.x, and it is incompatible with WAL as the EC output stream\n  does not support hflush/hsync. In order to create a non-EC file in an EC directory, we need to use\n  the new builder-based create API for *FileSystem*, but it is only introduced in hadoop-2.9+ and\n  for HBase we still need to support hadoop-2.7.x. So please do not enable EC for the WAL directory\n  until we find a way to deal with it.\n</Callout>\n\n### MultiWAL\n\nWith a single WAL per RegionServer, the RegionServer must write to the WAL serially, because HDFS files must be sequential. This causes the WAL to be a performance bottleneck.\n\nHBase 1.0 introduces support MultiWal in [HBASE-5699](https://issues.apache.org/jira/browse/HBASE-5699). MultiWAL allows a RegionServer to write multiple WAL streams in parallel, by using multiple pipelines in the underlying HDFS instance, which increases total throughput during writes. This parallelization is done by partitioning incoming edits by their Region. Thus, the current implementation will not help with increasing the throughput to a single Region.\n\nRegionServers using the original WAL implementation and those using the MultiWAL implementation can each handle recovery of either set of WALs, so a zero-downtime configuration update is possible through a rolling restart.\n\n#### Configure MultiWAL\n\nTo configure MultiWAL for a RegionServer, set the value of the property `hbase.wal.provider` to `multiwal` by pasting in the following XML:\n\n```xml\n<property>\n  <name>hbase.wal.provider</name>\n  <value>multiwal</value>\n</property>\n```\n\nRestart the RegionServer for the changes to take effect.\n\nTo disable MultiWAL for a RegionServer, unset the property and restart the RegionServer.\n\n### WAL Flushing\n\nTODO (describe).\n\n### WAL Splitting\n\nA RegionServer serves many regions. All of the regions in a region server share the same active WAL file. Each edit in the WAL file includes information about which region it belongs to. When a region is opened, the edits in the WAL file which belong to that region need to be replayed. Therefore, edits in the WAL file must be grouped by region so that particular sets can be replayed to regenerate the data in a particular region. The process of grouping the WAL edits by region is called *log splitting*. It is a critical process for recovering data if a region server fails.\n\nLog splitting is done by the HMaster during cluster start-up or by the ServerShutdownHandler as a region server shuts down. So that consistency is guaranteed, affected regions are unavailable until data is restored. All WAL edits need to be recovered and replayed before a given region can become available again. As a result, regions affected by log splitting are unavailable until the process completes.\n\n#### Procedure: Log Splitting, Step by Step\n\n<Steps>\n  <Step>\n    ##### The `/hbase/WALs/HOST,PORT,STARTCODE` directory is renamed\n\n    Renaming the directory is important because a RegionServer may still be up and accepting requests even if the HMaster thinks it is down. If the RegionServer does not respond immediately and does not heartbeat its ZooKeeper session, the HMaster may interpret this as a RegionServer failure. Renaming the logs directory ensures that existing, valid WAL files which are still in use by an active but busy RegionServer are not written to by accident.\n\n    The new directory is named according to the following pattern:\n\n    ```text\n    /hbase/WALs/HOST,PORT,STARTCODE-splitting\n    ```\n\n    An example of such a renamed directory might look like the following:\n\n    ```text\n    /hbase/WALs/srv.example.com,60020,1254173957298-splitting\n    ```\n  </Step>\n\n  <Step>\n    ##### Each log file is split, one at a time\n\n    The log splitter reads the log file one edit entry at a time and puts each edit entry into the buffer corresponding to the edit's region. At the same time, the splitter starts several writer threads. Writer threads pick up a corresponding buffer and write the edit entries in the buffer to a temporary recovered edit file. The temporary edit file is stored to disk with the following naming pattern:\n\n    ```text\n    /hbase/TABLE_NAME/REGION_ID/recovered.edits/.temp\n    ```\n\n    This file is used to store all the edits in the WAL log for this region. After log splitting completes, the *.temp* file is renamed to the sequence ID of the first log written to the file.\n\n    To determine whether all edits have been written, the sequence ID is compared to the sequence of the last edit that was written to the HFile. If the sequence of the last edit is greater than or equal to the sequence ID included in the file name, it is clear that all writes from the edit file have been completed.\n  </Step>\n\n  <Step>\n    ##### After log splitting is complete, each affected region is assigned to a RegionServer\n\n    When the region is opened, the *recovered.edits* folder is checked for recovered edits files. If any such files are present, they are replayed by reading the edits and saving them to the MemStore. After all edit files are replayed, the contents of the MemStore are written to disk (HFile) and the edit files are deleted.\n  </Step>\n</Steps>\n\n#### Handling of Errors During Log Splitting\n\nIf you set the `hbase.hlog.split.skip.errors` option to `true`, errors are treated as follows:\n\n* Any error encountered during splitting will be logged.\n* The problematic WAL log will be moved into the *.corrupt* directory under the hbase `rootdir`,\n* Processing of the WAL will continue\n\nIf the `hbase.hlog.split.skip.errors` option is set to `false`, the default, the exception will be propagated and the split will be logged as failed. See [HBASE-2958 When hbase.hlog.split.skip.errors is set to false, we fail the split but that's it](https://issues.apache.org/jira/browse/HBASE-2958). We need to do more than just fail split if this flag is set.\n\n#### How EOFExceptions are treated when splitting a crashed RegionServer's WALs\n\nIf an EOFException occurs while splitting logs, the split proceeds even when `hbase.hlog.split.skip.errors` is set to `false`. An EOFException while reading the last log in the set of files to split is likely, because the RegionServer was likely in the process of writing a record at the time of a crash. For background, see [HBASE-2643 Figure how to deal with eof splitting logs](https://issues.apache.org/jira/browse/HBASE-2643)\n\n#### Performance Improvements during Log Splitting\n\nWAL log splitting and recovery can be resource intensive and take a long time, depending on the number of RegionServers involved in the crash and the size of the regions. [Distributed log splitting](/docs/architecture/regionserver#enabling-or-disabling-distributed-log-splitting) was developed to improve performance during log splitting.\n\n#### Enabling or Disabling Distributed Log Splitting\n\nDistributed log processing is enabled by default since HBase 0.92. The setting is controlled by the `hbase.master.distributed.log.splitting` property, which can be set to `true` or `false`, but defaults to `true`.\n\n### WAL splitting based on procedureV2\n\nAfter HBASE-20610, we introduce a new way to do WAL splitting coordination by procedureV2 framework. This can simplify the process of WAL splitting and no need to connect zookeeper any more.\n\n#### Background \\[!toc]\n\nCurrently, splitting WAL processes are coordinated by zookeeper. Each region server are trying to grab tasks from zookeeper. And the burden becomes heavier when the number of region server increase.\n\n#### Implementation on Master side \\[!toc]\n\nDuring ServerCrashProcedure, SplitWALManager will create one SplitWALProcedure for each WAL file which should be split. Then each SplitWALProcedure will spawn a SplitWalRemoteProcedure to send the request to region server. SplitWALProcedure is a StateMachineProcedure and here is the state transfer diagram.\n\n<img alt=\"WAL splitting\" src={__img1} placeholder=\"blur\" />\n\n#### Implementation on Region Server side \\[!toc]\n\nRegion Server will receive a SplitWALCallable and execute it, which is much more straightforward than before. It will return null if success and return exception if there is any error.\n\n#### Performance \\[!toc]\n\nAccording to tests on a cluster which has 5 regionserver and 1 master. procedureV2 coordinated WAL splitting has a better performance than ZK coordinated WAL splitting no master when restarting the whole cluster or one region server crashing.\n\n#### Enable this feature \\[!toc]\n\nTo enable this feature, first we should ensure our package of HBase already contains these code. If not, please upgrade the package of HBase cluster without any configuration change first. Then change configuration 'hbase.split.wal.zk.coordinated' to false. Rolling upgrade the master with new configuration. Now WAL splitting are handled by our new implementation. But region server are still trying to grab tasks from zookeeper, we can rolling upgrade the region servers with the new configuration to stop that.\n\n* Steps as follows:\n  * Upgrade whole cluster to get the new Implementation.\n  * Upgrade Master with new configuration 'hbase.split.wal.zk.coordinated'=false.\n  * Upgrade region server to stop grab tasks from zookeeper.\n\n### WAL Compression\n\nThe content of the WAL can be compressed using LRU Dictionary compression. This can be used to speed up WAL replication to different datanodes. The dictionary can store up to 2<sup>15</sup> elements; eviction starts after this number is exceeded.\n\nTo enable WAL compression, set the `hbase.regionserver.wal.enablecompression` property to `true`. The default value for this property is `false`. By default, WAL tag compression is turned on when WAL compression is enabled. You can turn off WAL tag compression by setting the `hbase.regionserver.wal.tags.enablecompression` property to 'false'.\n\nA possible downside to WAL compression is that we lose more data from the last block in the WAL if it is ill-terminated mid-write. If entries in this last block were added with new dictionary entries but we failed persist the amended dictionary because of an abrupt termination, a read of this last block may not be able to resolve last-written entries.\n\n### Durability\n\nIt is possible to set *durability* on each Mutation or on a Table basis. Options include:\n\n* *SKIP\\_WAL*: Do not write Mutations to the WAL (See the next section, [Disabling the WAL](/docs/architecture/regionserver#disabling-the-wal)).\n* *ASYNC\\_WAL*: Write the WAL asynchronously; do not hold-up clients waiting on the sync of their write to the filesystem but return immediately. The edit becomes visible. Meanwhile, in the background, the Mutation will be flushed to the WAL at some time later. This option currently may lose data. See HBASE-16689.\n* *SYNC\\_WAL*: The **default**. Each edit is sync'd to HDFS before we return success to the client.\n* *FSYNC\\_WAL*: Each edit is fsync'd to HDFS and the filesystem before we return success to the client.\n\nDo not confuse the *ASYNC\\_WAL* option on a Mutation or Table with the *AsyncFSWAL* writer; they are distinct options unfortunately closely named\n\n### Custom WAL Directory\n\nHBASE-17437 added support for specifying a WAL directory outside the HBase root directory or even in a different FileSystem since 1.3.3/2.0+. Some FileSystems (such as Amazon S3) don't support append or consistent writes, in such scenario WAL directory needs to be configured in a different FileSystem to avoid loss of writes.\n\nFollowing configurations are added to accomplish this:\n\n1. `hbase.wal.dir`\\\n   This defines where the root WAL directory is located, could be on a different FileSystem than the root directory. WAL directory can not be set to a subdirectory of the root directory. The default value of this is the root directory if unset.\n2. `hbase.rootdir.perms`\\\n   Configures FileSystem permissions to set on the root directory. This is '700' by default.\n3. `hbase.wal.dir.perms`\\\n   Configures FileSystem permissions to set on the WAL directory FileSystem. This is '700' by default.\n\n<Callout type=\"info\">\n  While migrating to custom WAL dir (outside the HBase root directory or a different FileSystem)\n  existing WAL files must be copied manually to new WAL dir, otherwise it may lead to data\n  loss/inconsistency as HMaster has no information about previous WAL directory.\n</Callout>\n\n### Disabling the WAL\n\nIt is possible to disable the WAL, to improve performance in certain specific situations. However, disabling the WAL puts your data at risk. The only situation where this is recommended is during a bulk load. This is because, in the event of a problem, the bulk load can be re-run with no risk of data loss.\n\nThe WAL is disabled by calling the HBase client field `Mutation.writeToWAL(false)`. Use the `Mutation.setDurability(Durability.SKIP_WAL)` and Mutation.getDurability() methods to set and get the field's value. There is no way to disable the WAL for only a specific table.\n\n<Callout type=\"warn\">\n  If you disable the WAL for anything other than bulk loads, your data is at risk.\n</Callout>\n\n## Regions\n\nRegions are the basic element of availability and distribution for tables, and are comprised of a Store per Column Family. The hierarchy of objects is as follows:\n\n```\nTable                    (HBase table)\n    Region               (Regions for the table)\n        Store            (Store per ColumnFamily for each Region for the table)\n            MemStore     (MemStore for each Store for each Region for the table)\n            StoreFile    (StoreFiles for each Store for each Region for the table)\n                Block    (Blocks within a StoreFile within a Store for each Region for the table)\n```\n\nFor a description of what HBase files look like when written to HDFS, see [Browsing HDFS for HBase Objects](/docs/troubleshooting#browsing-hdfs-for-hbase-objects).\n\n## Considerations for Number of Regions\n\nIn general, HBase is designed to run with a small (20-200) number of relatively large (5-20Gb) regions per server. The considerations for this are as follows:\n\n### Why should I keep my Region count low?\n\nTypically you want to keep your region count low on HBase for numerous reasons. Usually right around 100 regions per RegionServer has yielded the best results. Here are some of the reasons below for keeping region count low:\n\n1. MSLAB (MemStore-local allocation buffer) requires 2MB per MemStore (that's 2MB per family per region). 1000 regions that have 2 families each is 3.9GB of heap used, and it's not even storing data yet. NB: the 2MB value is configurable.\n2. If you fill all the regions at somewhat the same rate, the global memory usage makes it that it forces tiny flushes when you have too many regions which in turn generates compactions. Rewriting the same data tens of times is the last thing you want. An example is filling 1000 regions (with one family) equally and let's consider a lower bound for global MemStore usage of 5GB (the region server would have a big heap). Once it reaches 5GB it will force flush the biggest region, at that point they should almost all have about 5MB of data so it would flush that amount. 5MB inserted later, it would flush another region that will now have a bit over 5MB of data, and so on. This is currently the main limiting factor for the number of regions; see [Number of regions per RS - upper bound](/docs/operational-management/region-and-capacity#number-of-regions-per-rs---upper-bound) for detailed formula.\n3. The master as is is allergic to tons of regions, and will take a lot of time assigning them and moving them around in batches. The reason is that it's heavy on ZK usage, and it's not very async at the moment (could really be improved — and has been improved a bunch in 0.96 HBase).\n4. In older versions of HBase (pre-HFile v2, 0.90 and previous), tons of regions on a few RS can cause the store file index to rise, increasing heap usage and potentially creating memory pressure or OOME on the RSs\n\nAnother issue is the effect of the number of regions on MapReduce jobs; it is typical to have one mapper per HBase region. Thus, hosting only 5 regions per RS may not be enough to get sufficient number of tasks for a MapReduce job, while 1000 regions will generate far too many tasks.\n\nSee [Determining region count and size](/docs/operational-management/region-and-capacity#determining-region-count-and-size) for configuration guidelines.\n\n## Region-RegionServer Assignment\n\nThis section describes how Regions are assigned to RegionServers.\n\n### Startup\n\nWhen HBase starts regions are assigned as follows (short version):\n\n1. The Master invokes the `AssignmentManager` upon startup.\n2. The `AssignmentManager` looks at the existing region assignments in `hbase:meta`.\n3. If the region assignment is still valid (i.e., if the RegionServer is still online) then the assignment is kept.\n4. If the assignment is invalid, then the `LoadBalancerFactory` is invoked to assign the region. The load balancer (`StochasticLoadBalancer` by default in HBase 1.0) assign the region to a RegionServer.\n5. `hbase:meta` is updated with the RegionServer assignment (if needed) and the RegionServer start codes (start time of the RegionServer process) upon region opening by the RegionServer.\n\n### Failover\n\nWhen a RegionServer fails:\n\n1. The regions immediately become unavailable because the RegionServer is down.\n2. The Master will detect that the RegionServer has failed.\n3. The region assignments will be considered invalid and will be re-assigned just like the startup sequence.\n4. In-flight queries are re-tried, and not lost.\n5. Operations are switched to a new RegionServer within the following amount of time:\n   ```text\n   ZooKeeper session timeout + split time + assignment/replay time\n   ```\n\n### Region Load Balancing\n\nRegions can be periodically moved by the [LoadBalancer](/docs/architecture/master#loadbalancer).\n\n### Region State Transition\n\nHBase maintains a state for each region and persists the state in `hbase:meta`. The state of the `hbase:meta` region itself is persisted in ZooKeeper. You can see the states of regions in transition in the Master web UI. Following is the list of possible region states.\n\n**Possible Region States:**\n\n* `OFFLINE`: the region is offline and not opening\n* `OPENING`: the region is in the process of being opened\n* `OPEN`: the region is open and the RegionServer has notified the master\n* `FAILED_OPEN`: the RegionServer failed to open the region\n* `CLOSING`: the region is in the process of being closed\n* `CLOSED`: the RegionServer has closed the region and notified the master\n* `FAILED_CLOSE`: the RegionServer failed to close the region\n* `SPLITTING`: the RegionServer notified the master that the region is splitting\n* `SPLIT`: the RegionServer notified the master that the region has finished splitting\n* `SPLITTING_NEW`: this region is being created by a split which is in progress\n* `MERGING`: the RegionServer notified the master that this region is being merged with another region\n* `MERGED`: the RegionServer notified the master that this region has been merged\n* `MERGING_NEW`: this region is being created by a merge of two regions\n\n<img alt=\"Region states\" src={__img2} placeholder=\"blur\" />\n\n**Graph Legend:**\n\n* Brown: Offline state, a special state that can be transient (after closed before opening), terminal (regions of disabled tables), or initial (regions of newly created tables)\n* Palegreen: Online state that regions can serve requests\n* Lightblue: Transient states\n* Red: Failure states that need OPS attention\n* Gold: Terminal states of regions split/merged\n* Grey: Initial states of regions created through split/merge\n\n**Transition State Descriptions:**\n\n1. The master moves a region from `OFFLINE` to `OPENING` state and tries to assign the region to a RegionServer. The RegionServer may or may not have received the open region request. The master retries sending the open region request to the RegionServer until the RPC goes through or the master runs out of retries. After the RegionServer receives the open region request, the RegionServer begins opening the region.\n2. If the master is running out of retries, the master prevents the RegionServer from opening the region by moving the region to `CLOSING` state and trying to close it, even if the RegionServer is starting to open the region.\n3. After the RegionServer opens the region, it continues to try to notify the master until the master moves the region to `OPEN` state and notifies the RegionServer. The region is now open.\n4. If the RegionServer cannot open the region, it notifies the master. The master moves the region to `CLOSED` state and tries to open the region on a different RegionServer.\n5. If the master cannot open the region on any of a certain number of regions, it moves the region to `FAILED_OPEN` state, and takes no further action until an operator intervenes from the HBase shell, or the server is dead.\n6. The master moves a region from `OPEN` to `CLOSING` state. The RegionServer holding the region may or may not have received the close region request. The master retries sending the close request to the server until the RPC goes through or the master runs out of retries.\n7. If the RegionServer is not online, or throws `NotServingRegionException`, the master moves the region to `OFFLINE` state and re-assigns it to a different RegionServer.\n8. If the RegionServer is online, but not reachable after the master runs out of retries, the master moves the region to `FAILED_CLOSE` state and takes no further action until an operator intervenes from the HBase shell, or the server is dead.\n9. If the RegionServer gets the close region request, it closes the region and notifies the master. The master moves the region to `CLOSED` state and re-assigns it to a different RegionServer.\n10. Before assigning a region, the master moves the region to `OFFLINE` state automatically if it is in `CLOSED` state.\n11. When a RegionServer is about to split a region, it notifies the master. The master moves the region to be split from `OPEN` to `SPLITTING` state and add the two new regions to be created to the RegionServer. These two regions are in `SPLITTING_NEW` state initially.\n12. After notifying the master, the RegionServer starts to split the region. Once past the point of no return, the RegionServer notifies the master again so the master can update the `hbase:meta` table. However, the master does not update the region states until it is notified by the server that the split is done. If the split is successful, the splitting region is moved from `SPLITTING` to `SPLIT` state and the two new regions are moved from `SPLITTING_NEW` to `OPEN` state.\n13. If the split fails, the splitting region is moved from `SPLITTING` back to `OPEN` state, and the two new regions which were created are moved from `SPLITTING_NEW` to `OFFLINE` state.\n14. When a RegionServer is about to merge two regions, it notifies the master first. The master moves the two regions to be merged from `OPEN` to `MERGING` state, and adds the new region which will hold the contents of the merged regions region to the RegionServer. The new region is in `MERGING_NEW` state initially.\n15. After notifying the master, the RegionServer starts to merge the two regions. Once past the point of no return, the RegionServer notifies the master again so the master can update the META. However, the master does not update the region states until it is notified by the RegionServer that the merge has completed. If the merge is successful, the two merging regions are moved from `MERGING` to `MERGED` state and the new region is moved from `MERGING_NEW` to `OPEN` state.\n16. If the merge fails, the two merging regions are moved from `MERGING` back to `OPEN` state, and the new region which was created to hold the contents of the merged regions is moved from `MERGING_NEW` to `OFFLINE` state.\n17. For regions in `FAILED_OPEN` or `FAILED_CLOSE` states, the master tries to close them again when they are reassigned by an operator via HBase Shell.\n\n## Region-RegionServer Locality\n\nOver time, Region-RegionServer locality is achieved via HDFS block replication. The HDFS client does the following by default when choosing locations to write replicas:\n\n1. First replica is written to local node\n2. Second replica is written to a random node on another rack\n3. Third replica is written on the same rack as the second, but on a different node chosen randomly\n4. Subsequent replicas are written on random nodes on the cluster. See *Replica Placement: The First Baby Steps* on this page: [HDFS Architecture](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html)\n\nThus, HBase eventually achieves locality for a region after a flush or a compaction. In a RegionServer failover situation a RegionServer may be assigned regions with non-local StoreFiles (because none of the replicas are local), however as new data is written in the region, or the table is compacted and StoreFiles are re-written, they will become \"local\" to the RegionServer.\n\nFor more information, see *Replica Placement: The First Baby Steps* on this page: [HDFS Architecture](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) and also Lars George's blog on [HBase and HDFS locality](http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html).\n\n## Region Splits\n\nRegions split when they reach a configured threshold. Below we treat the topic in short. For a longer exposition, see [Apache HBase Region Splitting and Merging](http://hortonworks.com/blog/apache-hbase-region-splitting-and-merging/) by our Enis Soztutar.\n\nSplits run unaided on the RegionServer; i.e. the Master does not participate. The RegionServer splits a region, offlines the split region and then adds the daughter regions to `hbase:meta`, opens daughters on the parent's hosting RegionServer and then reports the split to the Master. See [Managed Splitting](/docs/configuration/important#managed-splitting) for how to manually manage splits (and for why you might do this).\n\n### Custom Split Policies\n\nYou can override the default split policy using a custom [RegionSplitPolicy](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/regionserver/RegionSplitPolicy.html) (HBase 0.94+). Typically a custom split policy should extend HBase's default split policy: [IncreasingToUpperBoundRegionSplitPolicy](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/regionserver/IncreasingToUpperBoundRegionSplitPolicy.html).\n\nThe policy can set globally through the HBase configuration or on a per-table basis.\n\n#### Configuring the Split Policy Globally in *hbase-site.xml*\n\n```xml\n<property>\n  <name>hbase.regionserver.region.split.policy</name>\n  <value>org.apache.hadoop.hbase.regionserver.IncreasingToUpperBoundRegionSplitPolicy</value>\n</property>\n```\n\n#### Configuring a Split Policy On a Table Using the Java API\n\n```java\nHTableDescriptor tableDesc = new HTableDescriptor(\"test\");\ntableDesc.setValue(HTableDescriptor.SPLIT_POLICY, ConstantSizeRegionSplitPolicy.class.getName());\ntableDesc.addFamily(new HColumnDescriptor(Bytes.toBytes(\"cf1\")));\nadmin.createTable(tableDesc);\n```\n\n#### Configuring the Split Policy On a Table Using HBase Shell\n\n```ruby\nhbase> create 'test', {METADATA => {'SPLIT_POLICY' => 'org.apache.hadoop.hbase.regionserver.ConstantSizeRegionSplitPolicy'}},{NAME => 'cf1'}\n```\n\nThe policy can be set globally through the HBaseConfiguration used or on a per table basis:\n\n```java\nHTableDescriptor myHtd = ...;\nmyHtd.setValue(HTableDescriptor.SPLIT_POLICY, MyCustomSplitPolicy.class.getName());\n```\n\n<Callout type=\"info\">\n  The `DisabledRegionSplitPolicy` policy blocks manual region splitting.\n</Callout>\n\n## Manual Region Splitting\n\nIt is possible to manually split your table, either at table creation (pre-splitting), or at a later time as an administrative action. You might choose to split your region for one or more of the following reasons. There may be other valid reasons, but the need to manually split your table might also point to problems with your schema design.\n\n**Reasons to Manually Split Your Table:**\n\n* Your data is sorted by timeseries or another similar algorithm that sorts new data at the end of the table. This means that the Region Server holding the last region is always under load, and the other Region Servers are idle, or mostly idle. See also [Monotonically Increasing Row Keys/Timeseries Data](/docs/regionserver-sizing#monotonically-increasing-row-keystimeseries-data).\n* You have developed an unexpected hotspot in one region of your table. For instance, an application which tracks web searches might be inundated by a lot of searches for a celebrity in the event of news about that celebrity. See [perf.one.region](/docs/performance#anti-pattern-one-hot-region) for more discussion about this particular scenario.\n* After a big increase in the number of RegionServers in your cluster, to get the load spread out quickly.\n* Before a bulk-load which is likely to cause unusual and uneven load across regions.\n\nSee [Managed Splitting](/docs/configuration/important#managed-splitting) for a discussion about the dangers and possible benefits of managing splitting completely manually.\n\n<Callout type=\"info\">\n  The `DisabledRegionSplitPolicy` policy blocks manual region splitting.\n</Callout>\n\n### Determining Split Points\n\nThe goal of splitting your table manually is to improve the chances of balancing the load across the cluster in situations where good rowkey design alone won't get you there. Keeping that in mind, the way you split your regions is very dependent upon the characteristics of your data. It may be that you already know the best way to split your table. If not, the way you split your table depends on what your keys are like.\n\n**Alphanumeric Rowkeys**\\\nIf your rowkeys start with a letter or number, you can split your table at letter or number boundaries. For instance, the following command creates a table with regions that split at each vowel, so the first region has A-D, the second region has E-H, the third region has I-N, the fourth region has O-V, and the fifth region has U-Z.\n\n**Using a Custom Algorithm**\\\nThe RegionSplitter tool is provided with HBase, and uses a *SplitAlgorithm* to determine split points for you. As parameters, you give it the algorithm, desired number of regions, and column families. It includes three split algorithms. The first is the [`HexStringSplit`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/util/RegionSplitter.HexStringSplit.html) algorithm, which assumes the row keys are hexadecimal strings. The second is the [`DecimalStringSplit`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/util/RegionSplitter.DecimalStringSplit.html) algorithm, which assumes the row keys are decimal strings in the range 00000000 to 99999999. The third, [`UniformSplit`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/util/RegionSplitter.UniformSplit.html), assumes the row keys are random byte arrays. You will probably need to develop your own [`SplitAlgorithm`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/util/RegionSplitter.SplitAlgorithm.html), using the provided ones as models.\n\n## Online Region Merges\n\nBoth Master and RegionServer participate in the event of online region merges. Client sends merge RPC to the master, then the master moves the regions together to the RegionServer where the more heavily loaded region resided. Finally the master sends the merge request to this RegionServer which then runs the merge. Similar to process of region splitting, region merges run as a local transaction on the RegionServer. It offlines the regions and then merges two regions on the file system, atomically delete merging regions from `hbase:meta` and adds the merged region to `hbase:meta`, opens the merged region on the RegionServer and reports the merge to the Master.\n\nAn example of region merges in the HBase shell\n\n```ruby\n$ hbase> merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME'\n$ hbase> merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME', true\n```\n\nIt's an asynchronous operation and call returns immediately without waiting merge completed. Passing `true` as the optional third parameter will force a merge. Normally only adjacent regions can be merged. The `force` parameter overrides this behaviour and is for expert use only.\n\n## Store\n\nA Store hosts a MemStore and 0 or more StoreFiles (HFiles). A Store corresponds to a column family for a table for a given region.\n\n### MemStore\n\nThe MemStore holds in-memory modifications to the Store. Modifications are Cells/KeyValues. When a flush is requested, the current MemStore is moved to a snapshot and is cleared. HBase continues to serve edits from the new MemStore and backing snapshot until the flusher reports that the flush succeeded. At this point, the snapshot is discarded. Note that when the flush happens, MemStores that belong to the same region will all be flushed.\n\n### MemStore Flush\n\nA MemStore flush can be triggered under any of the conditions listed below. The minimum flush unit is per region, not at individual MemStore level.\n\n1. When a MemStore reaches the size specified by `hbase.hregion.memstore.flush.size`, all MemStores that belong to its region will be flushed out to disk.\n2. When the overall MemStore usage reaches the value specified by `hbase.regionserver.global.memstore.upperLimit`, MemStores from various regions will be flushed out to disk to reduce overall MemStore usage in a RegionServer.\\\n   The flush order is based on the descending order of a region's MemStore usage. Regions will have their MemStores flushed until the overall MemStore usage drops to or slightly below `hbase.regionserver.global.memstore.lowerLimit`.\n3. When the number of WAL log entries in a given region server's WAL reaches the value specified in `hbase.regionserver.max.logs`, MemStores from various regions will be flushed out to disk to reduce the number of logs in the WAL.\\\n   The flush order is based on time. Regions with the oldest MemStores are flushed first until WAL count drops below `hbase.regionserver.max.logs`.\n\n### Scans\n\n* When a client issues a scan against a table, HBase generates `RegionScanner` objects, one per region, to serve the scan request.\n* The `RegionScanner` object contains a list of `StoreScanner` objects, one per column family.\n* Each `StoreScanner` object further contains a list of `StoreFileScanner` objects, corresponding to each StoreFile and HFile of the corresponding column family, and a list of `KeyValueScanner` objects for the MemStore.\n* The two lists are merged into one, which is sorted in ascending order with the scan object for the MemStore at the end of the list.\n* When a `StoreFileScanner` object is constructed, it is associated with a `MultiVersionConcurrencyControl` read point, which is the current `memstoreTS`, filtering out any new updates beyond the read point.\n\n### StoreFile (HFile)\n\nStoreFiles are where your data lives.\n\n#### HFile Format\n\nThe *HFile* file format is based on the SSTable file described in the [BigTable \\[2006](http://research.google.com/archive/bigtable.html)] paper and on Hadoop's [TFile](https://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/file/tfile/TFile.html) (The unit test suite and the compression harness were taken directly from TFile). Schubert Zhang's blog post on [HFile: A Block-Indexed File Format to Store Sorted Key-Value Pairs](http://cloudepr.blogspot.com/2009/09/hfile-block-indexed-file-format-to.html) makes for a thorough introduction to HBase's HFile. Matteo Bertozzi has also put up a helpful description, [HBase I/O: HFile](http://th30z.blogspot.com/2011/02/hbase-io-hfile.html?spref=tw).\n\nFor more information, see the HFile source code. Also see [HBase file format with inline blocks (version 2)](/docs/hfile-format#hbase-file-format-with-inline-blocks-version-2) for information about the HFile v2 format that was included in 0.92.\n\n#### HFile Tool\n\nTo view a textualized version of HFile content, you can use the `hbase hfile` tool. Type the following to see usage:\n\n```bash\n$ ${HBASE_HOME}/bin/hbase hfile\n```\n\nFor example, to view the content of the file *hdfs\\://10.81.47.41:9000/hbase/default/TEST/1418428042/DSMP/4759508618286845475*, type the following:\n\n```bash\n$ ${HBASE_HOME}/bin/hbase hfile -v -f hdfs://10.81.47.41:9000/hbase/default/TEST/1418428042/DSMP/4759508618286845475\n```\n\nIf you leave off the option -v to see just a summary on the HFile. See usage for other things to do with the `hfile` tool.\n\n<Callout type=\"info\">\n  In the output of this tool, you might see 'seqid=0' for certain keys in places such as\n  'Mid-key'/'firstKey'/'lastKey'. These are 'KeyOnlyKeyValue' type instances - meaning their seqid\n  is irrelevant & we just need the keys of these Key-Value instances.\n</Callout>\n\n#### StoreFile Directory Structure on HDFS\n\nFor more information of what StoreFiles look like on HDFS with respect to the directory structure, see [Browsing HDFS for HBase Objects](/docs/troubleshooting#browsing-hdfs-for-hbase-objects).\n\n### Blocks\n\nStoreFiles are composed of blocks. The blocksize is configured on a per-ColumnFamily basis.\n\nCompression happens at the block level within StoreFiles. For more information on compression, see [Compression and Data Block Encoding In HBase](/docs/compression).\n\nFor more information on blocks, see the HFileBlock source code.\n\n### KeyValue\n\nThe KeyValue class is the heart of data storage in HBase. KeyValue wraps a byte array and takes offsets and lengths into the passed array which specify where to start interpreting the content as KeyValue.\n\nThe KeyValue format inside a byte array is:\n\n* keylength\n* valuelength\n* key\n* value\n\nThe Key is further decomposed as:\n\n* rowlength\n* row (i.e., the rowkey)\n* columnfamilylength\n* columnfamily\n* columnqualifier\n* timestamp\n* keytype (e.g., Put, Delete, DeleteColumn, DeleteFamily)\n\nKeyValue instances are *not* split across blocks. For example, if there is an 8 MB KeyValue, even if the block-size is 64kb this KeyValue will be read in as a coherent block. For more information, see the KeyValue source code.\n\n#### Example\n\nTo emphasize the points above, examine what happens with two Puts for two different columns for the same row:\n\n* Put #1: `rowkey=row1, cf:attr1=value1`\n* Put #2: `rowkey=row1, cf:attr2=value2`\n\nEven though these are for the same row, a KeyValue is created for each column:\n\nKey portion for Put #1:\n\n* `rowlength -----------→ 4`\n* `row -----------------→ row1`\n* `columnfamilylength --→ 2`\n* `columnfamily --------→ cf`\n* `columnqualifier -----→ attr1`\n* `timestamp -----------→ server time of Put`\n* `keytype -------------→ Put`\n\nKey portion for Put #2:\n\n* `rowlength -----------→ 4`\n* `row -----------------→ row1`\n* `columnfamilylength --→ 2`\n* `columnfamily --------→ cf`\n* `columnqualifier -----→ attr2`\n* `timestamp -----------→ server time of Put`\n* `keytype -------------→ Put`\n\nIt is critical to understand that the rowkey, ColumnFamily, and column (aka columnqualifier) are embedded within the KeyValue instance. The longer these identifiers are, the bigger the KeyValue is.\n\n### Compaction\n\n**Ambiguous Terminology:**\n\n* A *StoreFile* is a facade of HFile. In terms of compaction, use of StoreFile seems to have prevailed in the past.\n* A *Store* is the same thing as a ColumnFamily. StoreFiles are related to a Store, or ColumnFamily.\n* If you want to read more about StoreFiles versus HFiles and Stores versus ColumnFamilies, see [HBASE-11316](https://issues.apache.org/jira/browse/HBASE-11316).\n\nWhen the MemStore reaches a given size (`hbase.hregion.memstore.flush.size`), it flushes its contents to a StoreFile. The number of StoreFiles in a Store increases over time. *Compaction* is an operation which reduces the number of StoreFiles in a Store, by merging them together, in order to increase performance on read operations. Compactions can be resource-intensive to perform, and can either help or hinder performance depending on many factors.\n\nCompactions fall into two categories: minor and major. Minor and major compactions differ in the following ways.\n\n*Minor compactions* usually select a small number of small, adjacent StoreFiles and rewrite them as a single StoreFile. Minor compactions do not drop (filter out) deletes or expired versions, because of potential side effects. See [Compaction and Deletions](/docs/architecture/regions#compaction-and-deletions) and [Compaction and Versions](/docs/architecture/regions#compaction-and-versions) for information on how deletes and versions are handled in relation to compactions. The end result of a minor compaction is fewer, larger StoreFiles for a given Store.\n\nThe end result of a *major compaction* is a single StoreFile per Store. Major compactions also process delete markers and max versions. See [Compaction and Deletions](/docs/architecture/regions#compaction-and-deletions) and [Compaction and Versions](/docs/architecture/regions#compaction-and-versions) for information on how deletes and versions are handled in relation to compactions.\n\n#### Compaction and Deletions\n\nWhen an explicit deletion occurs in HBase, the data is not actually deleted. Instead, a *tombstone* marker is written. The tombstone marker prevents the data from being returned with queries. During a major compaction, the data is actually deleted, and the tombstone marker is removed from the StoreFile. If the deletion happens because of an expired TTL, no tombstone is created. Instead, the expired data is filtered out and is not written back to the compacted StoreFile.\n\n#### Compaction and Versions\n\nWhen you create a Column Family, you can specify the maximum number of versions to keep, by specifying `ColumnFamilyDescriptorBuilder.setMaxVersions(int versions)`. The default value is `1`. If more versions than the specified maximum exist, the excess versions are filtered out and not written back to the compacted StoreFile.\n\n<Callout type=\"info\">\n  In some situations, older versions can be inadvertently resurrected if a newer version is\n  explicitly deleted. See [Major compactions change query\n  results](/docs/datamodel#major-compactions-change-query-results) for a more in-depth explanation.\n  This situation is only possible before the compaction finishes.\n</Callout>\n\nIn theory, major compactions improve performance. However, on a highly loaded system, major compactions can require an inappropriate number of resources and adversely affect performance. In a default configuration, major compactions are scheduled automatically to run once in a 7-day period. This is sometimes inappropriate for systems in production. You can manage major compactions manually. See [Managed Compactions](/docs/configuration/important#managed-compactions).\n\nCompactions do not perform region merges. See [Merge](/docs/operational-management/region-and-capacity#merge) for more information on region merging.\n\n#### Compaction Switch\n\nWe can switch on and off the compactions at region servers. Switching off compactions will also interrupt any currently ongoing compactions. It can be done dynamically using the \"compaction\\_switch\" command from hbase shell. If done from the command line, this setting will be lost on restart of the server. To persist the changes across region servers modify the configuration hbase.regionserver .compaction.enabled in hbase-site.xml and restart HBase.\n\n#### Compaction Policy - HBase 0.96.x and newer\n\nCompacting large StoreFiles, or too many StoreFiles at once, can cause more IO load than your cluster is able to handle without causing performance problems. The method by which HBase selects which StoreFiles to include in a compaction (and whether the compaction is a minor or major compaction) is called the *compaction policy*.\n\nPrior to HBase 0.96.x, there was only one compaction policy. That original compaction policy is still available as `RatioBasedCompactionPolicy`. The new compaction default policy, called `ExploringCompactionPolicy`, was subsequently backported to HBase 0.94 and HBase 0.95, and is the default in HBase 0.96 and newer. It was implemented in [HBASE-7842](https://issues.apache.org/jira/browse/HBASE-7842). In short, `ExploringCompactionPolicy` attempts to select the best possible set of StoreFiles to compact with the least amount of work, while the `RatioBasedCompactionPolicy` selects the first set that meets the criteria.\n\nRegardless of the compaction policy used, file selection is controlled by several configurable parameters and happens in a multi-step approach. These parameters will be explained in context, and then will be given in a table which shows their descriptions, defaults, and implications of changing them.\n\n#### Being Stuck\n\nWhen the MemStore gets too large, it needs to flush its contents to a StoreFile. However, Stores are configured with a bound on the number StoreFiles, `hbase.hstore.blockingStoreFiles`, and if in excess, the MemStore flush must wait until the StoreFile count is reduced by one or more compactions. If the MemStore is too large and the number of StoreFiles is also too high, the algorithm is said to be \"stuck\". By default we'll wait on compactions up to `hbase.hstore.blockingWaitTime` milliseconds. If this period expires, we'll flush anyways even though we are in excess of the `hbase.hstore.blockingStoreFiles` count.\n\nUpping the `hbase.hstore.blockingStoreFiles` count will allow flushes to happen but a Store with many StoreFiles in will likely have higher read latencies. Try to figure why Compactions are not keeping up. Is it a write spurt that is bringing about this situation or is a regular occurance and the cluster is under-provisioned for the volume of writes?\n\n#### The ExploringCompactionPolicy Algorithm\n\nThe ExploringCompactionPolicy algorithm considers each possible set of adjacent StoreFiles before choosing the set where compaction will have the most benefit.\n\nOne situation where the ExploringCompactionPolicy works especially well is when you are bulk-loading data and the bulk loads create larger StoreFiles than the StoreFiles which are holding data older than the bulk-loaded data. This can \"trick\" HBase into choosing to perform a major compaction each time a compaction is needed, and cause a lot of extra overhead. With the ExploringCompactionPolicy, major compactions happen much less frequently because minor compactions are more efficient.\n\nIn general, ExploringCompactionPolicy is the right choice for most situations, and thus is the default compaction policy. You can also use ExploringCompactionPolicy along with [Experimental: Stripe Compactions](/docs/architecture/regions#experimental-stripe-compactions).\n\nThe logic of this policy can be examined in hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/ExploringCompactionPolicy.java. The following is a walk-through of the logic of the ExploringCompactionPolicy.\n\n1. Make a list of all existing StoreFiles in the Store. The rest of the algorithm filters this list to come up with the subset of HFiles which will be chosen for compaction.\n\n2. If this was a user-requested compaction, attempt to perform the requested compaction type, regardless of what would normally be chosen. Note that even if the user requests a major compaction, it may not be possible to perform a major compaction. This may be because not all StoreFiles in the Column Family are available to compact or because there are too many Stores in the Column Family.\n\n3. Some StoreFiles are automatically excluded from consideration. These include:\n   * StoreFiles that are larger than `hbase.hstore.compaction.max.size`\n   * StoreFiles that were created by a bulk-load operation which explicitly excluded compaction. You may decide to exclude StoreFiles resulting from bulk loads, from compaction. To do this, specify the `hbase.mapreduce.hfileoutputformat.compaction.exclude` parameter during the bulk load operation.\n\n4. Iterate through the list from step 1, and make a list of all potential sets of StoreFiles to compact together. A potential set is a grouping of `hbase.hstore.compaction.min` contiguous StoreFiles in the list. For each set, perform some sanity-checking and figure out whether this is the best compaction that could be done:\n   * If the number of StoreFiles in this set (not the size of the StoreFiles) is fewer than `hbase.hstore.compaction.min` or more than `hbase.hstore.compaction.max`, take it out of consideration.\n   * Compare the size of this set of StoreFiles with the size of the smallest possible compaction that has been found in the list so far. If the size of this set of StoreFiles represents the smallest compaction that could be done, store it to be used as a fall-back if the algorithm is \"stuck\" and no StoreFiles would otherwise be chosen. See [Being Stuck](/docs/architecture/regions#being-stuck).\n   * Do size-based sanity checks against each StoreFile in this set of StoreFiles.\n\n     * If the size of this StoreFile is larger than `hbase.hstore.compaction.max.size`, take it out of consideration.\n     * If the size is greater than or equal to `hbase.hstore.compaction.min.size`, sanity-check it against the file-based ratio to see whether it is too large to be considered.\n\n     The sanity-checking is successful if:\n\n     * There is only one StoreFile in this set, or\n     * For each StoreFile, its size multiplied by `hbase.hstore.compaction.ratio` (or `hbase.hstore.compaction.ratio.offpeak` if off-peak hours are configured and it is during off-peak hours) is less than the sum of the sizes of the other HFiles in the set.\n\n5. If this set of StoreFiles is still in consideration, compare it to the previously-selected best compaction. If it is better, replace the previously-selected best compaction with this one.\n\n6. When the entire list of potential compactions has been processed, perform the best compaction that was found. If no StoreFiles were selected for compaction, but there are multiple StoreFiles, assume the algorithm is stuck (see [Being Stuck](/docs/architecture/regions#being-stuck)) and if so, perform the smallest compaction that was found in step 3.\n\n#### RatioBasedCompactionPolicy Algorithm\n\nThe RatioBasedCompactionPolicy was the only compaction policy prior to HBase 0.96, though ExploringCompactionPolicy has now been backported to HBase 0.94 and 0.95. To use the RatioBasedCompactionPolicy rather than the ExploringCompactionPolicy, set `hbase.hstore.defaultengine.compactionpolicy.class` to `RatioBasedCompactionPolicy` in the *hbase-site.xml* file. To switch back to the ExploringCompactionPolicy, remove the setting from the *hbase-site.xml*.\n\nThe following section walks you through the algorithm used to select StoreFiles for compaction in the RatioBasedCompactionPolicy.\n\n1. The first phase is to create a list of all candidates for compaction. A list is created of all StoreFiles not already in the compaction queue, and all StoreFiles newer than the newest file that is currently being compacted. This list of StoreFiles is ordered by the sequence ID. The sequence ID is generated when a Put is appended to the write-ahead log (WAL), and is stored in the metadata of the HFile.\n2. Check to see if the algorithm is stuck (see [Being Stuck](/docs/architecture/regions#being-stuck), and if so, a major compaction is forced. This is a key area where [The ExploringCompactionPolicy Algorithm](/docs/architecture/regions#the-exploringcompactionpolicy-algorithm) is often a better choice than the RatioBasedCompactionPolicy.\n3. If the compaction was user-requested, try to perform the type of compaction that was requested. Note that a major compaction may not be possible if all HFiles are not available for compaction or if too many StoreFiles exist (more than `hbase.hstore.compaction.max`).\n4. Some StoreFiles are automatically excluded from consideration. These include:\n   * StoreFiles that are larger than `hbase.hstore.compaction.max.size`\n   * StoreFiles that were created by a bulk-load operation which explicitly excluded compaction. You may decide to exclude StoreFiles resulting from bulk loads, from compaction. To do this, specify the `hbase.mapreduce.hfileoutputformat.compaction.exclude` parameter during the bulk load operation.\n5. The maximum number of StoreFiles allowed in a major compaction is controlled by the `hbase.hstore.compaction.max` parameter. If the list contains more than this number of StoreFiles, a minor compaction is performed even if a major compaction would otherwise have been done. However, a user-requested major compaction still occurs even if there are more than `hbase.hstore.compaction.max` StoreFiles to compact.\n6. If the list contains fewer than `hbase.hstore.compaction.min` StoreFiles to compact, a minor compaction is aborted. Note that a major compaction can be performed on a single HFile. Its function is to remove deletes and expired versions, and reset locality on the StoreFile.\n7. The value of the `hbase.hstore.compaction.ratio` parameter is multiplied by the sum of StoreFiles smaller than a given file, to determine whether that StoreFile is selected for compaction during a minor compaction. For instance, if hbase.hstore.compaction.ratio is 1.2, FileX is 5MB, FileY is 2MB, and FileZ is 3MB:\n   ```\n   5 <= 1.2 x (2 + 3)            or            5 <= 6\n   ```\n   In this scenario, FileX is eligible for minor compaction. If FileX were 7MB, it would not be eligible for minor compaction. This ratio favors smaller StoreFile. You can configure a different ratio for use in off-peak hours, using the parameter `hbase.hstore.compaction.ratio.offpeak`, if you also configure `hbase.offpeak.start.hour` and `hbase.offpeak.end.hour`.\n8. If the last major compaction was too long ago and there is more than one StoreFile to be compacted, a major compaction is run, even if it would otherwise have been minor. By default, the maximum time between major compactions is 7 days, plus or minus a 4.8 hour period, and determined randomly within those parameters. Prior to HBase 0.96, the major compaction period was 24 hours. See `hbase.hregion.majorcompaction` in the table below to tune or disable time-based major compactions.\n\n#### Parameters Used by Compaction Algorithm\n\nThis table contains the main configuration parameters for compaction. This list is not exhaustive. To tune these parameters from the defaults, edit the *hbase-default.xml* file. For a full list of all configuration parameters available, see [config.files](/docs/configuration/default#configuration-default-hbase-default-configuration)\n\n* `hbase.hstore.compaction.min`\\\n  The minimum number of StoreFiles which must be eligible for compaction before compaction can run. The goal of tuning `hbase.hstore.compaction.min` is to avoid ending up with too many tiny StoreFiles to compact. Setting this value to 2 would cause a minor compaction each time you have two StoreFiles in a Store, and this is probably not appropriate. If you set this value too high, all the other values will need to be adjusted accordingly. For most cases, the default value is appropriate. In previous versions of HBase, the parameter `hbase.hstore.compaction.min` was called `hbase.hstore.compactionThreshold`.\\\n  **Default**: 3\n\n* `hbase.hstore.compaction.max`\n  The maximum number of StoreFiles which will be selected for a single minor compaction, regardless of the number of eligible StoreFiles. Effectively, the value of `hbase.hstore.compaction.max` controls the length of time it takes a single compaction to complete. Setting it larger means that more StoreFiles are included in a compaction. For most cases, the default value is appropriate.\\\n  **Default**: 10\n\n* `hbase.hstore.compaction.min.size`\\\n  A StoreFile smaller than this size will always be eligible for minor compaction. StoreFiles this size or larger are evaluated by `hbase.hstore.compaction.ratio` to determine if they are eligible. Because this limit represents the \"automatic include\" limit for all StoreFiles smaller than this value, this value may need to be reduced in write-heavy environments where many files in the 1-2 MB range are being flushed, because every StoreFile will be targeted for compaction and the resulting StoreFiles may still be under the minimum size and require further compaction. If this parameter is lowered, the ratio check is triggered more quickly. This addressed some issues seen in earlier versions of HBase but changing this parameter is no longer necessary in most situations.\\\n  **Default**:128 MB\n\n* `hbase.hstore.compaction.max.size`\\\n  A StoreFile larger than this size will be excluded from compaction. The effect of raising `hbase.hstore.compaction.max.size` is fewer, larger StoreFiles that do not get compacted often. If you feel that compaction is happening too often without much benefit, you can try raising this value.\\\n  **Default**: `Long.MAX_VALUE`\n\n* `hbase.hstore.compaction.ratio`\\\n  For minor compaction, this ratio is used to determine whether a given StoreFile which is larger than `hbase.hstore.compaction.min.size` is eligible for compaction. Its effect is to limit compaction of large StoreFile. The value of `hbase.hstore.compaction.ratio` is expressed as a floating-point decimal.\n  * A large ratio, such as 10, will produce a single giant StoreFile. Conversely, a value of .25, will produce behavior similar to the BigTable compaction algorithm, producing four StoreFiles.\n  * A moderate value of between 1.0 and 1.4 is recommended. When tuning this value, you are balancing write costs with read costs. Raising the value (to something like 1.4) will have more write costs, because you will compact larger StoreFiles. However, during reads, HBase will need to seek through fewer StoreFiles to accomplish the read. Consider this approach if you cannot take advantage of [Bloom Filters](/docs/performance#bloom-filters).\n  * Alternatively, you can lower this value to something like 1.0 to reduce the background cost of writes, and use to limit the number of StoreFiles touched during reads. For most cases, the default value is appropriate.\\\n    **Default**: `1.2F`\n\n* `hbase.hstore.compaction.ratio.offpeak`\\\n  The compaction ratio used during off-peak compactions, if off-peak hours are also configured (see below). Expressed as a floating-point decimal. This allows for more aggressive (or less aggressive, if you set it lower than `hbase.hstore.compaction.ratio`) compaction during a set time period. Ignored if off-peak is disabled (default). This works the same as `hbase.hstore.compaction.ratio`.\\\n  **Default**: `5.0F`\n\n* `hbase.offpeak.start.hour`\\\n  The start of off-peak hours, expressed as an integer between 0 and 23, inclusive. Set to -1 to disable off-peak.\\\n  **Default**: `-1` (disabled)\n\n* `hbase.offpeak.end.hour`\\\n  The end of off-peak hours, expressed as an integer between 0 and 23, inclusive. Set to -1 to disable off-peak.\\\n  **Default**: `-1` (disabled)\n\n* `hbase.regionserver.thread.compaction.throttle`\\\n  There are two different thread pools for compactions, one for large compactions and the other for small compactions. This helps to keep compaction of lean tables (such as `hbase:meta`) fast. If a compaction is larger than this threshold, it goes into the large compaction pool. In most cases, the default value is appropriate.\\\n  **Default**: `2 x hbase.hstore.compaction.max x hbase.hregion.memstore.flush.size` (which defaults to `128`)\n\n* `hbase.hregion.majorcompaction`\\\n  Time between major compactions, expressed in milliseconds. Set to 0 to disable time-based automatic major compactions. User-requested and size-based major compactions will still run. This value is multiplied by `hbase.hregion.majorcompaction.jitter` to cause compaction to start at a somewhat-random time during a given window of time.\\\n  **Default**: 7 days (`604800000` milliseconds)\n\n* `hbase.hregion.majorcompaction.jitter`\\\n  A multiplier applied to hbase.hregion.majorcompaction to cause compaction to occur a given amount of time either side of `hbase.hregion.majorcompaction`. The smaller the number, the closer the compactions will happen to the `hbase.hregion.majorcompaction` interval. Expressed as a floating-point decimal.\\\n  **Default**: `.50F`\n\n#### Compaction File Selection\n\n<Callout type=\"info\" title=\"Legacy Information\">\n  This section has been preserved for historical reasons and refers to the way compaction worked\n  prior to HBase 0.96.x. You can still use this behavior if you enable [RatioBasedCompactionPolicy\n  Algorithm](/docs/architecture/regions#ratiobasedcompactionpolicy-algorithm). For information on\n  the way that compactions work in HBase 0.96.x and later, see\n  [Compaction](/docs/architecture/regions#compaction).\n</Callout>\n\nTo understand the core algorithm for StoreFile selection, there is some ASCII-art in the Store source code that will serve as useful reference.\n\nIt has been copied below:\n\n```java\n/* normal skew:\n *\n *         older ----> newer\n *     _\n *    | |   _\n *    | |  | |   _\n *  --|-|- |-|- |-|---_-------_-------  minCompactSize\n *    | |  | |  | |  | |  _  | |\n *    | |  | |  | |  | | | | | |\n *    | |  | |  | |  | | | | | |\n */\n```\n\n**Important knobs:**\n\n* `hbase.hstore.compaction.ratio` Ratio used in compaction file selection algorithm (default 1.2f).\n* `hbase.hstore.compaction.min` (in HBase v 0.90 this is called `hbase.hstore.compactionThreshold`) (files) Minimum number of StoreFiles per Store to be selected for a compaction to occur (default 2).\n* `hbase.hstore.compaction.max` (files) Maximum number of StoreFiles to compact per minor compaction (default 10).\n* `hbase.hstore.compaction.min.size` (bytes) Any StoreFile smaller than this setting with automatically be a candidate for compaction. Defaults to `hbase.hregion.memstore.flush.size` (128 mb).\n* `hbase.hstore.compaction.max.size` (.92) (bytes) Any StoreFile larger than this setting with automatically be excluded from compaction (default Long.MAX\\_VALUE).\n\nThe minor compaction StoreFile selection logic is size based, and selects a file for compaction when the `file ⇐ sum(smaller_files) * hbase.hstore.compaction.ratio`.\n\n#### Minor Compaction File Selection - Example #1 (Basic Example)\n\nThis example mirrors an example from the unit test `TestCompactSelection`.\n\n* `hbase.hstore.compaction.ratio` = 1.0f\n* `hbase.hstore.compaction.min` = 3 (files)\n* `hbase.hstore.compaction.max` = 5 (files)\n* `hbase.hstore.compaction.min.size` = 10 (bytes)\n* `hbase.hstore.compaction.max.size` = 1000 (bytes)\n\nThe following StoreFiles exist: 100, 50, 23, 12, and 12 bytes apiece (oldest to newest). With the above parameters, the files that would be selected for minor compaction are 23, 12, and 12.\n\nWhy?\n\n* 100 → No, because sum(50, 23, 12, 12) \\* 1.0 = 97.\n* 50 → No, because sum(23, 12, 12) \\* 1.0 = 47.\n* 23 → Yes, because sum(12, 12) \\* 1.0 = 24.\n* 12 → Yes, because the previous file has been included, and because this does not exceed the max-file limit of 5\n* 12 → Yes, because the previous file had been included, and because this does not exceed the max-file limit of 5.\n\n#### Minor Compaction File Selection - Example #2 (Not Enough Files ToCompact)\n\nThis example mirrors an example from the unit test `TestCompactSelection`.\n\n* `hbase.hstore.compaction.ratio` = 1.0f\n* `hbase.hstore.compaction.min` = 3 (files)\n* `hbase.hstore.compaction.max` = 5 (files)\n* `hbase.hstore.compaction.min.size` = 10 (bytes)\n* `hbase.hstore.compaction.max.size` = 1000 (bytes)\n\nThe following StoreFiles exist: 100, 25, 12, and 12 bytes apiece (oldest to newest). With the above parameters, no compaction will be started.\n\nWhy?\n\n* 100 → No, because sum(25, 12, 12) \\* 1.0 = 47\n* 25 → No, because sum(12, 12) \\* 1.0 = 24\n* 12 → No. Candidate because sum(12) \\* 1.0 = 12, there are only 2 files to compact and that is less than the threshold of 3\n* 12 → No. Candidate because the previous StoreFile was, but there are not enough files to compact\n\n#### Minor Compaction File Selection - Example #3 (Limiting Files To Compact)\n\nThis example mirrors an example from the unit test `TestCompactSelection`.\n\n* `hbase.hstore.compaction.ratio` = 1.0f\n* `hbase.hstore.compaction.min` = 3 (files)\n* `hbase.hstore.compaction.max` = 5 (files)\n* `hbase.hstore.compaction.min.size` = 10 (bytes)\n* `hbase.hstore.compaction.max.size` = 1000 (bytes)\n\nThe following StoreFiles exist: 7, 6, 5, 4, 3, 2, and 1 bytes apiece (oldest to newest). With the above parameters, the files that would be selected for minor compaction are 7, 6, 5, 4, 3.\n\nWhy?\n\n* 7 → Yes, because sum(6, 5, 4, 3, 2, 1) \\* 1.0 = 21. Also, 7 is less than the min-size\n* 6 → Yes, because sum(5, 4, 3, 2, 1) \\* 1.0 = 15. Also, 6 is less than the min-size.\n* 5 → Yes, because sum(4, 3, 2, 1) \\* 1.0 = 10. Also, 5 is less than the min-size.\n* 4 → Yes, because sum(3, 2, 1) \\* 1.0 = 6. Also, 4 is less than the min-size.\n* 3 → Yes, because sum(2, 1) \\* 1.0 = 3. Also, 3 is less than the min-size.\n* 2 → No. Candidate because previous file was selected and 2 is less than the min-size, but the max-number of files to compact has been reached.\n* 1 → No. Candidate because previous file was selected and 1 is less than the min-size, but max-number of files to compact has been reached.\n\n<Callout type=\"info\" title=\"Impact of Key Configuration Options\">\n  This information is now included in the configuration parameter table in [Parameters Used by\n  Compaction Algorithm](/docs/architecture/regions#parameters-used-by-compaction-algorithm).\n</Callout>\n\n#### Date Tiered Compaction\n\nDate tiered compaction is a date-aware store file compaction strategy that is beneficial for time-range scans for time-series data.\n\n#### When To Use Date Tiered Compactions\n\nConsider using Date Tiered Compaction for reads for limited time ranges, especially scans of recent data\n\nDon't use it for\n\n* random gets without a limited time range\n* frequent deletes and updates\n* Frequent out of order data writes creating long tails, especially writes with future timestamps\n* frequent bulk loads with heavily overlapping time ranges\n\n**Performance Improvements**\\\nPerformance testing has shown that the performance of time-range scans improve greatly for limited time ranges, especially scans of recent data.\n\n#### Enabling Date Tiered Compaction\n\nYou can enable Date Tiered compaction for a table or a column family, by setting its `hbase.hstore.engine.class` to `org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine`.\n\nYou also need to set `hbase.hstore.blockingStoreFiles` to a high number, such as 60, if using all default settings, rather than the default value of 12). Use 1.5\\~2 x projected file count if changing the parameters, Projected file count = windows per tier x tier count + incoming window min + files older than max age\n\nYou also need to set `hbase.hstore.compaction.max` to the same value as `hbase.hstore.blockingStoreFiles` to unblock major compaction.\n\n**Procedure: Enable Date Tiered Compaction**\n\n<Steps>\n  <Step>\n    Run one of following commands in the HBase shell. Replace the table name `orders_table` with the name of your table.\n\n    ```ruby\n    alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine', 'hbase.hstore.blockingStoreFiles' => '60', 'hbase.hstore.compaction.min'=>'2', 'hbase.hstore.compaction.max'=>'60'}\n    alter 'orders_table', {NAME => 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine', 'hbase.hstore.blockingStoreFiles' => '60', 'hbase.hstore.compaction.min'=>'2', 'hbase.hstore.compaction.max'=>'60'}}\n    create 'orders_table', 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DateTieredStoreEngine', 'hbase.hstore.blockingStoreFiles' => '60', 'hbase.hstore.compaction.min'=>'2', 'hbase.hstore.compaction.max'=>'60'}\n    ```\n  </Step>\n\n  <Step>\n    Configure other options if needed. See [Configuring Date Tiered Compaction](/docs/architecture/regions#configuring-date-tiered-compaction) for more information.\n  </Step>\n</Steps>\n\n**Procedure: Disable Date Tiered Compaction**\n\n<Steps>\n  <Step>\n    Set the `hbase.hstore.engine.class` option to either nil or `org.apache.hadoop.hbase.regionserver.DefaultStoreEngine`. Either option has the same effect. Make sure you set the other options you changed to the original settings too.\n\n    ```ruby\n    alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DefaultStoreEngine', 'hbase.hstore.blockingStoreFiles' => '12', 'hbase.hstore.compaction.min'=>'6', 'hbase.hstore.compaction.max'=>'12'}\n    ```\n  </Step>\n</Steps>\n\nWhen you change the store engine either way, a major compaction will likely be performed on most regions. This is not necessary on new tables.\n\n#### Configuring Date Tiered Compaction\n\nEach of the settings for date tiered compaction should be configured at the table or column family level. If you use HBase shell, the general command pattern is as follows:\n\n```ruby\nalter 'orders_table', CONFIGURATION => {'key' => 'value', ..., 'key' => 'value'}}\n```\n\n**Data Tier Parameters**\\\nYou can configure your date tiers by changing the settings for the following parameters:\n\n| Setting                                                        | Notes                                                                                                                                                                         |\n| -------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `hbase.hstore.compaction.date.tiered.max.storefile.age.millis` | Files with max-timestamp smaller than this will no longer be compacted.Default at Long.MAX\\_VALUE.                                                                            |\n| `hbase.hstore.compaction.date.tiered.base.window.millis`       | Base window size in milliseconds. Default at 6 hours.                                                                                                                         |\n| `hbase.hstore.compaction.date.tiered.windows.per.tier`         | Number of windows per tier. Default at 4.                                                                                                                                     |\n| `hbase.hstore.compaction.date.tiered.incoming.window.min`      | Minimal number of files to compact in the incoming window. Set it to expected number of files in the window to avoid wasteful compaction. Default at 6.                       |\n| `hbase.hstore.compaction.date.tiered.window.policy.class`      | The policy to select store files within the same time window. It doesn't apply to the incoming window. Default at exploring compaction. This is to avoid wasteful compaction. |\n\n**Compaction Throttler**\\\nWith tiered compaction all servers in the cluster will promote windows to higher tier at the same time, so using a compaction throttle is recommended: Set `hbase.regionserver.throughput.controller` to `org.apache.hadoop.hbase.regionserver.compactions.PressureAwareCompactionThroughputController`.\n\n<Callout type=\"info\">\n  For more information about date tiered compaction, please refer to the design specification at\n  [https://docs.google.com/document/d/1\\_AmlNb2N8Us1xICsTeGDLKIqL6T-oHoRLZ323MG\\_uy8](https://docs.google.com/document/d/1_AmlNb2N8Us1xICsTeGDLKIqL6T-oHoRLZ323MG_uy8)\n</Callout>\n\n#### Experimental: Stripe Compactions\n\nStripe compactions is an experimental feature added in HBase 0.98 which aims to improve compactions for large regions or non-uniformly distributed row keys. In order to achieve smaller and/or more granular compactions, the StoreFiles within a region are maintained separately for several row-key sub-ranges, or \"stripes\", of the region. The stripes are transparent to the rest of HBase, so other operations on the HFiles or data work without modification.\n\nStripe compactions change the HFile layout, creating sub-regions within regions. These sub-regions are easier to compact, and should result in fewer major compactions. This approach alleviates some of the challenges of larger regions.\n\nStripe compaction is fully compatible with [Compaction](/docs/architecture/regions#compaction) and works in conjunction with either the ExploringCompactionPolicy or RatioBasedCompactionPolicy. It can be enabled for existing tables, and the table will continue to operate normally if it is disabled later.\n\n#### When To Use Stripe Compactions\n\nConsider using stripe compaction if you have either of the following:\n\n* Large regions. You can get the positive effects of smaller regions without additional overhead for MemStore and region management overhead.\n* Non-uniform keys, such as time dimension in a key. Only the stripes receiving the new keys will need to compact. Old data will not compact as often, if at all\n\n**Performance Improvements**\\\nPerformance testing has shown that the performance of reads improves somewhat, and variability of performance of reads and writes is greatly reduced. An overall long-term performance improvement is seen on large non-uniform-row key regions, such as a hash-prefixed timestamp key. These performance gains are the most dramatic on a table which is already large. It is possible that the performance improvement might extend to region splits.\n\n#### Enabling Stripe Compaction\n\nYou can enable stripe compaction for a table or a column family, by setting its `hbase.hstore.engine.class` to `org.apache.hadoop.hbase.regionserver.StripeStoreEngine`. You also need to set the `hbase.hstore.blockingStoreFiles` to a high number, such as 100 (rather than the default value of 10).\n\n**Procedure: Enable Stripe Compaction**\n\n<Steps>\n  <Step>\n    Run one of following commands in the HBase shell. Replace the table name `orders_table` with the name of your table.\n\n    ```ruby\n    alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}\n    alter 'orders_table', {NAME => 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}}\n    create 'orders_table', 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}\n    ```\n  </Step>\n\n  <Step>\n    Configure other options if needed. See [Configuring Stripe Compaction](/docs/architecture/regions#configuring-stripe-compaction) for more information.\n  </Step>\n\n  <Step>\n    Enable the table.\n  </Step>\n</Steps>\n\n**Procedure: Disable Stripe Compaction**\n\n<Steps>\n  <Step>\n    Set the `hbase.hstore.engine.class` option to either nil or `org.apache.hadoop.hbase.regionserver.DefaultStoreEngine`. Either option has the same effect.\n\n    ```ruby\n    alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.DefaultStoreEngine'}\n    ```\n  </Step>\n\n  <Step>\n    Enable the table.\n  </Step>\n</Steps>\n\nWhen you enable a large table after changing the store engine either way, a major compaction will likely be performed on most regions. This is not necessary on new tables.\n\n#### Configuring Stripe Compaction\n\nEach of the settings for stripe compaction should be configured at the table or column family level. If you use HBase shell, the general command pattern is as follows:\n\n```ruby\nalter 'orders_table', CONFIGURATION => {'key' => 'value', ..., 'key' => 'value'}}\n```\n\n**Region and stripe sizing**\\\nYou can configure your stripe sizing based upon your region sizing. By default, your new regions will start with one stripe. On the next compaction after the stripe has grown too large (16 x MemStore flushes size), it is split into two stripes. Stripe splitting continues as the region grows, until the region is large enough to split.\n\nYou can improve this pattern for your own data. A good rule is to aim for a stripe size of at least 1 GB, and about 8-12 stripes for uniform row keys. For example, if your regions are 30 GB, 12 x 2.5 GB stripes might be a good starting point.\n\n**Stripe Sizing Settings**\n\n| Setting                                 | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `hbase.store.stripe.initialStripeCount` | The number of stripes to create when stripe compaction is enabled. You can use it as follows:<br />- For relatively uniform row keys, if you know the approximate target number of stripes from the above, you can avoid some splitting overhead by starting with several stripes (2, 5, 10...). If the early data is not representative of overall row key distribution, this will not be as efficient.<br />- For existing tables with a large amount of data, this setting will effectively pre-split your stripes.<br />- For keys such as hash-prefixed sequential keys, with more than one hash prefix per region, pre-splitting may make sense. |\n| `hbase.store.stripe.sizeToSplit`        | The maximum size a stripe grows before splitting. Use this in conjunction with `hbase.store.stripe.splitPartCount` to control the target stripe size (`sizeToSplit = splitPartsCount * target stripe size`), according to the above sizing considerations.                                                                                                                                                                                                                                                                                                                                                                                             |\n| `hbase.store.stripe.splitPartCount`     | The number of new stripes to create when splitting a stripe. The default is 2, which is appropriate for most cases. For non-uniform row keys, you can experiment with increasing the number to 3 or 4, to isolate the arriving updates into narrower slice of the region without additional splits being required.                                                                                                                                                                                                                                                                                                                                     |\n\n**MemStore Size Settings**\\\nBy default, the flush creates several files from one MemStore, according to existing stripe boundaries and row keys to flush. This approach minimizes write amplification, but can be undesirable if the MemStore is small and there are many stripes, because the files will be too small.\\\nIn this type of situation, you can set `hbase.store.stripe.compaction.flushToL0` to `true`. This will cause a MemStore flush to create a single file instead. When at least `hbase.store.stripe.compaction.minFilesL0` such files (by default, 4) accumulate, they will be compacted into striped files.\n\n**Normal Compaction Configuration and Stripe Compaction**\\\nAll the settings that apply to normal compactions (see [Parameters Used by Compaction Algorithm](/docs/architecture/regions#parameters-used-by-compaction-algorithm)) apply to stripe compactions. The exceptions are the minimum and maximum number of files, which are set to higher values by default because the files in stripes are smaller. To control these for stripe compactions, use `hbase.store.stripe.compaction.minFiles` and `hbase.store.stripe.compaction.maxFiles`, rather than `hbase.hstore.compaction.min` and `hbase.hstore.compaction.max`.\n\n#### FIFO Compaction\n\nFIFO compaction policy selects only files which have all cells expired. The column family **MUST** have non-default TTL. Essentially, FIFO compactor only collects expired store files.\n\nBecause we don't do any real compaction, we do not use CPU and IO (disk and network) and evict hot data from a block cache. As a result, both RW throughput and latency can be improved.\n\n#### When To Use FIFO Compaction\n\nConsider using FIFO Compaction when your use case is\n\n* Very high volume raw data which has low TTL and which is the source of another data (after additional processing).\n* Data which can be kept entirely in a a block cache (RAM/SSD). No need for compaction of a raw data at all.\n\nDo not use FIFO compaction when\n\n* Table/ColumnFamily has MIN\\_VERSION > 0\n* Table/ColumnFamily has TTL = FOREVER (HColumnDescriptor.DEFAULT\\_TTL)\n\n#### Enabling FIFO Compaction\n\nFor Table:\n\n```java\nHTableDescriptor desc = new HTableDescriptor(tableName);\ndesc.setConfiguration(DefaultStoreEngine.DEFAULT_COMPACTION_POLICY_CLASS_KEY,\n  FIFOCompactionPolicy.class.getName());\n```\n\nFor Column Family:\n\n```java\nHColumnDescriptor desc = new HColumnDescriptor(family);\ndesc.setConfiguration(DefaultStoreEngine.DEFAULT_COMPACTION_POLICY_CLASS_KEY,\n  FIFOCompactionPolicy.class.getName());\n```\n\nFrom HBase Shell:\n\n```bash\ncreate 'x',{NAME=>'y', TTL=>'30'}, {CONFIGURATION => {'hbase.hstore.defaultengine.compactionpolicy.class' => 'org.apache.hadoop.hbase.regionserver.compactions.FIFOCompactionPolicy', 'hbase.hstore.blockingStoreFiles' => 1000}}\n```\n\nAlthough region splitting is still supported, for optimal performance it should be disabled, either by setting explicitly `DisabledRegionSplitPolicy` or by setting `ConstantSizeRegionSplitPolicy` and very large max region size. You will have to increase to a very large number store's blocking file (`hbase.hstore.blockingStoreFiles`) as well. There is a sanity check on table/column family configuration in case of FIFO compaction and minimum value for number of blocking file is 1000.\n\n## Bulk Loading\n\n## Overview\n\nHBase includes several methods of loading data into tables. The most straightforward method is to either use the `TableOutputFormat` class from a MapReduce job, or use the normal client APIs; however, these are not always the most efficient methods.\n\nThe bulk load feature uses a MapReduce job to output table data in HBase's internal data format, and then directly load the generated StoreFiles into a running cluster. Using bulk load will use less CPU and network resources than loading via the HBase API.\n\n## Bulk Load Architecture\n\nThe HBase bulk load process consists of two main steps.\n\n### Preparing data via a MapReduce job\n\nThe first step of a bulk load is to generate HBase data files (StoreFiles) from a MapReduce job using `HFileOutputFormat2`. This output format writes out data in HBase's internal storage format so that they can be later loaded efficiently into the cluster.\n\nIn order to function efficiently, `HFileOutputFormat2` must be configured such that each output HFile fits within a single region. In order to do this, jobs whose output will be bulk loaded into HBase use Hadoop's `TotalOrderPartitioner` class to partition the map output into disjoint ranges of the key space, corresponding to the key ranges of the regions in the table.\n\n`HFileOutputFormat2` includes a convenience function, `configureIncrementalLoad()`, which automatically sets up a `TotalOrderPartitioner` based on the current region boundaries of a table.\n\n### Completing the data load\n\nAfter a data import has been prepared, either by using the `importtsv` tool with the “importtsv.bulk.output” option or by some other MapReduce job using the `HFileOutputFormat`, the `completebulkload` tool is used to import the data into the running cluster. This command line tool iterates through the prepared data files, and for each one determines the region the file belongs to. It then contacts the appropriate RegionServer which adopts the HFile, moving it into its storage directory and making the data available to clients.\n\nIf the region boundaries have changed during the course of bulk load preparation, or between the preparation and completion steps, the `completebulkload` utility will automatically split the data files into pieces corresponding to the new boundaries. This process is not optimally efficient, so users should take care to minimize the delay between preparing a bulk load and importing it into the cluster, especially if other clients are simultaneously loading data through other means.\n\n```bash\n$ hadoop jar hbase-mapreduce-VERSION.jar completebulkload [-c /path/to/hbase/config/hbase-site.xml] /user/todd/myoutput mytable\n```\n\nThe `-c config-file` option can be used to specify a file containing the appropriate hbase parameters (e.g., hbase-site.xml) if not supplied already on the CLASSPATH (In addition, the CLASSPATH must contain the directory that has the zookeeper configuration file if zookeeper is NOT managed by HBase).\n\n## See Also\n\nFor more information about the referenced utilities, see [ImportTsv](/docs/operational-management/tools#importtsv) and [CompleteBulkLoad](/docs/operational-management/tools#completebulkload).\n\nSee [How-to: Use HBase Bulk Loading, and Why](http://blog.cloudera.com/blog/2013/09/how-to-use-hbase-bulk-loading-and-why/) for an old blog post on loading.\n\n## Advanced Usage\n\nAlthough the `importtsv` tool is useful in many cases, advanced users may want to generate data programmatically, or import data from other formats. To get started doing so, dig into `ImportTsv.java` and check the JavaDoc for HFileOutputFormat.\n\nThe import step of the bulk load can also be done programmatically. See the `LoadIncrementalHFiles` class for more information.\n\n### 'Adopting' Stray Data\n\nShould an HBase cluster lose account of regions or files during an outage or error, you can use the `completebulkload` tool to add back the dropped data. HBase operator tooling such as [HBCK2](https://github.com/apache/hbase-operator-tools/tree/master/hbase-hbck2) or the reporting added to the Master's UI under the `HBCK Report` (Since HBase 2.0.6/2.1.6/2.2.1) can identify such 'orphan' directories.\n\nBefore you begin the 'adoption', ensure the `hbase:meta` table is in a healthy state. Run the `CatalogJanitor` by executing the `catalogjanitor_run` command on the HBase shell. When finished, check the `HBCK Report` page on the Master UI. Work on fixing any inconsistencies, holes, or overlaps found before proceeding. The `hbase:meta` table is the authority on where all data is to be found and must be consistent for the `completebulkload` tool to work properly.\n\nThe `completebulkload` tool takes a directory and a `tablename`. The directory has subdirectories named for column families of the targeted `tablename`. In these subdirectories are `hfiles` to load. Given this structure, you can pass errant region directories (and the table name to which the region directory belongs) and the tool will bring the data files back into the fold by moving them under the approprate serving directory. If stray files, then you will need to mock up this structure before invoking the `completebulkload` tool; you may have to look at the file content using the [HFile Tool](/docs/operational-management/tools#operational-management-tools-hfile-tool) to see what the column family to use is. When the tool completes its run, you will notice that the source errant directory has had its storefiles moved/removed. It is now desiccated since its data has been drained, and the pointed-to directory can be safely removed. It may still have `.regioninfo` files and other subdirectories but they are of no relevance now (There may be content still under the *recovered\\_edits* directory; a TODO is tooling to replay the content of *recovered\\_edits* if needed; see [Add RecoveredEditsPlayer](https://issues.apache.org/jira/browse/HBASE-22976)). If you pass `completebulkload` a directory without store files, it will run and note the directory is storefile-free. Just remove such 'empty' directories.\n\nFor example, presuming a directory at the top level in HDFS named `eb3352fb5c9c9a05feeb2caba101e1cc` has data we need to re-add to the HBase `TestTable`:\n\n```bash\n$ ${HBASE_HOME}/bin/hbase --config ~/hbase-conf completebulkload hdfs://server.example.org:9000/eb3352fb5c9c9a05feeb2caba101e1cc TestTable\n```\n\nAfter it successfully completes, any files that were in `eb3352fb5c9c9a05feeb2caba101e1cc` have been moved under hbase and the `eb3352fb5c9c9a05feeb2caba101e1cc` directory can be deleted (Check content before and after by running `ls -r` on the HDFS directory).\n\n## Bulk Loading Replication\n\nHBASE-13153 adds replication support for bulk loaded HFiles, available since HBase 1.3/2.0. This feature is enabled by setting `hbase.replication.bulkload.enabled` to `true` (default is `false`). You also need to copy the source cluster configuration files to the destination cluster.\n\nAdditional configurations are required too:\n\n1. `hbase.replication.source.fs.conf.provider`\\\n   This defines the class which loads the source cluster file system client configuration in the destination cluster. This should be configured for all the RS in the destination cluster. Default is `org.apache.hadoop.hbase.replication.regionserver.DefaultSourceFSConfigurationProvider`.\n2. `hbase.replication.conf.dir`\\\n   This represents the base directory where the file system client configurations of the source cluster are copied to the destination cluster. This should be configured for all the RS in the destination cluster. Default is `$HBASE_CONF_DIR`.\n3. `hbase.replication.cluster.id`\\\n   This configuration is required in the cluster where replication for bulk loaded data is enabled. A source cluster is uniquely identified by the destination cluster using this id. This should be configured for all the RS in the source cluster configuration file for all the RS.\n\nFor example: If source cluster FS client configurations are copied to the destination cluster under directory `/home/user/dc1/`, then `hbase.replication.cluster.id` should be configured as `dc1` and `hbase.replication.conf.dir` as `/home/user`.\n\n<Callout type=\"info\">\n  `DefaultSourceFSConfigurationProvider` supports only `xml` type files. It loads source cluster FS\n  client configuration only once, so if source cluster FS client configuration files are updated,\n  every peer(s) cluster RS must be restarted to reload the configuration.\n</Callout>\n\n## HDFS\n\nAs HBase runs on HDFS (and each StoreFile is written as a file on HDFS), it is important to have an understanding of the HDFS Architecture especially in terms of how it stores files, handles failovers, and replicates blocks.\n\nSee the Hadoop documentation on [HDFS Architecture](https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html) for more information.\n\n## NameNode\n\nThe NameNode is responsible for maintaining the filesystem metadata. See the above HDFS Architecture link for more information.\n\n## DataNode\n\nThe DataNodes are responsible for storing HDFS blocks. See the above HDFS Architecture link for more information.\n\n## Timeline-consistent High Available Reads\n\n## Introduction\n\nHBase, architecturally, always had the strong consistency guarantee from the start. All reads and writes are routed through a single region server, which guarantees that all writes happen in an order, and all reads are seeing the most recent committed data.\n\nHowever, because of this single homing of the reads to a single location, if the server becomes unavailable, the regions of the table that were hosted in the region server become unavailable for some time. There are three phases in the region recovery process - detection, assignment, and recovery. Of these, the detection is usually the longest and is presently in the order of 20-30 seconds depending on the ZooKeeper session timeout. During this time and before the recovery is complete, the clients will not be able to read the region data.\n\nHowever, for some use cases, either the data may be read-only, or doing reads against some stale data is acceptable. With timeline-consistent high available reads, HBase can be used for these kind of latency-sensitive use cases where the application can expect to have a time bound on the read completion.\n\nFor achieving high availability for reads, HBase provides a feature called *region replication*. In this model, for each region of a table, there will be multiple replicas that are opened in different RegionServers. By default, the region replication is set to 1, so only a single region replica is deployed and there will not be any changes from the original model. If region replication is set to 2 or more, then the master will assign replicas of the regions of the table. The Load Balancer ensures that the region replicas are not co-hosted in the same region servers and also in the same rack (if possible).\n\nAll of the replicas for a single region will have a unique replica*id, starting from 0. The region replica having replica\\_id==0 is called the primary region, and the others \\_secondary regions* or secondaries. Only the primary can accept writes from the client, and the primary will always contain the latest changes. Since all writes still have to go through the primary region, the writes are not highly-available (meaning they might block for some time if the region becomes unavailable).\n\n## Timeline Consistency\n\nWith this feature, HBase introduces a Consistency definition, which can be provided per read operation (get or scan).\n\n```java\npublic enum Consistency {\n    STRONG,\n    TIMELINE\n}\n```\n\n`Consistency.STRONG` is the default consistency model provided by HBase. In case the table has region replication = 1, or in a table with region replicas but the reads are done with this consistency, the read is always performed by the primary regions, so that there will not be any change from the previous behaviour, and the client always observes the latest data.\n\nIn case a read is performed with `Consistency.TIMELINE`, then the read RPC will be sent to the primary region server first. After a short interval (`hbase.client.primaryCallTimeout.get`, 10ms by default), parallel RPC for secondary region replicas will also be sent if the primary does not respond back. After this, the result is returned from whichever RPC is finished first. If the response came back from the primary region replica, we can always know that the data is latest. For this Result.isStale() API has been added to inspect the staleness. If the result is from a secondary region, then Result.isStale() will be set to true. The user can then inspect this field to possibly reason about the data.\n\nIn terms of semantics, TIMELINE consistency as implemented by HBase differs from pure eventual consistency in these respects:\n\n* Single homed and ordered updates: Region replication or not, on the write side, there is still only 1 defined replica (primary) which can accept writes. This replica is responsible for ordering the edits and preventing conflicts. This guarantees that two different writes are not committed at the same time by different replicas and the data diverges. With this, there is no need to do read-repair or last-timestamp-wins kind of conflict resolution.\n* The secondaries also apply the edits in the order that the primary committed them. This way the secondaries will contain a snapshot of the primaries data at any point in time. This is similar to RDBMS replications and even HBase's own multi-datacenter replication, however in a single cluster.\n* On the read side, the client can detect whether the read is coming from up-to-date data or is stale data. Also, the client can issue reads with different consistency requirements on a per-operation basis to ensure its own semantic guarantees.\n* The client can still observe edits out-of-order, and can go back in time, if it observes reads from one secondary replica first, then another secondary replica. There is no stickiness to region replicas or a transaction-id based guarantee. If required, this can be implemented later though.\n\n**Timeline Consistency**\n<img alt=\"Timeline Consistency\" src={__img3} placeholder=\"blur\" />\n\nTo better understand the TIMELINE semantics, let's look at the above diagram. Let's say that there are two clients, and the first one writes x=1 at first, then x=2 and x=3 later. As above, all writes are handled by the primary region replica. The writes are saved in the write ahead log (WAL), and replicated to the other replicas asynchronously. In the above diagram, notice that replica\\_id=1 received 2 updates, and its data shows that x=2, while the replica\\_id=2 only received a single update, and its data shows that x=1.\n\nIf client1 reads with STRONG consistency, it will only talk with the replica\\_id=0, and thus is guaranteed to observe the latest value of x=3. In case of a client issuing TIMELINE consistency reads, the RPC will go to all replicas (after primary timeout) and the result from the first response will be returned back. Thus the client can see either 1, 2 or 3 as the value of x. Let's say that the primary region has failed and log replication cannot continue for some time. If the client does multiple reads with TIMELINE consistency, she can observe x=2 first, then x=1, and so on.\n\n## Tradeoffs\n\nHaving secondary regions hosted for read availability comes with some tradeoffs which should be carefully evaluated per use case. Following are advantages and disadvantages.\n\n**Advantages:**\n\n* High availability for read-only tables\n* High availability for stale reads\n* Ability to do very low latency reads with very high percentile (99.9%+) latencies for stale reads\n\n**Disadvantages:**\n\n* Double / Triple MemStore usage (depending on region replication count) for tables with region replication > 1\n* Increased block cache usage\n* Extra network traffic for log replication\n* Extra backup RPCs for replicas\n\nTo serve the region data from multiple replicas, HBase opens the regions in secondary mode in the region servers. The regions opened in secondary mode will share the same data files with the primary region replica, however each secondary region replica will have its own MemStore to keep the unflushed data (only primary region can do flushes). Also to serve reads from secondary regions, the blocks of data files may be also cached in the block caches for the secondary regions.\n\n## Where is the code\n\nThis feature is delivered in two phases, Phase 1 and 2. The first phase is done in time for HBase-1.0.0 release. Meaning that using HBase-1.0.x, you can use all the features that are marked for Phase 1. Phase 2 is committed in HBase-1.1.0, meaning all HBase versions after 1.1.0 should contain Phase 2 items.\n\n## Propagating writes to region replicas\n\nAs discussed above writes only go to the primary region replica. For propagating the writes from the primary region replica to the secondaries, there are two different mechanisms. For read-only tables, you do not need to use any of the following methods. Disabling and enabling the table should make the data available in all region replicas. For mutable tables, you have to use **only** one of the following mechanisms: storefile refresher, or async wal replication. The latter is recommended.\n\n### StoreFile Refresher\n\nThe first mechanism is store file refresher which is introduced in HBase-1.0+. Store file refresher is a thread per region server, which runs periodically, and does a refresh operation for the store files of the primary region for the secondary region replicas. If enabled, the refresher will ensure that the secondary region replicas see the new flushed, compacted or bulk loaded files from the primary region in a timely manner. However, this means that only flushed data can be read back from the secondary region replicas, and after the refresher is run, making the secondaries lag behind the primary for an a longer time.\n\nFor turning this feature on, you should configure `hbase.regionserver.storefile.refresh.period` to a non-zero value. See Configuration section below.\n\n### Async WAL replication\n\nThe second mechanism for propagation of writes to secondaries is done via the “Async WAL Replication” feature. It is only available in HBase-1.1+. This works similarly to HBase's multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as “in-cluster replication”, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region's in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n\nCommitting writes in the same order as in primary ensures that the secondaries won't diverge from the primary regions data, but since the log replication is asynchronous, the data might still be stale in secondary regions.\n\nAsync WAL Replication is **disabled** by default. You can enable this feature by setting `hbase.region.replica.replication.enabled` to `true`.\n\nBefore 3.0.0, this feature works as a replication endpoint, the performance and latency characteristics is expected to be similar to inter-cluster replication. And once enabled, it will create a replication peer named `region_replica_replication` as a replication peer when you create a table with region replication > 1 for the first time.\n\nif you want to disable this feature, you need to do two actions in the following order: \\* Set configuration property `hbase.region.replica.replication.enabled` to false in `hbase-site.xml` (see Configuration section below) \\* Disable the replication peer named `region_replica_replication` in the cluster using hbase shell or `Admin` class:\n\n```ruby\nhbase> disable_peer 'region_replica_replication'\n```\n\nIn 3.0.0, this feature is re-implemented to decouple with the general replication framework. Now we do not need to create a special replication peer. And during rolling upgrading, we will remove this replication peer automatically if it is present. See [HBASE-26233](https://issues.apache.org/jira/browse/HBASE-26233) and the design doc in our git repo for more details.\n\nAsync WAL Replication and the `hbase:meta` table is a little more involved and gets its own section below; see [Region replication for META table's region](/docs/architecture/timeline-consistent-reads#region-replication-for-meta-tables-region)\n\n## Store File TTL\n\nIn both of the write propagation approaches mentioned above, store files of the primary will be opened in secondaries independent of the primary region. So for files that the primary compacted away, the secondaries might still be referring to these files for reading. Both features are using HFileLinks to refer to files, but there is no protection (yet) for guaranteeing that the file will not be deleted prematurely. Thus, as a guard, you should set the configuration property `hbase.master.hfilecleaner.ttl` to a larger value, such as 1 hour to guarantee that you will not receive IOExceptions for requests going to replicas.\n\n## Region replication for META table's region\n\nThe general Async WAL Replication does not work for the META table's WAL. The meta table's secondary replicas refresh themselves from the persistent store files every `hbase.regionserver.meta.storefile.refresh.period`, (a non-zero value). Note how the META replication period is distinct from the user-space `hbase.regionserver.storefile.refresh.period` value.\n\n### Async WAL Replication for META table as of hbase-2.4.0+\n\nAsync WAL replication for META is added as a new feature in 2.4.0. Set `hbase.region.replica.replication.catalog.enabled` to enable async WAL Replication for META region replicas. It is off by default.\n\nRegarding META replicas count, up to hbase-2.4.0, you would set the special property 'hbase.meta.replica.count'. Now you can alter the META table as you would a user-space table (if `hbase.meta.replica.count` is set, it will take precedent over what is set for replica count in the META table updating META replica count to match).\n\n### Async WAL Replication for META table as of hbase-3.0.0+\n\nIn [HBASE-26233](https://issues.apache.org/jira/browse/HBASE-26233) we re-implemented the region replication framework to not rely on the general replication framework, so it can work together with META table as well. The code described in the above section have been removed mostly, but the config `hbase.region.replica.replication.catalog.enabled` is still kept, you could still use it to control whether to enable async wal replication for META table. And the ability to alter META table is also kept.\n\n### Load Balancing META table load\n\nhbase-2.4.0 also adds a new client-side `LoadBalance` mode. When enabled client-side, clients will try to read META replicas first before falling back on the primary. Before this, the replica lookup mode — now named `HedgedRead` in hbase-2.4.0 — had clients read the primary and if no response after a configurable amount of time had elapsed, it would start up reads against the replicas. Starting from hbase-2.4.12(and all higher minor versions), with client-side `LoadBalance` mode, clients load balance META scan requests across all META replica regions, including the primary META region. In case of exceptions such as NotServingRegionException, it will fall back on the primary META region.\n\nThe new 'LoadBalance' mode helps alleviate hotspotting on the META table distributing META read load.\n\nTo enable the meta replica locator's load balance mode, please set the following configuration at on the **client-side** (only): set 'hbase.locator.meta.replicas.mode' to \"LoadBalance\". Valid options for this configuration are `None`, `HedgedRead`, and `LoadBalance`. Option parse is case insensitive. The default mode is `None` (which falls through to `HedgedRead`, the current default). Do NOT put this configuration in any hbase server-side's configuration, Master or RegionServer (Master could make decisions based off stale state — to be avoided).\n\n## Memory accounting\n\nThe secondary region replicas refer to the data files of the primary region replica, but they have their own memstores (in HBase-1.1+) and uses block cache as well. However, one distinction is that the secondary region replicas cannot flush the data when there is memory pressure for their memstores. They can only free up memstore memory when the primary region does a flush and this flush is replicated to the secondary. Since in a region server hosting primary replicas for some regions and secondaries for some others, the secondaries might cause extra flushes to the primary regions in the same host. In extreme situations, there can be no memory left for adding new writes coming from the primary via wal replication. For unblocking this situation (and since secondary cannot flush by itself), the secondary is allowed to do a “store file refresh” by doing a file system list operation to pick up new files from primary, and possibly dropping its memstore. This refresh will only be performed if the memstore size of the biggest secondary region replica is at least `hbase.region.replica.storefile.refresh.memstore.multiplier` (default 4) times bigger than the biggest memstore of a primary replica. One caveat is that if this is performed, the secondary can observe partial row updates across column families (since column families are flushed independently). The default should be good to not do this operation frequently. You can set this value to a large number to disable this feature if desired, but be warned that it might cause the replication to block forever.\n\n## Secondary replica failover\n\nWhen a secondary region replica first comes online, or fails over, it may have served some edits from its memstore. Since the recovery is handled differently for secondary replicas, the secondary has to ensure that it does not go back in time before it starts serving requests after assignment. For doing that, the secondary waits until it observes a full flush cycle (start flush, commit flush) or a “region open event” replicated from the primary. Until this happens, the secondary region replica will reject all read requests by throwing an IOException with message “The region's reads are disabled”. However, the other replicas will probably still be available to read, thus not causing any impact for the rpc with TIMELINE consistency. To facilitate faster recovery, the secondary region will trigger a flush request from the primary when it is opened. The configuration property `hbase.region.replica.wait.for.primary.flush` (enabled by default) can be used to disable this feature if needed.\n\n## Configuration properties\n\nTo use highly available reads, you should set the following properties in `hbase-site.xml` file. There is no specific configuration to enable or disable region replicas. Instead you can change the number of region replicas per table to increase or decrease at the table creation or with alter table. The following configuration is for using async wal replication and using meta replicas of 3.\n\n### Server side properties\n\n```xml\n<property>\n  <name>hbase.regionserver.storefile.refresh.period</name>\n  <value>0</value>\n  <description>\n    The period (in milliseconds) for refreshing the store files for the secondary regions. 0 means this feature is disabled. Secondary regions sees new files (from flushes and compactions) from primary once the secondary region refreshes the list of files in the region (there is no notification mechanism). But too frequent refreshes might cause extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger value is also recommended with this setting.\n  </description>\n</property>\n\n<property>\n  <name>hbase.regionserver.meta.storefile.refresh.period</name>\n  <value>300000</value>\n  <description>\n    The period (in milliseconds) for refreshing the store files for the hbase:meta tables secondary regions. 0 means this feature is disabled. Secondary regions sees new files (from flushes and compactions) from primary once the secondary region refreshes the list of files in the region (there is no notification mechanism). But too frequent refreshes might cause extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger value is also recommended with this setting. This should be a non-zero number if meta replicas are enabled.\n  </description>\n</property>\n\n<property>\n  <name>hbase.region.replica.replication.enabled</name>\n  <value>true</value>\n  <description>\n    Whether asynchronous WAL replication to the secondary region replicas is enabled or not. If this is enabled, a replication peer named \"region_replica_replication\" will be created which will tail the logs and replicate the mutations to region replicas for tables that have region replication > 1. If this is enabled once, disabling this replication also requires disabling the replication peer using shell or Admin java class. Replication to secondary region replicas works over standard inter-cluster replication.\n  </description>\n</property>\n\n<property>\n  <name>hbase.master.hfilecleaner.ttl</name>\n  <value>3600000</value>\n  <description>\n    The period (in milliseconds) to keep store files in the archive folder before deleting them from the file system.\n  </description>\n</property>\n\n<property>\n  <name>hbase.region.replica.storefile.refresh.memstore.multiplier</name>\n  <value>4</value>\n  <description>\n    The multiplier for a \"store file refresh\" operation for the secondary region replica. If a region server has memory pressure, the secondary region will refresh it's store files if the memstore size of the biggest secondary replica is bigger this many times than the memstore size of the biggest primary replica. Set this to a very big value to disable this feature (not recommended).\n  </description>\n</property>\n\n<property>\n  <name>hbase.region.replica.wait.for.primary.flush</name>\n  <value>true</value>\n  <description>\n    Whether to wait for observing a full flush cycle from the primary before start serving data in a secondary. Disabling this might cause the secondary region replicas to go back in time for reads between region movements.Please note that if you set per-table property `REGION_MEMSTORE_REPLICATION` to false,`hbase.region.replica.wait.for.primary.flush` will be ignored.\n  </description>\n</property>\n```\n\nOne thing to keep in mind also is that, region replica placement policy is only enforced by the `StochasticLoadBalancer` which is the default balancer. If you are using a custom load balancer property in hbase-site.xml (`hbase.master.loadbalancer.class`) replicas of regions might end up being hosted in the same server.\n\n### Client side properties\n\nEnsure to set the following for all clients (and servers) that will use region replicas.\n\n```xml\n<property>\n  <name>hbase.ipc.client.specificThreadForWriting</name>\n  <value>true</value>\n  <description>\n    Whether to enable interruption of RPC threads at the client side. This is required for region replicas with fallback RPC's to secondary regions.\n  </description>\n</property>\n<property>\n  <name>hbase.client.primaryCallTimeout.get</name>\n  <value>10000</value>\n  <description>\n    The timeout (in microseconds), before secondary fallback RPC's are submitted for get requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC's, but will lower the p99 latencies.\n  </description>\n</property>\n<property>\n  <name>hbase.client.primaryCallTimeout.multiget</name>\n  <value>10000</value>\n  <description>\n    The timeout (in microseconds), before secondary fallback RPC's are submitted for multi-get requests (Table.get(List<Get>)) with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC's, but will lower the p99 latencies.\n  </description>\n</property>\n<property>\n  <name>hbase.client.replicaCallTimeout.scan</name>\n  <value>1000000</value>\n  <description>\n    The timeout (in microseconds), before secondary fallback RPC's are submitted for scan requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 1 sec. Setting this lower will increase the number of RPC's, but will lower the p99 latencies.\n  </description>\n</property>\n<property>\n  <name>hbase.meta.replicas.use</name>\n  <value>true</value>\n  <description>\n    Whether to use meta table replicas or not. Default is false.\n  </description>\n</property>\n```\n\nNote HBase-1.0.x users should use `hbase.ipc.client.allowsInterrupt` rather than `hbase.ipc.client.specificThreadForWriting`.\n\n## User Interface\n\nIn the masters user interface, the region replicas of a table are also shown together with the primary regions. You can notice that the replicas of a region will share the same start and end keys and the same region name prefix. The only difference would be the appended replica\\_id (which is encoded as hex), and the region encoded name will be different. You can also see the replica ids shown explicitly in the UI.\n\n## Creating a table with region replication\n\nRegion replication is a per-table property. All tables have `REGION_REPLICATION = 1` by default, which means that there is only one replica per region. You can set and change the number of replicas per region of a table by supplying the `REGION_REPLICATION` property in the table descriptor.\n\nThere is another per-table property `REGION_MEMSTORE_REPLICATION`.All tables have `REGION_MEMSTORE_REPLICATION = true` by default, which means the new data written to the primary region should be replicated. If you set this to `false`, replicas do not receive memstore updates from the primary RegionServer,they will only receive updates for events like flushes and bulkloads, and will not have access to data which the primary has not yet flushed. Please note that if you set `REGION_MEMSTORE_REPLICATION` to false,`hbase.region.replica.wait.for.primary.flush` will be ignored.\n\n### Shell\n\n```ruby\ncreate 't1', 'f1', {REGION_REPLICATION => 2}\n\ndescribe 't1'\nfor i in 1..100\nput 't1', \"r#{i}\", 'f1:c1', i\nend\nflush 't1'\n```\n\n### Java\n\n```java\nHTableDescriptor htd = new HTableDescriptor(TableName.valueOf(“test_table”));\nhtd.setRegionReplication(2);\n...\nadmin.createTable(htd);\n```\n\nYou can also use `setRegionReplication()` and alter table to increase, decrease the region replication for a table.\n\n## Read API and Usage\n\n### Shell\n\nYou can do reads in shell using a the Consistency.TIMELINE semantics as follows\n\n```java\nhbase(main):001:0> get 't1','r6', {CONSISTENCY => \"TIMELINE\"}\n```\n\nYou can simulate a region server pausing or becoming unavailable and do a read from the secondary replica:\n\n```bash\n$ kill -STOP <pid or primary region server>\n\nhbase(main):001:0> get 't1','r6', {CONSISTENCY => \"TIMELINE\"}\n```\n\nUsing scans is also similar\n\n```java\nhbase> scan 't1', {CONSISTENCY => 'TIMELINE'}\n```\n\n### Java\n\nYou can set the consistency for Gets and Scans and do requests as follows.\n\n```java\nGet get = new Get(row);\nget.setConsistency(Consistency.TIMELINE);\n...\nResult result = table.get(get);\n```\n\nYou can also pass multiple gets:\n\n```java\nGet get1 = new Get(row);\nget1.setConsistency(Consistency.TIMELINE);\n...\nArrayList<Get> gets = new ArrayList<Get>();\ngets.add(get1);\n...\nResult[] results = table.get(gets);\n```\n\nAnd Scans:\n\n```java\nScan scan = new Scan();\nscan.setConsistency(Consistency.TIMELINE);\n...\nResultScanner scanner = table.getScanner(scan);\n```\n\nYou can inspect whether the results are coming from primary region or not by calling the `Result.isStale()` method:\n\n```java\nResult result = table.get(get);\nif (result.isStale()) {\n  ...\n}\n```\n\n## Storing Medium-sized Objects (MOB)\n\nData comes in many sizes, and saving all of your data in HBase, including binary\ndata such as images and documents, is ideal. While HBase can technically handle\nbinary objects with cells that are larger than 100 KB in size, HBase's normal\nread and write paths are optimized for values smaller than 100KB in size. When\nHBase deals with large numbers of objects over this threshold, referred to here\nas medium objects, or MOBs, performance is degraded due to write amplification\ncaused by splits and compactions. When using MOBs, ideally your objects will be between\n100KB and 10MB (see the [faq](/docs/faq)). HBase 2 added special internal handling of MOBs\nto maintain performance, consistency, and low operational overhead. MOB support is\nprovided by the work done in [HBASE-11339](https://issues.apache.org/jira/browse/HBASE-11339).\nTo take advantage of MOB, you need to use [HFile version 3](/docs/hfile-format#hbase-file-format-with-security-enhancements-version-3). Optionally,\nconfigure the MOB file reader's cache settings for each RegionServer (see\n[Configure the MOB Cache](/docs/architecture/hbase-mob#configuring-the-mob-cache)), then configure specific columns to hold MOB data.\nClient code does not need to change to take advantage of HBase MOB support. The\nfeature is transparent to the client.\n\n## Configuring Columns for MOB\n\nYou can configure columns to support MOB during table creation or alteration,\neither in HBase Shell or via the Java API. The two relevant properties are the\nboolean `IS_MOB` and the `MOB_THRESHOLD`, which is the number of bytes at which\nan object is considered to be a MOB. Only `IS_MOB` is required. If you do not\nspecify the `MOB_THRESHOLD`, the default threshold value of 100 KB is used.\n\n### Configure a Column for MOB Using HBase Shell\n\n```bash\nhbase> create 't1', {NAME => 'f1', IS_MOB => true, MOB_THRESHOLD => 102400}\nhbase> alter 't1', {NAME => 'f1', IS_MOB => true, MOB_THRESHOLD => 102400}\n```\n\n### Configure a Column for MOB Using the Java API\n\n```java\n...\nHColumnDescriptor hcd = new HColumnDescriptor(\"f\");\nhcd.setMobEnabled(true);\n...\nhcd.setMobThreshold(102400L);\n...\n```\n\n## Testing MOB\n\nThe utility `org.apache.hadoop.hbase.IntegrationTestIngestWithMOB` is provided to assist with testing\nthe MOB feature. The utility is run as follows:\n\n```bash\n$ sudo -u hbase hbase org.apache.hadoop.hbase.IntegrationTestIngestWithMOB \\\n        -threshold 1024 \\\n        -minMobDataSize 512 \\\n        -maxMobDataSize 5120\n```\n\n* **`threshold`** is the threshold at which cells are considered to be MOBs.\n  The default is 1 kB, expressed in bytes.\n* **`minMobDataSize`** is the minimum value for the size of MOB data.\n  The default is 512 B, expressed in bytes.\n* **`maxMobDataSize`** is the maximum value for the size of MOB data.\n  The default is 5 kB, expressed in bytes.\n\n## MOB architecture\n\nThis section is derived from information found in\n[HBASE-11339](https://issues.apache.org/jira/browse/HBASE-11339), which covered the initial GA\nimplementation of MOB in HBase and\n[HBASE-22749](https://issues.apache.org/jira/browse/HBASE-22749), which improved things by\nparallelizing MOB maintenance across the RegionServers. For more information see\nthe last version of the design doc created during the initial work,\n\"[HBASE-11339 MOB GA design.pdf](https://github.com/apache/hbase/blob/master/dev-support/design-docs/HBASE-11339%20MOB%20GA%20design.pdf)\",\nand the design doc for the distributed mob compaction feature,\n\"[HBASE-22749 MOB distributed compaction.pdf](https://github.com/apache/hbase/blob/master/dev-support/design-docs/HBASE-22749%20MOB%20distributed%20compaction.pdf)\".\n\n### Overview\n\nThe MOB feature reduces the overall IO load for configured column families by storing values that\nare larger than the configured threshold outside of the normal regions to avoid splits, merges, and\nmost importantly normal compactions.\n\nWhen a cell is first written to a region it is stored in the WAL and memstore regardless of value\nsize. When memstores from a column family configured to use MOB are eventually flushed two hfiles\nare written simultaneously. Cells with a value smaller than the threshold size are written to a\nnormal region hfile. Cells with a value larger than the threshold are written into a special MOB\nhfile and also have a MOB reference cell written into the normal region HFile. As the Region Server\nflushes a MOB enabled memstore and closes a given normal region HFile it appends metadata that lists\neach of the special MOB hfiles referenced by the cells within.\n\nMOB reference cells have the same key as the cell they are based on. The value of the reference cell\nis made up of two pieces of metadata: the size of the actual value and the MOB hfile that contains\nthe original cell. In addition to any tags originally written to HBase, the reference cell prepends\ntwo additional tags. The first is a marker tag that says the cell is a MOB reference. This can be\nused later to scan specifically just for reference cells. The second stores the namespace and table\nat the time the MOB hfile is written out. This tag is used to optimize how the MOB system finds\nthe underlying value in MOB hfiles after a series of HBase snapshot operations (ref HBASE-12332).\nNote that tags are only available within HBase servers and by default are not sent over RPCs.\n\nAll MOB hfiles for a given table are managed within a logical region that does not directly serve\nrequests. When these MOB hfiles are created from a flush or MOB compaction they are placed in a\ndedicated mob data area under the hbase root directory specific to the namespace, table, mob\nlogical region, and column family. In general that means a path structured like:\n\n```\n%HBase Root Dir%/mobdir/data/%namespace%/%table%/%logical region%/%column family%/\n```\n\nWith default configs, an example table named 'some\\_table' in the\ndefault namespace with a MOB enabled column family named 'foo' this HDFS directory would be\n\n```\n/hbase/mobdir/data/default/some_table/372c1b27e3dc0b56c3a031926e5efbe9/foo/\n```\n\nThese MOB hfiles are maintained by special chores in the HBase Master and across the individual\nRegion Servers. Specifically those chores take care of enforcing TTLs and compacting them. Note that\nthis compaction is primarily a matter of controlling the total number of files in HDFS because our\noperational assumptions for MOB data is that it will seldom update or delete.\n\nWhen a given MOB hfile is no longer needed as a result of our compaction process then a chore in\nthe Master will take care of moving it to the archive just\nlike any normal hfile. Because the table's mob region is independent of all the normal regions it\ncan coexist with them in the regular archive storage area:\n\n```\n/hbase/archive/data/default/some_table/372c1b27e3dc0b56c3a031926e5efbe9/foo/\n```\n\nThe same hfile cleaning chores that take care of eventually deleting unneeded archived files from\nnormal regions thus also will take care of these MOB hfiles. As such, if there is a snapshot of a\nMOB enabled table then the cleaning system will make sure those MOB files stick around in the\narchive area as long as they are needed by a snapshot or a clone of a snapshot.\n\n### MOB compaction\n\nEach time the memstore for a MOB enabled column family performs a flush HBase will write values over\nthe MOB threshold into MOB specific hfiles. When normal region compaction occurs the Region Server\nrewrites the normal data files while maintaining references to these MOB files without rewriting\nthem. Normal client lookups for MOB values transparently will receive the original values because\nthe Region Server internals take care of using the reference data to then pull the value out of a\nspecific MOB file. This indirection means that building up a large number of MOB hfiles doesn't\nimpact the overall time to retrieve any specific MOB cell. Thus, we need not perform compactions of\nthe MOB hfiles nearly as often as normal hfiles. As a result, HBase saves IO by not rewriting MOB\nhfiles as a part of the periodic compactions a Region Server does on its own.\n\nHowever, if deletes and updates of MOB cells are frequent then this indirection will begin to waste\nspace. The only way to stop using the space of a particular MOB hfile is to ensure no cells still\nhold references to it. To do that we need to ensure we have written the current values into a new\nMOB hfile. If our backing filesystem has a limitation on the number of files that can be present, as\nHDFS does, then even if we do not have deletes or updates of MOB cells eventually there will be a\nsufficient number of MOB hfiles that we will need to coalesce them.\n\nPeriodically a chore in the master coordinates having the region servers\nperform a special major compaction that also handles rewriting new MOB files. Like all compactions\nthe Region Server will create updated hfiles that hold both the cells that are smaller than the MOB\nthreshold and cells that hold references to the newly rewritten MOB file. Because this rewriting has\nthe advantage of looking across all active cells for the region our several small MOB files should\nend up as a single MOB file per region. The chore defaults to running weekly and can be\nconfigured by setting `hbase.mob.compaction.chore.period` to the desired period in seconds.\n\n```xml\n<property>\n  <name>hbase.mob.compaction.chore.period</name>\n  <value>2592000</value>\n  <description>Example of changing the chore period from a week to a month.</description>\n</property>\n```\n\nBy default, the periodic MOB compaction coordination chore will attempt to keep every region\nbusy doing compactions in parallel in order to maximize the amount of work done on the cluster.\nIf you need to tune the amount of IO this compaction generates on the underlying filesystem, you\ncan control how many concurrent region-level compaction requests are allowed by setting\n`hbase.mob.major.compaction.region.batch.size` to an integer number greater than zero. If you set\nthe configuration to 0 then you will get the default behavior of attempting to do all regions in\nparallel.\n\n```xml\n<property>\n  <name>hbase.mob.major.compaction.region.batch.size</name>\n  <value>1</value>\n  <description>Example of switching from \"as parallel as possible\" to \"serially\"</description>\n</property>\n```\n\n### MOB file archiving\n\nEventually we will have MOB hfiles that are no longer needed. Either clients will overwrite the\nvalue or a MOB-rewriting compaction will store a reference to a newer larger MOB hfile. Because any\ngiven MOB cell could have originally been written either in the current region or in a parent region\nthat existed at some prior point in time, individual Region Servers do not decide when it is time\nto archive MOB hfiles. Instead a periodic chore in the Master evaluates MOB hfiles for archiving.\n\nA MOB HFile will be subject to archiving under any of the following conditions:\n\n* Any MOB HFile older than the column family's TTL\n* Any MOB HFile older than a \"too recent\" threshold with no references to it from the regular hfiles\n  for all regions in a column family\n\nTo determine if a MOB HFile meets the second criteria the chore extracts metadata from the regular\nHFiles for each MOB enabled column family for a given table. That metadata enumerates the complete\nset of MOB HFiles needed to satisfy the references stored in the normal HFile area.\n\nThe period of the cleaner chore can be configured by setting `hbase.master.mob.cleaner.period` to a\npositive integer number of seconds. It defaults to running daily. You should not need to tune it\nunless you have a very aggressive TTL or a very high rate of MOB updates with a correspondingly\nhigh rate of non-MOB compactions.\n\n## MOB Optimization Tasks\n\n### Further limiting write amplification\n\nIf your MOB workload has few to no updates or deletes then you can opt-in to MOB compactions that\noptimize for limiting the amount of write amplification. It achieves this by setting a\nsize threshold to ignore MOB files during the compaction process. When a given region goes\nthrough MOB compaction it will evaluate the size of the MOB file that currently holds the actual\nvalue and skip rewriting the value if that file is over threshold.\n\nThe bound of write amplification in this mode can be approximated as\n\"Write Amplification\" = $\\log_{K}\\!\\left(\\frac{M}{S}\\right)$ where **K** is the number of files in compaction\nselection, **M** is the configurable threshold for MOB files size, and **S** is the minmum size of\nmemstore flushes that create MOB files in the first place. For example given 5 files picked up per\ncompaction, a threshold of 1 GB, and a flush size of 10MB the write amplification will be\n$\\log\\\\_{5}\\!\\left(\\frac{1\\,\\text{GB}}{10\\,\\text{MB}}\\right) = \\log\\\\_{5}(100) \\approx 2.86$.\n\nIf we are using an underlying filesystem with a limitation on the number of files, such as HDFS,\nand we know our expected data set size we can choose our maximum file size in order to approach\nthis limit but stay within it in order to minimize write amplification. For example, if we expect to\nstore a petabyte and we have a conservative limitation of a million files in our HDFS instance, then\n$\\frac{1\\,\\text{PB}}{1\\,\\text{M}} = 1\\,\\text{GB}$ gives us a target limitation of a gigabyte per MOB file.\n\nTo opt-in to this compaction mode you must set `hbase.mob.compaction.type` to `optimized`. The\ndefault MOB size threshold in this mode is set to 1GB. It can be changed by setting\n`hbase.mob.compactions.max.file.size` to a positive integer number of bytes.\n\n```xml\n<property>\n  <name>hbase.mob.compaction.type</name>\n  <value>optimized</value>\n  <description>opt-in to write amplification optimized mob compaction.</description>\n</property>\n<property>\n  <name>hbase.mob.compactions.max.file.size</name>\n  <value>10737418240</value>\n  <description>Example of tuning the max mob file size to 10GB</description>\n</property>\n```\n\nAdditionally, when operating in this mode the compaction process will seek to avoid writing MOB\nfiles that are over the max file threshold. As it is writing out a additional MOB values into a MOB\nhfile it will check to see if the additional data causes the hfile to be over the max file size.\nWhen the hfile of MOB values reaches limit, the MOB hfile is committed to the MOB storage area and\na new one is created. The hfile with reference cells will track the complete set of MOB hfiles it\nneeds in its metadata.\n\n<Callout type=\"warn\" title=\"Be mindful of total time to complete compaction of a region\">\n  When using the write amplification optimized compaction mode you need to watch for the maximum\n  time to compact a single region. If it nears an hour you should read through the troubleshooting\n  section below [Adjusting the MOB cleaner's tolerance for new\n  hfiles](/docs/architecture/hbase-mob#adjusting-the-mob-cleaners-tolerance-for-new-hfiles). Failure\n  to make the adjustments discussed there could lead to dataloss.\n</Callout>\n\n### Configuring the MOB Cache\n\nBecause there can be a large number of MOB files at any time, as compared to the number of HFiles,\nMOB files are not always kept open. The MOB file reader cache is a LRU cache which keeps the most\nrecently used MOB files open. To configure the MOB file reader's cache on each RegionServer, add\nthe following properties to the RegionServer's `hbase-site.xml`, customize the configuration to\nsuit your environment, and restart or rolling restart the RegionServer.\n\n#### Example MOB Cache Configuration\n\n```xml\n<property>\n  <name>hbase.mob.file.cache.size</name>\n  <value>1000</value>\n  <description>\n    Number of opened file handlers to cache.\n    A larger value will benefit reads by providing more file handlers per mob\n    file cache and would reduce frequent file opening and closing.\n    However, if this is set too high, this could lead to a \"too many opened file handers\"\n    The default value is 1000.\n  </description>\n</property>\n<property>\n  <name>hbase.mob.cache.evict.period</name>\n  <value>3600</value>\n  <description>\n    The amount of time in seconds after which an unused file is evicted from the\n    MOB cache. The default value is 3600 seconds.\n  </description>\n</property>\n<property>\n  <name>hbase.mob.cache.evict.remain.ratio</name>\n  <value>0.5f</value>\n  <description>\n    A multiplier (between 0.0 and 1.0), which determines how many files remain cached\n    after the threshold of files that remains cached after a cache eviction occurs\n    which is triggered by reaching the `hbase.mob.file.cache.size` threshold.\n    The default value is 0.5f, which means that half the files (the least-recently-used\n    ones) are evicted.\n  </description>\n</property>\n```\n\n### Manually Compacting MOB Files\n\nTo manually compact MOB files, rather than waiting for the\nperiodic chore to trigger compaction, use the\n`major_compact` HBase shell commands. These commands\nrequire the first argument to be the table name, and take a column\nfamily as the second argument. If used with a column family that includes MOB data, then\nthese operator requests will result in the MOB data being compacted.\n\n```bash\nhbase> major_compact 't1'\nhbase> major_compact 't2', 'c1'\n```\n\nThis same request can be made via the `Admin.majorCompact` Java API.\n\n## MOB Troubleshooting\n\n### Adjusting the MOB cleaner's tolerance for new hfiles\n\nThe MOB cleaner chore ignores all MOB hfiles that were created more recently than an hour prior to\nthe start of the chore to ensure we don't miss the reference metadata from the corresponding regular\nhfile. Without this safety check it would be possible for the cleaner chore to see a MOB hfile for\nan in progress flush or compaction and prematurely archive the MOB data. This default buffer should\nbe sufficient for normal use.\n\nYou will need to adjust the tolerance if you use write amplification optimized MOB compaction and\nthe combination of your underlying filesystem performance and data shape is such that it could take\nmore than an hour to complete major compaction of a single region. For example, if your MOB data is\ndistributed such that your largest region adds 80GB of MOB data between compactions that include\nrewriting MOB data and your HDFS cluster is only capable of writing 20MB/s for a single file then\nwhen performing the optimized compaction the Region Server will take about a minute to write the\nfirst 1GB MOB hfile and then another hour and seven minutes to write the remaining seventy-nine 1GB\nMOB hfiles before finally committing the new reference hfile at the end of the compaction. Given\nthis example, you would need a larger tolerance window.\n\nYou will also need to adjust the tolerance if Region Server flush operations take longer than an\nhour for the two HDFS move operations needed to commit both the MOB hfile and the normal hfile that\nreferences it. Such a delay should not happen with a normally configured and healthy HDFS and HBase.\n\nThe cleaner's window for \"too recent\" is controlled by setting `hbase.mob.min.age.archive` to a\npositive integer number of milliseconds.\n\n```xml\n<property>\n  <name>hbase.mob.min.age.archive</name>\n  <value>86400000</value>\n  <description>Example of tuning the cleaner to only archive files older than a day.</description>\n</property>\n```\n\n### Retrieving MOB metadata through the HBase Shell\n\nWhile working on troubleshooting failures in the MOB system you can retrieve some of the internal\ninformation through the HBase shell by specifying special attributes on a scan.\n\n```ruby\nhbase(main):112:0> scan 'some_table', {STARTROW => '00012-example-row-key', LIMIT => 1,\nhbase(main):113:1*     CACHE_BLOCKS => false, ATTRIBUTES => { 'hbase.mob.scan.raw' => '1',\nhbase(main):114:2*     'hbase.mob.scan.ref.only' => '1' } }\n```\n\nThe MOB internal information is stored as four bytes for the size of the underlying cell value and\nthen a UTF8 string with the name of the MOB HFile that contains the underlying cell value. Note that\nby default the entirety of this serialized structure will be passed through the HBase shell's binary\nstring converter. That means the bytes that make up the value size will most likely be written as\nescaped non-printable byte values, e.g. '\\x03', unless they happen to correspond to ASCII\ncharacters.\n\nLet's look at a specific example:\n\n```ruby\nhbase(main):112:0> scan 'some_table', {STARTROW => '00012-example-row-key', LIMIT => 1,\nhbase(main):113:1*     CACHE_BLOCKS => false, ATTRIBUTES => { 'hbase.mob.scan.raw' => '1',\nhbase(main):114:2*     'hbase.mob.scan.ref.only' => '1' } }\nROW                        COLUMN+CELL\n 00012-example-row-key     column=foo:bar, timestamp=1511179764, value=\\x00\\x02|\\x94d41d8cd98f00b204\n                       e9800998ecf8427e19700118ffd9c244fe69488bbc9f2c77d24a3e6a\n1 row(s) in 0.0130 seconds\n```\n\nIn this case the first four bytes are `\\x00\\x02|\\x94` which corresponds to the bytes\n`[0x00, 0x02, 0x7C, 0x94]`. (Note that the third byte was printed as the ASCII character '|'.)\nDecoded as an integer this gives us an underlying value size of 162,964 bytes.\n\nThe remaining bytes give us an HFile name,\n'd41d8cd98f00b204e9800998ecf8427e19700118ffd9c244fe69488bbc9f2c77d24a3e6a'. This HFile will most\nlikely be stored in the designated MOB storage area for this specific table. However, the file could\nalso be in the archive area if this table is from a restored snapshot. Furthermore, if the table is\nfrom a cloned snapshot of a different table then the file could be in either the active or archive\narea of that source table. As mentioned in the explanation of MOB reference cells above, the Region\nServer will use a server side tag to optimize looking at the mob and archive area of the correct\noriginal table when finding the MOB HFile. Since your scan is client side it can't retrieve that tag\nand you'll either need to already know the lineage of your table or you'll need to search across all\ntables.\n\nAssuming you are authenticated as a user with HBase superuser rights, you can search for it:\n\n```bash\n$> hdfs dfs -find /hbase -name \\\nd41d8cd98f00b204e9800998ecf8427e19700118ffd9c244fe69488bbc9f2c77d24a3e6a\n/hbase/mobdir/data/default/some_table/372c1b27e3dc0b56c3a031926e5efbe9/foo/d41d8cd98f00b204e9800998ecf8427e19700118ffd9c244fe69488bbc9f2c77d24a3e6a\n```\n\n### Moving a column family out of MOB\n\nIf you want to disable MOB on a column family you must ensure you instruct HBase to migrate the data\nout of the MOB system prior to turning the feature off. If you fail to do this HBase will return the\ninternal MOB metadata to applications because it will not know that it needs to resolve the actual\nvalues.\n\nThe following procedure will safely migrate the underlying data without requiring a cluster outage.\nClients will see a number of retries when configuration settings are applied and regions are\nreloaded.\n\n#### Procedure: Stop MOB maintenance, change MOB threshold, rewrite data via compaction\n\n<Steps>\n  <Step>\n    Ensure the MOB compaction chore in the Master is off by setting\n    `hbase.mob.compaction.chore.period` to `0`. Applying this configuration change will require a\n    rolling restart of HBase Masters. That will require at least one fail-over of the active master,\n    which may cause retries for clients doing HBase administrative operations.\n  </Step>\n\n  <Step>\n    Ensure no MOB compactions are issued for the table via the HBase shell for the duration of this\n    migration.\n  </Step>\n\n  <Step>\n    ##### Change the MOB size threshold\n\n    Use the HBase shell to change the MOB size threshold for the column family you are migrating to a\n    value that is larger than the largest cell present in the column family. E.g. given a table named\n    'some\\_table' and a column family named 'foo' we can pick one gigabyte as an arbitrary \"bigger than\n    what we store\" value:\n\n    ```ruby\n     hbase(main):011:0> alter 'some_table', {NAME => 'foo', MOB_THRESHOLD => '1000000000'}\n     Updating all regions with the new schema...\n     9/25 regions updated.\n     25/25 regions updated.\n     Done.\n     0 row(s) in 3.4940 seconds\n    ```\n\n    Note that if you are still ingesting data you must ensure this threshold is larger than any cell value you might write; MAX\\_INT would be a safe choice.\n  </Step>\n\n  <Step>\n    ##### Perform a major compaction on the table\n\n    Specifically you are performing a \"normal\" compaction and not a MOB compaction.\n\n    ```ruby\n    hbase(main):012:0> major_compact 'some_table'\n    0 row(s) in 0.2600 seconds\n    ```\n  </Step>\n\n  <Step>\n    ##### Monitor for the end of the major compaction\n\n    Since compaction is handled asynchronously you'll need to use the shell to first see the compaction start and then see it end.\n\n    HBase should first say that a \"MAJOR\" compaction is happening.\n\n    ```ruby\n    hbase(main):015:0> @hbase.admin(@formatter).instance_eval do\n    hbase(main):016:1*   p @admin.get_compaction_state('some_table').to_string\n    hbase(main):017:2* end\n    \"MAJOR\"\n    ```\n\n    When the compaction has finished the result should print out \"NONE\".\n\n    ```ruby\n    hbase(main):015:0> @hbase.admin(@formatter).instance_eval do\n    hbase(main):016:1*   p @admin.get_compaction_state('some_table').to_string\n    hbase(main):017:2* end\n    \"NONE\"\n    ```\n  </Step>\n\n  <Step>\n    Run the *mobrefs* utility to ensure there are no MOB cells. Specifically, the tool will launch a\n    Hadoop MapReduce job that will show a job counter of 0 input records when we've successfully\n    rewritten all of the data.\n\n    ```bash\n    $> HADOOP_CLASSPATH=/etc/hbase/conf:$(hbase mapredcp) yarn jar \\\n    /some/path/to/hbase-shaded-mapreduce.jar mobrefs mobrefs-report-output some_table foo\n    ...\n    19/12/10 11:38:47 INFO impl.YarnClientImpl: Submitted application application_1575695902338_0004\n    19/12/10 11:38:47 INFO mapreduce.Job: The url to track the job: https://rm-2.example.com:8090/proxy application_1575695902338_0004/\n    19/12/10 11:38:47 INFO mapreduce.Job: Running job: job_1575695902338_0004\n    19/12/10 11:38:57 INFO mapreduce.Job: Job job_1575695902338_0004 running in uber mode : false\n    19/12/10 11:38:57 INFO mapreduce.Job:  map 0% reduce 0%\n    19/12/10 11:39:07 INFO mapreduce.Job:  map 7% reduce 0%\n    19/12/10 11:39:17 INFO mapreduce.Job:  map 13% reduce 0%\n    19/12/10 11:39:19 INFO mapreduce.Job:  map 33% reduce 0%\n    19/12/10 11:39:21 INFO mapreduce.Job:  map 40% reduce 0%\n    19/12/10 11:39:22 INFO mapreduce.Job:  map 47% reduce 0%\n    19/12/10 11:39:23 INFO mapreduce.Job:  map 60% reduce 0%\n    19/12/10 11:39:24 INFO mapreduce.Job:  map 73% reduce 0%\n    19/12/10 11:39:27 INFO mapreduce.Job:  map 100% reduce 0%\n    19/12/10 11:39:35 INFO mapreduce.Job:  map 100% reduce 100%\n    19/12/10 11:39:35 INFO mapreduce.Job: Job job_1575695902338_0004 completed successfully\n    19/12/10 11:39:35 INFO mapreduce.Job: Counters: 54\n    ...\n           Map-Reduce Framework\n                   Map input records=0\n    ...\n    19/12/09 22:41:28 INFO mapreduce.MobRefReporter: Finished creating report for 'some_table', family='foo'\n    ```\n\n    If the data has not successfully been migrated out, this report will show both a non-zero number\n    of input records and a count of mob cells.\n\n    ```bash\n    $> HADOOP_CLASSPATH=/etc/hbase/conf:$(hbase mapredcp) yarn jar \\\n    /some/path/to/hbase-shaded-mapreduce.jar mobrefs mobrefs-report-output some_table foo\n    ...\n    19/12/10 11:44:18 INFO impl.YarnClientImpl: Submitted application application_1575695902338_0005\n    19/12/10 11:44:18 INFO mapreduce.Job: The url to track the job: https://busbey-2.gce.cloudera.com:8090 proxy/application_1575695902338_0005/\n    19/12/10 11:44:18 INFO mapreduce.Job: Running job: job_1575695902338_0005\n    19/12/10 11:44:26 INFO mapreduce.Job: Job job_1575695902338_0005 running in uber mode : false\n    19/12/10 11:44:26 INFO mapreduce.Job:  map 0% reduce 0%\n    19/12/10 11:44:36 INFO mapreduce.Job:  map 7% reduce 0%\n    19/12/10 11:44:45 INFO mapreduce.Job:  map 13% reduce 0%\n    19/12/10 11:44:47 INFO mapreduce.Job:  map 27% reduce 0%\n    19/12/10 11:44:48 INFO mapreduce.Job:  map 33% reduce 0%\n    19/12/10 11:44:50 INFO mapreduce.Job:  map 40% reduce 0%\n    19/12/10 11:44:51 INFO mapreduce.Job:  map 53% reduce 0%\n    19/12/10 11:44:52 INFO mapreduce.Job:  map 73% reduce 0%\n    19/12/10 11:44:54 INFO mapreduce.Job:  map 100% reduce 0%\n    19/12/10 11:44:59 INFO mapreduce.Job:  map 100% reduce 100%\n    19/12/10 11:45:00 INFO mapreduce.Job: Job job_1575695902338_0005 completed successfully\n    19/12/10 11:45:00 INFO mapreduce.Job: Counters: 54\n    ...\n           Map-Reduce Framework\n                   Map input records=1\n    ...\n           MOB\n                   NUM_CELLS=1\n    ...\n    19/12/10 11:45:00 INFO mapreduce.MobRefReporter: Finished creating report for 'some_table', family='foo'\n    ```\n\n    If this happens you should verify that MOB compactions are disabled, verify that you have picked a sufficiently large MOB threshold, and redo the major compaction step.\n  </Step>\n\n  <Step>\n    ##### Disable the MOB feature for the column family\n\n    When the *mobrefs* report shows that no more data is stored in the MOB system then you can safely alter the column family configuration so that the MOB feature is disabled.\n\n    ```ruby\n    hbase(main):017:0> alter 'some_table', {NAME => 'foo', IS_MOB => 'false'}\n    Updating all regions with the new schema...\n    8/25 regions updated.\n    25/25 regions updated.\n    Done.\n    0 row(s) in 2.9370 seconds\n    ```\n\n    The MOB feature will be disabled on a column family only after altering the column family and performing a major compaction. Before performing the major compaction after altering the column family, the MOB cells will still be present in the MOB storage.\n  </Step>\n\n  <Step>\n    After the column family no longer shows the MOB feature enabled, it is safe to start MOB maintenance chores again. You can allow the default to be used for `hbase.mob.compaction.chore.period` by removing it from your configuration files or restore it to whatever custom value you had prior to starting this process.\n  </Step>\n\n  <Step>\n    ##### Clean up residual MOB data\n\n    Once the MOB feature is disabled for the column family there will be no internal HBase process\n    looking for data in the MOB storage area specific to this column family. There will still be data\n    present there from prior to the compaction process that rewrote the values into HBase's data area.\n    You can check for this residual data directly in HDFS as an HBase superuser.\n\n    ```bash\n    $ hdfs dfs -count /hbase/mobdir/data/default/some_table\n               4           54         9063269081 /hbase/mobdir/data/default/some_table\n    ```\n\n    This data is spurious and may be reclaimed. You should sideline it, verify your application's view of the table, and then delete it.\n  </Step>\n</Steps>\n\n### Data values over than the MOB threshold show up stored in non-MOB hfiles\n\nBulk load and WAL split-to-HFile don't consider MOB threshold and write data into normal hfile (under /hbase/data directory).\n\n<Callout type=\"info\">\n  This won't cause any functional problem, during next compaction such data will be written out to\n  the MOB hfiles.\n</Callout>\n\n## MOB Upgrade Considerations\n\nGenerally, data stored using the MOB feature should transparently continue to work correctly across\nHBase upgrades.\n\n### Upgrading to a version with the \"distributed MOB compaction\" feature\n\nPrior to the work in HBASE-22749, \"Distributed MOB compactions\", HBase had the Master coordinate all\ncompaction maintenance of the MOB hfiles. Centralizing management of the MOB data allowed for space\noptimizations but safely coordinating that management with Region Servers resulted in edge cases that\ncaused data loss (ref [HBASE-22075](https://issues.apache.org/jira/browse/HBASE-22075)).\n\nUsers of the MOB feature upgrading to a version of HBase that includes HBASE-22749 should be aware\nof the following changes:\n\n* The MOB system no longer allows setting \"MOB Compaction Policies\"\n* The MOB system no longer attempts to group MOB values by the date of the original cell's timestamp\n  according to said compaction policies, daily or otherwise\n* The MOB system no longer needs to track individual cell deletes through the use of special\n  files in the MOB storage area with the suffix `_del`. After upgrading you should sideline these\n  files.\n* Under default configuration the MOB system should take much less time to perform a compaction of\n  MOB stored values. This is a direct consequence of the fact that HBase will place a much larger\n  load on the underlying filesystem when doing compactions of MOB stored values; the additional load\n  should be a multiple on the order of magnitude of number of region servers. I.e. for a cluster\n  with three region servers and two masters the default configuration should have HBase put three\n  times the load on HDFS during major compactions that rewrite MOB data when compared to Master\n  handled MOB compaction; it should also be approximately three times as fast.\n* When the MOB system detects that a table has hfiles with references to MOB data but the reference\n  hfiles do not yet have the needed file level metadata (i.e. from use of the MOB feature prior to\n  HBASE-22749) then it will refuse to archive *any* MOB hfiles from that table. The normal course of\n  periodic compactions done by Region Servers will update existing hfiles with MOB references, but\n  until a given table has been through the needed compactions operators should expect to see an\n  increased amount of storage used by the MOB feature.\n* Performing a compaction with type \"MOB\" no longer has special handling to compact specifically the\n  MOB hfiles. Instead it will issue a warning and do a compaction of the table. For example using\n  the HBase shell as follows will result in a warning in the Master logs followed by a major\n  compaction of the 'example' table in its entirety or for the 'big' column respectively.\n  ```ruby\n  hbase> major_compact 'example', nil, 'MOB'\n  hbase> major_compact 'example', 'big', 'MOB'\n  ```\n  The same is true for directly using the Java API for `admin.majorCompact(TableName.valueOf(\"example\"), CompactType.MOB)`.\n* Similarly, manually performing a major compaction on a table or region will also handle compacting\n  the MOB stored values for that table or region respectively.\n\nThe following configuration setting has been deprecated and replaced:\n\n* `hbase.master.mob.ttl.cleaner.period` has been replaced with `hbase.master.mob.cleaner.period`\n\nThe following configuration settings are no longer used:\n\n* `hbase.mob.compaction.mergeable.threshold`\n* `hbase.mob.delfile.max.count`\n* `hbase.mob.compaction.batch.size`\n* `hbase.mob.compactor.class`\n* `hbase.mob.compaction.threads.max`\n\n## Scan Over Snapshot\n\nIn HBase, a scan of a table costs server-side HBase resources reading, formating, and returning data back to the client.\nLuckily, HBase provides a TableSnapshotScanner and TableSnapshotInputFormat (introduced by [HBASE-8369](https://issues.apache.org/jira/browse/HBASE-8369)),\nwhich can scan HBase-written HFiles directly in the HDFS filesystem completely by-passing hbase. This access mode\nperforms better than going via HBase and can be used with an offline HBase with in-place or exported\nsnapshot HFiles.\n\nTo read HFiles directly, the user must have sufficient permissions to access snapshots or in-place hbase HFiles.\n\n## TableSnapshotScanner\n\nTableSnapshotScanner provides a means for running a single client-side scan over snapshot files.\nWhen using TableSnapshotScanner, we must specify a temporary directory to copy the snapshot files into.\nThe client user should have write permissions to this directory, and the dir should not be a subdirectory of\nthe hbase.rootdir. The scanner deletes the contents of the directory once the scanner is closed.\n\n### Use TableSnapshotScanner\n\n```java\nPath restoreDir = new Path(\"XX\"); // restore dir should not be a subdirectory of hbase.rootdir\nScan scan = new Scan();\ntry (TableSnapshotScanner scanner = new TableSnapshotScanner(conf, restoreDir, snapshotName, scan)) {\n    Result result = scanner.next();\n    while (result != null) {\n        ...\n        result = scanner.next();\n    }\n}\n```\n\n## TableSnapshotInputFormat\n\nTableSnapshotInputFormat provides a way to scan over snapshot HFiles in a MapReduce job.\n\n### Use TableSnapshotInputFormat\n\n```java\nJob job = new Job(conf);\nPath restoreDir = new Path(\"XX\"); // restore dir should not be a subdirectory of hbase.rootdir\nScan scan = new Scan();\nTableMapReduceUtil.initTableSnapshotMapperJob(snapshotName, scan, MyTableMapper.class, MyMapKeyOutput.class, MyMapOutputValueWritable.class, job, true, restoreDir);\n```\n\n## Permission to access snapshot and data files\n\nGenerally, only the HBase owner or the HDFS admin have the permission to access HFiles.\n\n[HBASE-18659](https://issues.apache.org/jira/browse/HBASE-18659) uses HDFS ACLs to make HBase granted user have permission to access snapshot files.\n\n### HDFS ACLs\n\n[HDFS ACLs](https://hadoop.apache.org/docs/r2.7.1/hadoop-project-dist/hadoop-hdfs/HdfsPermissionsGuide.html#ACLs_Access_Control_Lists) supports an \"access ACL\", which defines the rules to enforce during permission checks, and a \"default ACL\", which defines the ACL entries that new child files or sub-directories receive automatically during creation. Via HDFS ACLs, HBase syncs granted users with read permission to HFiles.\n\n### Basic idea\n\nThe HBase files are organized in the following ways:\n\n* `{hbase-rootdir}/.tmp/data/{namespace}/{table}`\n* `{hbase-rootdir}/data/{namespace}/{table}`\n* `{hbase-rootdir}/archive/data/{namespace}/{table}`\n* `{hbase-rootdir}/.hbase-snapshot/{snapshotName}`\n\nSo the basic idea is to add or remove HDFS ACLs to files of the global/namespace/table directory\nwhen grant or revoke permission to global/namespace/table.\n\nSee the design doc in [HBASE-18659](https://issues.apache.org/jira/browse/HBASE-18659) for more details.\n\n### Configuration to use this feature\n\n* Firstly, make sure that HDFS ACLs are enabled and umask is set to 027\n\n  ```\n  dfs.namenode.acls.enabled = true\n  fs.permissions.umask-mode = 027\n  ```\n\n* Add master coprocessor, please make sure the SnapshotScannerHDFSAclController is configured after AccessController\n\n  ```\n  hbase.coprocessor.master.classes = \"org.apache.hadoop.hbase.security.access.AccessController\n  ,org.apache.hadoop.hbase.security.access.SnapshotScannerHDFSAclController\"\n  ```\n\n* Enable this feature\n\n  ```\n  hbase.acl.sync.to.hdfs.enable=true\n  ```\n\n* Modify table scheme to enable this feature for a specified table, this config is\n  false by default for every table, this means the HBase granted ACLs will not be synced to HDFS\n\n  ```ruby\n  alter 't1', CONFIGURATION => {'hbase.acl.sync.to.hdfs.enable' => 'true'}\n  ```\n\n### Limitation\n\nThere are some limitations for this feature:\n\n* If we enable this feature, some master operations such as grant, revoke, snapshot... (See the design doc for more details) will be slower as we need to sync HDFS ACLs to related hfiles.\n* HDFS has a config which limits the max ACL entries num for one directory or file:\n  ```\n  dfs.namenode.acls.max.entries = 32(default value)\n  ```\n  The 32 entries include four fixed users for each directory or file: owner, group, other, and mask. For a directory, the four users contain 8 ACL entries(access and default) and for a file, the four users contain 4 ACL entries(access). This means there are 24 ACL entries left for named users or groups.\\\n  Based on this limitation, we can only sync up to 12 HBase granted users' ACLs. This means, if a table enables this feature, then the total users with table, namespace of this table, global READ permission should not be greater than 12.\n* There are some cases that this coprocessor has not handled or could not handle, so the user HDFS ACLs are not synced normally. It will not make a reference link to another hfile of other tables.\n\n***\n\n# In-memory Compaction\n\n## Overview\n\nIn-memory Compaction (A.K.A Accordion) is a new feature in hbase-2.0.0.\nIt was first introduced on the Apache HBase Blog at\n[Accordion: HBase Breathes with In-Memory Compaction](https://blogs.apache.org/hbase/entry/accordion-hbase-breathes-with-in).\nQuoting the blog:\n\n> Accordion reapplies the LSM principal \\[*Log-Structured-Merge Tree*, the design pattern upon which HBase is based] to MemStore, in order to eliminate redundancies and other overhead while the data is still in RAM. Doing so decreases the frequency of flushes to HDFS, thereby reducing the write amplification and the overall disk footprint. With less flushes, the write operations are stalled less frequently as the MemStore overflows, therefore the write performance is improved. Less data on disk also implies less pressure on the block cache, higher hit rates, and eventually better read response times. Finally, having less disk writes also means having less compaction happening in the background, i.e., less cycles are stolen from productive (read and write) work. All in all, the effect of in-memory compaction can be envisioned as a catalyst that enables the system move faster as a whole.\n\nA developer view is available at\n[Accordion: Developer View of In-Memory Compaction](https://blogs.apache.org/hbase/entry/accordion-developer-view-of-in).\n\nIn-memory compaction works best when high data churn; overwrites or over-versions\ncan be eliminated while the data is still in memory. If the writes are all uniques,\nit may drag write throughput (In-memory compaction costs CPU). We suggest you test\nand compare before deploying to production.\n\nIn this section we describe how to enable Accordion and the available configurations.\n\n## Enabling\n\nTo enable in-memory compactions, set the *IN\\_MEMORY\\_COMPACTION* attribute\non per column family where you want the behavior. The *IN\\_MEMORY\\_COMPACTION*\nattribute can have one of four values.\n\n* *NONE*: No in-memory compaction.\n* *BASIC*: Basic policy enables flushing and keeps a pipeline of flushes until we trip the pipeline maximum threshold and then we flush to disk. No in-memory compaction but can help throughput as data is moved from the profligate, native ConcurrentSkipListMap data-type to more compact (and efficient) data types.\n* *EAGER*: This is *BASIC* policy plus in-memory compaction of flushes (much like the on-disk compactions done to hfiles); on compaction we apply on-disk rules eliminating versions, duplicates, ttl'd cells, etc.\n* *ADAPTIVE*: Adaptive compaction adapts to the workload. It applies either index compaction or data compaction based on the ratio of duplicate cells in the data. Experimental.\n\nTo enable *BASIC* on the *info* column family in the table *radish*, add the attribute to the *info* column family:\n\n```ruby\nhbase(main):003:0> alter 'radish', {NAME => 'info', IN_MEMORY_COMPACTION => 'BASIC'}\nUpdating all regions with the new schema...\nAll regions updated.\nDone.\nTook 1.2413 seconds\nhbase(main):004:0> describe 'radish'\nTable radish is DISABLED\nradish\nCOLUMN FAMILIES DESCRIPTION\n{NAME => 'info', VERSIONS => '1', EVICT_BLOCKS_ON_CLOSE => 'false', NEW_VERSION_BEHAVIOR => 'false', KEEP_DELETED_CELLS => 'FALSE', CACHE_DATA_ON_WRITE => 'false', DATA_BLOCK_ENCODING => 'NONE', TTL => 'FOREVER', MIN_VERSIONS => '0', REPLICATION_SCOPE => '0', BLOOMFILTER => 'ROW', CACHE_INDEX_ON_WRITE => 'false', IN_MEMORY => 'false', CACHE_BLOOMS_ON_WRITE => 'false', PREFETCH_BLOCKS_ON_OPEN => 'false', COMPRESSION => 'NONE', BLOCKCACHE => 'true', BLOCKSIZE => '65536', METADATA => {\n'IN_MEMORY_COMPACTION' => 'BASIC'}}\n1 row(s)\nTook 0.0239 seconds\n```\n\nNote how the IN*MEMORY\\_COMPACTION attribute shows as part of the \\_METADATA* map.\n\nThere is also a global configuration, *hbase.hregion.compacting.memstore.type* which you can set in your *hbase-site.xml* file. Use it to set the\ndefault on creation of a new table (On creation of a column family Store, we look first to the column family configuration looking for the\n*IN\\_MEMORY\\_COMPACTION* setting, and if none, we then consult the *hbase.hregion.compacting.memstore.type* value using its content; default is\n*NONE*).\n\nBy default, new hbase system tables will have *NONE* in-memory compaction set. To specify otherwise,\non new table-creation, set *hbase.systemtables.compacting.memstore.type* to *BASIC* / *EAGER* / *ADAPTIVE* (Note, setting this value\npost-creation of system tables will not have a retroactive effect; you will have to alter your tables\nto set the in-memory attribute).\n\nWhen an in-memory flush happens is calculated by dividing the configured region flush size (Set in the table descriptor\nor read from *hbase.hregion.memstore.flush.size*) by the number of column families and then multiplying by\n*hbase.memstore.inmemoryflush.threshold.factor*. Default is 0.014.\n\nThe number of flushes carried by the pipeline is monitored so as to fit within the bounds of memstore sizing\nbut you can also set a maximum on the number of flushes total by setting\n*hbase.hregion.compacting.pipeline.segments.limit*. Default is 2.\n\nWhen a column family Store is created, it says what memstore type is in effect. As of this writing\nthere is the old-school *DefaultMemStore* which fills a *ConcurrentSkipListMap* and then flushes\nto disk or the new *CompactingMemStore* that is the implementation that provides this new\nin-memory compactions facility. Here is a log-line from a RegionServer that shows a column\nfamily Store named *family* configured to use a *CompactingMemStore*:\n\n```\nNote how the IN_MEMORY_COMPACTION attribute shows as part of the _METADATA_ map.\n2018-03-30 11:02:24,466 INFO  [Time-limited test] regionserver.HStore(325): Store=family,  memstore type=CompactingMemStore, storagePolicy=HOT, verifyBulkLoads=false, parallelPutCountPrintThreshold=10\n```\n\nEnable TRACE-level logging on the CompactingMemStore class (*org.apache.hadoop.hbase.regionserver.CompactingMemStore*) to see detail on its operation.\n\n***\n\n# RegionServer Offheap Read/Write Path\n\n## Overview\n\nTo help reduce P99/P999 RPC latencies, HBase 2.x has made the read and write path use a pool of offheap buffers. Cells are\nallocated in offheap memory outside of the purview of the JVM garbage collector with attendent reduction in GC pressure.\nIn the write path, the request packet received from client will be read in on a pre-allocated offheap buffer and retained\noffheap until those cells are successfully persisted to the WAL and Memstore. The memory data structure in Memstore does\nnot directly store the cell memory, but references the cells encoded in the offheap buffers. Similarly for the read path.\nWe'll try to read the block cache first and if a cache misses, we'll go to the HFile and read the respective block. The\nworkflow from reading blocks to sending cells to client does its best to avoid on-heap memory allocations reducing the\namount of work the GC has to do.\n\n<img alt=\"Offheap Overview\" src={__img4} placeholder=\"blur\" />\n\nFor redress for the single mention of onheap in the read-section of the diagram above see [Read block from HDFS to offheap directly](/docs/offheap-read-write#read-block-from-hdfs-to-offheap-directly).\n\n## Offheap read-path\n\nIn HBase-2.0.0, [HBASE-11425](https://issues.apache.org/jira/browse/HBASE-11425) changed the HBase read path so it\ncould hold the read-data off-heap avoiding copying of cached data (BlockCache) on to the java heap (for uncached data,\nsee note under the diagram in the section above). This reduces GC pauses given there is less garbage made and so less\nto clear. The off-heap read path can have a performance that is similar or better to that of the on-heap LRU cache.\nThis feature is available since HBase 2.0.0. Refer to below blogs for more details and test results on off heaped read path\n[Offheaping the Read Path in Apache HBase: Part 1 of 2](https://blogs.apache.org/hbase/entry/offheaping_the_read_path_in)\nand [Offheap Read-Path in Production - The Alibaba story](https://blogs.apache.org/hbase/entry/offheap-read-path-in-production)\n\nFor an end-to-end off-heaped read-path, all you have to do is enable an off-heap backed [Off-heap Block Cache](/docs/architecture/regionserver#off-heap-block-cache)(BC).\nTo do this, configure *hbase.bucketcache.ioengine* to be *offheap* in *hbase-site.xml* (See [BucketCache Deploy Modes](/docs/architecture/regionserver#bucketcache-deploy-modes) to learn\nmore about *hbase.bucketcache.ioengine* options). Also specify the total capacity of the BC using `hbase.bucketcache.size`.\nPlease remember to adjust value of 'HBASE*OFFHEAPSIZE' in \\_hbase-env.sh* (See [BucketCache Example Configuration](/docs/architecture/regionserver#bucketcache-example-configuration) for help sizing and an example\nenabling). This configuration is for specifying the maximum possible off-heap memory allocation for the RegionServer java\nprocess. This should be bigger than the off-heap BC size to accommodate usage by other features making use of off-heap memory\nsuch as Server RPC buffer pool and short-circuit reads (See discussion in [BucketCache Example Configuration](/docs/architecture/regionserver#bucketcache-example-configuration)).\n\nPlease keep in mind that there is no default for `hbase.bucketcache.ioengine` which means the `BlockCache` is OFF by default\n(See the \"Direct Memory Usage In HBase\" info section in [BucketCache Example Configuration](/docs/architecture/regionserver#bucketcache-example-configuration)).\n\nThis is all you need to do to enable off-heap read path. Most buffers in HBase are already off-heap. With BC off-heap,\nthe read pipeline will copy data between HDFS and the server socket — caveat hbase.ipc.server.reservoir.initial.max —\nsending results back to the client.\n\n### Tuning the RPC buffer pool\n\nIt is possible to tune the ByteBuffer pool on the RPC server side used to accumulate the cell bytes and create result\ncell blocks to send back to the client side. Use `hbase.ipc.server.reservoir.enabled` to turn this pool ON or OFF. By\ndefault this pool is ON and available. HBase will create off-heap ByteBuffers and pool them them by default. Please\nmake sure not to turn this OFF if you want end-to-end off-heaping in read path.\n\nIf this pool is turned off, the server will create temp buffers onheap to accumulate the cell bytes and\nmake a result cell block. This can impact the GC on a highly read loaded server.\n\n<Callout type=\"info\">\n  The config keys which start with prefix `hbase.ipc.server.reservoir` are deprecated in hbase-3.x\n  (the internal pool implementation changed). If you are still in hbase-2.2.x or older, then just\n  use the old config keys. Otherwise if in hbase-3.x or hbase-2.3.x+, please use the new config keys\n  (See [deprecated and new configs in\n  HBase3.x](/docs/offheap-read-write#read-block-from-hdfs-to-offheap-directly))\n</Callout>\n\nNext thing to tune is the ByteBuffer pool on the RPC server side. The user can tune this pool with respect to how\nmany buffers are in the pool and what should be the size of each ByteBuffer. Use the config\n`hbase.ipc.server.reservoir.initial.buffer.size` to tune each of the buffer sizes. Default is 64KB for hbase-2.2.x\nand less, changed to 65KB by default for hbase-2.3.x+\n(see [HBASE-22532](https://issues.apache.org/jira/browse/HBASE-22532))\n\nWhen the result size is larger than one 64KB (Default) ByteBuffer size, the server will try to grab more than one\nByteBuffer and make a result cell block out of a collection of fixed-sized ByteBuffers. When the pool is running\nout of buffers, the server will skip the pool and create temporary on-heap buffers.\n\nThe maximum number of ByteBuffers in the pool can be tuned using the config `hbase.ipc.server.reservoir.initial.max`.\nIts default is a factor of region server handlers count (See the config `hbase.regionserver.handler.count`). The\nmath is such that by default we consider 2 MB as the result cell block size per read result and each handler will be\nhandling a read. For 2 MB size, we need 32 buffers each of size 64 KB (See default buffer size in pool). So per handler\n32 ByteBuffers(BB). We allocate twice this size as the max BBs count such that one handler can be creating the response\nand handing it to the RPC Responder thread and then handling a new request creating a new response cell block (using\npooled buffers). Even if the responder could not send back the first TCP reply immediately, our count should allow that\nwe should still have enough buffers in our pool without having to make temporary buffers on the heap. Again for smaller\nsized random row reads, tune this max count. These are lazily created buffers and the count is the max count to be pooled.\n\nIf you still see GC issues even after making end-to-end read path off-heap, look for issues in the appropriate buffer\npool. Check for the below RegionServer log line at INFO level in HBase2.x:\n\n```\nPool already reached its max capacity : XXX and no free buffers now. Consider increasing the value for 'hbase.ipc.server.reservoir.initial.max' ?\n```\n\nOr the following log message in HBase3.x:\n\n```\nPool already reached its max capacity : XXX and no free buffers now. Consider increasing the value for 'hbase.server.allocator.max.buffer.count' ?\n```\n\nThe setting for *HBASE\\_OFFHEAPSIZE* in *hbase-env.sh* should consider this off heap buffer pool on the server side also.\nWe need to config this max off heap size for the RegionServer as a bit higher than the sum of this max pool size and\nthe off heap cache size. The TCP layer will also need to create direct bytebuffers for TCP communication. Also the DFS\nclient will need some off-heap to do its workings especially if short-circuit reads are configured. Allocating an extra\n1 - 2 GB for the max direct memory size has worked in tests.\n\nIf you are using coprocessors and refer to the Cells in the read results, DO NOT store reference to these Cells out of\nthe scope of the CP hook methods. Some times the CPs want to store info about the cell (Like its row key) for considering\nin the next CP hook call etc. For such cases, pls clone the required fields of the entire Cell as per the use cases.\n\\[ See CellUtil#cloneXXX(Cell) APIs ]\n\n## Read block from HDFS to offheap directly\n\nIn HBase-2.x, the RegionServer will read blocks from HDFS to a temporary onheap ByteBuffer and then flush to\nthe BucketCache. Even if the BucketCache is offheap, we will first pull the HDFS read onheap before writing\nit out to the offheap BucketCache. We can observe much GC pressure when cache hit ratio low (e.g. a cacheHitRatio \\~ 60% ).\n[HBASE-21879](https://issues.apache.org/jira/browse/HBASE-21879) addresses this issue (Requires hbase-2.3.x/hbase-3.x).\nIt depends on there being a supporting HDFS being in place (hadoop-2.10.x or hadoop-3.3.x) and it may require patching\nHBase itself (as of this writing); see\n[HBASE-21879 Read HFile's block to ByteBuffer directly instead of to byte for reducing young gc purpose](https://issues.apache.org/jira/browse/HBASE-21879).\nAppropriately setup, reads from HDFS can be into offheap buffers passed offheap to the offheap BlockCache to cache.\n\nFor more details about the design and performance improvement, please see the\n[Design Doc -Read HFile's block to Offheap](https://docs.google.com/document/d/1xSy9axGxafoH-Qc17zbD2Bd--rWjjI00xTWQZ8ZwI_E).\n\nHere we will share some best practice about the performance tuning but first we introduce new (hbase-3.x/hbase-2.3.x) configuration names\nthat go with the new internal pool implementation (`ByteBuffAllocator` vs the old `ByteBufferPool`), some of which mimic now deprecated\nhbase-2.2.x configurations discussed above in the [Tuning the RPC buffer pool](/docs/offheap-read-write#tuning-the-rpc-buffer-pool). Much of the advice here overlaps that given above\nin the [Tuning the RPC buffer pool](/docs/offheap-read-write#tuning-the-rpc-buffer-pool) since the implementations have similar configurations.\n\n1. `hbase.server.allocator.pool.enabled` is for whether the RegionServer will use the pooled offheap ByteBuffer allocator. Default\n   value is true. In hbase-2.x, the deprecated `hbase.ipc.server.reservoir.enabled` did similar and is mapped to this config\n   until support for the old configuration is removed. This new name will be used in hbase-3.x and hbase-2.3.x+.\n2. `hbase.server.allocator.minimal.allocate.size` is the threshold at which we start allocating from the pool. Otherwise the\n   request will be allocated from onheap directly because it would be wasteful allocating small stuff from our pool of fixed-size\n   ByteBuffers. The default minimum is `hbase.server.allocator.buffer.size/6`.\n3. `hbase.server.allocator.max.buffer.count`: The `ByteBuffAllocator`, the new pool/reservoir implementation, has fixed-size\n   ByteBuffers. This config is for how many buffers to pool. Its default value is 2MB \\_ 2 \\_ hbase.regionserver.handler.count / 65KB\n   (similar to the discussion above in [Tuning the RPC buffer pool](/docs/offheap-read-write#tuning-the-rpc-buffer-pool)). If the default `hbase.regionserver.handler.count` is 30, then the default will be 1890.\n4. `hbase.server.allocator.buffer.size`: The byte size of each ByteBuffer. The default value is 66560 (65KB), here we choose 65KB instead of 64KB\n   because of [HBASE-22532](https://issues.apache.org/jira/browse/HBASE-22532).\n\nThe three config keys —`hbase.ipc.server.reservoir.enabled`, `hbase.ipc.server.reservoir.initial.buffer.size` and `hbase.ipc.server.reservoir.initial.max` — introduced in hbase-2.x\nhave been renamed and deprecated in hbase-3.x/hbase-2.3.x. Please use the new config keys instead:\n`hbase.server.allocator.pool.enabled`, `hbase.server.allocator.buffer.size` and `hbase.server.allocator.max.buffer.count`.\n\nNext, we have some suggestions regards performance.\n\n**Please make sure that there are enough pooled DirectByteBuffer in your ByteBuffAllocator.**\\\nThe ByteBuffAllocator will allocate ByteBuffer from the DirectByteBuffer pool first. If\nthere's no available ByteBuffer in the pool, then we will allocate the ByteBuffers from onheap.\nBy default, we will pre-allocate 4MB for each RPC handler (The handler count is determined by the config:\n`hbase.regionserver.handler.count`, it has the default value 30) . That's to say, if your `hbase.server.allocator.buffer.size`\nis 65KB, then your pool will have 2MB \\_ 2 / 65KB \\_ 30 = 945 DirectByteBuffer. If you have a large scan and a big cache,\nyou may have a RPC response whose bytes size is greater than 2MB (another 2MB for receiving rpc request), then it will\nbe better to increase the `hbase.server.allocator.max.buffer.count`.\n\nThe RegionServer web UI has statistics on ByteBuffAllocator:\n\n<img alt=\"ByteBuff Allocator Stats\" src={__img5} placeholder=\"blur\" />\n\nIf the following condition is met, you may need to increase your max buffer.count:\n\n```\nheapAllocationRatio >= hbase.server.allocator.minimal.allocate.size / hbase.server.allocator.buffer.size * 100%\n```\n\n**Please make sure the buffer size is greater than your block size.**\\\nWe have the default block size of 64KB, so almost all of the data blocks will be 64KB + a small delta, where the delta is\nvery small, depending on the size of the last Cell. If we set `hbase.server.allocator.buffer.size`=64KB,\nthen each block will be allocated as two ByteBuffers: one 64KB DirectByteBuffer and one HeapByteBuffer for the delta bytes.\nIdeally, we should let the data block to be allocated as one ByteBuffer; it has a simpler data structure, faster access speed,\nand less heap usage. Also, if the blocks are a composite of multiple ByteBuffers, to validate the checksum\nwe have to perform a temporary heap copy (see [HBASE-21917](https://issues.apache.org/jira/browse/HBASE-21917))\nwhereas if it's a single ByteBuffer we can speed the checksum by calling the hadoop' checksum native lib; it's more faster.\n\nPlease also see: [HBASE-22483](https://issues.apache.org/jira/browse/HBASE-22483)\n\nDon't forget to up your *HBASE\\_OFFHEAPSIZE* accordingly.\n\n## Offheap write-path\n\nIn hbase-2.x, [HBASE-15179](https://issues.apache.org/jira/browse/HBASE-15179) made the HBase write path work off-heap. By default, the MemStores in\nHBase have always used MemStore Local Allocation Buffers (MSLABs) to avoid memory fragmentation; an MSLAB creates bigger fixed sized chunks and then the\nMemStores Cell's data gets copied into these MSLAB chunks. These chunks can be pooled also and from hbase-2.x on, the MSLAB pool is by default ON.\nWrite off-heaping makes use of the MSLAB pool. It creates MSLAB chunks as Direct ByteBuffers and pools them.\n\n`hbase.regionserver.offheap.global.memstore.size` is the configuration key which controls the amount of off-heap data. Its value is the number of megabytes\nof off-heap memory that should be used by MSLAB (e.g. `25` would result in 25MB of off-heap). Be sure to increase *HBASE\\_OFFHEAPSIZE* which will set the JVM's\nMaxDirectMemorySize property (see [Tuning the RPC buffer pool](/docs/offheap-read-write#tuning-the-rpc-buffer-pool) for more on *HBASE\\_OFFHEAPSIZE*). The default value of\n`hbase.regionserver.offheap.global.memstore.size` is 0 which means MSLAB uses onheap, not offheap, chunks by default.\n\n`hbase.hregion.memstore.mslab.chunksize` controls the size of each off-heap chunk. Default is `2097152` (2MB).\n\nWhen a Cell is added to a MemStore, the bytes for that Cell are copied into these off-heap buffers (if `hbase.regionserver.offheap.global.memstore.size` is non-zero)\nand a Cell POJO will refer to this memory area. This can greatly reduce the on-heap occupancy of the MemStores and reduce the total heap utilization for RegionServers\nin a write-heavy workload. On-heap and off-heap memory utiliazation are tracked at multiple levels to implement low level and high level memory management.\nThe decision to flush a MemStore considers both the on-heap and off-heap usage of that MemStore. At the Region level, we sum the on-heap and off-heap usages and\ncompare them against the region flush size (128MB, by default). Globally, on-heap size occupancy of all memstores are tracked as well as off-heap size. When any of\nthese sizes breache the lower mark (`hbase.regionserver.global.memstore.size.lower.limit`) or the maximum size `hbase.regionserver.global.memstore.size`), all\nregions are selected for forced flushes.\n\n***\n\n# Backup and Restore\n\n\n\n## Overview\n\nBackup and restore is a standard operation provided by many databases. An effective backup and restore\nstrategy helps ensure that users can recover data in case of unexpected failures. The HBase backup and restore\nfeature helps ensure that enterprises using HBase as a canonical data repository can recover from catastrophic\nfailures. Another important feature is the ability to restore the database to a particular\npoint-in-time, commonly referred to as a snapshot.\n\nThe HBase backup and restore feature provides the ability to create full backups and incremental backups on\ntables in an HBase cluster. The full backup is the foundation on which incremental backups are applied\nto build iterative snapshots. Incremental backups can be run on a schedule to capture changes over time,\nfor example by using a Cron task. Incremental backups are more cost-effective than full backups because they only capture\nthe changes since the last backup and they also enable administrators to restore the database to any prior incremental backup. Furthermore, the\nutilities also enable table-level data backup-and-recovery if you do not want to restore the entire dataset\nof the backup.\n\nThe backup and restore feature supplements the HBase Replication feature. While HBase replication is ideal for\ncreating \"hot\" copies of the data (where the replicated data is immediately available for query), the backup and\nrestore feature is ideal for creating \"cold\" copies of data (where a manual step must be taken to restore the system).\nPreviously, users only had the ability to create full backups via the ExportSnapshot functionality. The incremental\nbackup implementation is the novel improvement over the previous \"art\" provided by ExportSnapshot.\n\nThe backup and restore feature uses DistCp to transfer files between clusters .\n[HADOOP-15850](https://issues.apache.org/jira/browse/HADOOP-15850) fixes a bug where CopyCommitter#concatFileChunks\nunconditionally tried to concatenate the files being DistCp'ed to target cluster (though the files are\nindependent) . Without the fix from\n[HADOOP-15850](https://issues.apache.org/jira/browse/HADOOP-15850) , the transfer would fail.\nSo the backup and restore feature need hadoop version as below\n\n* 2.7.x\n* 2.8.x\n* 2.9.2+\n* 2.10.0+\n* 3.0.4+\n* 3.1.2+\n* 3.2.0+\n* 3.3.0+\n\n## Terminology\n\nThe backup and restore feature introduces new terminology which can be used to understand how control flows through the\nsystem.\n\n* *A backup*: A logical unit of data and metadata which can restore a table to its state at a specific point in time.\n* *Full backup*: a type of backup which wholly encapsulates the contents of the table at a point in time.\n* *Incremental backup*: a type of backup which contains the changes in a table since a full backup.\n* *Backup set*: A user-defined name which references one or more tables over which a backup can be executed.\n* *Backup ID*: A unique names which identifies one backup from the rest, e.g. `backupId_1467823988425`\n\n## Planning\n\nThere are some common strategies which can be used to implement backup and restore in your environment. The following section\nshows how these strategies are implemented and identifies potential tradeoffs with each.\n\n<Callout type=\"warn\">\n  This backup and restore tools has not been tested on Transparent Data Encryption (TDE) enabled\n  HDFS clusters. This is related to the open issue\n  [HBASE-16178](https://issues.apache.org/jira/browse/HBASE-16178).\n</Callout>\n\n### Backup within a cluster\n\nThis strategy stores the backups on the same cluster as where the backup was taken. This approach is only appropriate for testing\nas it does not provide any additional safety on top of what the software itself already provides.\n\n<img alt=\"Intra-Cluster Backup\" src={__img6} placeholder=\"blur\" />\n\n### Backup using a dedicated cluster\n\nThis strategy provides greater fault tolerance and provides a path towards disaster recovery. In this setting, you will\nstore the backup on a separate HDFS cluster by supplying the backup destination cluster's HDFS URL to the backup utility.\nYou should consider backing up to a different physical location, such as a different data center.\n\nTypically, a backup-dedicated HDFS cluster uses a more economical hardware profile to save money.\n\n<img alt=\"Dedicated HDFS Cluster Backup\" src={__img7} placeholder=\"blur\" />\n\n### Backup to the Cloud or a storage vendor appliance\n\nAnother approach to safeguarding HBase incremental backups is to store the data on provisioned, secure servers that belong\nto third-party vendors and that are located off-site. The vendor can be a public cloud provider or a storage vendor who uses\na Hadoop-compatible file system, such as S3 and other HDFS-compatible destinations.\n\n<img alt=\"Backup to Cloud or Vendor Storage Solutions\" src={__img8} placeholder=\"blur\" />\n\n<Callout type=\"info\">\n  The HBase backup utility does not support backup to multiple destinations. A workaround is to\n  manually create copies of the backup files from HDFS or S3.\n</Callout>\n\n## First-time configuration steps\n\nThis section contains the necessary configuration changes that must be made in order to use the backup and restore feature.\nAs this feature makes significant use of YARN's MapReduce framework to parallelize these I/O heavy operations, configuration\nchanges extend outside of just `hbase-site.xml`.\n\n### Allow the \"hbase\" system user in YARN\n\nThe YARN *container-executor.cfg* configuration file must have the following property setting: *allowed.system.users=hbase*. No spaces\nare allowed in entries of this configuration file.\n\n<Callout type=\"warn\">\n  Skipping this step will result in runtime errors when executing the first backup tasks.\n</Callout>\n\n**Example of a valid container-executor.cfg file for backup and restore:**\n\n```text\nyarn.nodemanager.log-dirs=/var/log/hadoop/mapred\nyarn.nodemanager.linux-container-executor.group=yarn\nbanned.users=hdfs,yarn,mapred,bin\nallowed.system.users=hbase\nmin.user.id=500\n```\n\n### HBase specific changes\n\nAdd the following properties to hbase-site.xml and restart HBase if it is already running.\n\n<Callout type=\"info\">\n  The \",...\" is an ellipsis meant to imply that this is a comma-separated list of values, not\n  literal text which should be added to hbase-site.xml.\n</Callout>\n\n```xml\n<property>\n  <name>hbase.backup.enable</name>\n  <value>true</value>\n</property>\n<property>\n  <name>hbase.master.logcleaner.plugins</name>\n  <value>org.apache.hadoop.hbase.backup.master.BackupLogCleaner,...</value>\n</property>\n<property>\n  <name>hbase.procedure.master.classes</name>\n  <value>org.apache.hadoop.hbase.backup.master.LogRollMasterProcedureManager,...</value>\n</property>\n<property>\n  <name>hbase.procedure.regionserver.classes</name>\n  <value>org.apache.hadoop.hbase.backup.regionserver.LogRollRegionServerProcedureManager,...</value>\n</property>\n<property>\n  <name>hbase.coprocessor.region.classes</name>\n  <value>org.apache.hadoop.hbase.backup.BackupObserver,...</value>\n</property>\n<property>\n  <name>hbase.coprocessor.master.classes</name>\n  <value>org.apache.hadoop.hbase.backup.BackupMasterObserver,...</value>\n</property>\n<property>\n  <name>hbase.master.hfilecleaner.plugins</name>\n  <value>org.apache.hadoop.hbase.backup.BackupHFileCleaner,...</value>\n</property>\n```\n\n## Backup and Restore commands\n\nThis covers the command-line utilities that administrators would run to create, restore, and merge backups. Tools to\ninspect details on specific backup sessions is covered in the next section, [Administration of Backup Images](/docs/backup-restore/administration).\n\nRun the command `hbase backup help <command>` to access the online help that provides basic information about a command\nand its options. The below information is captured in this help message for each command.\n\n### Creating a Backup Image\n\n<Callout type=\"info\">\n  For HBase clusters also using Apache Phoenix: include the SQL system catalog tables in the backup.\n  In the event that you need to restore the HBase backup, access to the system catalog tables enable\n  you to resume Phoenix interoperability with the restored data.\n</Callout>\n\nThe first step in running the backup and restore utilities is to perform a full backup and to store the data in a separate image\nfrom the source. At a minimum, you must do this to get a baseline before you can rely on incremental backups.\n\nRun the following command as HBase superuser:\n\n```bash\nhbase backup create <type> <backup_path>\n```\n\nAfter the command finishes running, the console prints a SUCCESS or FAILURE status message. The SUCCESS message includes a *backup* ID.\nThe backup ID is the Unix time (also known as Epoch time) that the HBase master received the backup request from the client.\n\n<Callout type=\"info\">\n  Record the backup ID that appears at the end of a successful backup. In case the source cluster\n  fails and you need to recover the dataset with a restore operation, having the backup ID readily\n  available can save time.\n</Callout>\n\n#### Positional Command-Line Arguments\n\n***type***\\\nThe type of backup to execute: *full* or *incremental*. As a reminder, an *incremental* backup requires a *full* backup to\nalready exist.\n\n***backup\\_path***\\\nThe *backup\\_path* argument specifies the full filesystem URI of where to store the backup image. Valid prefixes are\n*hdfs:*, *webhdfs:*, *s3a:* or other compatible Hadoop File System implementations.\n\n#### Named Command-Line Arguments\n\n***-t \\<table\\_name\\[,table\\_name]>***\\\nA comma-separated list of tables to back up. If no tables are specified, all tables are backed up. No regular-expression or\nwildcard support is present; all table names must be explicitly listed. See [Backup Sets](/docs/backup-restore/commands#using-backup-sets) for more\ninformation about peforming operations on collections of tables. Mutually exclusive with the *-s* option; one of these\nnamed options are required.\n\n***-s \\<backup\\_set\\_name>***\\\nIdentify tables to backup based on a backup set. See [Using Backup Sets](/docs/backup-restore/commands#using-backup-sets) for the purpose and usage\nof backup sets. Mutually exclusive with the *-t* option.\n\n***-w \\<number\\_workers>***\\\n(Optional) Specifies the number of parallel workers to copy data to backup destination. Backups are currently executed by MapReduce jobs\nso this value corresponds to the number of Mappers that will be spawned by the job.\n\n***-b \\<bandwidth\\_per\\_worker>***\\\n(Optional) Specifies the bandwidth of each worker in MB per second.\n\n***-d***\\\n(Optional) Enables \"DEBUG\" mode which prints additional logging about the backup creation.\n\n***-i***\\\n(Optional) Ignore checksum verify between source snapshot and exported snapshot. Especially when the source and target file system types\nare different, we should use -i option to skip checksum-checks.\n\n***-q \\<name>***\\\n(Optional) Allows specification of the name of a YARN queue which the MapReduce job to create the backup should be executed in. This option\nis useful to prevent backup tasks from stealing resources away from other MapReduce jobs of high importance.\n\n#### Example usage\n\n```bash\n$ hbase backup create full hdfs://host5:9000/data/backup -t SALES2,SALES3 -w 3\n```\n\nThis command creates a full backup image of two tables, SALES2 and SALES3, in the HDFS instance who NameNode is host5:9000\nin the path */data/backup*. The *-w* option specifies that no more than three parallel works complete the operation.\n\n### Restoring a Backup Image\n\nRun the following command as an HBase superuser. You can only restore a backup on a running HBase cluster because the data must be\nredistributed the RegionServers for the operation to complete successfully.\n\n```bash\nhbase restore <backup_path> <backup_id>\n```\n\n#### Positional Command-Line Arguments\n\n***backup\\_path***\\\nThe *backup\\_path* argument specifies the full filesystem URI of where to store the backup image. Valid prefixes are\n*hdfs:*, *webhdfs:*, *s3a:* or other compatible Hadoop File System implementations.\n\n***backup\\_id***\\\nThe backup ID that uniquely identifies the backup image to be restored.\n\n#### Named Command-Line Arguments\n\n***-t \\<table\\_name\\[,table\\_name]>***\\\nA comma-separated list of tables to restore. See [Backup Sets](/docs/backup-restore/commands#using-backup-sets) for more\ninformation about peforming operations on collections of tables. Mutually exclusive with the *-s* option; one of these\nnamed options are required.\n\n***-s \\<backup\\_set\\_name>***\\\nIdentify tables to backup based on a backup set. See [Using Backup Sets](/docs/backup-restore/commands#using-backup-sets) for the purpose and usage\nof backup sets. Mutually exclusive with the *-t* option.\n\n***-q \\<name>***\\\n(Optional) Allows specification of the name of a YARN queue which the MapReduce job to create the backup should be executed in. This option\nis useful to prevent backup tasks from stealing resources away from other MapReduce jobs of high importance.\n\n***-c***\\\n(Optional) Perform a dry-run of the restore. The actions are checked, but not executed.\n\n***-m \\<target\\_tables>***\\\n(Optional) A comma-separated list of tables to restore into. If this option is not provided, the original table name is used. When\nthis option is provided, there must be an equal number of entries provided in the `-t` option.\n\n***-o***\\\n(Optional) Overwrites the target table for the restore if the table already exists.\n\n#### Example of Usage\n\n```bash\nhbase restore /tmp/backup_incremental backupId_1467823988425 -t mytable1,mytable2\n```\n\nThis command restores two tables of an incremental backup image. In this example:\n• `/tmp/backup_incremental` is the path to the directory containing the backup image.\n• `backupId_1467823988425` is the backup ID.\n• `mytable1` and `mytable2` are the names of tables in the backup image to be restored.\n\n<Callout type=\"info\">\n  If the namespace of a table being restored does not exist in the target environment, it will be\n  automatically created during the restore operation.\n  [HBASE-25707](https://issues.apache.org/jira/browse/HBASE-25707)\n</Callout>\n\n### Merging Incremental Backup Images\n\nThis command can be used to merge two or more incremental backup images into a single incremental\nbackup image. This can be used to consolidate multiple, small incremental backup images into a single\nlarger incremental backup image. This command could be used to merge hourly incremental backups\ninto a daily incremental backup image, or daily incremental backups into a weekly incremental backup.\n\n```bash\n$ hbase backup merge <backup_ids>\n```\n\n#### Positional Command-Line Arguments\n\n***backup\\_ids***\\\nA comma-separated list of incremental backup image IDs that are to be combined into a single image.\n\n#### Named Command-Line Arguments\n\nNone.\n\n#### Example usage\n\n```bash\n$ hbase backup merge backupId_1467823988425,backupId_1467827588425\n```\n\n### Using Backup Sets\n\nBackup sets can ease the administration of HBase data backups and restores by reducing the amount of repetitive input\nof table names. You can group tables into a named backup set with the `hbase backup set add` command. You can then use\nthe `-set` option to invoke the name of a backup set in the `hbase backup create` or `hbase restore` rather than list\nindividually every table in the group. You can have multiple backup sets.\n\n<Callout type=\"info\">\n  Note the differentiation between the `hbase backup set add` command and the *-set* option. The\n  `hbase backup set add` command must be run before using the `-set` option in a different command\n  because backup sets must be named and defined before using backup sets as a shortcut.\n</Callout>\n\nIf you run the `hbase backup set add` command and specify a backup set name that does not yet exist on your system, a new set\nis created. If you run the command with the name of an existing backup set name, then the tables that you specify are added\nto the set.\n\nIn this command, the backup set name is case-sensitive.\n\n<Callout type=\"info\">\n  The metadata of backup sets are stored within HBase. If you do not have access to the original\n  HBase cluster with the backup set metadata, then you must specify individual table names to\n  restore the data.\n</Callout>\n\nTo create a backup set, run the following command as the HBase superuser:\n\n```bash\n$ hbase backup set <subcommand> <backup_set_name> <tables>\n```\n\n#### Backup Set Subcommands\n\nThe following list details subcommands of the hbase backup set command.\n\n<Callout type=\"info\">\n  You must enter one (and no more than one) of the following subcommands after hbase backup set to\n  complete an operation. Also, the backup set name is case-sensitive in the command-line utility.\n</Callout>\n\n***add***\\\nAdds table\\[s] to a backup set. Specify a *backup\\_set\\_name* value after this argument to create a backup set.\n\n***remove***\\\nRemoves tables from the set. Specify the tables to remove in the tables argument.\n\n***list***\\\nLists all backup sets.\n\n***describe***\\\nDisplays a description of a backup set. The information includes whether the set has full\nor incremental backups, start and end times of the backups, and a list of the tables in the set. This subcommand must precede\na valid value for the *backup\\_set\\_name* value.\n\n***delete***\\\nDeletes a backup set. Enter the value for the *backup\\_set\\_name* option directly after the `hbase backup set delete` command.\n\n#### Positional Command-Line Arguments\n\n***backup\\_set\\_name***\\\nUse to assign or invoke a backup set name. The backup set name must contain only printable characters and cannot have any spaces.\n\n***tables***\\\nList of tables (or a single table) to include in the backup set. Enter the table names as a comma-separated list. If no tables\nare specified, all tables are included in the set.\n\n<Callout type=\"info\">\n  Maintain a log or other record of the case-sensitive backup set names and the corresponding tables\n  in each set on a separate or remote cluster, backup strategy. This information can help you in\n  case of failure on the primary cluster.\n</Callout>\n\n#### Example of Usage\n\n```bash\n$ hbase backup set add Q1Data TEAM3,TEAM_4\n```\n\nDepending on the environment, this command results in *one* of the following actions:\n\n* If the `Q1Data` backup set does not exist, a backup set containing tables `TEAM_3` and `TEAM_4` is created.\n* If the `Q1Data` backup set exists already, the tables `TEAM_3` and `TEAM_4` are added to the `Q1Data` backup set.\n\n## Administration of Backup Images\n\nThe `hbase backup` command has several subcommands that help with administering backup images as they accumulate. Most production\nenvironments require recurring backups, so it is necessary to have utilities to help manage the data of the backup repository.\nSome subcommands enable you to find information that can help identify backups that are relevant in a search for particular data.\nYou can also delete backup images.\n\nThe following list details each `hbase backup subcommand` that can help administer backups. Run the full command-subcommand line as\nthe HBase superuser.\n\n### Managing Backup Progress\n\nYou can monitor a running backup in another terminal session by running the *hbase backup progress* command and specifying the backup ID as an argument.\n\nFor example, run the following command as hbase superuser to view the progress of a backup\n\n```bash\n$ hbase backup progress <backup_id>\n```\n\n#### Positional Command-Line Arguments\n\n***backup\\_id***\\\nSpecifies the backup that you want to monitor by seeing the progress information. The backupId is case-sensitive.\n\n#### Named Command-Line Arguments\n\nNone.\n\n#### Example usage\n\n```bash\nhbase backup progress backupId_1467823988425\n```\n\n### Managing Backup History\n\nThis command displays a log of backup sessions. The information for each session includes backup ID, type (full or incremental), the tables\nin the backup, status, and start and end time. Specify the number of backup sessions to display with the optional -n argument.\n\n```bash\n$ hbase backup history <backup_id>\n```\n\n#### Positional Command-Line Arguments\n\n***backup\\_id***\\\nSpecifies the backup that you want to monitor by seeing the progress information. The backupId is case-sensitive.\n\n#### Named Command-Line Arguments\n\n***-n \\<num\\_records>***\\\n(Optional) The maximum number of backup records (Default: 10).\n\n***-p \\<backup\\_root\\_path>***\\\nThe full filesystem URI of where backup images are stored.\n\n***-s \\<backup\\_set\\_name>***\\\nThe name of the backup set to obtain history for. Mutually exclusive with the *-t* option.\n\n***-t \\<table\\_name>***\\\nThe name of table to obtain history for. Mutually exclusive with the *-s* option.\n\n#### Example usage\n\n```bash\n$ hbase backup history\n$ hbase backup history -n 20\n$ hbase backup history -t WebIndexRecords\n```\n\n### Describing a Backup Image\n\nThis command can be used to obtain information about a specific backup image.\n\n```bash\n$ hbase backup describe <backup_id>\n```\n\n#### Positional Command-Line Arguments\n\n***backup\\_id***\nThe ID of the backup image to describe.\n\n#### Named Command-Line Arguments\n\nNone.\n\n#### Example usage\n\n```bash\n$ hbase backup describe backupId_1467823988425\n```\n\n### Deleting Backup Images\n\nThe `hbase backup delete` command deletes backup images that are no longer needed.\n\n#### Syntax\n\n```bash\n$ hbase backup delete -l <backup_id1,backup_id2,...>\n$ hbase backup delete -k <days>\n```\n\n#### Named Command-Line Arguments\n\n***-l \\<backup\\_id1,backup\\_id2,...>***\\\nComma-separated list of backup IDs to delete.\n\n***-k \\<days>***\\\nDeletes all backup images completed more than the specified number of days ago.\n\n<Callout type=\"info\">\n  These options are **mutually exclusive**. Only one of `-l` or `-k` may be used at a time.\n</Callout>\n\n#### Example Usage\n\nDelete specific backup images by ID:\n\n```bash\n$ hbase backup delete -l backupId_1467823988425,backupId_1467824989999\n```\n\nDelete all backup images older than 30 days:\n\n```bash\n$ hbase backup delete -k 30\n```\n\n<Callout type=\"warn\">\n  * Deleting a backup may affect all following incremental backups (in the same backup root) up to\n    the next full backup. For example, if you take a full backup every 2 weeks and\n    daily incremental backups, running `hbase backup delete -k 7` when the full backup is older than\n    7 days will effectively remove the data for all subsequent incremental backups.\n    The backup IDs may still be listed, but their data will be gone.\n\n  * If the most recent backup is an incremental backup and you delete it,\n    you should run a **full backup** next.\n    Running another incremental backup immediately after may result in missing data in the\n    backup image. (See [HBASE-28084](https://issues.apache.org/jira/browse/HBASE-28084))\n</Callout>\n\n### Backup Repair Command\n\nThis command attempts to correct any inconsistencies in persisted backup metadata which exists as\nthe result of software errors or unhandled failure scenarios. While the backup implementation tries\nto correct all errors on its own, this tool may be necessary in the cases where the system cannot\nautomatically recover on its own.\n\n```bash\n$ hbase backup repair\n```\n\n#### Positional Command-Line Arguments\n\nNone.\n\n#### Named Command-Line Arguments\n\nNone.\n\n#### Example usage\n\n```bash\n$ hbase backup repair\n```\n\n## Additional Topics\n\n## Configuration keys\n\nThe backup and restore feature includes both required and optional configuration keys.\n\n### Required properties\n\n***hbase.backup.enable***: Controls whether or not the feature is enabled (Default: `false`). Set this value to `true`.\n\n***hbase.master.logcleaner.plugins***: A comma-separated list of classes invoked when cleaning logs in the HBase Master. Set\nthis value to `org.apache.hadoop.hbase.backup.master.BackupLogCleaner` or append it to the current value.\n\n***hbase.procedure.master.classes***: A comma-separated list of classes invoked with the Procedure framework in the Master. Set\nthis value to `org.apache.hadoop.hbase.backup.master.LogRollMasterProcedureManager` or append it to the current value.\n\n***hbase.procedure.regionserver.classes***: A comma-separated list of classes invoked with the Procedure framework in the RegionServer.\nSet this value to `org.apache.hadoop.hbase.backup.regionserver.LogRollRegionServerProcedureManager` or append it to the current value.\n\n***hbase.coprocessor.region.classes***: A comma-separated list of RegionObservers deployed on tables. Set this value to\n`org.apache.hadoop.hbase.backup.BackupObserver` or append it to the current value.\n\n***hbase.coprocessor.master.classes***: A comma-separated list of MasterObservers deployed on tables. Set this value to\n`org.apache.hadoop.hbase.backup.BackupMasterObserver` or append it to the current value.\n\n***hbase.master.hfilecleaner.plugins***: A comma-separated list of HFileCleaners deployed on the Master. Set this value\nto `org.apache.hadoop.hbase.backup.BackupHFileCleaner` or append it to the current value.\n\n### Optional properties\n\n***hbase.backup.system.ttl***: The time-to-live in seconds of data in the `hbase:backup` tables (default: forever). This property\nis only relevant prior to the creation of the `hbase:backup` table. Use the `alter` command in the HBase shell to modify the TTL\nwhen this table already exists. See the [below section](/docs/backup-restore/additional-topics#a-warning-on-file-system-growth) for more details on the impact of this\nconfiguration property.\n\n***hbase.backup.attempts.max***: The number of attempts to perform when taking hbase table snapshots (default: 10).\n\n***hbase.backup.attempts.pause.ms***: The amount of time to wait between failed snapshot attempts in milliseconds (default: 10000).\n\n***hbase.backup.logroll.timeout.millis***: The amount of time (in milliseconds) to wait for RegionServers to execute a WAL rolling\nin the Master's procedure framework (default: 30000).\n\n## Best Practices\n\n### Formulate a restore strategy and test it.\n\nBefore you rely on a backup and restore strategy for your production environment, identify how backups must be performed,\nand more importantly, how restores must be performed. Test the plan to ensure that it is workable.\nAt a minimum, store backup data from a production cluster on a different cluster or server. To further safeguard the data,\nuse a backup location that is at a different physical location.\n\nIf you have a unrecoverable loss of data on your primary production cluster as a result of computer system issues, you may\nbe able to restore the data from a different cluster or server at the same site. However, a disaster that destroys the whole\nsite renders locally stored backups useless. Consider storing the backup data and necessary resources (both computing capacity\nand operator expertise) to restore the data at a site sufficiently remote from the production site. In the case of a catastrophe\nat the whole primary site (fire, earthquake, etc.), the remote backup site can be very valuable.\n\n### Secure a full backup image first.\n\nAs a baseline, you must complete a full backup of HBase data at least once before you can rely on incremental backups. The full\nbackup should be stored outside of the source cluster. To ensure complete dataset recovery, you must run the restore utility\nwith the option to restore baseline full backup. The full backup is the foundation of your dataset. Incremental backup data\nis applied on top of the full backup during the restore operation to return you to the point in time when backup was last taken.\n\n### Define and use backup sets for groups of tables that are logical subsets of the entire dataset.\n\nYou can group tables into an object called a backup set. A backup set can save time when you have a particular group of tables\nthat you expect to repeatedly back up or restore.\n\nWhen you create a backup set, you type table names to include in the group. The backup set includes not only groups of related\ntables, but also retains the HBase backup metadata. Afterwards, you can invoke the backup set name to indicate what tables apply\nto the command execution instead of entering all the table names individually.\n\n### Document the backup and restore strategy, and ideally log information about each backup.\n\nDocument the whole process so that the knowledge base can transfer to new administrators after employee turnover. As an extra\nsafety precaution, also log the calendar date, time, and other relevant details about the data of each backup. This metadata\ncan potentially help locate a particular dataset in case of source cluster failure or primary site disaster. Maintain duplicate\ncopies of all documentation: one copy at the production cluster site and another at the backup location or wherever it can be\naccessed by an administrator remotely from the production cluster.\n\n## Scenario: Safeguarding Application Datasets on Amazon S3\n\nThis scenario describes how a hypothetical retail business uses backups to safeguard application data and then restore the dataset\nafter failure.\n\nThe HBase administration team uses backup sets to store data from a group of tables that have interrelated information for an\napplication called green. In this example, one table contains transaction records and the other contains customer details. The\ntwo tables need to be backed up and be recoverable as a group.\n\nThe admin team also wants to ensure daily backups occur automatically.\n\n<img alt=\"Tables Composing The Backup Set\" src={__img9} placeholder=\"blur\" />\n\nThe following is an outline of the steps and examples of commands that are used to backup the data for the *green* application and\nto recover the data later. All commands are run when logged in as HBase superuser.\n\n* A backup set called *green\\_set* is created as an alias for both the transactions table and the customer table. The backup set can\n  be used for all operations to avoid typing each table name. The backup set name is case-sensitive and should be formed with only\n  printable characters and without spaces.\n\n  ```bash\n  $ hbase backup set add green_set transactions\n  $ hbase backup set add green_set customer\n  ```\n\n* The first backup of green\\_set data must be a full backup. The following command example shows how credentials are passed to Amazon\n  S3 and specifies the file system with the s3a: prefix.\n\n  ```bash\n  $ ACCESS_KEY=ABCDEFGHIJKLMNOPQRST\n  $ SECRET_KEY=123456789abcdefghijklmnopqrstuvwxyzABCD\n  $ sudo -u hbase hbase backup create full\\\n    s3a://$ACCESS_KEY:SECRET_KEY@prodhbasebackups/backups -s green_set\n  ```\n\n* Incremental backups should be run according to a schedule that ensures essential data recovery in the event of a catastrophe. At\n  this retail company, the HBase admin team decides that automated daily backups secures the data sufficiently. The team decides that\n  they can implement this by modifying an existing Cron job that is defined in `/etc/crontab`. Consequently, IT modifies the Cron job\n  by adding the following line:\n\n  ```bash\n  @daily hbase hbase backup create incremental s3a://$ACCESS_KEY:$SECRET_KEY@prodhbasebackups/backups -s green_set\n  ```\n\n* A catastrophic IT incident disables the production cluster that the green application uses. An HBase system administrator of the\n  backup cluster must restore the *green\\_set* dataset to the point in time closest to the recovery objective.\n\n  <Callout type=\"info\">\n    If the administrator of the backup HBase cluster has the backup ID with relevant details in accessible records, the following\n    search with the `hdfs dfs -ls` command and manually scanning the backup ID list can be bypassed. Consider continuously maintaining\n    and protecting a detailed log of backup IDs outside the production cluster in your environment.\n  </Callout>\n\n  The HBase administrator runs the following command on the directory where backups are stored to print the list of successful backup\n  IDs on the console:\n\n  ```bash\n  hdfs dfs -ls -t /prodhbasebackups/backups\n  ```\n\n* The admin scans the list to see which backup was created at a date and time closest to the recovery objective. To do this, the\n  admin converts the calendar timestamp of the recovery point in time to Unix time because backup IDs are uniquely identified with\n  Unix time. The backup IDs are listed in reverse chronological order, meaning the most recent successful backup appears first.\n\n  The admin notices that the following line in the command output corresponds with the *green\\_set* backup that needs to be restored:\n\n  ```bash\n  /prodhbasebackups/backups/backup_1467823988425`\n  ```\n\n* The admin restores green\\_set invoking the backup ID and the -overwrite option. The -overwrite option truncates all existing data\n  in the destination and populates the tables with data from the backup dataset. Without this flag, the backup data is appended to the\n  existing data in the destination. In this case, the admin decides to overwrite the data because it is corrupted.\n\n  ```bash\n  $ sudo -u hbase hbase restore -s green_set \\\n    s3a://$ACCESS_KEY:$SECRET_KEY@prodhbasebackups/backups backup_1467823988425 \\ -overwrite\n  ```\n\n## Security of Backup Data\n\nWith this feature which makes copying data to remote locations, it's important to take a moment to clearly state the procedural\nconcerns that exist around data security. Like the HBase replication feature, backup and restore provides the constructs to automatically\ncopy data from within a corporate boundary to some system outside of that boundary. It is imperative when storing sensitive data that with backup and restore, much\nless any feature which extracts data from HBase, the locations to which data is being sent has undergone a security audit to ensure\nthat only authenticated users are allowed to access that data.\n\nFor example, with the above example of backing up data to S3, it is of the utmost importance that the proper permissions are assigned\nto the S3 bucket to ensure that only a minimum set of authorized users are allowed to access this data. Because the data is no longer\nbeing accessed via HBase, and its authentication and authorization controls, we must ensure that the filesystem storing that data is\nproviding a comparable level of security. This is a manual step which users **must** implement on their own.\n\n## Technical Details of Incremental Backup and Restore\n\nHBase incremental backups enable more efficient capture of HBase table images than previous attempts\nat serial backup and restore solutions, such as those that only used HBase Export and Import APIs.\nIncremental backups use Write Ahead Logs (WALs) to capture the data changes since the\nprevious backup was created. A WAL roll (create new WALs) is executed across all RegionServers\nto track the WALs that need to be in the backup.\nIn addition to WALs, incremental backups also track bulk-loaded HFiles for tables under backup.\n\nIncremental backup gathers all WAL files generated since the last backup from the source cluster,\nconverts them to HFiles in a `.tmp` directory under the `BACKUP_ROOT`, and then moves these\nHFiles to their final location under the backup root directory to form the backup image.\nIt also reads bulk load records from the backup system table, forms the paths for the corresponding\nbulk-loaded HFiles, and copies those files to the backup destination.\nBulk-loaded files are preserved (not deleted by cleaner chores) until they've been included in a\nbackup (for each backup root).\nA process similar to the DistCp (distributed copy) tool is used to move the backup files to the\ntarget file system.\n\nWhen a table restore operation starts, a two-step process is initiated.\nFirst, the full backup is restored from the full backup image.\nSecond, all HFiles from incremental backups between the last full backup and the incremental backup\nbeing restored (including bulk-loaded HFiles) are bulk loaded into the table using the\nHBase Bulk Load utility.\n\nYou can only restore on a live HBase cluster because the data must be redistributed to complete the restore operation successfully.\n\n## A Warning on File System Growth\n\nAs a reminder, incremental backups are implemented via retaining the write-ahead logs which HBase primarily uses for data durability.\nThus, to ensure that all data needing to be included in a backup is still available in the system, the HBase backup and restore feature\nretains all write-ahead logs since the last backup until the next incremental backup is executed.\n\nLike HBase Snapshots, this can have an expectedly large impact on the HDFS usage of HBase for high volume tables. Take care in enabling\nand using the backup and restore feature, specifically with a mind to removing backup sessions when they are not actively being used.\n\nThe only automated, upper-bound on retained write-ahead logs for backup and restore is based on the TTL of the `hbase:backup` system table which,\nas of the time this document is written, is infinite (backup table entries are never automatically deleted). This requires that administrators\nperform backups on a schedule whose frequency is relative to the amount of available space on HDFS (e.g. less available HDFS space requires\nmore aggressive backup merges and deletions). As a reminder, the TTL can be altered on the `hbase:backup` table using the `alter` command\nin the HBase shell. Modifying the configuration property `hbase.backup.system.ttl` in hbase-site.xml after the system table exists has no effect.\n\n## Capacity Planning\n\nWhen designing a distributed system deployment, it is critical that some basic mathmatical rigor is executed to ensure sufficient computational\ncapacity is available given the data and software requirements of the system. For this feature, the availability of network capacity is the largest\nbottleneck when estimating the performance of some implementation of backup and restore. The second most costly function is the speed at which\ndata can be read/written.\n\n### Full Backups\n\nTo estimate the duration of a full backup, we have to understand the general actions which are invoked:\n\n* Write-ahead log roll on each RegionServer: ones to tens of seconds per RegionServer in parallel. Relative to the load on each RegionServer.\n* Take an HBase snapshot of the table(s): tens of seconds. Relative to the number of regions and files that comprise the table.\n* Export the snapshot to the destination: see below. Relative to the size of the data and the network bandwidth to the destination.\n\nTo approximate how long the final step will take, we have to make some assumptions on hardware. Be aware that these will *not* be accurate for your\nsystem — these are numbers that your or your administrator know for your system. Let's say the speed of reading data from HDFS on a single node is\ncapped at 80MB/s (across all Mappers that run on that host), a modern network interface controller (NIC) supports 10Gb/s, the top-of-rack switch can\nhandle 40Gb/s, and the WAN between your clusters is 10Gb/s. This means that you can only ship data to your remote at a speed of 1.25GB/s — meaning\nthat 16 nodes (`1.25 * 1024 / 80 = 16`) participating in the ExportSnapshot should be able to fully saturate the link between clusters. With more\nnodes in the cluster, we can still saturate the network but at a lesser impact on any one node which helps ensure local SLAs are made. If the size\nof the snapshot is 10TB, this would full backup would take in the ballpark of 2.5 hours (`10 * 1024 / 1.25 / (60 * 60) = 2.23hrs`)\n\nAs a general statement, it is very likely that the WAN bandwidth between your local cluster and the remote storage is the largest\nbottleneck to the speed of a full backup.\n\nWhen the concern is restricting the computational impact of backups to a \"production system\", the above formulas can be reused with the optional\ncommand-line arguments to `hbase backup create`: `-b`, `-w`, `-q`. The `-b` option defines the bandwidth at which each worker (Mapper) would\nwrite data. The `-w` argument limits the number of workers that would be spawned in the DistCp job. The `-q` allows the user to specify a YARN\nqueue which can limit the specific nodes where the workers will be spawned — this can quarantine the backup workers performing the copy to\na set of non-critical nodes. Relating the `-b` and `-w` options to our earlier equations: `-b` would be used to restrict each node from reading\ndata at the full 80MB/s and `-w` is used to limit the job from spawning 16 worker tasks.\n\n### Incremental Backup\n\nLike we did for full backups, we have to understand the incremental backup process to approximate its runtime and cost.\n\n* Identify new write-ahead logs since the last full or incremental backup: negligible. Apriori knowledge from the backup system table(s).\n* Read, filter, and write \"minimized\" HFiles equivalent to the WALs: dominated by the speed of writing data. Relative to write speed of HDFS.\n* Read bulk load records from the backup system table, form the paths for bulk-loaded HFiles, and copy them to the backup destination.\n* DistCp the HFiles to the destination: [see above](/docs/backup-restore/additional-topics#full-backups).\n\nFor the second step, the dominating cost of this operation would be the re-writing the data (under the assumption that a majority of the\ndata in the WAL is preserved). In this case, we can assume an aggregate write speed of 30MB/s per node. Continuing our 16-node cluster example,\nthis would require approximately 15 minutes to perform this step for 50GB of data (50 \\* 1024 / 60 / 60 = 14.2). The amount of time to start the\nDistCp MapReduce job would likely dominate the actual time taken to copy the data (50 / 1.25 = 40 seconds) and can be ignored.\n\n## Limitations of the Backup and Restore Utility\n\n**Serial backup operations**\\\nBackup operations cannot be run concurrently. An operation includes actions like create, delete, restore, and merge. Only one active backup session is supported. [HBASE-16391](https://issues.apache.org/jira/browse/HBASE-16391)\nwill introduce multiple-backup sessions support.\n\n**No means to cancel backups**\\\nBoth backup and restore operations cannot be canceled. ([HBASE-15997](https://issues.apache.org/jira/browse/HBASE-15997), [HBASE-15998](https://issues.apache.org/jira/browse/HBASE-15998)).\nThe workaround to cancel a backup would be to kill the client-side backup command (`control-C`), ensure all relevant MapReduce jobs have exited, and then\nrun the `hbase backup repair` command to ensure the system backup metadata is consistent.\n\n**Backups can only be saved to a single location**\\\nCopying backup information to multiple locations is an exercise left to the user. [HBASE-15476](https://issues.apache.org/jira/browse/HBASE-15476) will\nintroduce the ability to specify multiple-backup destinations intrinsically.\n\n**HBase superuser access is required**\\\nOnly an HBase superuser (e.g. hbase) is allowed to perform backup/restore, can pose a problem for shared HBase installations. Current mitigations would require\ncoordination with system administrators to build and deploy a backup and restore strategy ([HBASE-14138](https://issues.apache.org/jira/browse/HBASE-14138)).\n\n**Backup restoration is an online operation**\\\nTo perform a restore from a backup, it requires that the HBase cluster is online as a caveat of the current implementation ([HBASE-16573](https://issues.apache.org/jira/browse/HBASE-16573)).\n\n**Some operations may fail and require re-run**\\\nThe HBase backup feature is primarily client driven. While there is the standard HBase retry logic built into the HBase Connection, persistent errors in executing operations\nmay propagate back to the client (e.g. snapshot failure due to region splits). The backup implementation should be moved from client-side into the ProcedureV2 framework\nin the future which would provide additional robustness around transient/retryable failures. The `hbase backup repair` command is meant to correct states which the system\ncannot automatically detect and recover from.\n\n**Avoidance of declaration of public API**\\\nWhile the Java API to interact with this feature exists and its implementation is separated from an interface, insufficient rigor has been applied to determine if\nit is exactly what we intend to ship to users. As such, it is marked as for a `Private` audience with the expectation that, as users begin to try the feature, there\nwill be modifications that would necessitate breaking compatibility ([HBASE-17517](https://issues.apache.org/jira/browse/HBASE-17517)).\n\n**Lack of global metrics for backup and restore**\\\nIndividual backup and restore operations contain metrics about the amount of work the operation included, but there is no centralized location (e.g. the Master UI)\nwhich present information for consumption ([HBASE-16565](https://issues.apache.org/jira/browse/HBASE-16565)).\n\n***\n\n# Synchronous Replication\n\n## Background\n\nThe current [Cluster Replication](/docs/operational-management/cluster-replication) in HBase in asynchronous. So if the master cluster crashes, the slave cluster may not have the\nnewest data. If users want strong consistency then they can not switch to the slave cluster.\n\n## Design\n\nPlease see the design doc on [HBASE-19064](https://issues.apache.org/jira/browse/HBASE-19064)\n\n## Operation and maintenance\n\n### Case.1 Setup two synchronous replication clusters\n\n* Add a synchronous peer in both source cluster and peer cluster.\n\nFor source cluster:\n\n```ruby\nhbase> add_peer  '1', CLUSTER_KEY => 'lg-hadoop-tst-st01.bj:10010,lg-hadoop-tst-st02.bj:10010,lg-hadoop-tst-st03.bj:10010:/hbase/test-hbase-slave', REMOTE_WAL_DIR=>'hdfs://lg-hadoop-tst-st01.bj:20100/hbase/test-hbase-slave/remoteWALs', TABLE_CFS => {\"ycsb-test\"=>[]}\n```\n\nFor peer cluster:\n\n```ruby\nhbase> add_peer  '1', CLUSTER_KEY => 'lg-hadoop-tst-st01.bj:10010,lg-hadoop-tst-st02.bj:10010,lg-hadoop-tst-st03.bj:10010:/hbase/test-hbase', REMOTE_WAL_DIR=>'hdfs://lg-hadoop-tst-st01.bj:20100/hbase/test-hbase/remoteWALs', TABLE_CFS => {\"ycsb-test\"=>[]}\n```\n\n<Callout type=\"info\">\n  For synchronous replication, the current implementation require that we have the same peer id for\n  both source and peer cluster. Another thing that need attention is: the peer does not support\n  cluster-level, namespace-level, or cf-level replication, only support table-level replication now.\n</Callout>\n\n* Transit the peer cluster to be STANDBY state\n\n  ```ruby\n  hbase> transit_peer_sync_replication_state '1', 'STANDBY'\n  ```\n\n* Transit the source cluster to be ACTIVE state\n  ```ruby\n  hbase> transit_peer_sync_replication_state '1', 'ACTIVE'\n  ```\n\nNow, the synchronous replication has been set up successfully. the HBase client can only request to source cluster, if\nrequest to peer cluster, the peer cluster which is STANDBY state now will reject the read/write requests.\n\n### Case.2 How to operate when standby cluster crashed\n\nIf the standby cluster has been crashed, it will fail to write remote WAL for the active cluster. So we need to transit\nthe source cluster to DOWNGRANDE\\_ACTIVE state, which means source cluster won't write any remote WAL any more, but\nthe normal replication (asynchronous Replication) can still work fine, it queue the newly written WALs, but the\nreplication block until the peer cluster come back.\n\n```ruby\nhbase> transit_peer_sync_replication_state '1', 'DOWNGRADE_ACTIVE'\n```\n\nOnce the peer cluster come back, we can just transit the source cluster to ACTIVE, to ensure that the replication will be\nsynchronous.\n\n```ruby\nhbase> transit_peer_sync_replication_state '1', 'ACTIVE'\n```\n\n### Case.3 How to operate when active cluster crashed\n\nIf the active cluster has been crashed (it may be not reachable now), so let's just transit the standby cluster to\nDOWNGRADE\\_ACTIVE state, and after that, we should redirect all the requests from client to the DOWNGRADE\\_ACTIVE cluster.\n\n```ruby\nhbase> transit_peer_sync_replication_state '1', 'DOWNGRADE_ACTIVE'\n```\n\nIf the crashed cluster come back again, we just need to transit it to STANDBY directly. Otherwise if you transit the\ncluster to DOWNGRADE\\_ACTIVE, the original ACTIVE cluster may have redundant data compared to the current ACTIVE\ncluster. Because we designed to write source cluster WALs and remote cluster WALs concurrently, so it's possible that\nthe source cluster WALs has more data than the remote cluster, which result in data inconsistency. The procedure of\ntransiting ACTIVE to STANDBY has no problem, because we'll skip to replay the original WALs.\n\n```ruby\nhbase> transit_peer_sync_replication_state '1', 'STANDBY'\n```\n\nAfter that, we can promote the DOWNGRADE\\_ACTIVE cluster to ACTIVE now, to ensure that the replication will be synchronous.\n\n```ruby\nhbase> transit_peer_sync_replication_state '1', 'ACTIVE'\n```\n\n***\n\n# Apache HBase APIs\n\nThis information is not exhaustive, and provides a quick reference in addition to the [User API Reference](https://hbase.apache.org/apidocs/index.html).\nThe examples here are not comprehensive or complete, and should be used for purposes of illustration only.\n\nApache HBase also works with multiple external APIs.\nSee [Apache HBase External APIs](/docs/external-apis) for more information.\n\n## Examples\n\n### Create, modify and delete a Table Using Java\n\n```java\npackage com.example.hbase.admin;\n\nimport java.io.IOException;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.hbase.HBaseConfiguration;\nimport org.apache.hadoop.hbase.HColumnDescriptor;\nimport org.apache.hadoop.hbase.HConstants;\nimport org.apache.hadoop.hbase.HTableDescriptor;\nimport org.apache.hadoop.hbase.TableName;\nimport org.apache.hadoop.hbase.client.Admin;\nimport org.apache.hadoop.hbase.client.Connection;\nimport org.apache.hadoop.hbase.client.ConnectionFactory;\nimport org.apache.hadoop.hbase.io.compress.Compression.Algorithm;\n\npublic class Example {\n\n  private static final String TABLE_NAME = \"MY_TABLE_NAME_TOO\";\n  private static final String CF_DEFAULT = \"DEFAULT_COLUMN_FAMILY\";\n\n  public static void createOrOverwrite(Admin admin, HTableDescriptor table) throws IOException {\n    if (admin.tableExists(table.getTableName())) {\n      admin.disableTable(table.getTableName());\n      admin.deleteTable(table.getTableName());\n    }\n    admin.createTable(table);\n  }\n\n  public static void createSchemaTables(Configuration config) throws IOException {\n    try (Connection connection = ConnectionFactory.createConnection(config);\n         Admin admin = connection.getAdmin()) {\n\n      HTableDescriptor table = new HTableDescriptor(TableName.valueOf(TABLE_NAME));\n      table.addFamily(new HColumnDescriptor(CF_DEFAULT).setCompressionType(Algorithm.NONE));\n\n      System.out.print(\"Creating table. \");\n      createOrOverwrite(admin, table);\n      System.out.println(\" Done.\");\n    }\n  }\n\n  public static void modifySchema (Configuration config) throws IOException {\n    try (Connection connection = ConnectionFactory.createConnection(config);\n         Admin admin = connection.getAdmin()) {\n\n      TableName tableName = TableName.valueOf(TABLE_NAME);\n      if (!admin.tableExists(tableName)) {\n        System.out.println(\"Table does not exist.\");\n        System.exit(-1);\n      }\n\n      HTableDescriptor table = admin.getTableDescriptor(tableName);\n\n      // Update existing table\n      HColumnDescriptor newColumn = new HColumnDescriptor(\"NEWCF\");\n      newColumn.setCompactionCompressionType(Algorithm.GZ);\n      newColumn.setMaxVersions(HConstants.ALL_VERSIONS);\n      admin.addColumn(tableName, newColumn);\n\n      // Update existing column family\n      HColumnDescriptor existingColumn = new HColumnDescriptor(CF_DEFAULT);\n      existingColumn.setCompactionCompressionType(Algorithm.GZ);\n      existingColumn.setMaxVersions(HConstants.ALL_VERSIONS);\n      table.modifyFamily(existingColumn);\n      admin.modifyTable(tableName, table);\n\n      // Disable an existing table\n      admin.disableTable(tableName);\n\n      // Delete an existing column family\n      admin.deleteColumn(tableName, CF_DEFAULT.getBytes(\"UTF-8\"));\n\n      // Delete a table (Need to be disabled first)\n      admin.deleteTable(tableName);\n    }\n  }\n\n  public static void main(String... args) throws IOException {\n    Configuration config = HBaseConfiguration.create();\n\n    //Add any necessary configuration files (hbase-site.xml, core-site.xml)\n    config.addResource(new Path(System.getenv(\"HBASE_CONF_DIR\"), \"hbase-site.xml\"));\n    config.addResource(new Path(System.getenv(\"HADOOP_CONF_DIR\"), \"core-site.xml\"));\n    createSchemaTables(config);\n    modifySchema(config);\n  }\n}\n```\n\n***\n\n# Apache HBase External APIs\n\nFor information on using the native HBase APIs, refer to [User API Reference](https://hbase.apache.org/apidocs/index.html) and the [HBase APIs](/docs/hbase-apis) chapter.\n\n## REST\n\nRepresentational State Transfer (REST) was introduced in 2000 in the doctoral dissertation of Roy Fielding, one of the principal authors of the HTTP specification.\n\nREST itself is out of the scope of this documentation, but in general, REST allows client-server interactions via an API that is tied to the URL itself. This section discusses how to configure and run the REST server included with HBase, which exposes HBase tables, rows, cells, and metadata as URL specified resources. There is also a nice series of blogs on [How-to: Use the Apache HBase REST Interface](http://blog.cloudera.com/blog/2013/03/how-to-use-the-apache-hbase-rest-interface-part-1/) by Jesse Anderson.\n\n### Starting and Stopping the REST Server\n\nThe included REST server can run as a daemon which starts an embedded Jetty servlet container and deploys the servlet into it. Use one of the following commands to start the REST server in the foreground or background. The port is optional, and defaults to 8080.\n\n```bash\n# Foreground\n$ bin/hbase rest start -p <port>\n\n# Background, logging to a file in $HBASE_LOGS_DIR\n$ bin/hbase-daemon.sh start rest -p <port>\n```\n\nTo stop the REST server, use Ctrl-C if you were running it in the foreground, or the following command if you were running it in the background.\n\n```bash\n$ bin/hbase-daemon.sh stop rest\n```\n\n### Configuring the REST Server and Client\n\nFor information about configuring the REST server and client for SSL, as well as `doAs` impersonation for the REST server, see [Configure the Thrift Gateway to Authenticate on Behalf of the Client](/docs/security/client-access#configure-the-thrift-gateway-to-authenticate-on-behalf-of-the-client) and other portions of the [Securing Apache HBase](/docs/security) chapter.\n\n### Using REST Endpoints\n\nThe following examples use the placeholder server [http://example.com:8000](http://example.com:8000), and the following commands can all be run using `curl` or `wget` commands. You can request plain text (the default), XML , or JSON output by adding no header for plain text, or the header \"Accept: text/xml\" for XML, \"Accept: application/json\" for JSON, or \"Accept: application/x-protobuf\" to for protocol buffers.\n\n<Callout type=\"info\">\n  Unless specified, use `GET` requests for queries, `PUT` or `POST` requests for creation or\n  mutation, and `DELETE` for deletion.\n</Callout>\n\n#### Cluster-Wide Endpoints\n\n| Endpoint           | HTTP Verb | Description                              |\n| ------------------ | --------- | ---------------------------------------- |\n| `/version/cluster` | `GET`     | Version of HBase running on this cluster |\n| `/version/rest`    | `GET`     | Version of the HBase REST Server         |\n| `/status/cluster`  | `GET`     | Cluster status                           |\n| `/`                | `GET`     | List of all non-system tables            |\n\n**Examples:**\n\n```bash\n# Get cluster version\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/version/cluster\"\n\n# Get REST server version\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/version/rest\"\n\n# Get cluster status\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/status/cluster\"\n\n# List all non-system tables\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/\"\n```\n\n#### Namespace Endpoints\n\n| Endpoint                       | HTTP Verb | Description                                      |\n| ------------------------------ | --------- | ------------------------------------------------ |\n| `/namespaces`                  | `GET`     | List all namespaces                              |\n| `/namespaces/namespace`        | `GET`     | Describe a specific namespace                    |\n| `/namespaces/namespace`        | `POST`    | Create a new namespace                           |\n| `/namespaces/namespace/tables` | `GET`     | List all tables in a specific namespace          |\n| `/namespaces/namespace`        | `PUT`     | Alter an existing namespace. Currently not used. |\n| `/namespaces/namespace`        | `DELETE`  | Delete a namespace. The namespace must be empty. |\n\n**Examples:**\n\n```bash\n# List all namespaces\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/namespaces/\"\n\n# Describe a specific namespace\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/namespaces/special_ns\"\n\n# Create a new namespace\ncurl -vi -X POST \\\n  -H \"Accept: text/xml\" \\\n  \"example.com:8000/namespaces/special_ns\"\n\n# List all tables in a specific namespace\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/namespaces/special_ns/tables\"\n\n# Alter an existing namespace\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/namespaces/special_ns\n\n# Delete a namespace\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  \"example.com:8000/namespaces/special_ns\"\n```\n\n#### Table Endpoints\n\n| Endpoint         | HTTP Verb | Description                                                                      |\n| ---------------- | --------- | -------------------------------------------------------------------------------- |\n| `/table/exists`  | `GET`     | Returns if the specified table exists.                                           |\n| `/table/schema`  | `GET`     | Describe the schema of the specified table.                                      |\n| `/table/schema`  | `POST`    | Update an existing table with the provided schema fragment                       |\n| `/table/schema`  | `PUT`     | Create a new table, or replace an existing table's schema                        |\n| `/table/schema`  | `DELETE`  | Delete the table. You must use the `/table/schema` endpoint, not just `/table/`. |\n| `/table/regions` | `GET`     | List the table regions                                                           |\n\n**Examples:**\n\n```bash\n# Check if table exists\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/exists\"\n\n# Get table schema\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/schema\"\n\n# Update table schema\ncurl -vi -X POST \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\"?><TableSchema name=\"users\"><ColumnSchema name=\"cf\" KEEP_DELETED_CELLS=\"true\" /></TableSchema>' \\\n  \"http://example.com:8000/users/schema\"\n\n# Create or replace table schema\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\"?><TableSchema name=\"users\"><ColumnSchema name=\"cf\" /></TableSchema>' \\\n  \"http://example.com:8000/users/schema\"\n\n# Delete table\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/schema\"\n\n# List table regions\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/regions\"\n```\n\n#### Endpoints for `Get` Operations\n\n| Endpoint                                                                                 | HTTP Verb | Description                                                                                                                                                                                                                                                                                                             |\n| ---------------------------------------------------------------------------------------- | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row`                                                                             | `GET`     | Get all columns of a single row. Values are Base-64 encoded. This requires the \"Accept\" request header with a type that can hold multiple columns (like xml, json or protobuf).                                                                                                                                         |\n| `/table/row/column:qualifier/timestamp`                                                  | `GET`     | Get the value of a single column. Values are Base-64 encoded.                                                                                                                                                                                                                                                           |\n| `/table/row/column:qualifier`                                                            | `GET`     | Get the value of a single column. Values are Base-64 encoded.                                                                                                                                                                                                                                                           |\n| `/table/row/column:qualifier?e=b64`                                                      | `GET`     | Get the value of a single column using a binary rowkey and column name, encoded in [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5). Returned values are Base-64 encoded.                                                                                                                     |\n| `/table/row_prefix*/column`                                                              | `GET`     | Get a combination of rows which matches the given row prefix and column family. Returned values are Base-64 encoded.                                                                                                                                                                                                    |\n| `/table/row_prefix*/column:qualifier`                                                    | `GET`     | Get a combination of rows which matches the given row prefix, column family and qualifier. Returned values are Base-64 encoded.                                                                                                                                                                                         |\n| `/table/multiget?row=row&row=row/column:qualifier&row=...`                               | `GET`     | Multi-Get a combination of rows/columns. Values are Base-64 encoded.                                                                                                                                                                                                                                                    |\n| `/table/multiget?e=b64&row=row&row=row/column:qualifier&row=...`                         | `GET`     | Multi-Get a combination of rows/columns using binary rowkeys and column names, encoded in [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5). Returned values are Base-64 encoded.                                                                                                              |\n| `/table/multiget?row=row&row=row/column:qualifier&filter=url_encoded_filter`             | `GET`     | Multi-Get a combination of rows/columns with a filter. The filter should be specified according to the [Thrift Filter Language](/docs/thrift-filter-language#filter-language) and then encoded as `application/x-www-form-urlencoded` MIME format string. This example uses `PrefixFilter('row1')`.                     |\n| `/table/multiget?row=row&row=row/column:qualifier&row=...&filter_b64=b64_encoded_filter` | `GET`     | Multi-Get a combination of rows/columns with a filter. The filter should be specified according to the [Thrift Filter Language](/docs/thrift-filter-language#filter-language) and then encoded in [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5). This example uses `PrefixFilter('row1')`. |\n| `/table/row/column:qualifier/?v=number_of_versions`                                      | `GET`     | Multi-Get a specified number of versions of a given cell. Values are Base-64 encoded.                                                                                                                                                                                                                                   |\n\n**Examples:**\n\n```bash\n# Get all columns of a single row\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1\"\n\n# Get single column with timestamp\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1/cf:a/1458586888395\"\n\n# Get single column\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1/cf:a\"\n\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1/cf:a/\"\n\n# Get single column with base64 encoding\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/cm93MQ/Y2Y6YQ?e=b64\"\n\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  -H \"Encoding: base64\" \\\n  \"http://example.com:8000/users/cm93MQ/Y2Y6YQ/\"\n\n# Get rows with prefix\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row*/cf\"\n\n# Multi-get\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/multiget?row=row1&row=row2/cf:a\"\n\n# Multi-get with base64\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/multiget?e=b64&row=cm93MQ&row=cm93Mg%2FY2Y6YQ\"\n\n# Multi-get with filter\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/multiget?row=row1&row=row2/cf:a&filter=PrefixFilter%28%27row1%27%29\"\n\n# Multi-get with base64 filter\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/multiget?row=row1&row=row2/cf:a&filter_b64=UHJlZml4RmlsdGVyKCdyb3cxJyk\"\n\n# Get multiple versions\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1/cf:a?v=2\"\n```\n\n#### Endpoints for `Delete` Operations\n\n| Endpoint                                | HTTP Verb | Description                                                                                                                                          |\n| --------------------------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row`                            | `DELETE`  | Delete all columns of a single row.                                                                                                                  |\n| `/table/row/column_family:`             | `DELETE`  | Delete all columns of a single row and column family.                                                                                                |\n| `/table/row/column:qualifier/timestamp` | `DELETE`  | Delete a single column.                                                                                                                              |\n| `/table/row/column:qualifier`           | `DELETE`  | Delete a single column.                                                                                                                              |\n| `/table/row/column:qualifier?e=b64`     | `DELETE`  | Delete a single column using a binary rowkey and column name, encoded in [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5). |\n\n**Examples:**\n\n```bash\n# Delete all columns of a row\ncurl -vi -X DELETE \\\n  \"http://example.com:8000/users/row1\"\n\n# Delete all columns of a row and column family\ncurl -vi -X DELETE \\\n  \"http://example.com:8000/users/row1/cf\"\n\n# Delete a single column with timestamp\ncurl -vi -X DELETE \\\n  \"http://example.com:8000/users/row1/cf:a/1458586888395\"\n\n# Delete a single column\ncurl -vi -X DELETE \\\n  \"http://example.com:8000/users/row1/cf:a\"\n\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1/cf:a/\"\n\n# Delete with base64 encoding\ncurl -vi -X DELETE \\\n  \"http://example.com:8000/users/cm93MQ/Y2Y6YQ?e=b64\"\n\ncurl -vi -X DELETE \\\n  -H \"Encoding: base64\" \\\n  \"http://example.com:8000/users/cm93MQ/Y2Y6YQ/\"\n```\n\n#### Stateful endpoints for `Scan` Operations\n\n| Endpoint                    | HTTP Verb | Description                                                                                                                                                                                                                                                                                                                                                                                                                |\n| --------------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/scanner/`           | `PUT`     | Get a Scanner object. Required by all other Scan operations. Adjust the batch parameter to the number of rows the scan should return in a batch. See the next example for adding filters to your scanner. The scanner endpoint URL is returned as the `Location` in the HTTP response. The other examples in this table assume that the scanner endpoint is `http://example.com:8000/users/scanner/145869072824375522207`. |\n| `/table/scanner/`           | `PUT`     | To supply filters to the Scanner object or configure the Scanner in any other way, you can create a text file and add your filter to the file. For example, to return only rows for which keys start with u123 and use a batch size of 100, pass the file to the `-d` argument of the `curl` request (see example below).                                                                                                  |\n| `/table/scanner/scanner-id` | `GET`     | Get the next batch from the scanner. Cell values are byte-encoded. If the scanner has been exhausted, HTTP status `204` is returned.                                                                                                                                                                                                                                                                                       |\n| `table/scanner/scanner-id`  | `DELETE`  | Deletes the scanner and frees the resources it used.                                                                                                                                                                                                                                                                                                                                                                       |\n\nFor the filter file example, it should contain:\n\n```xml\n<Scanner batch=\"100\">\n  <filter>\n    {\n      \"type\": \"PrefixFilter\",\n      \"value\": \"u123\"\n    }\n  </filter>\n</Scanner>\n```\n\n**Examples:**\n\n```bash\n# Create a scanner\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<Scanner batch=\"1\"/>' \\\n  \"http://example.com:8000/users/scanner/\"\n\n# Create a scanner with filter from file\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type:text/xml\" \\\n  -d @filter.txt \\\n  \"http://example.com:8000/users/scanner/\"\n\n# Get next batch from scanner\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/scanner/145869072824375522207\"\n\n# Delete scanner\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/scanner/145869072824375522207\"\n```\n\n#### Stateless endpoints for `Scan` Operations\n\n| Endpoint                                                | HTTP Verb | Description                                                                                                                                                                                                                                                           |\n| ------------------------------------------------------- | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/*`                                              | `GET`     | Scanning the entire table. The stateless scanner endpoint does not require a followup call to return the results.                                                                                                                                                     |\n| `/table/*?limit=number_of_rows`                         | `GET`     | Scanning the first row of the table.                                                                                                                                                                                                                                  |\n| `/table/*?column=column:qualifier`                      | `GET`     | Scanning a given column of the table.                                                                                                                                                                                                                                 |\n| `/table/*?column=column1:qualifier1,column2:qualifier2` | `GET`     | Scanning more than one column of the table.                                                                                                                                                                                                                           |\n| `/table/*?startrow=row&limit=number_of_rows`            | `GET`     | Scanning table with start row and limit.                                                                                                                                                                                                                              |\n| `/table/row_prefix*`                                    | `GET`     | Scanning table with row prefix.                                                                                                                                                                                                                                       |\n| `/table/*?reversed=true`                                | `GET`     | Scanning table in reverse.                                                                                                                                                                                                                                            |\n| `/table/*?filter=url_encoded_filter`                    | `GET`     | Scanning with a filter `PrefixFilter('row1')`. The filter should be specified according to the [Thrift Filter Language](/docs/thrift-filter-language#filter-language) and then encoded as `application/x-www-form-urlencoded` MIME format string.                     |\n| `/table/*?filter_b64=b64_encoded_filter`                | `GET`     | Scanning with a filter `PrefixFilter('row1')`. The filter should be specified according to the [Thrift Filter Language](/docs/thrift-filter-language#filter-language) and then encoded in [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5). |\n\n**Examples:**\n\n```bash\n# Scan entire table\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*\"\n\n# Scan with limit\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?limit=1\"\n\n# Scan single column\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?column=cf:a\"\n\n# Scan multiple columns\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?column=cf:a,cf:b\"\n\n# Scan with start row and limit\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?startrow=row1&limit=2\"\n\n# Scan with row prefix\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/row1*\"\n\n# Scan in reverse\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?reversed=true\"\n\n# Scan with filter\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?filter=PrefixFilter%28%27row1%27%29\"\n\n# Scan with base64 filter\ncurl -vi -X GET \\\n  -H \"Accept: text/xml\" \\\n  \"http://example.com:8000/users/*?filter_b64=UHJlZml4RmlsdGVyKCdyb3cxJyk\"\n```\n\nThe [stateful scanner API](/docs/external-apis#stateful-endpoints-for-scan-operations) expects clients to restart scans if there is a REST server failure in the midst. The stateless does not store any state related to scan operation and all the parameters are specified as query parameters.\n\n<Callout type=\"info\">\n  The stateless endpoints are optimized for small results, while the [stateful scanner\n  API](/docs/external-apis#stateful-endpoints-for-scan-operations) can also be used for large\n  results.\n</Callout>\n\nThe following are the scan parameters:\n\n* `startrow` - The start row for the scan.\n* `endrow` - The end row for the scan.\n* `column` - The comma separated list of columns to scan.\n* `starttime`, `endtime` - To only retrieve columns within a specific range of version timestamps, both start and end time must be specified.\n* `maxversions` - To limit the number of versions of each column to be returned.\n* `batchsize` - To limit the maximum number of values returned for each call to next().\n* `limit` - The number of rows to return in the scan operation.\n* `cacheblocks` - Whether to use the [Block Cache](/docs/architecture/regionserver#performance-reading-from-hbase-block-cache) in the RegionServer. By default `true`.\n* `reversed` - When set to `true`, reverse scan will be executed. By default `false`.\n* `filter` - Allows to specify a filter for the scan as an `application/x-www-form-urlencoded` MIME format string.\n* `filter_b64` - On versions which include the [HBASE-28518](https://issues.apache.org/jira/browse/HBASE-28518) patch, `filter_b64` allows to specify a [URL-safe base64](https://datatracker.ietf.org/doc/html/rfc4648#section-5) encoded filter for the scan. When both `filter` and `filter_b64` are specified, only `filter_b64` is considered.\n* `includeStartRow` - Whether start row should be included in the scan. By default `true`.\n* `includeStopRow` - Whether end row (stop row) should be included in the scan. By default `false`.\n\n<Callout type=\"info\">\n  `includeStartRow` and `includeStopRow` are only supported on versions that include [HBASE-28627](https://issues.apache.org/jira/browse/HBASE-28627).\n\n  Versions without this patch will either ignore these parameters or will error out if they are set to a non-default value.\n</Callout>\n\nMore on start row, end row and limit parameters:\n\n* If start row, end row and limit not specified, then the whole table will be scanned.\n* If start row and limit (say N) is specified, then the scan operation will return N rows from the start row specified.\n* If only limit parameter is specified, then the scan operation will return N rows from the start of the table.\n* If limit and end row are specified, then the scan operation will return N rows from start of table till the end row. If the end row is reached before N rows ( say M and M \\< N ), then M rows will be returned to the user.\n* If start row, end row and limit ( say N ) are specified and N \\< number of rows between start row and end row, then N rows from start row will be returned to the user. If N > (number of rows between start row and end row (say M), then M number of rows will be returned to the user.\n\n#### Endpoints for `Put` Operations\n\n| Endpoint         | HTTP Verb | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| ---------------- | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row_key` | `PUT`     | Write a row to a table. The row, column qualifier, and value must each be Base-64 encoded. To encode a string, use the `base64` command-line utility. To decode the string, use `base64 -d`. The payload is in the `--data` argument, and the `/users/fakerow` value is a placeholder. Insert multiple rows by adding them to the `<CellSet>` element. You can also save the data to be inserted to a file and pass it to the `-d` parameter with syntax like `-d @filename.txt`. |\n\n**Example:**\n\n```bash\n# XML format\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93NQo=\"><Cell column=\"Y2Y6ZQo=\">dmFsdWU1Cg==</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/fakerow\"\n\n# JSON format\ncurl -vi -X PUT \\\n  -H \"Accept: text/json\" \\\n  -H \"Content-Type: text/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93NQo=\", \"Cell\": [{\"column\":\"Y2Y6ZQo=\", \"$\":\"dmFsdWU1Cg==\"}]}]}'' \\\n  \"example.com:8000/users/fakerow\"\n```\n\n#### Endpoints for `Check-And-Put` Operations\n\n| Endpoint                    | HTTP Verb | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| --------------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row_key/?check=put` | `PUT`     | Conditional Put - Change the current version value of a cell: Compare the current or latest version value (`current-version-value`) of a cell with the `check-value`, and if `current-version-value` == `check-value`, write new data (the `new-value`) into the cell as the current or latest version. The row, column qualifier, and value must each be Base-64 encoded. To encode a string, use the `base64` command-line utility. To decode the string, use `base64 -d`. The payload is in the `--data` or `-d` argument, with `the check cell name (column family:column name) and value` always at the end and right after `the new Put cell name (column family:column name) and value` of the same row key. You can also save the data to be inserted to a file and pass it to the `-d` parameter with syntax like `-d @filename.txt`. |\n\n**Example:**\n\n```bash\n# XML format\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93MQ==\"><Cell column=\"Y2ZhOmFsaWFz\">T2xkR3V5</Cell><Cell column=\"Y2ZhOmFsaWFz\">TmV3R3V5</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row1/?check=put\"\n\n# JSON format\ncurl -vi -X PUT \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93MQ==\",\"Cell\":[{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"T2xkR3V5\"},{\"column\":\"Y2ZhOmFsaWFz\", \"$\":\"TmV3R3V5\"}] }]}' \\\n  \"http://example.com:8000/users/row1/?check=put\"\n```\n\nDetailed Explanation:\n\n* In the above json-format example:\n  1. `{\"column\":\"Y2ZhOmFsaWFz\", \"$\":\"TmV3R3V5\"}` at the end of `-d` option are `the check cell name and check cell value in Base-64` respectively: `\"Y2ZhOmFsaWFz\" for \"cfa:alias\"`, and `\"TmV3R3V5\" for \"NewGuy\"`\n  2. `{{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"T2xkR3V5\"}}` are `the new Put cell name and cell value in Base-64` respectively: `\"Y2ZhOmFsaWFz\" for \"cfa:alias\"`, and `\"T2xkR3V5\" for \"OldGuy\"`\n  3. `\"cm93MQ==\"` is `the Base-64 for \"row1\"` for the checkAndPut `row key`\n  4. `\"/?check=put\"` after the `\"row key\" in the request URL` is required for checkAndPut WebHBase operation to work\n  5. The `\"row key\" in the request URL` should be URL-encoded, e.g., `\"david%20chen\"` and `\"row1\"` are the URL-encoded formats of row keys `\"david chen\"` and `\"row1\"`, respectively\n     <Callout type=\"info\">\n       Note: \"cfa\" is the column family name and \"alias\" are the column (qualifier) name for the\n       non-Base64 encoded cell name.\n     </Callout>\n\n* Basically, the xml-format example is the same as the json-format example, and will not be explained here in detail.\n\n#### Endpoints for `Check-And-Delete` Operations\n\n| Endpoint                                                   | HTTP Verb | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| ---------------------------------------------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row_key/?check=delete`                             | `DELETE`  | Conditional Deleting a Row: Compare the value of any version of a cell (`any-version-value`) with the `check-value`, and if `any-version-value` == `check-value`, delete the row specified by the `row_key` inside the requesting URL. The row, column qualifier, and value for checking in the payload must each be Base-64 encoded. To encode a string, use the base64 command-line utility. To decode the string, use base64 -d. The payload is in the --data argument. You can also save the data to be checked to a file and pass it to the `-d` parameter with syntax like `-d @filename.txt`. |\n| `/table/row_key/column_family/?check=delete`               | `DELETE`  | Conditional Deleting a Column Family of a Row: Compare the value of any version of a cell (`any-version-value`) with the `check-value`, and if `any-version-value` == `check-value`, delete the column family of a row specified by the `row_key/column_family` inside the requesting URL. Anything else is the same as those in `Conditional Deleting a Row`.                                                                                                                                                                                                                                       |\n| `/table/row_key/column:qualifier/?check=delete`            | `DELETE`  | Conditional Deleting All Versions of a Column of a Row: Compare the value of any version of a cell (`any-version-value`) with the `check-value`, and if `any-version-value` == `check-value`, delete the column of a row specified by the `row_key/column:qualifier` inside the requesting URL. The `column:qualifier` in the requesting URL is the `column_family:column_name`. Anything else is the same as those in `Conditional Deleting a Row`.                                                                                                                                                 |\n| `/table/row_key/column:qualifier/version_id/?check=delete` | `DELETE`  | Conditional Deleting a Single Version of a Column of a Row: Compare the value of any version of a cell (`any-version-value`) with the `check-value`, and if `any-version-value` == `check-value`, delete the version of a column of a row specified by the `row_key/column:qualifier/version_id` inside the requesting URL. The `column:qualifier` in the requesting URL is the `column_family:column_name`. The `version_id` in the requesting URL is a number, which equals to `the timestamp of the targeted version + 1`. Anything else is the same as those in `Conditional Deleting a Row`.    |\n\n**Examples:**\n\n```bash\n# Conditional delete a row (XML)\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93MQ==\"><Cell column=\"Y2ZhOmFsaWFz\">TmV3R3V5</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row1/?check=delete\"\n\n# Conditional delete a row (JSON)\ncurl -vi -X DELETE \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93MQ==\",\"Cell\":[{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"TmV3R3V5\"}]}]}' \\\n  \"http://example.com:8000/users/row1/?check=delete\"\n\n# Conditional delete a column family (XML)\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93MQ==\"><Cell column=\"Y2ZhOmFsaWFz\">TmV3R3V5</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row1/cfa/?check=delete\"\n\n# Conditional delete a column family (JSON)\ncurl -vi -X DELETE \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93MQ==\",\"Cell\":[{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"TmV3R3V5\"}]}]}' \\\n  \"http://example.com:8000/users/row1/cfa/?check=delete\"\n\n# Conditional delete all versions of a column (XML)\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93MQ==\"><Cell column=\"Y2ZhOmFsaWFz\">TmV3R3V5</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row1/cfa:alias/?check=delete\"\n\n# Conditional delete all versions of a column (JSON)\ncurl -vi -X DELETE \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93MQ==\",\"Cell\":[{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"TmV3R3V5\"}]}]}' \\\n  \"http://example.com:8000/users/row1/cfa:alias/?check=delete\"\n\n# Conditional delete a single version (XML)\ncurl -vi -X DELETE \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93MQ==\"><Cell column=\"Y2ZhOmFsaWFz\">TmV3R3V5</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row1/cfa:alias/1519423552160/?check=delete\"\n\n# Conditional delete a single version (JSON)\ncurl -vi -X DELETE \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"cm93MQ==\",\"Cell\":[{\"column\":\"Y2ZhOmFsaWFz\",\"$\":\"TmV3R3V5\"}]}]}' \\\n  \"http://example.com:8000/users/row1/cfa:alias/1519423552160/?check=delete\"\n```\n\nDetailed Explanation:\n\n* In the above 4 json-format examples:\n  1. `{\"column\":\"Y2ZhOmFsaWFz\", \"$\":\"TmV3R3V5\"}` at the end of `-d` option are `the check cell name and check cell value in Base-64` respectively: `\"Y2ZhOmFsaWFz\" for \"cfa:alias\"`, and `\"TmV3R3V5\" for \"NewGuy\"`\n  2. `\"cm93MQ==\"` is `the Base-64 for \"row1\"` for the checkAndDelete `row key`\n  3. `\"/?check=delete\"` at the end of `the request URL` is required for checkAndDelete WebHBase operation to work\n  4. `\"version_id\"` in the `request URL` of the last json-format example should be equivalent to the value of `\"the timestamp number + 1\"`\n  5. The `\"row key\"`, `\"column family\"`, `\"cell name\" or \"column family:column name\"`, and `\"version_id\"` in `the request URL` of a checkAndDelete WebHBase operation should be URL-encoded, e.g., `\"row1\"`, `\"cfa\"`, `\"cfa:alias\"` and `\"1519423552160\"` in the examples are the URL-encoded `\"row key\"`, `\"column family\"`, `\"column family:column name\"`, and `\"version_id\"`, respectively\n\n* Basically, the 4 xml-format examples are the same as the 4 corresponding json-format examples, and will not be explained here in detail.\n\n#### Endpoints for `Append` Operations\n\n| Endpoint                       | HTTP Verb | Description                                                                                                                                 |\n| ------------------------------ | --------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/table/row_key/?check=append` | `PUT`     | Appends the given new value to the end of the current value of the cell. The row, column qualifier, and value must each be Base-64 encoded. |\n\n**Example:**\n\n```bash\n# XML format\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93NQo=\"><Cell column=\"Y2Y6ZQo=\">dmFsdWU1Cg==</Cell></Row></CellSet>' \\\n  \"http://example.com:8000/users/row5?check=append\"\n\n# JSON format\ncurl -vi -X PUT \\\n  -H \"Content-type: application/json\" \\\n  -H \"Accept: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"dGVzdHJvdzE=\",\"Cell\":[{\"column\":\"YTox\",\"$\":\"dGVzdHZhbHVlMgo\"},{\"column\":\"YToy\",\"$\":\"dGVzdHZhbHVlMTIK\"}]}]}' \\\n  \"http://localhost:8080/users/testrow1?check=append\"\n```\n\n#### Endpoints for `Increment` Operations\n\n| Endpoint                          | HTTP Verb | Description                                                                                                  |\n| --------------------------------- | --------- | ------------------------------------------------------------------------------------------------------------ |\n| `/table/row_key/?check=increment` | `PUT`     | Increments the current value of the cell. The row, column qualifier, and value must each be Base-64 encoded. |\n\n**Example:**\n\n```bash\n# XML format\ncurl -vi -X PUT \\\n  -H \"Accept: text/xml\" \\\n  -H \"Content-Type: text/xml\" \\\n  -d '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><CellSet><Row key=\"cm93NQo=\"><Cell column=\"YTox\">MQ==</Cell></Row></CellSet>' \\\n  \"http://localhost:8080/users/row5?check=increment\"\n\n# JSON format\ncurl -vi -X PUT \\\n  -H \"Content-type: application/json\" \\\n  -H \"Accept: application/json\" \\\n  -d '{\"Row\":[{\"key\":\"dGVzdHJvdzE=\",\"Cell\":[{\"column\":\"YTox\",\"$\":\"MQ==\"},{\"column\":\"YToy\",\"$\":\"MQ==\"}]}]}' \\\n  \"http://localhost:8080/users/testrow1?check=increment\"\n```\n\n### REST XML Schema\n\n```xml\n<schema xmlns=\"http://www.w3.org/2001/XMLSchema\" xmlns:tns=\"RESTSchema\">\n\n  <element name=\"Version\" type=\"tns:Version\"></element>\n\n  <complexType name=\"Version\">\n    <attribute name=\"REST\" type=\"string\"></attribute>\n    <attribute name=\"JVM\" type=\"string\"></attribute>\n    <attribute name=\"OS\" type=\"string\"></attribute>\n    <attribute name=\"Server\" type=\"string\"></attribute>\n    <attribute name=\"Jersey\" type=\"string\"></attribute>\n    <attribute name=\"Version\" type=\"string\"></attribute>\n    <attribute name=\"Revision\" type=\"string\"></attribute>\n  </complexType>\n\n  <element name=\"TableList\" type=\"tns:TableList\"></element>\n\n  <complexType name=\"TableList\">\n    <sequence>\n      <element name=\"table\" type=\"tns:Table\" maxOccurs=\"unbounded\" minOccurs=\"1\"></element>\n    </sequence>\n  </complexType>\n\n  <complexType name=\"Table\">\n    <sequence>\n      <element name=\"name\" type=\"string\"></element>\n    </sequence>\n  </complexType>\n\n  <element name=\"TableInfo\" type=\"tns:TableInfo\"></element>\n\n  <complexType name=\"TableInfo\">\n    <sequence>\n      <element name=\"region\" type=\"tns:TableRegion\" maxOccurs=\"unbounded\" minOccurs=\"1\"></element>\n    </sequence>\n    <attribute name=\"name\" type=\"string\"></attribute>\n  </complexType>\n\n  <complexType name=\"TableRegion\">\n    <attribute name=\"name\" type=\"string\"></attribute>\n    <attribute name=\"id\" type=\"int\"></attribute>\n    <attribute name=\"startKey\" type=\"base64Binary\"></attribute>\n    <attribute name=\"endKey\" type=\"base64Binary\"></attribute>\n    <attribute name=\"location\" type=\"string\"></attribute>\n  </complexType>\n\n  <element name=\"TableSchema\" type=\"tns:TableSchema\"></element>\n\n  <complexType name=\"TableSchema\">\n    <sequence>\n      <element name=\"column\" type=\"tns:ColumnSchema\" maxOccurs=\"unbounded\" minOccurs=\"1\"></element>\n    </sequence>\n    <attribute name=\"name\" type=\"string\"></attribute>\n    <anyAttribute></anyAttribute>\n  </complexType>\n\n  <complexType name=\"ColumnSchema\">\n    <attribute name=\"name\" type=\"string\"></attribute>\n    <anyAttribute></anyAttribute>\n  </complexType>\n\n  <element name=\"CellSet\" type=\"tns:CellSet\"></element>\n\n  <complexType name=\"CellSet\">\n    <sequence>\n      <element name=\"row\" type=\"tns:Row\" maxOccurs=\"unbounded\" minOccurs=\"1\"></element>\n    </sequence>\n  </complexType>\n\n  <element name=\"Row\" type=\"tns:Row\"></element>\n\n  <complexType name=\"Row\">\n    <sequence>\n      <element name=\"key\" type=\"base64Binary\"></element>\n      <element name=\"cell\" type=\"tns:Cell\" maxOccurs=\"unbounded\" minOccurs=\"1\"></element>\n    </sequence>\n  </complexType>\n\n  <element name=\"Cell\" type=\"tns:Cell\"></element>\n\n  <complexType name=\"Cell\">\n    <sequence>\n      <element name=\"value\" maxOccurs=\"1\" minOccurs=\"1\">\n        <simpleType><restriction base=\"base64Binary\">\n        </simpleType>\n      </element>\n    </sequence>\n    <attribute name=\"column\" type=\"base64Binary\" />\n    <attribute name=\"timestamp\" type=\"int\" />\n  </complexType>\n\n  <element name=\"Scanner\" type=\"tns:Scanner\"></element>\n\n  <complexType name=\"Scanner\">\n    <sequence>\n      <element name=\"column\" type=\"base64Binary\" minOccurs=\"0\" maxOccurs=\"unbounded\"></element>\n    </sequence>\n    <attribute name=\"startRow\" type=\"base64Binary\"></attribute>\n    <attribute name=\"endRow\" type=\"base64Binary\"></attribute>\n    <attribute name=\"batch\" type=\"int\"></attribute>\n    <attribute name=\"startTime\" type=\"int\"></attribute>\n    <attribute name=\"endTime\" type=\"int\"></attribute>\n    <attribute name=\"filter\" type=\"string\"></attribute>\n    <attribute name=\"caching\" type=\"int\"></attribute>\n    <sequence>\n        <element name=\"labels\" type=\"string\" minOccurs=\"0\" maxOccurs=\"unbounded\"></element>\n    </sequence>\n    <attribute name=\"cacheBlocks\" type=\"boolean\"></attribute>\n    <attribute name=\"maxVersions\" type=\"int\"></attribute>\n    <attribute name=\"limit\" type=\"int\"></attribute>\n    <attribute name=\"includeStartRow\" type=\"boolean\"></attribute>\n    <attribute name=\"includeStopRow\" type=\"boolean\"></attribute>\n  </complexType>\n\n  <element name=\"StorageClusterVersion\" type=\"tns:StorageClusterVersion\" />\n\n  <complexType name=\"StorageClusterVersion\">\n    <attribute name=\"version\" type=\"string\"></attribute>\n  </complexType>\n\n  <element name=\"StorageClusterStatus\"\n    type=\"tns:StorageClusterStatus\">\n  </element>\n\n  <complexType name=\"StorageClusterStatus\">\n    <sequence>\n      <element name=\"liveNode\" type=\"tns:Node\"\n        maxOccurs=\"unbounded\" minOccurs=\"0\">\n      </element>\n      <element name=\"deadNode\" type=\"string\" maxOccurs=\"unbounded\"\n        minOccurs=\"0\">\n      </element>\n    </sequence>\n    <attribute name=\"regions\" type=\"int\"></attribute>\n    <attribute name=\"requests\" type=\"int\"></attribute>\n    <attribute name=\"averageLoad\" type=\"float\"></attribute>\n  </complexType>\n\n  <complexType name=\"Node\">\n    <sequence>\n      <element name=\"region\" type=\"tns:Region\"\n   maxOccurs=\"unbounded\" minOccurs=\"0\">\n      </element>\n    </sequence>\n    <attribute name=\"name\" type=\"string\"></attribute>\n    <attribute name=\"startCode\" type=\"int\"></attribute>\n    <attribute name=\"requests\" type=\"int\"></attribute>\n    <attribute name=\"heapSizeMB\" type=\"int\"></attribute>\n    <attribute name=\"maxHeapSizeMB\" type=\"int\"></attribute>\n  </complexType>\n\n  <complexType name=\"Region\">\n    <attribute name=\"name\" type=\"base64Binary\"></attribute>\n    <attribute name=\"stores\" type=\"int\"></attribute>\n    <attribute name=\"storefiles\" type=\"int\"></attribute>\n    <attribute name=\"storefileSizeMB\" type=\"int\"></attribute>\n    <attribute name=\"memstoreSizeMB\" type=\"int\"></attribute>\n    <attribute name=\"storefileIndexSizeKB\" type=\"int\"></attribute>\n    <attribute name=\"readRequestsCount\" type=\"int\"></attribute>\n    <attribute name=\"cpRequestsCount\" type=\"int\"></attribute>\n    <attribute name=\"writeRequestsCount\" type=\"int\"></attribute>\n    <attribute name=\"rootIndexSizeKB\" type=\"int\"></attribute>\n    <attribute name=\"totalStaticIndexSizeKB\" type=\"int\"></attribute>\n    <attribute name=\"totalStaticBloomSizeKB\" type=\"int\"></attribute>\n    <attribute name=\"totalCompactingKVs\" type=\"int\"></attribute>\n    <attribute name=\"currentCompactedKVs\" type=\"int\"></attribute>\n  </complexType>\n\n</schema>\n```\n\n### REST Protobufs Schema\n\n```protobuf\nmessage Version {\n  optional string restVersion = 1;\n  optional string jvmVersion = 2;\n  optional string osVersion = 3;\n  optional string serverVersion = 4;\n  optional string jerseyVersion = 5;\n  optional string version = 6;\n  optional string revision = 7;\n}\n\nmessage StorageClusterStatus {\n  message Region {\n    required bytes name = 1;\n    optional int32 stores = 2;\n    optional int32 storefiles = 3;\n    optional int32 storefileSizeMB = 4;\n    optional int32 memStoreSizeMB = 5;\n    optional int64 storefileIndexSizeKB = 6;\n    optional int64 readRequestsCount = 7;\n    optional int64 writeRequestsCount = 8;\n    optional int32 rootIndexSizeKB = 9;\n    optional int32 totalStaticIndexSizeKB = 10;\n    optional int32 totalStaticBloomSizeKB = 11;\n    optional int64 totalCompactingKVs = 12;\n    optional int64 currentCompactedKVs = 13;\n    optional int64 cpRequestsCount = 14;\n  }\n  message Node {\n    required string name = 1;    // name:port\n    optional int64 startCode = 2;\n    optional int32 requests = 3;\n    optional int32 heapSizeMB = 4;\n    optional int32 maxHeapSizeMB = 5;\n    repeated Region regions = 6;\n  }\n  // node status\n  repeated Node liveNodes = 1;\n  repeated string deadNodes = 2;\n  // summary statistics\n  optional int32 regions = 3;\n  optional int32 requests = 4;\n  optional double averageLoad = 5;\n}\n\nmessage TableList {\n  repeated string name = 1;\n}\n\nmessage TableInfo {\n  required string name = 1;\n  message Region {\n    required string name = 1;\n    optional bytes startKey = 2;\n    optional bytes endKey = 3;\n    optional int64 id = 4;\n    optional string location = 5;\n  }\n  repeated Region regions = 2;\n}\n\nmessage TableSchema {\n  optional string name = 1;\n  message Attribute {\n    required string name = 1;\n    required string value = 2;\n  }\n  repeated Attribute attrs = 2;\n  repeated ColumnSchema columns = 3;\n  // optional helpful encodings of commonly used attributes\n  optional bool inMemory = 4;\n  optional bool readOnly = 5;\n}\n\nmessage ColumnSchema {\n  optional string name = 1;\n  message Attribute {\n    required string name = 1;\n    required string value = 2;\n  }\n  repeated Attribute attrs = 2;\n  // optional helpful encodings of commonly used attributes\n  optional int32 ttl = 3;\n  optional int32 maxVersions = 4;\n  optional string compression = 5;\n}\n\nmessage Cell {\n  optional bytes row = 1;       // unused if Cell is in a CellSet\n  optional bytes column = 2;\n  optional int64 timestamp = 3;\n  optional bytes data = 4;\n}\n\nmessage CellSet {\n  message Row {\n    required bytes key = 1;\n    repeated Cell values = 2;\n  }\n  repeated Row rows = 1;\n}\n\nmessage Scanner {\n  optional bytes startRow = 1;\n  optional bytes endRow = 2;\n  repeated bytes columns = 3;\n  optional int32 batch = 4;\n  optional int64 startTime = 5;\n  optional int64 endTime = 6;\n  optional int32 maxVersions = 7;\n  optional string filter = 8;\n  optional int32 caching = 9;     // specifies REST scanner caching\n  repeated string labels = 10;\n  optional bool cacheBlocks = 11; // server side block caching hint\n  optional int32 limit = 12;\n  optional bool includeStartRow = 13;\n  optional bool includeStopRow = 14;\n}\n```\n\n## Thrift\n\nDocumentation about Thrift has moved to [Thrift API and Filter Language](/docs/thrift-filter-language).\n\n## C/C++ Apache HBase Client\n\nFB's Chip Turner wrote a pure C/C++ client. [Check it out](https://github.com/hinaria/native-cpp-hbase-client).\n\nC++ client implementation. To see [HBASE-14850](https://issues.apache.org/jira/browse/HBASE-14850).\n\n## Using Java Data Objects (JDO) with HBase\n\n[Java Data Objects (JDO)](https://db.apache.org/jdo/) is a standard way to access persistent data in databases, using plain old Java objects (POJO) to represent persistent data.\n\n**Dependencies**\n\nThis code example has the following dependencies:\n\n1. HBase 0.90.x or newer\n2. commons-beanutils.jar ([https://commons.apache.org/](https://commons.apache.org/))\n3. commons-pool-1.5.5.jar ([https://commons.apache.org/](https://commons.apache.org/))\n4. transactional-tableindexed for HBase 0.90 ([https://github.com/hbase-trx/hbase-transactional-tableindexed](https://github.com/hbase-trx/hbase-transactional-tableindexed))\n\n**Download `hbase-jdo`**\\\nDownload the code from [http://code.google.com/p/hbase-jdo/](http://code.google.com/p/hbase-jdo/).\n\n**JDO Example**\\\nThis example uses JDO to create a table and an index, insert a row into a table, get a row, get a column value, perform a query, and do some additional HBase operations.\n\n```java\npackage com.apache.hadoop.hbase.client.jdo.examples;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.Hashtable;\n\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.hbase.client.tableindexed.IndexedTable;\n\nimport com.apache.hadoop.hbase.client.jdo.AbstractHBaseDBO;\nimport com.apache.hadoop.hbase.client.jdo.HBaseBigFile;\nimport com.apache.hadoop.hbase.client.jdo.HBaseDBOImpl;\nimport com.apache.hadoop.hbase.client.jdo.query.DeleteQuery;\nimport com.apache.hadoop.hbase.client.jdo.query.HBaseOrder;\nimport com.apache.hadoop.hbase.client.jdo.query.HBaseParam;\nimport com.apache.hadoop.hbase.client.jdo.query.InsertQuery;\nimport com.apache.hadoop.hbase.client.jdo.query.QSearch;\nimport com.apache.hadoop.hbase.client.jdo.query.SelectQuery;\nimport com.apache.hadoop.hbase.client.jdo.query.UpdateQuery;\n\n/**\n * Hbase JDO Example.\n *\n * dependency library.\n * - commons-beanutils.jar\n * - commons-pool-1.5.5.jar\n * - hbase0.90.0-transactionl.jar\n *\n * you can expand Delete,Select,Update,Insert Query classes.\n *\n */\npublic class HBaseExample {\n  public static void main(String[] args) throws Exception {\n    AbstractHBaseDBO dbo = new HBaseDBOImpl();\n\n    //*drop if table is already exist.*\n    if(dbo.isTableExist(\"user\")){\n     dbo.deleteTable(\"user\");\n    }\n\n    //*create table*\n    dbo.createTableIfNotExist(\"user\",HBaseOrder.DESC,\"account\");\n    //dbo.createTableIfNotExist(\"user\",HBaseOrder.ASC,\"account\");\n\n    //create index.\n    String[] cols={\"id\",\"name\"};\n    dbo.addIndexExistingTable(\"user\",\"account\",cols);\n\n    //insert\n    InsertQuery insert = dbo.createInsertQuery(\"user\");\n    UserBean bean = new UserBean();\n    bean.setFamily(\"account\");\n    bean.setAge(20);\n    bean.setEmail(\"ncanis@gmail.com\");\n    bean.setId(\"ncanis\");\n    bean.setName(\"ncanis\");\n    bean.setPassword(\"1111\");\n    insert.insert(bean);\n\n    //select 1 row\n    SelectQuery select = dbo.createSelectQuery(\"user\");\n    UserBean resultBean = (UserBean)select.select(bean.getRow(),UserBean.class);\n\n    // select column value.\n    String value = (String)select.selectColumn(bean.getRow(),\"account\",\"id\",String.class);\n\n    // search with option (QSearch has EQUAL, NOT_EQUAL, LIKE)\n    // select id,password,name,email from account where id='ncanis' limit startRow,20\n    HBaseParam param = new HBaseParam();\n    param.setPage(bean.getRow(),20);\n    param.addColumn(\"id\",\"password\",\"name\",\"email\");\n    param.addSearchOption(\"id\",\"ncanis\",QSearch.EQUAL);\n    select.search(\"account\", param, UserBean.class);\n\n    // search column value is existing.\n    boolean isExist = select.existColumnValue(\"account\",\"id\",\"ncanis\".getBytes());\n\n    // update password.\n    UpdateQuery update = dbo.createUpdateQuery(\"user\");\n    Hashtable<String, byte[]> colsTable = new Hashtable<String, byte[]>();\n    colsTable.put(\"password\",\"2222\".getBytes());\n    update.update(bean.getRow(),\"account\",colsTable);\n\n    //delete\n    DeleteQuery delete = dbo.createDeleteQuery(\"user\");\n    delete.deleteRow(resultBean.getRow());\n\n    ////////////////////////////////////\n    // etc\n\n    // HTable pool with apache commons pool\n    // borrow and release. HBasePoolManager(maxActive, minIdle etc..)\n    IndexedTable table = dbo.getPool().borrow(\"user\");\n    dbo.getPool().release(table);\n\n    // upload bigFile by hadoop directly.\n    HBaseBigFile bigFile = new HBaseBigFile();\n    File file = new File(\"doc/movie.avi\");\n    FileInputStream fis = new FileInputStream(file);\n    Path rootPath = new Path(\"/files/\");\n    String filename = \"movie.avi\";\n    bigFile.uploadFile(rootPath,filename,fis,true);\n\n    // receive file stream from hadoop.\n    Path p = new Path(rootPath,filename);\n    InputStream is = bigFile.path2Stream(p,4096);\n\n  }\n}\n```\n\n## Scala\n\n### Setting the Classpath\n\nTo use Scala with HBase, your CLASSPATH must include HBase's classpath as well as the Scala JARs required by your code. First, use the following command on a server running the HBase RegionServer process, to get HBase's classpath.\n\n```bash\n$ ps aux |grep regionserver| awk -F 'java.library.path=' {'print $2'} | awk {'print $1'}\n\n/usr/lib/hadoop/lib/native:/usr/lib/hbase/lib/native/Linux-amd64-64\n```\n\nSet the `$CLASSPATH` environment variable to include the path you found in the previous step, plus the path of `scala-library.jar` and each additional Scala-related JAR needed for your project.\n\n```bash\n$ export CLASSPATH=$CLASSPATH:/usr/lib/hadoop/lib/native:/usr/lib/hbase/lib/native/Linux-amd64-64:/path/to/scala-library.jar\n```\n\n### Scala SBT File\n\nYour `build.sbt` file needs the following `resolvers` and `libraryDependencies` to work with HBase.\n\n```scala\nresolvers += \"Apache HBase\" at \"https://repository.apache.org/content/repositories/releases\"\n\nresolvers += \"Thrift\" at \"https://people.apache.org/~rawson/repo/\"\n\nlibraryDependencies ++= Seq(\n    \"org.apache.hadoop\" % \"hadoop-core\" % \"0.20.2\",\n    \"org.apache.hbase\" % \"hbase\" % \"0.90.4\"\n)\n```\n\n### Example Scala Code\n\nThis example lists HBase tables, creates a new table, adds a row to it, and gets the value of the row.\n\n```scala\nimport org.apache.hadoop.hbase.{HBaseConfiguration, TableName}\nimport org.apache.hadoop.hbase.client.{Admin, Connection, ConnectionFactory, Get, Put}\nimport org.apache.hadoop.hbase.util.Bytes\n\nval conf = HBaseConfiguration.create()\nval connection = ConnectionFactory.createConnection(conf);\nval admin = connection.getAdmin();\n\n// list the tables\nval listtables = admin.listTables()\nlisttables.foreach(println)\n\n// let's insert some data in 'mytable' and get the row\nval table = connection.getTable(TableName.valueOf(\"mytable\"))\n\nval theput = new Put(Bytes.toBytes(\"rowkey1\"))\n\ntheput.addColumn(Bytes.toBytes(\"ids\"),Bytes.toBytes(\"id1\"),Bytes.toBytes(\"one\"))\ntable.put(theput)\n\nval theget = new Get(Bytes.toBytes(\"rowkey1\"))\nval result = table.get(theget)\nval value = result.value()\nprintln(Bytes.toString(value))\n```\n\n## Jython\n\n### Setting the Classpath\n\nTo use Jython with HBase, your CLASSPATH must include HBase's classpath as well as the Jython JARs required by your code.\n\nSet the path to directory containing the `jython.jar` and each additional Jython-related JAR needed for your project. Then export HBASE\\_CLASSPATH pointing to the \\$JYTHON\\_HOME env. variable.\n\n```bash\n$ export HBASE_CLASSPATH=/directory/jython.jar\n```\n\nStart a Jython shell with HBase and Hadoop JARs in the classpath: \\$ bin/hbase org.python.util.jython\n\n### Jython Code Examples\n\n**Example: Table Creation, Population, Get, and Delete with Jython**\\\nThe following Jython code example checks for table, if it exists, deletes it and then creates it. Then it populates the table with data and fetches the data.\n\n```python\nimport java.lang\nfrom org.apache.hadoop.hbase import HBaseConfiguration, HTableDescriptor, HColumnDescriptor, TableName\nfrom org.apache.hadoop.hbase.client import Admin, Connection, ConnectionFactory, Get, Put, Result, Table\nfrom org.apache.hadoop.conf import Configuration\n\n# First get a conf object.  This will read in the configuration\n# that is out in your hbase-*.xml files such as location of the\n# hbase master node.\nconf = HBaseConfiguration.create()\nconnection = ConnectionFactory.createConnection(conf)\nadmin = connection.getAdmin()\n\n# Create a table named 'test' that has a column family\n# named 'content'.\ntableName = TableName.valueOf(\"test\")\ntable = connection.getTable(tableName)\n\ndesc = HTableDescriptor(tableName)\ndesc.addFamily(HColumnDescriptor(\"content\"))\n\n# Drop and recreate if it exists\nif admin.tableExists(tableName):\n    admin.disableTable(tableName)\n    admin.deleteTable(tableName)\n\nadmin.createTable(desc)\n\n# Add content to 'column:' on a row named 'row_x'\nrow = 'row_x'\nput = Put(row)\nput.addColumn(\"content\", \"qual\", \"some content\")\ntable.put(put)\n\n# Now fetch the content just added, returns a byte[]\nget = Get(row)\n\nresult = table.get(get)\ndata = java.lang.String(result.getValue(\"content\", \"qual\"), \"UTF8\")\n\nprint \"The fetched row contains the value '%s'\" % data\n```\n\n**Example: Table Scan Using Jython**\\\nThis example scans a table and returns the results that match a given family qualifier.\n\n```python\nimport java.lang\nfrom org.apache.hadoop.hbase import TableName, HBaseConfiguration\nfrom org.apache.hadoop.hbase.client import Connection, ConnectionFactory, Result, ResultScanner, Table, Admin\nfrom org.apache.hadoop.conf import Configuration\nconf = HBaseConfiguration.create()\nconnection = ConnectionFactory.createConnection(conf)\nadmin = connection.getAdmin()\ntableName = TableName.valueOf('wiki')\ntable = connection.getTable(tableName)\n\ncf = \"title\"\nattr = \"attr\"\nscanner = table.getScanner(cf)\nwhile 1:\n    result = scanner.next()\n    if not result:\n       break\n    print java.lang.String(result.row), java.lang.String(result.getValue(cf, attr))\n```\n\n***\n\n# Thrift API and Filter Language\n\nYou can configure [Thrift](https://thrift.apache.org/) for secure authentication at the server and client side, by following the procedures in [Client-side Configuration for Secure Operation - Thrift Gateway](/docs/security/client-access#client-side-configuration-for-secure-operation---thrift-gateway) and [Configure the Thrift Gateway to Authenticate on Behalf of the Client](/docs/security/client-access#configure-the-thrift-gateway-to-authenticate-on-behalf-of-the-client).\n\nThe rest of this chapter discusses the filter language provided by the Thrift API.\n\n## Filter Language\n\nThrift Filter Language was introduced in HBase 0.92.\nIt allows you to perform server-side filtering when accessing HBase over Thrift or in the HBase shell.\nYou can find out more about shell integration by using the `scan help` command in the shell.\n\nYou specify a filter as a string, which is parsed on the server to construct the filter.\n\n### General Filter String Syntax\n\nA simple filter expression is expressed as a string:\n\n```text\n\"FilterName (argument, argument,... , argument)\"\n```\n\nKeep the following syntax guidelines in mind.\n\n* Specify the name of the filter followed by the comma-separated argument list in parentheses.\n* If the argument represents a string, it should be enclosed in single quotes (`'`).\n* Arguments which represent a boolean, an integer, or a comparison operator (such as `<`, `>`, or `!=`), should not be enclosed in quotes\n* The filter name must be a single word.\n  All ASCII characters are allowed except for whitespace, single quotes and parentheses.\n* The filter's arguments can contain any ASCII character.\n  If single quotes are present in the argument, they must be escaped by an additional preceding single quote.\n\n### Compound Filters and Operators\n\n#### Binary Operators\n\n**`AND`**\\\nIf the `AND` operator is used, the key-value must satisfy both filters.\n\n**`OR`**\\\nIf the `OR` operator is used, the key-value must satisfy at least one of the filters.\n\n#### Unary Operators\n\n**`SKIP`**\\\nFor a particular row, if any of the key-values fail the filter condition, the entire row is skipped.\n\n**`WHILE`**\\\nFor a particular row, key-values will be emitted until a key-value is reached that fails the filter condition.\n\n#### Compound Operators\n\nYou can combine multiple operators to create a hierarchy of filters, such as the following example:\n\n```text\n(Filter1 AND Filter2) OR (Filter3 AND Filter4)\n```\n\n### Order of Evaluation\n\n1. Parentheses have the highest precedence.\n2. The unary operators `SKIP` and `WHILE` are next, and have the same precedence.\n3. The binary operators follow. `AND` has highest precedence, followed by `OR`.\n\n#### Precedence Example\n\n```text\nFilter1 AND Filter2 OR Filter\nis evaluated as\n(Filter1 AND Filter2) OR Filter3\n```\n\n```text\nFilter1 AND SKIP Filter2 OR Filter3\nis evaluated as\n(Filter1 AND (SKIP Filter2)) OR Filter3\n```\n\nYou can use parentheses to explicitly control the order of evaluation.\n\n### Compare Operator\n\nThe following compare operators are provided:\n\n1. LESS (`<`)\n2. LESS\\_OR\\_EQUAL (`<=`)\n3. EQUAL (`=`)\n4. NOT\\_EQUAL (`!=`)\n5. GREATER\\_OR\\_EQUAL (`>=`)\n6. GREATER (`>`)\n7. NO\\_OP (no operation)\n\nThe client should use the symbols (`<`, `<=`, `=`, `!=`, `>`, `>=`) to express compare operators.\n\n### Comparator\n\nA comparator can be any of the following:\n\n1. *BinaryComparator* - This lexicographically compares against the specified byte array using Bytes.compareTo(byte\\[], byte\\[])\n2. *BinaryPrefixComparator* - This lexicographically compares against a specified byte array.\n   It only compares up to the length of this byte array.\n3. *RegexStringComparator* - This compares against the specified byte array using the given regular expression.\n   Only EQUAL and NOT\\_EQUAL comparisons are valid with this comparator\n4. *SubStringComparator* - This tests if the given substring appears in a specified byte array.\n   The comparison is case insensitive.\n   Only EQUAL and NOT\\_EQUAL comparisons are valid with this comparator\n\nThe general syntax of a comparator is: `ComparatorType:ComparatorValue`\n\nThe ComparatorType for the various comparators is as follows:\n\n1. *BinaryComparator* - binary\n2. *BinaryPrefixComparator* - binaryprefix\n3. *RegexStringComparator* - regexstring\n4. *SubStringComparator* - substring\n\nThe ComparatorValue can be any value.\n\n#### Example ComparatorValues\n\n1. `binary:abc` will match everything that is lexicographically greater than \"abc\"\n2. `binaryprefix:abc` will match everything whose first 3 characters are lexicographically equal to \"abc\"\n3. `regexstring:ab*yz` will match everything that doesn't begin with \"ab\" and ends with \"yz\"\n4. `substring:abc123` will match everything that begins with the substring \"abc123\"\n\n### Example PHP Client Program that uses the Filter Language\n\n```php\n<?\n  $_SERVER['PHP_ROOT'] = realpath(dirname(__FILE__).'/..');\n  require_once $_SERVER['PHP_ROOT'].'/flib/__flib.php';\n  flib_init(FLIB_CONTEXT_SCRIPT);\n  require_module('storage/hbase');\n  $hbase = new HBase('<server_name_running_thrift_server>', <port on which thrift server is running>);\n  $hbase->open();\n  $client = $hbase->getClient();\n  $result = $client->scannerOpenWithFilterString('table_name', \"(PrefixFilter ('row2') AND (QualifierFilter (>=, 'binary:xyz'))) AND (TimestampsFilter ( 123, 456))\");\n  $to_print = $client->scannerGetList($result,1);\n  while ($to_print) {\n    print_r($to_print);\n    $to_print = $client->scannerGetList($result,1);\n  }\n  $client->scannerClose($result);\n?>\n```\n\n### Example Filter Strings\n\n* `\"PrefixFilter ('Row') AND PageFilter (1) AND FirstKeyOnlyFilter ()\"` will return all key-value pairs that match the following conditions:\n  1. The row containing the key-value should have prefix *Row*\n  2. The key-value must be located in the first row of the table\n  3. The key-value pair must be the first key-value in the row\n* `\"(RowFilter (=, 'binary:Row 1') AND TimeStampsFilter (74689, 89734)) OR ColumnRangeFilter ('abc', true, 'xyz', false))\"` will return all key-value pairs that match both the following conditions:\n  * The key-value is in a row having row key *Row 1*\n  * The key-value must have a timestamp of either 74689 or 89734.\n  * Or it must match the following condition:\n    * The key-value pair must be in a column that is lexicographically >= abc and \\< xyz\n* `\"SKIP ValueFilter (0)\"` will skip the entire row if any of the values in the row is not 0\n\n### Individual Filter Syntax\n\n**KeyOnlyFilter**\\\nThis filter doesn't take any arguments.\nIt returns only the key component of each key-value.\n\n**FirstKeyOnlyFilter**\\\nThis filter doesn't take any arguments.\nIt returns only the first key-value from each row.\n\n**PrefixFilter**\\\nThis filter takes one argument – a prefix of a row key.\nIt returns only those key-values present in a row that starts with the specified row prefix\n\n**ColumnPrefixFilter**\\\nThis filter takes one argument – a column prefix.\nIt returns only those key-values present in a column that starts with the specified column prefix.\nThe column prefix must be of the form: `\"qualifier\"`.\n\n**MultipleColumnPrefixFilter**\\\nThis filter takes a list of column prefixes.\nIt returns key-values that are present in a column that starts with any of the specified column prefixes.\nEach of the column prefixes must be of the form: `\"qualifier\"`.\n\n**ColumnCountGetFilter**\\\nThis filter takes one argument – a limit.\nIt returns the first limit number of columns in the table.\n\n**PageFilter**\\\nThis filter takes one argument – a page size.\nIt returns page size number of rows from the table.\n\n**ColumnPaginationFilter**\\\nThis filter takes two arguments – a limit and offset.\nIt returns limit number of columns after offset number of columns.\nIt does this for all the rows.\n\n**InclusiveStopFilter**\\\nThis filter takes one argument – a row key on which to stop scanning.\nIt returns all key-values present in rows up to and including the specified row.\n\n**TimeStampsFilter**\\\nThis filter takes a list of timestamps.\nIt returns those key-values whose timestamps matches any of the specified timestamps.\n\n**RowFilter**\\\nThis filter takes a compare operator and a comparator.\nIt compares each row key with the comparator using the compare operator and if the comparison returns true, it returns all the key-values in that row.\n\n**Family Filter**\\\nThis filter takes a compare operator and a comparator.\nIt compares each column family name with the comparator using the compare operator and if the comparison returns true, it returns all the Cells in that column family.\n\n**QualifierFilter**\\\nThis filter takes a compare operator and a comparator.\nIt compares each qualifier name with the comparator using the compare operator and if the comparison returns true, it returns all the key-values in that column.\n\n**ValueFilter**\\\nThis filter takes a compare operator and a comparator.\nIt compares each value with the comparator using the compare operator and if the comparison returns true, it returns that key-value.\n\n**DependentColumnFilter**\\\nThis filter takes two arguments – a family and a qualifier.\nIt tries to locate this column in each row and returns all key-values in that row that have the same timestamp.\nIf the row doesn't contain the specified column – none of the key-values in that row will be returned.\n\n**SingleColumnValueFilter**\\\nThis filter takes a column family, a qualifier, a compare operator and a comparator.\nIf the specified column is not found – all the columns of that row will be emitted.\nIf the column is found and the comparison with the comparator returns true, all the columns of the row will be emitted.\nIf the condition fails, the row will not be emitted.\n\n**SingleColumnValueExcludeFilter**\\\nThis filter takes the same arguments and behaves same as SingleColumnValueFilter – however, if the column is found and the condition passes, all the columns of the row will be emitted except for the tested column value.\n\n**ColumnRangeFilter**\\\nThis filter is used for selecting only those keys with columns that are between minColumn and maxColumn.\nIt also takes two boolean variables to indicate whether to include the minColumn and maxColumn or not.\n\n***\n\n# HBase and Spark\n\n[Spark](https://spark.apache.org/) itself is out of scope of this document, please refer to the Spark site for\nmore information on the Spark project and subprojects. This document will focus\non 4 main interaction points between Spark and HBase. Those interaction points are:\n\n**Basic Spark**\\\nThe ability to have an HBase Connection at any point in your Spark DAG.\n\n**Spark Streaming**\\\nThe ability to have an HBase Connection at any point in your Spark Streaming\napplication.\n\n**Spark Bulk Load**\\\nThe ability to write directly to HBase HFiles for bulk insertion into HBase\n\n**SparkSQL/DataFrames**\\\nThe ability to write SparkSQL that draws on tables that are represented in HBase.\n\nThe following sections will walk through examples of all these interaction points.\n\n## Basic Spark\n\nThis section discusses Spark HBase integration at the lowest and simplest levels.\nAll the other interaction points are built upon the concepts that will be described\nhere.\n\nAt the root of all Spark and HBase integration is the HBaseContext. The HBaseContext\ntakes in HBase configurations and pushes them to the Spark executors. This allows\nus to have an HBase Connection per Spark Executor in a static location.\n\nFor reference, Spark Executors can be on the same nodes as the Region Servers or\non different nodes, there is no dependence on co-location. Think of every Spark\nExecutor as a multi-threaded client application. This allows any Spark Tasks\nrunning on the executors to access the shared Connection object.\n\n### HBaseContext Usage Example\n\nThis example shows how HBaseContext can be used to do a `foreachPartition` on a RDD\nin Scala:\n\n```scala\nval sc = new SparkContext(\"local\", \"test\")\nval config = new HBaseConfiguration()\n\n...\n\nval hbaseContext = new HBaseContext(sc, config)\n\nrdd.hbaseForeachPartition(hbaseContext, (it, conn) => {\n val bufferedMutator = conn.getBufferedMutator(TableName.valueOf(\"t1\"))\n it.foreach((putRecord) => {\n. val put = new Put(putRecord._1)\n. putRecord._2.foreach((putValue) => put.addColumn(putValue._1, putValue._2, putValue._3))\n. bufferedMutator.mutate(put)\n })\n bufferedMutator.flush()\n bufferedMutator.close()\n})\n```\n\nHere is the same example implemented in Java:\n\n```java\nJavaSparkContext jsc = new JavaSparkContext(sparkConf);\n\ntry {\n  List<byte[]> list = new ArrayList<>();\n  list.add(Bytes.toBytes(\"1\"));\n  ...\n  list.add(Bytes.toBytes(\"5\"));\n\n  JavaRDD<byte[]> rdd = jsc.parallelize(list);\n  Configuration conf = HBaseConfiguration.create();\n\n  JavaHBaseContext hbaseContext = new JavaHBaseContext(jsc, conf);\n\n  hbaseContext.foreachPartition(rdd,\n      new VoidFunction<Tuple2<Iterator<byte[]>, Connection>>() {\n   public void call(Tuple2<Iterator<byte[]>, Connection> t)\n        throws Exception {\n    Table table = t._2().getTable(TableName.valueOf(tableName));\n    BufferedMutator mutator = t._2().getBufferedMutator(TableName.valueOf(tableName));\n    while (t._1().hasNext()) {\n      byte[] b = t._1().next();\n      Result r = table.get(new Get(b));\n      if (r.getExists()) {\n       mutator.mutate(new Put(b));\n      }\n    }\n\n    mutator.flush();\n    mutator.close();\n    table.close();\n   }\n  });\n} finally {\n  jsc.stop();\n}\n```\n\nAll functionality between Spark and HBase will be supported both in Scala and in\nJava, with the exception of SparkSQL which will support any language that is\nsupported by Spark. For the remaining of this documentation we will focus on\nScala examples.\n\nThe examples above illustrate how to do a foreachPartition with a connection. A\nnumber of other Spark base functions are supported out of the box:\n\n**`bulkPut`**\\\nFor massively parallel sending of puts to HBase\n\n**`bulkDelete`**\\\nFor massively parallel sending of deletes to HBase\n\n**`bulkGet`**\\\nFor massively parallel sending of gets to HBase to create a new RDD\n\n**`mapPartition`**\\\nTo do a Spark Map function with a Connection object to allow full\naccess to HBase\n\n**`hbaseRDD`**\\\nTo simplify a distributed scan to create a RDD\n\nFor examples of all these functionalities, see the\n[hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\nin the [hbase-connectors](https://github.com/apache/hbase-connectors) repository\n(the hbase-spark connectors live outside hbase core in a related,\nApache HBase project maintained, associated repo).\n\n## Spark Streaming\n\n[Spark Streaming](https://spark.apache.org/streaming/) is a micro batching stream\nprocessing framework built on top of Spark. HBase and Spark Streaming make great\ncompanions in that HBase can help serve the following benefits alongside Spark\nStreaming.\n\n* A place to grab reference data or profile data on the fly\n* A place to store counts or aggregates in a way that supports Spark Streaming's\n  promise of *only once processing*.\n\nThe [hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\nwith Spark Streaming is similar to its normal Spark integration points, in that the following\ncommands are possible straight off a Spark Streaming DStream.\n\n**`bulkPut`**\\\nFor massively parallel sending of puts to HBase\n\n**`bulkDelete`**\\\nFor massively parallel sending of deletes to HBase\n\n**`bulkGet`**\\\nFor massively parallel sending of gets to HBase to create a new RDD\n\n**`mapPartition`**\\\nTo do a Spark Map function with a Connection object to allow full\naccess to HBase\n\n**`hbaseRDD`**\\\nTo simplify a distributed scan to create a RDD\n\n### `bulkPut` Example with DStreams\n\nBelow is an example of bulkPut with DStreams. It is very close in feel to the RDD\nbulk put.\n\n```scala\nval sc = new SparkContext(\"local\", \"test\")\nval config = new HBaseConfiguration()\n\nval hbaseContext = new HBaseContext(sc, config)\nval ssc = new StreamingContext(sc, Milliseconds(200))\n\nval rdd1 = ...\nval rdd2 = ...\n\nval queue = mutable.Queue[RDD[(Array[Byte], Array[(Array[Byte],\n    Array[Byte], Array[Byte])])]]()\n\nqueue += rdd1\nqueue += rdd2\n\nval dStream = ssc.queueStream(queue)\n\ndStream.hbaseBulkPut(\n  hbaseContext,\n  TableName.valueOf(tableName),\n  (putRecord) => {\n   val put = new Put(putRecord._1)\n   putRecord._2.foreach((putValue) => put.addColumn(putValue._1, putValue._2, putValue._3))\n   put\n  })\n```\n\nThere are three inputs to the `hbaseBulkPut` function.\nThe hbaseContext that carries the configuration broadcast information link\nto the HBase Connections in the executor, the table name of the table we are\nputting data into, and a function that will convert a record in the DStream\ninto an HBase Put object.\n\n## Bulk Load\n\nThere are two options for bulk loading data into HBase with Spark. There is the\nbasic bulk load functionality that will work for cases where your rows have\nmillions of columns and cases where your columns are not consolidated and\npartitioned before the map side of the Spark bulk load process.\n\nThere is also a thin record bulk load option with Spark. This second option is\ndesigned for tables that have less then 10k columns per row. The advantage\nof this second option is higher throughput and less over-all load on the Spark\nshuffle operation.\n\nBoth implementations work more or less like the MapReduce bulk load process in\nthat a partitioner partitions the rowkeys based on region splits and\nthe row keys are sent to the reducers in order, so that HFiles can be written\nout directly from the reduce phase.\n\nIn Spark terms, the bulk load will be implemented around a Spark\n`repartitionAndSortWithinPartitions` followed by a Spark `foreachPartition`.\n\nFirst lets look at an example of using the basic bulk load functionality\n\n### Bulk Loading Example\n\nThe following example shows bulk loading with Spark.\n\n```scala\nval sc = new SparkContext(\"local\", \"test\")\nval config = new HBaseConfiguration()\n\nval hbaseContext = new HBaseContext(sc, config)\n\nval stagingFolder = ...\nval rdd = sc.parallelize(Array(\n      (Bytes.toBytes(\"1\"),\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"a\"), Bytes.toBytes(\"foo1\"))),\n      (Bytes.toBytes(\"3\"),\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"b\"), Bytes.toBytes(\"foo2.b\"))), ...\n\nrdd.hbaseBulkLoad(TableName.valueOf(tableName),\n  t => {\n   val rowKey = t._1\n   val family:Array[Byte] = t._2(0)._1\n   val qualifier = t._2(0)._2\n   val value = t._2(0)._3\n\n   val keyFamilyQualifier= new KeyFamilyQualifier(rowKey, family, qualifier)\n\n   Seq((keyFamilyQualifier, value)).iterator\n  },\n  stagingFolder.getPath)\n\nval load = new LoadIncrementalHFiles(config)\nload.doBulkLoad(new Path(stagingFolder.getPath),\n  conn.getAdmin, table, conn.getRegionLocator(TableName.valueOf(tableName)))\n```\n\nThe `hbaseBulkLoad` function takes three required parameters:\n\n1. The table name of the table we intend to bulk load too\n2. A function that will convert a record in the RDD to a tuple key value par. With\n   the tuple key being a KeyFamilyQualifer object and the value being the cell value.\n   The KeyFamilyQualifer object will hold the RowKey, Column Family, and Column Qualifier.\n   The shuffle will partition on the RowKey but will sort by all three values.\n3. The temporary path for the HFile to be written out too\n\nFollowing the Spark bulk load command, use the HBase's LoadIncrementalHFiles object\nto load the newly created HFiles into HBase.\n\n### Additional Parameters for Bulk Loading with Spark\n\nYou can set the following attributes with additional parameter options on hbaseBulkLoad.\n\n* Max file size of the HFiles\n* A flag to exclude HFiles from compactions\n* Column Family settings for compression, bloomType, blockSize, and dataBlockEncoding\n\n### Using Additional Parameters\n\n```scala\nval sc = new SparkContext(\"local\", \"test\")\nval config = new HBaseConfiguration()\n\nval hbaseContext = new HBaseContext(sc, config)\n\nval stagingFolder = ...\nval rdd = sc.parallelize(Array(\n      (Bytes.toBytes(\"1\"),\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"a\"), Bytes.toBytes(\"foo1\"))),\n      (Bytes.toBytes(\"3\"),\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"b\"), Bytes.toBytes(\"foo2.b\"))), ...\n\nval familyHBaseWriterOptions = new java.util.HashMap[Array[Byte], FamilyHFileWriteOptions]\nval f1Options = new FamilyHFileWriteOptions(\"GZ\", \"ROW\", 128, \"PREFIX\")\n\nfamilyHBaseWriterOptions.put(Bytes.toBytes(\"columnFamily1\"), f1Options)\n\nrdd.hbaseBulkLoad(TableName.valueOf(tableName),\n  t => {\n   val rowKey = t._1\n   val family:Array[Byte] = t._2(0)._1\n   val qualifier = t._2(0)._2\n   val value = t._2(0)._3\n\n   val keyFamilyQualifier= new KeyFamilyQualifier(rowKey, family, qualifier)\n\n   Seq((keyFamilyQualifier, value)).iterator\n  },\n  stagingFolder.getPath,\n  familyHBaseWriterOptions,\n  compactionExclude = false,\n  HConstants.DEFAULT_MAX_FILE_SIZE)\n\nval load = new LoadIncrementalHFiles(config)\nload.doBulkLoad(new Path(stagingFolder.getPath),\n  conn.getAdmin, table, conn.getRegionLocator(TableName.valueOf(tableName)))\n```\n\nNow lets look at how you would call the thin record bulk load implementation\n\n### Using thin record bulk load\n\n```scala\nval sc = new SparkContext(\"local\", \"test\")\nval config = new HBaseConfiguration()\n\nval hbaseContext = new HBaseContext(sc, config)\n\nval stagingFolder = ...\nval rdd = sc.parallelize(Array(\n      (\"1\",\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"a\"), Bytes.toBytes(\"foo1\"))),\n      (\"3\",\n        (Bytes.toBytes(columnFamily1), Bytes.toBytes(\"b\"), Bytes.toBytes(\"foo2.b\"))), ...\n\nrdd.hbaseBulkLoadThinRows(hbaseContext,\n      TableName.valueOf(tableName),\n      t => {\n        val rowKey = t._1\n\n        val familyQualifiersValues = new FamiliesQualifiersValues\n        t._2.foreach(f => {\n          val family:Array[Byte] = f._1\n          val qualifier = f._2\n          val value:Array[Byte] = f._3\n\n          familyQualifiersValues +=(family, qualifier, value)\n        })\n        (new ByteArrayWrapper(Bytes.toBytes(rowKey)), familyQualifiersValues)\n      },\n      stagingFolder.getPath,\n      new java.util.HashMap[Array[Byte], FamilyHFileWriteOptions],\n      compactionExclude = false,\n      20)\n\nval load = new LoadIncrementalHFiles(config)\nload.doBulkLoad(new Path(stagingFolder.getPath),\n  conn.getAdmin, table, conn.getRegionLocator(TableName.valueOf(tableName)))\n```\n\nNote that the big difference in using bulk load for thin rows is the function\nreturns a tuple with the first value being the row key and the second value\nbeing an object of FamiliesQualifiersValues, which will contain all the\nvalues for this row for all column families.\n\n## SparkSQL/DataFrames\n\nThe [hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\nleverages\n[DataSource API](https://databricks.com/blog/2015/01/09/spark-sql-data-sources-api-unified-data-access-for-the-spark-platform.html)\n([SPARK-3247](https://issues.apache.org/jira/browse/SPARK-3247))\nintroduced in Spark-1.2.0, which bridges the gap between simple HBase KV store and complex\nrelational SQL queries and enables users to perform complex data analytical work\non top of HBase using Spark. HBase Dataframe is a standard Spark Dataframe, and is able to\ninteract with any other data sources such as Hive, Orc, Parquet, JSON, etc.\nThe [hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\napplies critical techniques such as partition pruning, column pruning,\npredicate pushdown and data locality.\n\nTo use the\n[hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\nconnector, users need to define the Catalog for the schema mapping\nbetween HBase and Spark tables, prepare the data and populate the HBase table,\nthen load the HBase DataFrame. After that, users can do integrated query and access records\nin HBase tables with SQL query. The following illustrates the basic procedure.\n\n### Define catalog\n\n```scala\ndef catalog = s\"\"\"{\n       |\"table\":{\"namespace\":\"default\", \"name\":\"table1\"},\n       |\"rowkey\":\"key\",\n       |\"columns\":{\n         |\"col0\":{\"cf\":\"rowkey\", \"col\":\"key\", \"type\":\"string\"},\n         |\"col1\":{\"cf\":\"cf1\", \"col\":\"col1\", \"type\":\"boolean\"},\n         |\"col2\":{\"cf\":\"cf2\", \"col\":\"col2\", \"type\":\"double\"},\n         |\"col3\":{\"cf\":\"cf3\", \"col\":\"col3\", \"type\":\"float\"},\n         |\"col4\":{\"cf\":\"cf4\", \"col\":\"col4\", \"type\":\"int\"},\n         |\"col5\":{\"cf\":\"cf5\", \"col\":\"col5\", \"type\":\"bigint\"},\n         |\"col6\":{\"cf\":\"cf6\", \"col\":\"col6\", \"type\":\"smallint\"},\n         |\"col7\":{\"cf\":\"cf7\", \"col\":\"col7\", \"type\":\"string\"},\n         |\"col8\":{\"cf\":\"cf8\", \"col\":\"col8\", \"type\":\"tinyint\"}\n       |}\n     |}\"\"\".stripMargin\n```\n\nCatalog defines a mapping between HBase and Spark tables. There are two critical parts of this catalog.\nOne is the rowkey definition and the other is the mapping between table column in Spark and\nthe column family and column qualifier in HBase. The above defines a schema for a HBase table\nwith name as table1, row key as key and a number of columns (col1 `-` col8). Note that the rowkey\nalso has to be defined in details as a column (col0), which has a specific cf (rowkey).\n\n### Save the DataFrame\n\n```scala\ncase class HBaseRecord(\n   col0: String,\n   col1: Boolean,\n   col2: Double,\n   col3: Float,\n   col4: Int,\n   col5: Long,\n   col6: Short,\n   col7: String,\n   col8: Byte)\n\nobject HBaseRecord\n{\n   def apply(i: Int, t: String): HBaseRecord = {\n      val s = s\"\"\"row${\"%03d\".format(i)}\"\"\"\n      HBaseRecord(s,\n      i % 2 == 0,\n      i.toDouble,\n      i.toFloat,\n      i,\n      i.toLong,\n      i.toShort,\n      s\"String$i: $t\",\n      i.toByte)\n  }\n}\n\nval data = (0 to 255).map { i =>  HBaseRecord(i, \"extra\")}\n\nsc.parallelize(data).toDF.write.options(\n Map(HBaseTableCatalog.tableCatalog -> catalog, HBaseTableCatalog.newTable -> \"5\"))\n .format(\"org.apache.hadoop.hbase.spark \")\n .save()\n```\n\n`data` prepared by the user is a local Scala collection which has 256 HBaseRecord objects.\n`sc.parallelize(data)` function distributes `data` to form an RDD. `toDF` returns a DataFrame.\n`write` function returns a DataFrameWriter used to write the DataFrame to external storage\nsystems (e.g. HBase here). Given a DataFrame with specified schema `catalog`, `save` function\nwill create an HBase table with 5 regions and save the DataFrame inside.\n\n### Load the DataFrame\n\n```scala\ndef withCatalog(cat: String): DataFrame = {\n  sqlContext\n  .read\n  .options(Map(HBaseTableCatalog.tableCatalog->cat))\n  .format(\"org.apache.hadoop.hbase.spark\")\n  .load()\n}\nval df = withCatalog(catalog)\n```\n\nIn 'withCatalog' function, sqlContext is a variable of SQLContext, which is the entry point\nfor working with structured data (rows and columns) in Spark.\n`read` returns a DataFrameReader that can be used to read data in as a DataFrame.\n`option` function adds input options for the underlying data source to the DataFrameReader,\nand `format` function specifies the input data source format for the DataFrameReader.\nThe `load()` function loads input in as a DataFrame. The date frame `df` returned\nby `withCatalog` function could be used to access HBase table, such as 4.4 and 4.5.\n\n### Language Integrated Query\n\n```scala\nval s = df.filter(($\"col0\" <= \"row050\" && $\"col0\" > \"row040\") ||\n  $\"col0\" === \"row005\" ||\n  $\"col0\" <= \"row005\")\n  .select(\"col0\", \"col1\", \"col4\")\ns.show\n```\n\nDataFrame can do various operations, such as join, sort, select, filter, orderBy and so on.\n`df.filter` above filters rows using the given SQL expression. `select` selects a set of columns:\n`col0`, `col1` and `col4`.\n\n### SQL Query\n\n```scala\ndf.registerTempTable(\"table1\")\nsqlContext.sql(\"select count(col1) from table1\").show\n```\n\n`registerTempTable` registers `df` DataFrame as a temporary table using the table name `table1`.\nThe lifetime of this temporary table is tied to the SQLContext that was used to create `df`.\n`sqlContext.sql` function allows the user to execute SQL queries.\n\n### Others\n\n#### Query with different timestamps\n\nIn HBaseSparkConf, four parameters related to timestamp can be set. They are TIMESTAMP,\nMIN\\_TIMESTAMP, MAX\\_TIMESTAMP and MAX\\_VERSIONS respectively. Users can query records with\ndifferent timestamps or time ranges with MIN\\_TIMESTAMP and MAX\\_TIMESTAMP. In the meantime,\nuse concrete value instead of tsSpecified and oldMs in the examples below.\n\nThe example below shows how to load df DataFrame with different timestamps.\ntsSpecified is specified by the user.\nHBaseTableCatalog defines the HBase and Relation relation schema.\nwriteCatalog defines catalog for the schema mapping.\n\n```scala\nval df = sqlContext.read\n      .options(Map(HBaseTableCatalog.tableCatalog -> writeCatalog, HBaseSparkConf.TIMESTAMP -> tsSpecified.toString))\n      .format(\"org.apache.hadoop.hbase.spark\")\n      .load()\n```\n\nThe example below shows how to load df DataFrame with different time ranges.\noldMs is specified by the user.\n\n```scala\nval df = sqlContext.read\n      .options(Map(HBaseTableCatalog.tableCatalog -> writeCatalog, HBaseSparkConf.MIN_TIMESTAMP -> \"0\",\n        HBaseSparkConf.MAX_TIMESTAMP -> oldMs.toString))\n      .format(\"org.apache.hadoop.hbase.spark\")\n      .load()\n```\n\nAfter loading df DataFrame, users can query data.\n\n```scala\ndf.registerTempTable(\"table\")\nsqlContext.sql(\"select count(col1) from table\").show\n```\n\n#### Native Avro support\n\nThe [hbase-spark integration](https://github.com/apache/hbase-connectors/tree/master/spark)\nconnector supports different data formats like Avro, JSON, etc. The use case below\nshows how spark supports Avro. Users can persist the Avro record into HBase directly. Internally,\nthe Avro schema is converted to a native Spark Catalyst data type automatically.\nNote that both key-value parts in an HBase table can be defined in Avro format.\n\n1. Define catalog for the schema mapping:\n\n   ```scala\n   def catalog = s\"\"\"{\n                       |\"table\":{\"namespace\":\"default\", \"name\":\"Avrotable\"},\n                         |\"rowkey\":\"key\",\n                         |\"columns\":{\n                         |\"col0\":{\"cf\":\"rowkey\", \"col\":\"key\", \"type\":\"string\"},\n                         |\"col1\":{\"cf\":\"cf1\", \"col\":\"col1\", \"type\":\"binary\"}\n                         |}\n                         |}\"\"\".stripMargin\n   ```\n\n   `catalog` is a schema for a HBase table named `Avrotable`. row key as key and\n   one column col1. The rowkey also has to be defined in details as a column (col0),\n   which has a specific cf (rowkey).\n\n2. Prepare the Data:\n\n   ```scala\n   object AvroHBaseRecord {\n     val schemaString =\n       s\"\"\"{\"namespace\": \"example.avro\",\n           |   \"type\": \"record\",      \"name\": \"User\",\n           |    \"fields\": [\n           |        {\"name\": \"name\", \"type\": \"string\"},\n           |        {\"name\": \"favorite_number\",  \"type\": [\"int\", \"null\"]},\n           |        {\"name\": \"favorite_color\", \"type\": [\"string\", \"null\"]},\n           |        {\"name\": \"favorite_array\", \"type\": {\"type\": \"array\", \"items\": \"string\"}},\n           |        {\"name\": \"favorite_map\", \"type\": {\"type\": \"map\", \"values\": \"int\"}}\n           |      ]    }\"\"\".stripMargin\n\n     val avroSchema: Schema = {\n       val p = new Schema.Parser\n       p.parse(schemaString)\n     }\n\n     def apply(i: Int): AvroHBaseRecord = {\n       val user = new GenericData.Record(avroSchema);\n       user.put(\"name\", s\"name${\"%03d\".format(i)}\")\n       user.put(\"favorite_number\", i)\n       user.put(\"favorite_color\", s\"color${\"%03d\".format(i)}\")\n       val favoriteArray = new GenericData.Array[String](2, avroSchema.getField(\"favorite_array\").schema())\n       favoriteArray.add(s\"number${i}\")\n       favoriteArray.add(s\"number${i+1}\")\n       user.put(\"favorite_array\", favoriteArray)\n       import collection.JavaConverters._\n       val favoriteMap = Map[String, Int]((\"key1\" -> i), (\"key2\" -> (i+1))).asJava\n       user.put(\"favorite_map\", favoriteMap)\n       val avroByte = AvroSedes.serialize(user, avroSchema)\n       AvroHBaseRecord(s\"name${\"%03d\".format(i)}\", avroByte)\n     }\n   }\n\n   val data = (0 to 255).map { i =>\n       AvroHBaseRecord(i)\n   }\n   ```\n\n   `schemaString` is defined first, then it is parsed to get `avroSchema`. `avroSchema` is used to\n   generate `AvroHBaseRecord`. `data` prepared by users is a local Scala collection\n   which has 256 `AvroHBaseRecord` objects.\n\n3. Save DataFrame:\n\n   ```scala\n   sc.parallelize(data).toDF.write.options(\n       Map(HBaseTableCatalog.tableCatalog -> catalog, HBaseTableCatalog.newTable -> \"5\"))\n       .format(\"org.apache.spark.sql.execution.datasources.hbase\")\n       .save()\n   ```\n\n   Given a data frame with specified schema `catalog`, above will create an HBase table with 5\n   regions and save the data frame inside.\n\n4. Load the DataFrame\n\n   ```scala\n   def avroCatalog = s\"\"\"{\n               |\"table\":{\"namespace\":\"default\", \"name\":\"avrotable\"},\n               |\"rowkey\":\"key\",\n               |\"columns\":{\n                 |\"col0\":{\"cf\":\"rowkey\", \"col\":\"key\", \"type\":\"string\"},\n                 |\"col1\":{\"cf\":\"cf1\", \"col\":\"col1\", \"avro\":\"avroSchema\"}\n               |}\n             |}\"\"\".stripMargin\n\n   def withCatalog(cat: String): DataFrame = {\n       sqlContext\n           .read\n           .options(Map(\"avroSchema\" -> AvroHBaseRecord.schemaString, HBaseTableCatalog.tableCatalog -> avroCatalog))\n           .format(\"org.apache.spark.sql.execution.datasources.hbase\")\n           .load()\n   }\n   val df = withCatalog(catalog)\n   ```\n\n   In `withCatalog` function, `read` returns a DataFrameReader that can be used to read data in as a DataFrame.\n   The `option` function adds input options for the underlying data source to the DataFrameReader.\n   There are two options: one is to set `avroSchema` as `AvroHBaseRecord.schemaString`, and one is to\n   set `HBaseTableCatalog.tableCatalog` as `avroCatalog`. The `load()` function loads input in as a DataFrame.\n   The date frame `df` returned by `withCatalog` function could be used to access the HBase table.\n\n5. SQL Query\n\n   ```scala\n   df.registerTempTable(\"avrotable\")\n   val c = sqlContext.sql(\"select count(1) from avrotable\").\n   ```\n\n   After loading df DataFrame, users can query data. registerTempTable registers df DataFrame\n   as a temporary table using the table name avrotable. `sqlContext.sql` function allows the\n   user to execute SQL queries.\n\n***\n\n# Apache HBase Coprocessors\n\nHBase Coprocessors are modeled after Google BigTable's coprocessor implementation\n([http://research.google.com/people/jeff/SOCC2010-keynote-slides.pdf](http://research.google.com/people/jeff/SOCC2010-keynote-slides.pdf) pages 41-42.).\nEfforts are ongoing to bridge gaps between HBase's\nimplementation and BigTable's architecture. For more information see\n[HBASE-4047](https://issues.apache.org/jira/browse/HBASE-4047).\n\nThe information in this chapter is primarily sourced and heavily reused from the following\nresources:\n\n1. Mingjie Lai's blog post\n   [Coprocessor Introduction](https://blogs.apache.org/hbase/entry/coprocessor_introduction).\n2. Gaurav Bhardwaj's blog post\n   [The How To Of HBase Coprocessors](http://www.3pillarglobal.com/insights/hbase-coprocessors).\n\n<Callout type=\"warn\" title=\"Use Coprocessors At Your Own Risk\">\n  Coprocessors are an advanced feature of HBase and are intended to be used by system\n  developers only. Because coprocessor code runs directly on the RegionServer and has\n  direct access to your data, they introduce the risk of data corruption, man-in-the-middle\n  attacks, or other malicious data access. Currently, there is no mechanism to prevent\n  data corruption by coprocessors, though work is underway on\n  [HBASE-4047](https://issues.apache.org/jira/browse/HBASE-4047).\n\n  In addition, there is no resource isolation, so a well-intentioned but misbehaving\n  coprocessor can severely degrade cluster performance and stability.\n</Callout>\n\n## Coprocessor Overview\n\nIn HBase, you fetch data using a `Get` or `Scan`, whereas in an RDBMS you use a SQL\nquery. In order to fetch only the relevant data, you filter it using a HBase\n[Filter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/Filter.html)\n, whereas in an RDBMS you use a `WHERE` predicate.\n\nAfter fetching the data, you perform computations on it. This paradigm works well\nfor \"small data\" with a few thousand rows and several columns. However, when you scale\nto billions of rows and millions of columns, moving large amounts of data across your\nnetwork will create bottlenecks at the network layer, and the client needs to be powerful\nenough and have enough memory to handle the large amounts of data and the computations.\nIn addition, the client code can grow large and complex.\n\nIn this scenario, coprocessors might make sense. You can put the business computation\ncode into a coprocessor which runs on the RegionServer, in the same location as the\ndata, and returns the result to the client.\n\nThis is only one scenario where using coprocessors can provide benefit. Following\nare some analogies which may help to explain some of the benefits of coprocessors.\n\n### Coprocessor Analogies\n\n**Triggers and Stored Procedure**\\\nAn Observer coprocessor is similar to a trigger in a RDBMS in that it executes\nyour code either before or after a specific event (such as a `Get` or `Put`)\noccurs. An endpoint coprocessor is similar to a stored procedure in a RDBMS\nbecause it allows you to perform custom computations on the data on the\nRegionServer itself, rather than on the client.\n\n**MapReduce**\\\nMapReduce operates on the principle of moving the computation to the location of\nthe data. Coprocessors operate on the same principal.\n\n**AOP**\\\nIf you are familiar with Aspect Oriented Programming (AOP), you can think of a coprocessor\nas applying advice by intercepting a request and then running some custom code,\nbefore passing the request on to its final destination (or even changing the destination).\n\n### Coprocessor Implementation Overview\n\n1. Your class should implement one of the Coprocessor interfaces -\n   [Coprocessor](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/Coprocessor.html),\n   [RegionObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html),\n   [CoprocessorService](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/CoprocessorService.html) - to name a few.\n2. Load the coprocessor, either statically (from the configuration) or dynamically,\n   using HBase Shell. For more details see [Loading Coprocessors](/docs/cp#loading-coprocessors).\n3. Call the coprocessor from your client-side code. HBase handles the coprocessor\n   transparently.\n\nThe framework API is provided in the\n[coprocessor](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/package-summary.html)\npackage.\n\n## Types of Coprocessors\n\n### Observer Coprocessors\n\nObserver coprocessors are triggered either before or after a specific event occurs.\nObservers that happen before an event use methods that start with a `pre` prefix,\nsuch as [`prePut`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html#prePut\\(org.apache.hadoop.hbase.coprocessor.ObserverContext,org.apache.hadoop.hbase.client.Put,org.apache.hadoop.hbase.wal.WALEdit\\)). Observers that happen just after an event override methods that start\nwith a `post` prefix, such as [`postPut`](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html#postPut\\(org.apache.hadoop.hbase.coprocessor.ObserverContext,org.apache.hadoop.hbase.client.Put,org.apache.hadoop.hbase.wal.WALEdit\\)).\n\n#### Use Cases for Observer Coprocessors\n\n**Security**\\\nBefore performing a `Get` or `Put` operation, you can check for permission using\n`preGet` or `prePut` methods.\n\n**Referential Integrity**\\\nHBase does not directly support the RDBMS concept of refential integrity, also known\nas foreign keys. You can use a coprocessor to enforce such integrity. For instance,\nif you have a business rule that every insert to the `users` table must be followed\nby a corresponding entry in the `user_daily_attendance` table, you could implement\na coprocessor to use the `prePut` method on `user` to insert a record into `user_daily_attendance`.\n\n**Secondary Indexes**\\\nYou can use a coprocessor to maintain secondary indexes. For more information, see\n[SecondaryIndexing](https://cwiki.apache.org/confluence/display/HADOOP2/Hbase+SecondaryIndexing).\n\n#### Types of Observer Coprocessor\n\n**RegionObserver**\\\nA RegionObserver coprocessor allows you to observe events on a region, such as `Get`\nand `Put` operations. See\n[RegionObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html).\n\n**RegionServerObserver**\\\nA RegionServerObserver allows you to observe events related to the RegionServer's\noperation, such as starting, stopping, or performing merges, commits, or rollbacks.\nSee\n[RegionServerObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionServerObserver.html).\n\n**MasterObserver**\\\nA MasterObserver allows you to observe events related to the HBase Master, such\nas table creation, deletion, or schema modification. See\n[MasterObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/MasterObserver.html).\n\n**WalObserver**\\\nA WalObserver allows you to observe events related to writes to the Write-Ahead\nLog (WAL). See\n[WALObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/WALObserver.html).\n\n[Examples](/docs/cp#cp-examples) provides working examples of observer coprocessors.\n\n### Endpoint Coprocessor\n\nEndpoint processors allow you to perform computation at the location of the data.\nSee [Coprocessor Analogy](/docs/cp#coprocessor-analogies). An example is the need to calculate a running\naverage or summation for an entire table which spans hundreds of regions.\n\nIn contrast to observer coprocessors, where your code is run transparently, endpoint\ncoprocessors must be explicitly invoked using the\n[CoprocessorService()](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/AsyncTable.html#coprocessorService\\(java.util.function.Function,org.apache.hadoop.hbase.client.ServiceCaller,byte%5B%5D\\))\nmethod available in\n[AsyncTable](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/AsyncTable.html).\n\n<Callout type=\"warn\" title=\"On using coprocessorService method with sync client\">\n  The coprocessorService method in [Table](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html)\n  has been deprecated.\n\n  In [HBASE-21512](https://issues.apache.org/jira/browse/HBASE-21512)\n  we reimplement the sync client based on the async client. The coprocessorService\n  method defined in `Table` interface directly references a method from protobuf's\n  `BlockingInterface`, which means we need to use a separate thread pool to execute\n  the method so we avoid blocking the async client(We want to avoid blocking calls in\n  our async implementation).\n\n  Since coprocessor is an advanced feature, we believe it is OK for coprocessor users to\n  instead switch over to use `AsyncTable`. There is a lightweight\n  [toAsyncConnection](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Connection.html#toAsyncConnection\\(\\))\n  method to get an `AsyncConnection` from `Connection` if needed.\n</Callout>\n\nStarting with HBase 0.96, endpoint coprocessors are implemented using Google Protocol\nBuffers (protobuf). For more details on protobuf, see Google's\n[Protocol Buffer Guide](https://developers.google.com/protocol-buffers/docs/proto).\nEndpoints Coprocessor written in version 0.94 are not compatible with version 0.96 or later.\nSee\n[HBASE-5448](https://issues.apache.org/jira/browse/HBASE-5448)). To upgrade your\nHBase cluster from 0.94 or earlier to 0.96 or later, you need to reimplement your\ncoprocessor.\n\nIn HBase 2.x, we made use of a shaded version of protobuf 3.x, but kept the\nprotobuf for coprocessors on 2.5.0. In HBase 3.0.0, we removed all dependencies on\nnon-shaded protobuf so you need to reimplement your coprocessor to make use of the\nshaded protobuf version provided in hbase-thirdparty. Please see\nthe [protobuf](/docs/protobuf) section for more details.\n\nCoprocessor Endpoints should make no use of HBase internals and\nonly avail of public APIs; ideally a CPEP should depend on Interfaces\nand data structures only. This is not always possible but beware\nthat doing so makes the Endpoint brittle, liable to breakage as HBase\ninternals evolve. HBase internal APIs annotated as private or evolving\ndo not have to respect semantic versioning rules or general java rules on\ndeprecation before removal. While generated protobuf files are\nabsent the hbase audience annotations — they are created by the\nprotobuf protoc tool which knows nothing of how HBase works —\nthey should be consided `@InterfaceAudience.Private` so are liable to\nchange.\n\n[Examples](/docs/cp#cp-examples) provides working examples of endpoint coprocessors.\n\n## Loading Coprocessors\n\nTo make your coprocessor available to HBase, it must be *loaded*, either statically\n(through the HBase configuration) or dynamically (using HBase Shell or the Java API).\n\n### Static Loading\n\nFollow these steps to statically load your coprocessor. Keep in mind that you must\nrestart HBase to unload a coprocessor that has been loaded statically.\n\n1. Define the Coprocessor in *hbase-site.xml*, with a `<property>` element with a `<name>`\n   and a `<value>` sub-element. The `<name>` should be one of the following:\n\n   * `hbase.coprocessor.region.classes` for RegionObservers and Endpoints.\n   * `hbase.coprocessor.wal.classes` for WALObservers.\n   * `hbase.coprocessor.master.classes` for MasterObservers.\n\n     `<value>` must contain the fully-qualified class name of your coprocessor's implementation\n     class.\n\n     For example to load a Coprocessor (implemented in class SumEndPoint.java) you have to create\n     following entry in RegionServer's 'hbase-site.xml' file (generally located under 'conf' directory):\n\n     ```xml\n     <property>\n         <name>hbase.coprocessor.region.classes</name>\n         <value>org.myname.hbase.coprocessor.endpoint.SumEndPoint</value>\n     </property>\n     ```\n\n     If multiple classes are specified for loading, the class names must be comma-separated.\n     The framework attempts to load all the configured classes using the default class loader.\n     Therefore, the jar file must reside on the server-side HBase classpath.\n\n     Coprocessors which are loaded in this way will be active on all regions of all tables.\n     These are also called system Coprocessor.\n     The first listed Coprocessors will be assigned the priority `Coprocessor.Priority.SYSTEM`.\n     Each subsequent coprocessor in the list will have its priority value incremented by one (which\n     reduces its priority, because priorities have the natural sort order of Integers).\n\n     These priority values can be manually overriden in hbase-site.xml. This can be useful if you\n     want to guarantee that a coprocessor will execute after another. For example, in the following\n     configuration `SumEndPoint` would be guaranteed to go last, except in the case of a tie with\n     another coprocessor:\n\n     ```xml\n     <property>\n         <name>hbase.coprocessor.region.classes</name>\n         <value>org.myname.hbase.coprocessor.endpoint.SumEndPoint|2147483647</value>\n     </property>\n     ```\n\n   When calling out to registered observers, the framework executes their callbacks methods in the\n   sorted order of their priority.\n   Ties are broken arbitrarily.\n\n2. Put your code on HBase's classpath. One easy way to do this is to drop the jar\n   (containing you code and all the dependencies) into the `lib/` directory in the\n   HBase installation.\n\n3. Restart HBase.\n\n### Static Unloading\n\n1. Delete the coprocessor's `<property>` element, including sub-elements, from `hbase-site.xml`.\n2. Restart HBase.\n3. Optionally, remove the coprocessor's JAR file from the classpath or HBase's `lib/`\n   directory.\n\n### Dynamic Loading\n\nYou can also load a coprocessor dynamically, without restarting HBase. This may seem\npreferable to static loading, but dynamically loaded coprocessors are loaded on a\nper-table basis, and are only available to the table for which they were loaded. For\nthis reason, dynamically loaded tables are sometimes called **Table Coprocessor**.\n\nIn addition, dynamically loading a coprocessor acts as a schema change on the table,\nand the table must be taken offline to load the coprocessor.\n\nThere are three ways to dynamically load Coprocessor.\n\n<Callout type=\"info\" title=\"Assumptions\">\n  The below mentioned instructions makes the following assumptions:\n\n  * A JAR called `coprocessor.jar` contains the Coprocessor implementation along with all of its\n    dependencies.\n  * The JAR is available in HDFS in some location like\n    `hdfs://NAMENODE:PORT/user/HADOOP_USER/coprocessor.jar`.\n</Callout>\n\n#### Using HBase Shell\n\n1. Load the Coprocessor, using a command like the following:\n\n   ```ruby\n   hbase alter 'users', METHOD => 'table_att', 'Coprocessor'=>'hdfs://NAMENODE:PORT/user/HADOOP_USER/coprocessor.jar|org.myname.hbase.Coprocessor.RegionObserverExample|1073741823|arg1=1,arg2=2'\n   ```\n\n   The Coprocessor framework will try to read the class information from the coprocessor table\n   attribute value.\n   The value contains four pieces of information which are separated by the pipe (`|`) character.\n\n   * File path: The jar file containing the Coprocessor implementation must be in a location where\n     all region servers can read it.\n     You could copy the file onto the local disk on each region server, but it is recommended to store\n     it in HDFS.\n     [HBASE-14548](https://issues.apache.org/jira/browse/HBASE-14548) allows a directory containing the jars\n     or some wildcards to be specified, such as: `hdfs://NAMENODE:PORT/user/HADOOP_USER/` or\n     `hdfs://NAMENODE:PORT/user/HADOOP_USER/*.jar`. Please note that if a directory is specified,\n     all jar files(.jar) in the directory are added. It does not search for files in sub-directories.\n     Do not use a wildcard if you would like to specify a directory. This enhancement applies to the\n     usage via the JAVA API as well.\n   * Class name: The full class name of the Coprocessor.\n   * Priority: An integer. The framework will determine the execution sequence of all configured\n     observers registered at the same hook using priorities. This field can be left blank. In that\n     case the framework will assign a default priority value.\n   * Arguments (Optional): This field is passed to the Coprocessor implementation. This is optional.\n\n2. Verify that the coprocessor loaded:\n\n   ```ruby\n   hbase(main):04:0> describe 'users'\n   ```\n\n   The coprocessor should be listed in the `TABLE_ATTRIBUTES`.\n\n#### Using the Java API (all HBase versions)\n\nThe following Java code shows how to use the `setValue()` method of `HTableDescriptor`\nto load a coprocessor on the `users` table.\n\n```java\nTableName tableName = TableName.valueOf(\"users\");\nString path = \"hdfs://<namenode>:<port>/user/<hadoop-user>/coprocessor.jar\";\nConfiguration conf = HBaseConfiguration.create();\nConnection connection = ConnectionFactory.createConnection(conf);\nAdmin admin = connection.getAdmin();\nHTableDescriptor hTableDescriptor = new HTableDescriptor(tableName);\nHColumnDescriptor columnFamily1 = new HColumnDescriptor(\"personalDet\");\ncolumnFamily1.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily1);\nHColumnDescriptor columnFamily2 = new HColumnDescriptor(\"salaryDet\");\ncolumnFamily2.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily2);\nhTableDescriptor.setValue(\"COPROCESSOR$1\", path + \"|\"\n+ RegionObserverExample.class.getCanonicalName() + \"|\"\n+ Coprocessor.PRIORITY_USER);\nadmin.modifyTable(tableName, hTableDescriptor);\n```\n\n#### Using the Java API (HBase 0.96+ only)\n\nIn HBase 0.96 and newer, the `addCoprocessor()` method of `HTableDescriptor` provides\nan easier way to load a coprocessor dynamically.\n\n```java\nTableName tableName = TableName.valueOf(\"users\");\nPath path = new Path(\"hdfs://<namenode>:<port>/user/<hadoop-user>/coprocessor.jar\");\nConfiguration conf = HBaseConfiguration.create();\nConnection connection = ConnectionFactory.createConnection(conf);\nAdmin admin = connection.getAdmin();\nHTableDescriptor hTableDescriptor = new HTableDescriptor(tableName);\nHColumnDescriptor columnFamily1 = new HColumnDescriptor(\"personalDet\");\ncolumnFamily1.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily1);\nHColumnDescriptor columnFamily2 = new HColumnDescriptor(\"salaryDet\");\ncolumnFamily2.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily2);\nhTableDescriptor.addCoprocessor(RegionObserverExample.class.getCanonicalName(), path,\nCoprocessor.PRIORITY_USER, null);\nadmin.modifyTable(tableName, hTableDescriptor);\n```\n\n<Callout type=\"warn\">\n  There is no guarantee that the framework will load a given Coprocessor successfully. For example,\n  the shell command neither guarantees a jar file exists at a particular location nor verifies\n  whether the given class is actually contained in the jar file.\n</Callout>\n\n### Dynamic Unloading\n\n#### Using HBase Shell\n\n1. Alter the table to remove the coprocessor with `table_att_unset`.\n\n   ```ruby\n   hbase> alter 'users', METHOD => 'table_att_unset', NAME => 'coprocessor$1'\n   ```\n\n2. Alter the table to remove the coprocessor with `table_remove_coprocessor` introduced in\n   [HBASE-26524](https://issues.apache.org/jira/browse/HBASE-26524) by specifying an explicit\n   classname\n\n   ```ruby\n   hbase> alter 'users', METHOD => 'table_remove_coprocessor', CLASSNAME => \\\n       'org.myname.hbase.Coprocessor.RegionObserverExample'\n   ```\n\n#### Using the Java API\n\nReload the table definition without setting the value of the coprocessor either by\nusing `setValue()` or `addCoprocessor()` methods. This will remove any coprocessor\nattached to the table.\n\n```java\nTableName tableName = TableName.valueOf(\"users\");\nString path = \"hdfs://<namenode>:<port>/user/<hadoop-user>/coprocessor.jar\";\nConfiguration conf = HBaseConfiguration.create();\nConnection connection = ConnectionFactory.createConnection(conf);\nAdmin admin = connection.getAdmin();\nHTableDescriptor hTableDescriptor = new HTableDescriptor(tableName);\nHColumnDescriptor columnFamily1 = new HColumnDescriptor(\"personalDet\");\ncolumnFamily1.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily1);\nHColumnDescriptor columnFamily2 = new HColumnDescriptor(\"salaryDet\");\ncolumnFamily2.setMaxVersions(3);\nhTableDescriptor.addFamily(columnFamily2);\nadmin.modifyTable(tableName, hTableDescriptor);\n```\n\nIn HBase 0.96 and newer, you can instead use the `removeCoprocessor()` method of the\n`HTableDescriptor` class.\n\n## Examples\n\nHBase ships examples for Observer Coprocessor.\n\nA more detailed example is given below.\n\nThese examples assume a table called `users`, which has two column families `personalDet`\nand `salaryDet`, containing personal and salary details. Below is the graphical representation\nof the `users` table.\n\n**Users Table**\n\n|            | **personalDet** |              |            | **salaryDet** |         |                |\n| ---------- | --------------- | ------------ | ---------- | ------------- | ------- | -------------- |\n| **rowkey** | **name**        | **lastname** | **dob**    | **gross**     | **net** | **allowances** |\n| admin      | Admin           | Admin        |            |               |         |                |\n| cdickens   | Charles         | Dickens      | 02/07/1812 | 10000         | 8000    | 2000           |\n| jverne     | Jules           | Verne        | 02/08/1828 | 12000         | 9000    | 3000           |\n\n### Observer Example\n\nThe following Observer coprocessor prevents the details of the user `admin` from being\nreturned in a `Get` or `Scan` of the `users` table.\n\n1. Write a class that implements the\n   [RegionCoprocessor](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionCoprocessor.html),\n   [RegionObserver](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html)\n   class.\n2. Override the `preGetOp()` method (the `preGet()` method is deprecated) to check\n   whether the client has queried for the rowkey with value `admin`. If so, return an\n   empty result. Otherwise, process the request as normal.\n3. Put your code and dependencies in a JAR file.\n4. Place the JAR in HDFS where HBase can locate it.\n5. Load the Coprocessor.\n6. Write a simple program to test it.\n\nFollowing are the implementation of the above steps:\n\n```java\npublic class RegionObserverExample implements RegionCoprocessor, RegionObserver {\n\n    private static final byte[] ADMIN = Bytes.toBytes(\"admin\");\n    private static final byte[] COLUMN_FAMILY = Bytes.toBytes(\"details\");\n    private static final byte[] COLUMN = Bytes.toBytes(\"Admin_det\");\n    private static final byte[] VALUE = Bytes.toBytes(\"You can't see Admin details\");\n\n    @Override\n    public Optional<RegionObserver> getRegionObserver() {\n      return Optional.of(this);\n    }\n\n    @Override\n    public void preGetOp(final ObserverContext<RegionCoprocessorEnvironment> e, final Get get, final List<Cell> results)\n    throws IOException {\n\n        if (Bytes.equals(get.getRow(),ADMIN)) {\n            Cell c = CellUtil.createCell(get.getRow(),COLUMN_FAMILY, COLUMN,\n            System.currentTimeMillis(), (byte)4, VALUE);\n            results.add(c);\n            e.bypass();\n        }\n    }\n}\n```\n\nOverriding the `preGetOp()` will only work for `Get` operations. You also need to override\nthe `preScannerOpen()` method to filter the `admin` row from scan results.\n\n```java\n@Override\npublic RegionScanner preScannerOpen(final ObserverContext<RegionCoprocessorEnvironment> e, final Scan scan,\nfinal RegionScanner s) throws IOException {\n\n    Filter filter = new RowFilter(CompareOp.NOT_EQUAL, new BinaryComparator(ADMIN));\n    scan.setFilter(filter);\n    return s;\n}\n```\n\nThis method works but there is a *side effect*. If the client has used a filter in\nits scan, that filter will be replaced by this filter. Instead, you can explicitly\nremove any `admin` results from the scan:\n\n```java\n@Override\npublic boolean postScannerNext(final ObserverContext<RegionCoprocessorEnvironment> e, final InternalScanner s,\nfinal List<Result> results, final int limit, final boolean hasMore) throws IOException {\n        Result result = null;\n    Iterator<Result> iterator = results.iterator();\n    while (iterator.hasNext()) {\n    result = iterator.next();\n        if (Bytes.equals(result.getRow(), ROWKEY)) {\n            iterator.remove();\n            break;\n        }\n    }\n    return hasMore;\n}\n```\n\n### Endpoint Example\n\nStill using the `users` table, this example implements a coprocessor to calculate\nthe sum of all employee salaries, using an endpoint coprocessor.\n\n1. Create a '.proto' file defining your service.\n\n   ```protobuf\n   option java_package = \"org.myname.hbase.coprocessor.autogenerated\";\n   option java_outer_classname = \"Sum\";\n   option java_generic_services = true;\n   option java_generate_equals_and_hash = true;\n   option optimize_for = SPEED;\n   message SumRequest {\n       required string family = 1;\n       required string column = 2;\n   }\n\n   message SumResponse {\n   required int64 sum = 1 [default = 0];\n   }\n\n   service SumService {\n   rpc getSum(SumRequest)\n       returns (SumResponse);\n   }\n   ```\n\n2. Execute the `protoc` command to generate the Java code from the above .proto' file.\n\n   ```bash\n   $ mkdir src\n   $ protoc --java_out=src ./sum.proto\n   ```\n\n   This will generate a class call `Sum.java`.\n\n3. Write a class that extends the generated service class, implement the `Coprocessor`\n   and `CoprocessorService` classes, and override the service method.\n\n   <Callout type=\"warn\">\n     If you load a coprocessor from `hbase-site.xml` and then load the same coprocessor\n     again using HBase Shell, it will be loaded a second time. The same class will\n     exist twice, and the second instance will have a higher ID (and thus a lower priority).\n     The effect is that the duplicate coprocessor is effectively ignored.\n   </Callout>\n\n   ```java\n   public class SumEndPoint extends Sum.SumService implements Coprocessor, CoprocessorService {\n\n       private RegionCoprocessorEnvironment env;\n\n       @Override\n       public Service getService() {\n           return this;\n       }\n\n       @Override\n       public void start(CoprocessorEnvironment env) throws IOException {\n           if (env instanceof RegionCoprocessorEnvironment) {\n               this.env = (RegionCoprocessorEnvironment)env;\n           } else {\n               throw new CoprocessorException(\"Must be loaded on a table region!\");\n           }\n       }\n\n       @Override\n       public void stop(CoprocessorEnvironment env) throws IOException {\n           // do nothing\n       }\n\n       @Override\n       public void getSum(RpcController controller, Sum.SumRequest request, RpcCallback<Sum.SumResponse> done) {\n           Scan scan = new Scan();\n           scan.addFamily(Bytes.toBytes(request.getFamily()));\n           scan.addColumn(Bytes.toBytes(request.getFamily()), Bytes.toBytes(request.getColumn()));\n\n           Sum.SumResponse response = null;\n           InternalScanner scanner = null;\n\n           try {\n               scanner = env.getRegion().getScanner(scan);\n               List<Cell> results = new ArrayList<>();\n               boolean hasMore = false;\n               long sum = 0L;\n\n               do {\n                   hasMore = scanner.next(results);\n                   for (Cell cell : results) {\n                       sum = sum + Bytes.toLong(CellUtil.cloneValue(cell));\n                   }\n                   results.clear();\n               } while (hasMore);\n\n               response = Sum.SumResponse.newBuilder().setSum(sum).build();\n           } catch (IOException ioe) {\n               ResponseConverter.setControllerException(controller, ioe);\n           } finally {\n               if (scanner != null) {\n                   try {\n                       scanner.close();\n                   } catch (IOException ignored) {}\n               }\n           }\n\n           done.run(response);\n       }\n   }\n   ```\n\n   ```java\n   Configuration conf = HBaseConfiguration.create();\n   Connection connection = ConnectionFactory.createConnection(conf);\n   TableName tableName = TableName.valueOf(\"users\");\n   Table table = connection.getTable(tableName);\n\n   final Sum.SumRequest request = Sum.SumRequest.newBuilder().setFamily(\"salaryDet\").setColumn(\"gross\").build();\n   try {\n       Map<byte[], Long> results = table.coprocessorService(\n           Sum.SumService.class,\n           null,  /* start key */\n           null,  /* end   key */\n           new Batch.Call<Sum.SumService, Long>() {\n               @Override\n               public Long call(Sum.SumService aggregate) throws IOException {\n                   BlockingRpcCallback<Sum.SumResponse> rpcCallback = new BlockingRpcCallback<>();\n                   aggregate.getSum(null, request, rpcCallback);\n                   Sum.SumResponse response = rpcCallback.get();\n\n                   return response.hasSum() ? response.getSum() : 0L;\n               }\n           }\n       );\n\n       for (Long sum : results.values()) {\n           System.out.println(\"Sum = \" + sum);\n       }\n   } catch (ServiceException e) {\n       e.printStackTrace();\n   } catch (Throwable e) {\n       e.printStackTrace();\n   }\n   ```\n\n4. Load the Coprocessor.\n\n5. Write a client code to call the Coprocessor.\n\n## Guidelines For Deploying A Coprocessor\n\n**Bundling Coprocessors**\\\nYou can bundle all classes for a coprocessor into a\nsingle JAR on the RegionServer's classpath, for easy deployment. Otherwise,\nplace all dependencies on the RegionServer's classpath so that they can be\nloaded during RegionServer start-up. The classpath for a RegionServer is set\nin the RegionServer's `hbase-env.sh` file.\n\n**Automating Deployment**\\\nYou can use a tool such as Puppet, Chef, or\nAnsible to ship the JAR for the coprocessor to the required location on your\nRegionServers' filesystems and restart each RegionServer, to automate\ncoprocessor deployment. Details for such set-ups are out of scope of this\ndocument.\n\n**Updating a Coprocessor**\\\nDeploying a new version of a given coprocessor is not as simple as disabling it,\nreplacing the JAR, and re-enabling the coprocessor. This is because you cannot\nreload a class in a JVM unless you delete all the current references to it.\nSince the current JVM has reference to the existing coprocessor, you must restart\nthe JVM, by restarting the RegionServer, in order to replace it. This behavior\nis not expected to change.\n\n**Coprocessor Logging**\\\nThe Coprocessor framework does not provide an API for logging beyond standard Java\nlogging.\n\n**Coprocessor Configuration**\\\nIf you do not want to load coprocessors from the HBase Shell, you can add their configuration\nproperties to `hbase-site.xml`. In [Using HBase Shell](/docs/cp#using-hbase-shell), two arguments are\nset: `arg1=1,arg2=2`. These could have been added to `hbase-site.xml` as follows:\n\n```xml\n<property>\n  <name>arg1</name>\n  <value>1</value>\n</property>\n<property>\n  <name>arg2</name>\n  <value>2</value>\n</property>\n```\n\nThen you can read the configuration using code like the following:\n\n```java\nConfiguration conf = HBaseConfiguration.create();\nConnection connection = ConnectionFactory.createConnection(conf);\nTableName tableName = TableName.valueOf(\"users\");\nTable table = connection.getTable(tableName);\n\nGet get = new Get(Bytes.toBytes(\"admin\"));\nResult result = table.get(get);\nfor (Cell c : result.rawCells()) {\n    System.out.println(Bytes.toString(CellUtil.cloneRow(c))\n        + \"==> \" + Bytes.toString(CellUtil.cloneFamily(c))\n        + \"{\" + Bytes.toString(CellUtil.cloneQualifier(c))\n        + \":\" + Bytes.toLong(CellUtil.cloneValue(c)) + \"}\");\n}\nScan scan = new Scan();\nResultScanner scanner = table.getScanner(scan);\nfor (Result res : scanner) {\n    for (Cell c : res.rawCells()) {\n        System.out.println(Bytes.toString(CellUtil.cloneRow(c))\n        + \" ==> \" + Bytes.toString(CellUtil.cloneFamily(c))\n        + \" {\" + Bytes.toString(CellUtil.cloneQualifier(c))\n        + \":\" + Bytes.toLong(CellUtil.cloneValue(c))\n        + \"}\");\n    }\n}\n```\n\n## Restricting Coprocessor Usage\n\nRestricting arbitrary user coprocessors can be a big concern in multitenant environments. HBase provides a continuum of options for ensuring only expected coprocessors are running:\n\n* `hbase.coprocessor.enabled`: Enables or disables all coprocessors. This will limit the functionality of HBase, as disabling all coprocessors will disable some security providers. An example coproccessor so affected is `org.apache.hadoop.hbase.security.access.AccessController`.\n  * `hbase.coprocessor.user.enabled`: Enables or disables loading coprocessors on tables (i.e. user coprocessors).\n  * One can statically load coprocessors, and optionally tune their priorities, via the following tunables in `hbase-site.xml`:\n    * `hbase.coprocessor.regionserver.classes`: A comma-separated list of coprocessors that are loaded by region servers\n    * `hbase.coprocessor.region.classes`: A comma-separated list of RegionObserver and Endpoint coprocessors\n    * `hbase.coprocessor.user.region.classes`: A comma-separated list of coprocessors that are loaded by all regions\n    * `hbase.coprocessor.master.classes`: A comma-separated list of coprocessors that are loaded by the master (MasterObserver coprocessors)\n    * `hbase.coprocessor.wal.classes`: A comma-separated list of WALObserver coprocessors to load\n  * `hbase.coprocessor.abortonerror`: Whether to abort the daemon which has loaded the coprocessor if the coprocessor should error other than `IOError`. If this is set to false and an access controller coprocessor should have a fatal error the coprocessor will be circumvented, as such in secure installations this is advised to be `true`; however, one may override this on a per-table basis for user coprocessors, to ensure they do not abort their running region server and are instead unloaded on error.\n  * `hbase.coprocessor.region.whitelist.paths`: A comma separated list available for those loading `org.apache.hadoop.hbase.security.access.CoprocessorWhitelistMasterObserver` whereby one can use the following options to white-list paths from which coprocessors may be loaded.\n    * Coprocessors on the classpath are implicitly white-listed\n    * `*` to wildcard all coprocessor paths\n    * An entire filesystem (e.g. `hdfs://my-cluster/`)\n    * A wildcard path to be evaluated by [FilenameUtils.wildcardMatch](https://commons.apache.org/proper/commons-io/javadocs/api-release/org/apache/commons/io/FilenameUtils.html)\n    * Note: Path can specify scheme or not (e.g. `file:///usr/hbase/lib/coprocessors` or for all filesystems `/usr/hbase/lib/coprocessors`)\n\n***\n\n# Apache HBase Performance Tuning\n\n## Operating System\n\n### Memory\n\nRAM, RAM, RAM. Don't starve HBase.\n\n### 64-bit\n\nUse a 64-bit platform (and 64-bit JVM).\n\n### Swapping\n\nWatch out for swapping. Set `swappiness` to 0.\n\n### CPU\n\nMake sure you have set up your Hadoop to use native, hardware checksumming. See [hadoop.native.lib](/docs/compression#making-use-of-hadoop-native-libraries-in-hbase).\n\n## Network\n\nPerhaps the most important factor in avoiding network issues degrading Hadoop and HBase performance is the switching hardware that is used, decisions made early in the scope of the project can cause major problems when you double or triple the size of your cluster (or more).\n\nImportant items to consider:\n\n* Switching capacity of the device\n* Number of systems connected\n* Uplink capacity\n\n### Single Switch\n\nThe single most important factor in this configuration is that the switching capacity of the hardware is capable of handling the traffic which can be generated by all systems connected to the switch. Some lower priced commodity hardware can have a slower switching capacity than could be utilized by a full switch.\n\n### Multiple Switches\n\nMultiple switches are a potential pitfall in the architecture. The most common configuration of lower priced hardware is a simple 1Gbps uplink from one switch to another. This often overlooked pinch point can easily become a bottleneck for cluster communication. Especially with MapReduce jobs that are both reading and writing a lot of data the communication across this uplink could be saturated.\n\nMitigation of this issue is fairly simple and can be accomplished in multiple ways:\n\n* Use appropriate hardware for the scale of the cluster which you're attempting to build.\n* Use larger single switch configurations i.e. single 48 port as opposed to 2x 24 port\n* Configure port trunking for uplinks to utilize multiple interfaces to increase cross switch bandwidth.\n\n### Multiple Racks\n\nMultiple rack configurations carry the same potential issues as multiple switches, and can suffer performance degradation from two main areas:\n\n* Poor switch capacity performance\n* Insufficient uplink to another rack\n\nIf the switches in your rack have appropriate switching capacity to handle all the hosts at full speed, the next most likely issue will be caused by homing more of your cluster across racks. The easiest way to avoid issues when spanning multiple racks is to use port trunking to create a bonded uplink to other racks. The downside of this method however, is in the overhead of ports that could potentially be used. An example of this is, creating an 8Gbps port channel from rack A to rack B, using 8 of your 24 ports to communicate between racks gives you a poor ROI, using too few however can mean you're not getting the most out of your cluster.\n\nUsing 10Gbe links between racks will greatly increase performance, and assuming your switches support a 10Gbe uplink or allow for an expansion card will allow you to save your ports for machines as opposed to uplinks.\n\n### Network Interfaces\n\nAre all the network interfaces functioning correctly? Are you sure? See the Troubleshooting Case Study in [Case Study #1 (Performance Issue On A Single Node)](/docs/case-studies#case-study-1-performance-issue-on-a-single-node).\n\n### Network Consistency and Partition Tolerance\n\nThe [CAP Theorem](http://en.wikipedia.org/wiki/CAP_theorem) states that a distributed system can maintain two out of the following three characteristics:\n\n* ***C***&#x6F;nsistency — all nodes see the same data.\n* ***A***&#x76;ailability — every request receives a response about whether it succeeded or failed.\n* ***P***&#x61;rtition tolerance — the system continues to operate even if some of its components become unavailable to the others.\n\nHBase favors consistency and partition tolerance, where a decision has to be made. Coda Hale explains why partition tolerance is so important, in [http://codahale.com/you-cant-sacrifice-partition-tolerance/](http://codahale.com/you-cant-sacrifice-partition-tolerance/).\n\nRobert Yokota used an automated testing framework called [Jepson](https://aphyr.com/tags/jepsen) to test HBase's partition tolerance in the face of network partitions, using techniques modeled after Aphyr's [Call Me Maybe](https://aphyr.com/posts/281-call-me-maybe-carly-rae-jepsen-and-the-perils-of-network-partitions) series. The results, available as a [blog post](https://rayokota.wordpress.com/2015/09/30/call-me-maybe-hbase/) and an [addendum](https://rayokota.wordpress.com/2015/09/30/call-me-maybe-hbase-addendum/), show that HBase performs correctly.\n\n## Java\n\n### The Garbage Collector and Apache HBase\n\n#### Long GC pauses\n\nIn his presentation, [Avoiding Full GCs with MemStore-Local Allocation Buffers](http://www.slideshare.net/cloudera/hbase-hug-presentation), Todd Lipcon describes two cases of stop-the-world garbage collections common in HBase, especially during loading; CMS failure modes and old generation heap fragmentation brought.\n\nTo address the first, start the CMS earlier than default by adding `-XX:CMSInitiatingOccupancyFraction` and setting it down from defaults. Start at 60 or 70 percent (The lower you bring down the threshold, the more GCing is done, the more CPU used). To address the second fragmentation issue, Todd added an experimental facility, (MSLAB), that must be explicitly enabled in Apache HBase 0.90.x (It's defaulted to be *on* in Apache 0.92.x HBase). Set `hbase.hregion.memstore.mslab.enabled` to true in your `Configuration`. See the cited slides for background and detail. The latest JVMs do better regards fragmentation so make sure you are running a recent release. Read down in the message, [Identifying concurrent mode failures caused by fragmentation](http://osdir.com/ml/hotspot-gc-use/2011-11/msg00002.html). Be aware that when enabled, each MemStore instance will occupy at least an MSLAB instance of memory. If you have thousands of regions or lots of regions each with many column families, this allocation of MSLAB may be responsible for a good portion of your heap allocation and in an extreme case cause you to OOME. Disable MSLAB in this case, or lower the amount of memory it uses or float less regions per server.\n\nIf you have a write-heavy workload, check out [HBASE-8163 MemStoreChunkPool: An improvement for JAVA GC when using MSLAB](https://issues.apache.org/jira/browse/HBASE-8163). It describes configurations to lower the amount of young GC during write-heavy loadings. If you do not have HBASE-8163 installed, and you are trying to improve your young GC times, one trick to consider — courtesy of our Liang Xie — is to set the GC config `-XX:PretenureSizeThreshold` in *hbase-env.sh* to be just smaller than the size of `hbase.hregion.memstore.mslab.chunksize` so MSLAB allocations happen in the tenured space directly rather than first in the young gen. You'd do this because these MSLAB allocations are going to likely make it to the old gen anyways and rather than pay the price of a copies between s0 and s1 in eden space followed by the copy up from young to old gen after the MSLABs have achieved sufficient tenure, save a bit of YGC churn and allocate in the old gen directly.\n\nOther sources of long GCs can be the JVM itself logging. See [Eliminating Large JVM GC Pauses Caused by Background IO Traffic](https://engineering.linkedin.com/blog/2016/02/eliminating-large-jvm-gc-pauses-caused-by-background-io-traffic)\n\nFor more information about GC logs, see [JVM Garbage Collection Logs](/docs/troubleshooting#jvm-garbage-collection-logs).\n\nConsider also enabling the off-heap Block Cache. This has been shown to mitigate GC pause times. See [Block Cache](/docs/architecture/regionserver#architecture-regionserver-block-cache)\n\n## HBase Configurations\n\nSee [Recommended Configurations](/docs/configuration/important#recommended-configurations).\n\n### Improving the 99th Percentile\n\nTry [hedged\\_reads](/docs/performance#hedged-reads).\n\n### Managing Compactions\n\nFor larger systems, managing [compactions and splits](/docs/configuration/important#managed-compactions) may be something you want to consider.\n\n### `hbase.regionserver.handler.count`\n\nSee [hbase.regionserver.handler.count](/docs/configuration/default#hbaseregionserverhandlercount-toc).\n\n### `hfile.block.cache.size`\n\nSee [hfile.block.cache.size](/docs/configuration/default#hfileblockcachesize-toc). A memory setting for the RegionServer process.\n\n### Prefetch Option for Blockcache\n\n[HBASE-9857](https://issues.apache.org/jira/browse/HBASE-9857) adds a new option to prefetch HFile contents when opening the BlockCache, if a Column family or RegionServer property is set. This option is available for HBase 0.98.3 and later. The purpose is to warm the BlockCache as rapidly as possible after the cache is opened, using in-memory table data, and not counting the prefetching as cache misses. This is great for fast reads, but is not a good idea if the data to be preloaded will not fit into the BlockCache. It is useful for tuning the IO impact of prefetching versus the time before all data blocks are in cache.\n\nTo enable prefetching on a given column family, you can use HBase Shell or use the API.\n\n**Enable Prefetch Using HBase Shell**\n\n```ruby\nhbase> create 'MyTable', { NAME => 'myCF', PREFETCH_BLOCKS_ON_OPEN => 'true' }\n```\n\n**Enable Prefetch Using the API**\n\n```java\n// ...\nHTableDescriptor tableDesc = new HTableDescriptor(\"myTable\");\nHColumnDescriptor cfDesc = new HColumnDescriptor(\"myCF\");\ncfDesc.setPrefetchBlocksOnOpen(true);\ntableDesc.addFamily(cfDesc);\n// ...\n```\n\nSee the API documentation for [CacheConfig](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html).\n\nTo see prefetch in operation, enable TRACE level logging on `org.apache.hadoop.hbase.io.hfile.HFileReaderImpl` in hbase-2.0+ or on `org.apache.hadoop.hbase.io.hfile.HFileReaderV2` in earlier versions, hbase-1.x, of HBase.\n\n### `hbase.regionserver.global.memstore.size`\n\nSee [hbase.regionserver.global.memstore.size](/docs/configuration/default#hbaseregionserverglobalmemstoresize-toc). This memory setting is often adjusted for the RegionServer process depending on needs.\n\n### `hbase.regionserver.global.memstore.size.lower.limit`\n\nSee [hbase.regionserver.global.memstore.size.lower.limit](/docs/configuration/default#hbaseregionserverglobalmemstoresizelowerlimit-toc). This memory setting is often adjusted for the RegionServer process depending on needs.\n\n### `hbase.hstore.blockingStoreFiles`\n\nSee [hbase.hstore.blockingStoreFiles](/docs/configuration/default#hbasehstoreblockingStoreFiles-toc). If there is blocking in the RegionServer logs, increasing this can help.\n\n### `hbase.hregion.memstore.block.multiplier`\n\nSee [hbase.hregion.memstore.block.multiplier](/docs/configuration/default#hbasehregionmemstoreblockmultiplier-toc). If there is enough RAM, increasing this can help.\n\n### `hbase.regionserver.checksum.verify`\n\nHave HBase write the checksum into the datablock and save having to do the checksum seek whenever you read.\n\nSee [hbase.regionserver.checksum.verify](/docs/configuration/default#hbaseregionserverchecksumverify-toc), [hbase.hstore.bytes.per.checksum](/docs/configuration/default#hbasehstorebytesperchecksum-toc) and [hbase.hstore.checksum.algorithm](/docs/configuration/default#hbasehstorechecksumalgorithm-toc). For more information see the release note on [HBASE-5074 support checksums in HBase block cache](https://issues.apache.org/jira/browse/HBASE-5074).\n\n### Tuning `callQueue` Options\n\n[HBASE-11355](https://issues.apache.org/jira/browse/HBASE-11355) introduces several callQueue tuning mechanisms which can increase performance. See the JIRA for some benchmarking information.\n\nTo increase the number of callqueues, set `hbase.ipc.server.num.callqueue` to a value greater than `1`. To split the callqueue into separate read and write queues, set `hbase.ipc.server.callqueue.read.ratio` to a value between `0` and `1`. This factor weights the queues toward writes (if below .5) or reads (if above .5). Another way to say this is that the factor determines what percentage of the split queues are used for reads. The following examples illustrate some of the possibilities. Note that you always have at least one write queue, no matter what setting you use.\n\n* The default value of `0` does not split the queue.\n* A value of `.3` uses 30% of the queues for reading and 70% for writing. Given a value of `10` for `hbase.ipc.server.num.callqueue`, 3 queues would be used for reads and 7 for writes.\n* A value of `.5` uses the same number of read queues and write queues. Given a value of `10` for `hbase.ipc.server.num.callqueue`, 5 queues would be used for reads and 5 for writes.\n* A value of `.6` uses 60% of the queues for reading and 40% for writing. Given a value of `10` for `hbase.ipc.server.num.callqueue`, 6 queues would be used for reads and 4 for writes.\n* A value of `1.0` uses one queue to process write requests, and all other queues process read requests. A value higher than `1.0` has the same effect as a value of `1.0`. Given a value of `10` for `hbase.ipc.server.num.callqueue`, 9 queues would be used for reads and 1 for writes.\n\nYou can also split the read queues so that separate queues are used for short reads (from Get operations) and long reads (from Scan operations), by setting the `hbase.ipc.server.callqueue.scan.ratio` option. This option is a factor between 0 and 1, which determine the ratio of read queues used for Gets and Scans. More queues are used for Gets if the value is below `.5` and more are used for scans if the value is above `.5`. No matter what setting you use, at least one read queue is used for Get operations.\n\n* A value of `0` does not split the read queue.\n* A value of `.3` uses 70% of the read queues for Gets and 30% for Scans. Given a value of `20` for `hbase.ipc.server.num.callqueue` and a value of `.5` for `hbase.ipc.server.callqueue.read.ratio`, 10 queues would be used for reads, out of those 10, 7 would be used for Gets and 3 for Scans.\n* A value of `.5` uses half the read queues for Gets and half for Scans. Given a value of `20` for `hbase.ipc.server.num.callqueue` and a value of `.5` for `hbase.ipc.server.callqueue.read.ratio`, 10 queues would be used for reads, out of those 10, 5 would be used for Gets and 5 for Scans.\n* A value of `.7` uses 30% of the read queues for Gets and 70% for Scans. Given a value of `20` for `hbase.ipc.server.num.callqueue` and a value of `.5` for `hbase.ipc.server.callqueue.read.ratio`, 10 queues would be used for reads, out of those 10, 3 would be used for Gets and 7 for Scans.\n* A value of `1.0` uses all but one of the read queues for Scans. Given a value of `20` for `hbase.ipc.server.num.callqueue` and a value of `.5` for `hbase.ipc.server.callqueue.read.ratio`, 10 queues would be used for reads, out of those 10, 1 would be used for Gets and 9 for Scans.\n\nYou can use the new option `hbase.ipc.server.callqueue.handler.factor` to programmatically tune the number of queues:\n\n* A value of `0` uses a single shared queue between all the handlers.\n* A value of `1` uses a separate queue for each handler.\n* A value between `0` and `1` tunes the number of queues against the number of handlers. For instance, a value of `.5` shares one queue between each two handlers.\\\n  Having more queues, such as in a situation where you have one queue per handler, reduces contention when adding a task to a queue or selecting it from a queue. The trade-off is that if you have some queues with long-running tasks, a handler may end up waiting to execute from that queue rather than processing another queue which has waiting tasks.\n\nFor these values to take effect on a given RegionServer, the RegionServer must be restarted. These parameters are intended for testing purposes and should be used carefully.\n\n## ZooKeeper\n\nSee [ZooKeeper](/docs/zookeeper) for information on configuring ZooKeeper, and see the part about having a dedicated disk.\n\n## Schema Design\n\n### Number of Column Families\n\nSee [On the number of column families](/docs/regionserver-sizing#on-the-number-of-column-families).\n\n### Key and Attribute Lengths\n\nSee [Try to minimize row and column sizes](/docs/regionserver-sizing#try-to-minimize-row-and-column-sizes). See also [However...](/docs/performance#however) for compression caveats.\n\n### Table RegionSize\n\nThe regionsize can be set on a per-table basis via `setMaxFileSize` on [TableDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/TableDescriptorBuilder.html) in the event where certain tables require different regionsizes than the configured default regionsize.\n\nSee [Determining region count and size](/docs/operational-management/region-and-capacity#determining-region-count-and-size) for more information.\n\n### Bloom Filters\n\nA Bloom filter, named for its creator, Burton Howard Bloom, is a data structure which is designed to predict whether a given element is a member of a set of data. A positive result from a Bloom filter is not always accurate, but a negative result is guaranteed to be accurate. Bloom filters are designed to be \"accurate enough\" for sets of data which are so large that conventional hashing mechanisms would be impractical. For more information about Bloom filters in general, refer to [http://en.wikipedia.org/wiki/Bloom\\_filter](http://en.wikipedia.org/wiki/Bloom_filter).\n\nIn terms of HBase, Bloom filters provide a lightweight in-memory structure to reduce the number of disk reads for a given Get operation (Bloom filters do not work with Scans) to only the StoreFiles likely to contain the desired Row. The potential performance gain increases with the number of parallel reads.\n\nThe Bloom filters themselves are stored in the metadata of each HFile and never need to be updated. When an HFile is opened because a region is deployed to a RegionServer, the Bloom filter is loaded into memory.\n\nHBase includes some tuning mechanisms for folding the Bloom filter to reduce the size and keep the false positive rate within a desired range.\n\nBloom filters were introduced in [HBASE-1200](https://issues.apache.org/jira/browse/HBASE-1200). Since HBase 0.96, row-based Bloom filters are enabled by default. ([HBASE-8450](https://issues.apache.org/jira/browse/HBASE-8450))\n\nFor more information on Bloom filters in relation to HBase, see [Bloom Filters](/docs/performance#bloom-filters) for more information, or the following Quora discussion: [How are bloom filters used in HBase?](http://www.quora.com/How-are-bloom-filters-used-in-HBase).\n\n#### When To Use Bloom Filters\n\nSince HBase 0.96, row-based Bloom filters are enabled by default. You may choose to disable them or to change some tables to use row+column Bloom filters, depending on the characteristics of your data and how it is loaded into HBase.\n\nTo determine whether Bloom filters could have a positive impact, check the value of `blockCacheHitRatio` in the RegionServer metrics. If Bloom filters are enabled, the value of `blockCacheHitRatio` should increase, because the Bloom filter is filtering out blocks that are definitely not needed.\n\nYou can choose to enable Bloom filters for a row or for a row+column combination. If you generally scan entire rows, the row+column combination will not provide any benefit. A row-based Bloom filter can operate on a row+column Get, but not the other way around. However, if you have a large number of column-level Puts, such that a row may be present in every StoreFile, a row-based filter will always return a positive result and provide no benefit. Unless you have one column per row, row+column Bloom filters require more space, in order to store more keys. Bloom filters work best when the size of each data entry is at least a few kilobytes in size.\n\nOverhead will be reduced when your data is stored in a few larger StoreFiles, to avoid extra disk IO during low-level scans to find a specific row.\n\nBloom filters need to be rebuilt upon deletion, so may not be appropriate in environments with a large number of deletions.\n\n#### Enabling Bloom Filters\n\nBloom filters are enabled on a Column Family. You can do this by using the setBloomFilterType method of HColumnDescriptor or using the HBase API. Valid values are `NONE`, `ROW` (default), or `ROWCOL`. See [When To Use Bloom Filters](/docs/performance#when-to-use-bloom-filters) for more information on `ROW` versus `ROWCOL`. See also the API documentation for [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html).\n\nThe following example creates a table and enables a ROWCOL Bloom filter on the `colfam1` column family.\n\n```ruby\nhbase> create 'mytable',{NAME => 'colfam1', BLOOMFILTER => 'ROWCOL'}\n```\n\n#### Configuring Server-Wide Behavior of Bloom Filters\n\nYou can configure the following settings in the *hbase-site.xml*.\n\n| Parameter                                | Default   | Description                                                                                                                                                    |\n| ---------------------------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| io.storefile.bloom.enabled               | yes       | Set to no to kill bloom filters server-wide if something goes wrong                                                                                            |\n| io.storefile.bloom.error.rate            | .01       | The average false positive rate for bloom filters. Folding is used to maintain the false positive rate. Expressed as a decimal representation of a percentage. |\n| io.storefile.bloom.max.fold              | 7         | The guaranteed maximum fold rate. Changing this setting should not be necessary and is not recommended.                                                        |\n| io.storefile.bloom.max.keys              | 128000000 | For default (single-block) Bloom filters, this specifies the maximum number of keys.                                                                           |\n| io.storefile.delete.family.bloom.enabled | true      | Master switch to enable Delete Family Bloom filters and store them in the StoreFile.                                                                           |\n| io.storefile.bloom.block.size            | 131072    | Target Bloom block size. Bloom filter blocks of approximately this size are interleaved with data blocks.                                                      |\n| hfile.block.bloom.cacheonwrite           | false     | Enables cache-on-write for inline blocks of a compound Bloom filter.                                                                                           |\n\n### ColumnFamily BlockSize\n\nThe blocksize can be configured for each ColumnFamily in a table, and defaults to 64k. Larger cell values require larger blocksizes. There is an inverse relationship between blocksize and the resulting StoreFile indexes (i.e., if the blocksize is doubled then the resulting indexes should be roughly halved).\n\nSee [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html) and [Store](/docs/architecture/regions#store) for more information.\n\n### In-Memory ColumnFamilies\n\nColumnFamilies can optionally be defined as in-memory. Data is still persisted to disk, just like any other ColumnFamily. In-memory blocks have the highest priority in the [Block Cache](/docs/architecture/regionserver#architecture-regionserver-block-cache), but it is not a guarantee that the entire table will be in memory.\n\nSee [ColumnFamilyDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ColumnFamilyDescriptorBuilder.html) for more information.\n\n### Compression\n\nProduction systems should use compression with their ColumnFamily definitions. See [Compression and Data Block Encoding In HBase](/docs/compression) for more information.\n\n#### However...\n\nCompression deflates data *on disk*. When it's in-memory (e.g., in the MemStore) or on the wire (e.g., transferring between RegionServer and Client) it's inflated. So while using ColumnFamily compression is a best practice, but it's not going to completely eliminate the impact of over-sized Keys, over-sized ColumnFamily names, or over-sized Column names.\n\nSee [Try to minimize row and column sizes](/docs/regionserver-sizing#try-to-minimize-row-and-column-sizes) on for schema design tips, and [KeyValue](/docs/architecture/regions#keyvalue) for more information on HBase stores data internally.\n\n## HBase General Patterns\n\n### Constants\n\nWhen people get started with HBase they have a tendency to write code that looks like this:\n\n```java\nGet get = new Get(rowkey);\nResult r = table.get(get);\nbyte[] b = r.getValue(Bytes.toBytes(\"cf\"), Bytes.toBytes(\"attr\"));  // returns current version of value\n```\n\nBut especially when inside loops (and MapReduce jobs), converting the columnFamily and column-names to byte-arrays repeatedly is surprisingly expensive. It's better to use constants for the byte-arrays, like this:\n\n```java\npublic static final byte[] CF = \"cf\".getBytes();\npublic static final byte[] ATTR = \"attr\".getBytes();\n...\nGet get = new Get(rowkey);\nResult r = table.get(get);\nbyte[] b = r.getValue(CF, ATTR);  // returns current version of value\n```\n\n## Writing to HBase\n\n### Batch Loading\n\nUse the bulk load tool if you can. See [Bulk Loading](/docs/architecture/bulk-loading). Otherwise, pay attention to the below.\n\n### Table Creation: Pre-Creating Regions\n\nTables in HBase are initially created with one region by default. For bulk imports, this means that all clients will write to the same region until it is large enough to split and become distributed across the cluster. A useful pattern to speed up the bulk import process is to pre-create empty regions. Be somewhat conservative in this, because too-many regions can actually degrade performance.\n\nThere are two different approaches to pre-creating splits using the HBase API. The first approach is to rely on the default `Admin` strategy (which is implemented in `Bytes.split`)...\n\n```java\nbyte[] startKey = ...;      // your lowest key\nbyte[] endKey = ...;        // your highest key\nint numberOfRegions = ...;  // # of regions to create\nadmin.createTable(table, startKey, endKey, numberOfRegions);\n```\n\nAnd the other approach, using the HBase API, is to define the splits yourself...\n\n```java\nbyte[][] splits = ...;   // create your own splits\nadmin.createTable(table, splits);\n```\n\nYou can achieve a similar effect using the HBase Shell to create tables by specifying split options.\n\n```ruby\n# create table with specific split points\nhbase>create 't1','f1',SPLITS => ['\\x10\\x00', '\\x20\\x00', '\\x30\\x00', '\\x40\\x00']\n\n# create table with four regions based on random bytes keys\nhbase>create 't2','f1', { NUMREGIONS => 4 , SPLITALGO => 'UniformSplit' }\n\n# create table with five regions based on hex keys\ncreate 't3','f1', { NUMREGIONS => 5, SPLITALGO => 'HexStringSplit' }\n```\n\nSee [Relationship Between RowKeys and Region Splits](/docs/regionserver-sizing#relationship-between-rowkeys-and-region-splits) for issues related to understanding your keyspace and pre-creating regions. See [manual region splitting decisions](/docs/architecture/regions#manual-region-splitting) for discussion on manually pre-splitting regions. See [Pre-splitting tables with the HBase Shell](/docs/shell#pre-splitting-tables-with-the-hbase-shell) for more details of using the HBase Shell to pre-split tables.\n\n### Table Creation: Deferred Log Flush\n\nThe default behavior for Puts using the Write Ahead Log (WAL) is that `WAL` edits will be written immediately. If deferred log flush is used, WAL edits are kept in memory until the flush period. The benefit is aggregated and asynchronous `WAL`- writes, but the potential downside is that if the RegionServer goes down the yet-to-be-flushed edits are lost. This is safer, however, than not using WAL at all with Puts.\n\nDeferred log flush can be configured on tables via [TableDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/TableDescriptorBuilder.html). The default value of `hbase.regionserver.optionallogflushinterval` is 1000ms.\n\n### HBase Client: Turn off WAL on Puts\n\nA frequent request is to disable the WAL to increase performance of Puts. This is only appropriate for bulk loads, as it puts your data at risk by removing the protection of the WAL in the event of a region server crash. Bulk loads can be re-run in the event of a crash, with little risk of data loss.\n\n<Callout type=\"warn\">\n  If you disable the WAL for anything other than bulk loads, your data is at risk.\n</Callout>\n\nIn general, it is best to use WAL for Puts, and where loading throughput is a concern to use bulk loading techniques instead. For normal Puts, you are not likely to see a performance improvement which would outweigh the risk. To disable the WAL, see [Disabling the WAL](/docs/architecture/regionserver#disabling-the-wal).\n\n### HBase Client: Group Puts by RegionServer\n\nIn addition to using the writeBuffer, grouping `Put`s by RegionServer can reduce the number of client RPC calls per writeBuffer flush. There is a utility `HTableUtil` currently on MASTER that does this, but you can either copy that or implement your own version for those still on 0.90.x or earlier.\n\n### MapReduce: Skip The Reducer\n\nWhen writing a lot of data to an HBase table from a MR job (e.g., with [TableOutputFormat](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html)), and specifically where Puts are being emitted from the Mapper, skip the Reducer step. When a Reducer step is used, all of the output (Puts) from the Mapper will get spooled to disk, then sorted/shuffled to other Reducers that will most likely be off-node. It's far more efficient to just write directly to HBase.\n\nFor summary jobs where HBase is used as a source and a sink, then writes will be coming from the Reducer step (e.g., summarize values then write out result). This is a different processing problem than from the above case.\n\n### Anti-Pattern: One Hot Region\n\nIf all your data is being written to one region at a time, then re-read the section on processing timeseries data.\n\nAlso, if you are pre-splitting regions and all your data is *still* winding up in a single region even though your keys aren't monotonically increasing, confirm that your keyspace actually works with the split strategy. There are a variety of reasons that regions may appear \"well split\" but won't work with your data. As the HBase client communicates directly with the RegionServers, this can be obtained via [RegionLocator.getRegionLocation](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/RegionLocator.html#getRegionLocation\\(byte%5B%5D\\)).\n\nSee [Table Creation: Pre-Creating Regions](/docs/performance#table-creation-pre-creating-regions), as well as [HBase Configurations](/docs/performance#hbase-configurations)\n\n## Reading from HBase\n\nThe mailing list can help if you are having performance issues.\n\n### Scan Caching\n\nIf HBase is used as an input source for a MapReduce job, for example, make sure that the input [Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) instance to the MapReduce job has `setCaching` set to something greater than the default (which is 1). Using the default value means that the map-task will make call back to the region-server for every record processed. Setting this value to 500, for example, will transfer 500 rows at a time to the client to be processed. There is a cost/benefit to have the cache value be large because it costs more in memory for both client and RegionServer, so bigger isn't always better.\n\n#### Scan Caching in MapReduce Jobs\n\nScan settings in MapReduce jobs deserve special attention. Timeouts can result (e.g., UnknownScannerException) in Map tasks if it takes longer to process a batch of records before the client goes back to the RegionServer for the next set of data. This problem can occur because there is non-trivial processing occurring per row. If you process rows quickly, set caching higher. If you process rows more slowly (e.g., lots of transformations per row, writes), then set caching lower.\n\nTimeouts can also happen in a non-MapReduce use case (i.e., single threaded HBase client doing a Scan), but the processing that is often performed in MapReduce jobs tends to exacerbate this issue.\n\n### Scan Attribute Selection\n\nWhenever a Scan is used to process large numbers of rows (and especially when used as a MapReduce source), be aware of which attributes are selected. If `scan.addFamily` is called then *all* of the attributes in the specified ColumnFamily will be returned to the client. If only a small number of the available attributes are to be processed, then only those attributes should be specified in the input scan because attribute over-selection is a non-trivial performance penalty over large datasets.\n\n### Avoid scan seeks\n\nWhen columns are selected explicitly with `scan.addColumn`, HBase will schedule seek operations to seek between the selected columns. When rows have few columns and each column has only a few versions this can be inefficient. A seek operation is generally slower if does not seek at least past 5-10 columns/versions or 512-1024 bytes.\n\nIn order to opportunistically look ahead a few columns/versions to see if the next column/version can be found that way before a seek operation is scheduled, a new attribute `Scan.HINT_LOOKAHEAD` can be set on the Scan object. The following code instructs the RegionServer to attempt two iterations of next before a seek is scheduled:\n\n```java\nScan scan = new Scan();\nscan.addColumn(...);\nscan.setAttribute(Scan.HINT_LOOKAHEAD, Bytes.toBytes(2));\ntable.getScanner(scan);\n```\n\n### MapReduce - Input Splits\n\nFor MapReduce jobs that use HBase tables as a source, if there a pattern where the \"slow\" map tasks seem to have the same Input Split (i.e., the RegionServer serving the data), see the Troubleshooting Case Study in [Case Study #1 (Performance Issue On A Single Node)](/docs/case-studies#case-study-1-performance-issue-on-a-single-node).\n\n### Close ResultScanners\n\nThis isn't so much about improving performance but rather *avoiding* performance problems. If you forget to close [ResultScanners](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/ResultScanner.html) you can cause problems on the RegionServers. Always have ResultScanner processing enclosed in try/catch blocks.\n\n```java\nScan scan = new Scan();\n// set attrs...\nResultScanner rs = table.getScanner(scan);\ntry {\n  for (Result r = rs.next(); r != null; r = rs.next()) {\n    // process result...\n  }\n} finally {\n  rs.close();  // always close the ResultScanner!\n}\ntable.close();\n```\n\n### Block Cache\n\n[Scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) instances can be set to use the block cache in the RegionServer via the `setCacheBlocks` method. For input Scans to MapReduce jobs, this should be `false`. For frequently accessed rows, it is advisable to use the block cache.\n\nCache more data by moving your Block Cache off-heap. See [Off-heap Block Cache](/docs/architecture/regionserver#off-heap-block-cache)\n\n### Optimal Loading of Row Keys\n\nWhen performing a table [scan](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Scan.html) where only the row keys are needed (no families, qualifiers, values or timestamps), add a FilterList with a `MUST_PASS_ALL` operator to the scanner using `setFilter`. The filter list should include both a [FirstKeyOnlyFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html) and a [KeyOnlyFilter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/filter/KeyOnlyFilter.html). Using this filter combination will result in a worst case scenario of a RegionServer reading a single value from disk and minimal network traffic to the client for a single row.\n\n### Concurrency: Monitor Data Spread\n\nWhen performing a high number of concurrent reads, monitor the data spread of the target tables. If the target table(s) have too few regions then the reads could likely be served from too few nodes.\n\nSee [Table Creation: Pre-Creating Regions](/docs/performance#table-creation-pre-creating-regions), as well as [HBase Configurations](/docs/performance#hbase-configurations)\n\n### Bloom Filters\n\nEnabling Bloom Filters can save your having to go to disk and can help improve read latencies.\n\n[Bloom filters](http://en.wikipedia.org/wiki/Bloom_filter) were developed over in [HBase-1200 Add bloomfilters](https://issues.apache.org/jira/browse/HBASE-1200). For description of the development process — why static blooms rather than dynamic — and for an overview of the unique properties that pertain to blooms in HBase, as well as possible future directions, see the *Development Process* section of the document [BloomFilters in HBase](https://issues.apache.org/jira/secure/attachment/12444007/Bloom_Filters_in_HBase.pdf) attached to [HBASE-1200](https://issues.apache.org/jira/browse/HBASE-1200). The bloom filters described here are actually version two of blooms in HBase. In versions up to 0.19.x, HBase had a dynamic bloom option based on work done by the [European Commission One-Lab Project 034819](http://www.onelab.org). The core of the HBase bloom work was later pulled up into Hadoop to implement org.apache.hadoop.io.BloomMapFile. Version 1 of HBase blooms never worked that well. Version 2 is a rewrite from scratch though again it starts with the one-lab work.\n\nSee also [Bloom Filters](/docs/performance#bloom-filters).\n\n#### Bloom StoreFile footprint\n\nBloom filters add an entry to the `StoreFile` general `FileInfo` data structure and then two extra entries to the `StoreFile` metadata section.\n\n**BloomFilter in the `StoreFile` `FileInfo` data structure**\\\n`FileInfo` has a `BLOOM_FILTER_TYPE` entry which is set to `NONE`, `ROW` or `ROWCOL.`\n\n**BloomFilter entries in `StoreFile` metadata**\\\n`BLOOM_FILTER_META` holds Bloom Size, Hash Function used, etc. It's small in size and is cached on `StoreFile.Reader` load.\\\n`BLOOM_FILTER_DATA` is the actual bloomfilter data. Obtained on-demand. Stored in the LRU cache, if it is enabled (It's enabled by default).\n\n#### Bloom Filter Configuration\n\n**`io.storefile.bloom.enabled` global kill switch**\\\n`io.storefile.bloom.enabled` in `Configuration` serves as the kill switch in case something goes wrong. Default = `true`.\n\n`io.storefile.bloom.error.rate`\\\n`io.storefile.bloom.error.rate` = average false positive rate. Default = 1%. Decrease rate by ½ (e.g. to .5%) == +1 bit per bloom entry.\n\n`io.storefile.bloom.max.fold`\\\n`io.storefile.bloom.max.fold` = guaranteed minimum fold rate. Most people should leave this alone. Default = 7, or can collapse to at least 1/128th of original size. See the *Development Process* section of the document [BloomFilters in HBase](https://issues.apache.org/jira/secure/attachment/12444007/Bloom_Filters_in_HBase.pdf) for more on what this option means.\n\n### Hedged Reads\n\nHedged reads are a feature of HDFS, introduced in Hadoop 2.4.0 with [HDFS-5776](https://issues.apache.org/jira/browse/HDFS-5776). Normally, a single thread is spawned for each read request. However, if hedged reads are enabled, the client waits some configurable amount of time, and if the read does not return, the client spawns a second read request, against a different block replica of the same data. Whichever read returns first is used, and the other read request is discarded.\n\nHedged reads are \"...very good at eliminating outlier datanodes, which in turn makes them very good choice for latency sensitive setups. But, if you are looking for maximizing throughput, hedged reads tend to create load amplification as things get slower in general. In short, the thing to watch out for is the non-graceful performance degradation when you are running close a certain throughput threshold.\" (Quote from Ashu Pachauri in HBASE-17083).\n\nOther concerns to keep in mind while running with hedged reads enabled include:\n\n* They may lead to network congestion. See [HBASE-17083](https://issues.apache.org/jira/browse/HBASE-17083)\n* Make sure you set the thread pool large enough so as blocking on the pool does not become a bottleneck (Again see [HBASE-17083](https://issues.apache.org/jira/browse/HBASE-17083))\n\n(From Yu Li up in HBASE-17083)\n\nBecause an HBase RegionServer is a HDFS client, you can enable hedged reads in HBase, by adding the following properties to the RegionServer's hbase-site.xml and tuning the values to suit your environment.\n\n**Configuration for Hedged Reads**\n\n* `dfs.client.hedged.read.threadpool.size` - the number of threads dedicated to servicing hedged reads. If this is set to 0 (the default), hedged reads are disabled.\n* `dfs.client.hedged.read.threshold.millis` - the number of milliseconds to wait before spawning a second read thread.\n\n**Hedged Reads Configuration Example**\n\n```xml\n<property>\n  <name>dfs.client.hedged.read.threadpool.size</name>\n  <value>20</value>  <!-- 20 threads -->\n</property>\n<property>\n  <name>dfs.client.hedged.read.threshold.millis</name>\n  <value>10</value>  <!-- 10 milliseconds -->\n</property>\n```\n\nUse the following metrics to tune the settings for hedged reads on your cluster. See [HBase Metrics](/docs/operational-management/metrics-and-monitoring) for more information.\n\n**Metrics for Hedged Reads**\n\n* hedgedReadOps - the number of times hedged read threads have been triggered. This could indicate that read requests are often slow, or that hedged reads are triggered too quickly.\n* hedgeReadOpsWin - the number of times the hedged read thread was faster than the original thread. This could indicate that a given RegionServer is having trouble servicing requests.\n* hedgedReadOpsInCurThread - the number of times hedged read was rejected from executor and needed to fallback to be executed in current thread. This could indicate that current hedged read thread pool size is not appropriate.\n\n## Deleting from HBase\n\n### Using HBase Tables as Queues\n\nHBase tables are sometimes used as queues. In this case, special care must be taken to regularly perform major compactions on tables used in this manner. As is documented in [Data Model](/docs/datamodel), marking rows as deleted creates additional StoreFiles which then need to be processed on reads. Tombstones only get cleaned up with major compactions.\n\nSee also [Compaction](/docs/architecture/regions#compaction) and [Admin.majorCompact](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Admin.html#majorCompact\\(org.apache.hadoop.hbase.TableName\\)).\n\n### Delete RPC Behavior\n\nBe aware that `Table.delete(Delete)` doesn't use the writeBuffer. It will execute an RegionServer RPC with each invocation. For a large number of deletes, consider `Table.delete(List)`.\n\nSee [hbase.client.Delete](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html#delete\\(org.apache.hadoop.hbase.client.Delete\\))\n\n## HDFS\n\nBecause HBase runs on [HDFS](/docs/architecture/hdfs) it is important to understand how it works and how it affects HBase.\n\n### Current Issues With Low-Latency Reads\n\nThe original use-case for HDFS was batch processing. As such, there low-latency reads were historically not a priority. With the increased adoption of Apache HBase this is changing, and several improvements are already in development. See the [Umbrella Jira Ticket for HDFS Improvements for HBase](https://issues.apache.org/jira/browse/HDFS-1599).\n\n### Leveraging local data\n\nSince Hadoop 1.0.0 (also 0.22.1, 0.23.1, CDH3u3 and HDP 1.0) via [HDFS-2246](https://issues.apache.org/jira/browse/HDFS-2246), it is possible for the DFSClient to take a \"short circuit\" and read directly from the disk instead of going through the DataNode when the data is local. What this means for HBase is that the RegionServers can read directly off their machine's disks instead of having to open a socket to talk to the DataNode, the former being generally much faster. See JD's [Performance Talk](http://files.meetup.com/1350427/hug_ebay_jdcryans.pdf). Also see [HBase, mail # dev - read short circuit](https://lists.apache.org/thread.html/ce2ce3a3bbd20806d0c017b2e7528e78a46ccb87c063831db051949d%401347548325%40%3Cdev.hbase.apache.org%3E) thread for more discussion around short circuit reads.\n\nTo enable \"short circuit\" reads, it will depend on your version of Hadoop. The original shortcircuit read patch was much improved upon in Hadoop 2 in [HDFS-347](https://issues.apache.org/jira/browse/HDFS-347). See [http://blog.cloudera.com/blog/2013/08/how-improved-short-circuit-local-reads-bring-better-performance-and-security-to-hadoop/](http://blog.cloudera.com/blog/2013/08/how-improved-short-circuit-local-reads-bring-better-performance-and-security-to-hadoop/) for details on the difference between the old and new implementations. See [Hadoop shortcircuit reads configuration page](http://archive.cloudera.com/cdh4/cdh/4/hadoop/hadoop-project-dist/hadoop-hdfs/ShortCircuitLocalReads.html) for how to enable the latter, better version of shortcircuit. For example, here is a minimal config. enabling short-circuit reads added to *hbase-site.xml*:\n\n```xml\n<property>\n  <name>dfs.client.read.shortcircuit</name>\n  <value>true</value>\n  <description>\n    This configuration parameter turns on short-circuit local reads.\n  </description>\n</property>\n<property>\n  <name>dfs.domain.socket.path</name>\n  <value>/home/stack/sockets/short_circuit_read_socket_PORT</value>\n  <description>\n    Optional.  This is a path to a UNIX domain socket that will be used for\n    communication between the DataNode and local HDFS clients.\n    If the string \"_PORT\" is present in this path, it will be replaced by the\n    TCP port of the DataNode.\n  </description>\n</property>\n```\n\nBe careful about permissions for the directory that hosts the shared domain socket; dfsclient will complain if open to other than the hbase user.\n\nIf you are running on an old Hadoop, one that is without [HDFS-347](https://issues.apache.org/jira/browse/HDFS-347) but that has [HDFS-2246](https://issues.apache.org/jira/browse/HDFS-2246), you must set two configurations. First, the hdfs-site.xml needs to be amended. Set the property `dfs.block.local-path-access.user` to be the *only* user that can use the shortcut. This has to be the user that started HBase. Then in hbase-site.xml, set `dfs.client.read.shortcircuit` to be `true`\n\nServices — at least the HBase RegionServers — will need to be restarted in order to pick up the new configurations.\n\n<Callout type=\"info\" title=\"dfs.client.read.shortcircuit.buffer.size\">\n  The default for this value is too high when running on a highly trafficked HBase. In HBase, if\n  this value has not been set, we set it down from the default of 1M to 128k (Since HBase 0.98.0 and\n  0.96.1). See [HBASE-8143 HBase on Hadoop 2 with local short circuit reads (ssr) causes\n  OOM](https://issues.apache.org/jira/browse/HBASE-8143). The Hadoop DFSClient in HBase will\n  allocate a direct byte buffer of this size for *each* block it has open; given HBase keeps its\n  HDFS files open all the time, this can add up quickly.\n</Callout>\n\n### Performance Comparisons of HBase vs. HDFS\n\nA fairly common question on the dist-list is why HBase isn't as performant as HDFS files in a batch context (e.g., as a MapReduce source or sink). The short answer is that HBase is doing a lot more than HDFS (e.g., reading the KeyValues, returning the most current row or specified timestamps, etc.), and as such HBase is 4-5 times slower than HDFS in this processing context. There is room for improvement and this gap will, over time, be reduced, but HDFS will always be faster in this use-case.\n\n## Amazon EC2\n\nPerformance questions are common on Amazon EC2 environments because it is a shared environment. You will not see the same throughput as a dedicated server. In terms of running tests on EC2, run them several times for the same reason (i.e., it's a shared environment and you don't know what else is happening on the server).\n\nIf you are running on EC2 and post performance questions on the dist-list, please state this fact up-front that because EC2 issues are practically a separate class of performance issues.\n\n## Collocating HBase and MapReduce\n\nIt is often recommended to have different clusters for HBase and MapReduce. A better qualification of this is: don't collocate an HBase that serves live requests with a heavy MR workload. OLTP and OLAP-optimized systems have conflicting requirements and one will lose to the other, usually the former. For example, short latency-sensitive disk reads will have to wait in line behind longer reads that are trying to squeeze out as much throughput as possible. MR jobs that write to HBase will also generate flushes and compactions, which will in turn invalidate blocks in the [Block Cache](/docs/architecture/regionserver#architecture-regionserver-block-cache).\n\nIf you need to process the data from your live HBase cluster in MR, you can ship the deltas with [CopyTable](/docs/operational-management/tools#copytable) or use replication to get the new data in real time on the OLAP cluster. In the worst case, if you really need to collocate both, set MR to use less Map and Reduce slots than you'd normally configure, possibly just one.\n\nWhen HBase is used for OLAP operations, it's preferable to set it up in a hardened way like configuring the ZooKeeper session timeout higher and giving more memory to the MemStores (the argument being that the Block Cache won't be used much since the workloads are usually long scans).\n\n## Case Studies\n\nFor Performance and Troubleshooting Case Studies, see [Apache HBase Case Studies](/docs/case-studies).\n\n***\n\n# Profiler Servlet\n\n## Background\n\n[HBASE-21926](https://issues.apache.org/jira/browse/HBASE-21926) introduced a new servlet that\nsupports integrated, on-demand profiling via the\n[Async Profiler](https://github.com/jvm-profiling-tools/async-profiler) project.\n\n## Prerequisites\n\nGo to the [Async Profiler Home Page](https://github.com/jvm-profiling-tools/async-profiler), download\na release appropriate for your platform, and install on every cluster host. If running a Linux\nkernel v4.6 or later, be sure to set proc variables as per the\n[Basic Usage](https://github.com/jvm-profiling-tools/async-profiler#basic-usage) section. Not doing\nso will result in flame graphs that contain no content.\n\nSet `ASYNC_PROFILER_HOME` in the environment (put it in hbase-env.sh) to the root directory of the\nasync-profiler install location, or pass it on the HBase daemon's command line as a system property\nas `-Dasync.profiler.home=/path/to/async-profiler`.\n\n## Usage\n\nOnce the prerequisites are satisfied, access to async-profiler is available by way of the HBase UI\nor direct interaction with the infoserver.\n\nExamples:\n\n* To collect 30 second CPU profile of current process (returns FlameGraph svg)\n  `curl http://localhost:16030/prof`\n* To collect 1 minute CPU profile of current process and output in tree format (html)\n  `curl http://localhost:16030/prof?output=tree&duration=60`\n* To collect 30 second heap allocation profile of current process (returns FlameGraph svg)\n  `curl http://localhost:16030/prof?event=alloc`\n* To collect lock contention profile of current process (returns FlameGraph svg)\n  `curl http://localhost:16030/prof?event=lock`\n\nThe following event types are supported by async-profiler. Use the 'event' parameter to specify. Default is 'cpu'. Not all operating systems will support all types.\n\nPerf events:\n\n* cpu\n* page-faults\n* context-switches\n* cycles\n* instructions\n* cache-references\n* cache-misses\n* branches\n* branch-misses\n* bus-cycles\n* L1-dcache-load-misses\n* LLC-load-misses\n* dTLB-load-misses\n\nJava events:\n\n* alloc\n* lock\n\nThe following output formats are supported. Use the 'output' parameter to specify. Default is 'flamegraph'.\n\nOutput formats:\n\n* summary: A dump of basic profiling statistics.\n* traces: Call traces.\n* flat: Flat profile (top N hot methods).\n* collapsed: Collapsed call traces in the format used by FlameGraph script. This is a collection of call stacks, where each line is a semicolon separated list of frames followed by a counter.\n* svg: FlameGraph in SVG format.\n* tree: Call tree in HTML format.\n* jfr: Call traces in Java Flight Recorder format.\n\nThe 'duration' parameter specifies how long to collect trace data before generating output, specified in seconds. The default is 10 seconds.\n\n## UI\n\nIn the UI, there is a new entry 'Profiler' in the top menu that will run the default action, which is to profile the CPU usage of the local process for thirty seconds and then produce FlameGraph SVG output.\n\n## Notes\n\nThe query parameter `pid` can be used to specify the process id of a specific process to be profiled. If this parameter is missing the local process in which the infoserver is embedded will be profiled. Profile targets that are not JVMs might work but is not specifically supported. There are security implications. Access to the infoserver should be appropriately restricted.\n\n***\n\n# Troubleshooting and Debugging Apache HBase\n\n## General Guidelines\n\nAlways start with the master log (TODO: Which lines?). Normally it's just printing the same lines over and over again. If not, then there's an issue. Google should return some hits for those exceptions you're seeing.\n\nAn error rarely comes alone in Apache HBase, usually when something gets screwed up what will follow may be hundreds of exceptions and stack traces coming from all over the place. The best way to approach this type of problem is to walk the log up to where it all began, for example one trick with RegionServers is that they will print some metrics when aborting so grepping for *Dump* should get you around the start of the problem.\n\nRegionServer suicides are 'normal', as this is what they do when something goes wrong. For example, if ulimit and max transfer threads (the two most important initial settings, see [\\[ulimit\\]](/docs/configuration/basic-prerequisites#limits-on-number-of-files-and-processes-ulimit) and [`dfs.datanode.max.transfer.threads`](/docs/configuration/basic-prerequisites#dfsdatanodemaxtransferthreads)) aren't changed, it will make it impossible at some point for DataNodes to create new threads that from the HBase point of view is seen as if HDFS was gone. Think about what would happen if your MySQL database was suddenly unable to access files on your local file system, well it's the same with HBase and HDFS. Another very common reason to see RegionServers committing seppuku is when they enter prolonged garbage collection pauses that last longer than the default ZooKeeper session timeout. For more information on GC pauses, see the [3 part blog post](https://blog.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/) by Todd Lipcon and [Long GC pauses](/docs/performance#long-gc-pauses) above.\n\n## Logs\n\nThe key process logs are as follows... (replace `<user>` with the user that started the service, and `<hostname>` for the machine name)\n\nNameNode: *\\$HADOOP\\_HOME/logs/hadoop-\\<user>-namenode-\\<hostname>.log*\n\nDataNode: *\\$HADOOP\\_HOME/logs/hadoop-\\<user>-datanode-\\<hostname>.log*\n\nJobTracker: *\\$HADOOP\\_HOME/logs/hadoop-\\<user>-jobtracker-\\<hostname>.log*\n\nTaskTracker: *\\$HADOOP\\_HOME/logs/hadoop-\\<user>-tasktracker-\\<hostname>.log*\n\nHMaster: *\\$HBASE\\_HOME/logs/hbase-\\<user>-master-\\<hostname>.log*\n\nRegionServer: *\\$HBASE\\_HOME/logs/hbase-\\<user>-regionserver-\\<hostname>.log*\n\nZooKeeper: *TODO*\n\n## Log Locations\n\nFor stand-alone deployments the logs are obviously going to be on a single machine, however this is a development configuration only. Production deployments need to run on a cluster.\n\n### NameNode\n\nThe NameNode log is on the NameNode server. The HBase Master is typically run on the NameNode server, and well as ZooKeeper.\n\nFor smaller clusters the JobTracker/ResourceManager is typically run on the NameNode server as well.\n\n### DataNode\n\nEach DataNode server will have a DataNode log for HDFS, as well as a RegionServer log for HBase.\n\nAdditionally, each DataNode server will also have a TaskTracker/NodeManager log for MapReduce task execution.\n\n## Log Levels\n\n### Enabling RPC-level logging\n\nEnabling the RPC-level logging on a RegionServer can often give insight on timings at the server. Once enabled, the amount of log spewed is voluminous. It is not recommended that you leave this logging on for more than short bursts of time. To enable RPC-level logging, browse to the RegionServer UI and click on *Log Level*. Set the log level to `TRACE` for the package `org.apache.hadoop.hbase.ipc`, then tail the RegionServers log. Analyze.\n\nTo disable, set the logging level back to `INFO` level.\n\nThe same log settings also work on Master and for the client.\n\n## JVM Garbage Collection Logs\n\n<Callout type=\"info\">\n  All example Garbage Collection logs in this section are based on Java 8 output. The introduction\n  of Unified Logging in Java 9 and newer will result in very different looking logs.\n</Callout>\n\nHBase is memory intensive, and using the default GC you can see long pauses in all threads including the *Juliet Pause* aka \"GC of Death\". To help debug this or confirm this is happening GC logging can be turned on in the Java virtual machine.\n\nTo enable, in *hbase-env.sh*, uncomment one of the below lines :\n\n```bash\n# This enables basic gc logging to the .out file.\n# export SERVER_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps\"\n\n# This enables basic gc logging to its own file.\n# export SERVER_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<FILE-PATH>\"\n\n# This enables basic GC logging to its own file with automatic log rolling. Only applies to jdk 1.6.0_34+ and 1.7.0_2+.\n# export SERVER_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<FILE-PATH> -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=1 -XX:GCLogFileSize=512M\"\n\n# If <FILE-PATH> is not replaced, the log file(.gc) would be generated in the HBASE_LOG_DIR.\n```\n\nAt this point you should see logs like so:\n\n```text\n64898.952: [GC [1 CMS-initial-mark: 2811538K(3055704K)] 2812179K(3061272K), 0.0007360 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n64898.953: [CMS-concurrent-mark-start]\n64898.971: [GC 64898.971: [ParNew: 5567K->576K(5568K), 0.0101110 secs] 2817105K->2812715K(3061272K), 0.0102200 secs] [Times: user=0.07 sys=0.00, real=0.01 secs]\n```\n\nIn this section, the first line indicates a 0.0007360 second pause for the CMS to initially mark. This pauses the entire VM, all threads for that period of time.\n\nThe third line indicates a \"minor GC\", which pauses the VM for 0.0101110 seconds - aka 10 milliseconds. It has reduced the \"ParNew\" from about 5.5m to 576k. Later on in this cycle we see:\n\n```text\n64901.445: [CMS-concurrent-mark: 1.542/2.492 secs] [Times: user=10.49 sys=0.33, real=2.49 secs]\n64901.445: [CMS-concurrent-preclean-start]\n64901.453: [GC 64901.453: [ParNew: 5505K->573K(5568K), 0.0062440 secs] 2868746K->2864292K(3061272K), 0.0063360 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]\n64901.476: [GC 64901.476: [ParNew: 5563K->575K(5568K), 0.0072510 secs] 2869283K->2864837K(3061272K), 0.0073320 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]\n64901.500: [GC 64901.500: [ParNew: 5517K->573K(5568K), 0.0120390 secs] 2869780K->2865267K(3061272K), 0.0121150 secs] [Times: user=0.09 sys=0.00, real=0.01 secs]\n64901.529: [GC 64901.529: [ParNew: 5507K->569K(5568K), 0.0086240 secs] 2870200K->2865742K(3061272K), 0.0087180 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]\n64901.554: [GC 64901.555: [ParNew: 5516K->575K(5568K), 0.0107130 secs] 2870689K->2866291K(3061272K), 0.0107820 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]\n64901.578: [CMS-concurrent-preclean: 0.070/0.133 secs] [Times: user=0.48 sys=0.01, real=0.14 secs]\n64901.578: [CMS-concurrent-abortable-preclean-start]\n64901.584: [GC 64901.584: [ParNew: 5504K->571K(5568K), 0.0087270 secs] 2871220K->2866830K(3061272K), 0.0088220 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]\n64901.609: [GC 64901.609: [ParNew: 5512K->569K(5568K), 0.0063370 secs] 2871771K->2867322K(3061272K), 0.0064230 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]\n64901.615: [CMS-concurrent-abortable-preclean: 0.007/0.037 secs] [Times: user=0.13 sys=0.00, real=0.03 secs]\n64901.616: [GC[YG occupancy: 645 K (5568 K)]64901.616: [Rescan (parallel) , 0.0020210 secs]64901.618: [weak refs processing, 0.0027950 secs] [1 CMS-remark: 2866753K(3055704K)] 2867399K(3061272K), 0.0049380 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]\n64901.621: [CMS-concurrent-sweep-start]\n```\n\nThe first line indicates that the CMS concurrent mark (finding garbage) has taken 2.4 seconds. But this is a *concurrent* 2.4 seconds, Java has not been paused at any point in time.\n\nThere are a few more minor GCs, then there is a pause at the 2nd last line:\n\n```text\n64901.616: [GC[YG occupancy: 645 K (5568 K)]64901.616: [Rescan (parallel) , 0.0020210 secs]64901.618: [weak refs processing, 0.0027950 secs] [1 CMS-remark: 2866753K(3055704K)] 2867399K(3061272K), 0.0049380 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]\n```\n\nThe pause here is 0.0049380 seconds (aka 4.9 milliseconds) to 'remark' the heap.\n\nAt this point the sweep starts, and you can watch the heap size go down:\n\n```text\n64901.637: [GC 64901.637: [ParNew: 5501K->569K(5568K), 0.0097350 secs] 2871958K->2867441K(3061272K), 0.0098370 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]\n...  lines removed ...\n64904.936: [GC 64904.936: [ParNew: 5532K->568K(5568K), 0.0070720 secs] 1365024K->1360689K(3061272K), 0.0071930 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]\n64904.953: [CMS-concurrent-sweep: 2.030/3.332 secs] [Times: user=9.57 sys=0.26, real=3.33 secs]\n```\n\nAt this point, the CMS sweep took 3.332 seconds, and heap went from about \\~ 2.8 GB to 1.3 GB (approximate).\n\nThe key points here is to keep all these pauses low. CMS pauses are always low, but if your ParNew starts growing, you can see minor GC pauses approach 100ms, exceed 100ms and hit as high at 400ms.\n\nThis can be due to the size of the ParNew, which should be relatively small. If your ParNew is very large after running HBase for a while, in one example a ParNew was about 150MB, then you might have to constrain the size of ParNew (The larger it is, the longer the collections take but if it's too small, objects are promoted to old gen too quickly). In the below we constrain new gen size to 64m.\n\nAdd the below line in *hbase-env.sh*:\n\n```bash\nexport SERVER_GC_OPTS=\"$SERVER_GC_OPTS -XX:NewSize=64m -XX:MaxNewSize=64m\"\n```\n\nSimilarly, to enable GC logging for client processes, uncomment one of the below lines in *hbase-env.sh*:\n\n```bash\n# This enables basic gc logging to the .out file.\n# export CLIENT_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps\"\n\n# This enables basic gc logging to its own file.\n# export CLIENT_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<FILE-PATH>\"\n\n# This enables basic GC logging to its own file with automatic log rolling. Only applies to jdk 1.6.0_34+ and 1.7.0_2+.\n# export CLIENT_GC_OPTS=\"-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<FILE-PATH> -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=1 -XX:GCLogFileSize=512M\"\n\n# If <FILE-PATH> is not replaced, the log file(.gc) would be generated in the HBASE_LOG_DIR .\n```\n\nFor more information on GC pauses, see the [3 part blog post](https://blog.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/) by Todd Lipcon and [Long GC pauses](/docs/performance#long-gc-pauses) above.\n\n## Resources\n\n### Mailing Lists\n\nAsk a question on the [Apache HBase mailing lists](https://hbase.apache.org/mailing-lists.html). The 'dev' mailing list is aimed at the community of developers actually building Apache HBase and for features currently under development, and 'user' is generally used for questions on released versions of Apache HBase. Before going to the mailing list, make sure your question has not already been answered by searching the mailing list archives first. For those who prefer to communicate in Chinese, they can use the 'user-zh' mailing list instead of the 'user' list. Take some time crafting your question. See [Getting Answers](http://www.mikeash.com/getting_answers.html) for ideas on crafting good questions. A quality question that includes all context and exhibits evidence the author has tried to find answers in the manual and out on lists is more likely to get a prompt response.\n\n### Slack\n\n\\#hbase on [https://the-asf.slack.com/](https://the-asf.slack.com/)\n\n### IRC\n\n(You will probably get a more prompt response on the Slack channel)\n\n\\#hbase on irc.freenode.net\n\n### JIRA\n\n[JIRA](https://issues.apache.org/jira/browse/HBASE) is also really helpful when looking for Hadoop/HBase-specific issues.\n\n## Tools\n\n### Builtin Tools\n\n#### Master Web Interface\n\nThe Master starts a web-interface on port 16010 by default.\n\nThe Master web UI lists created tables and their definition (e.g., ColumnFamilies, blocksize, etc.). Additionally, the available RegionServers in the cluster are listed along with selected high-level metrics (requests, number of regions, usedHeap, maxHeap). The Master web UI allows navigation to each RegionServer's web UI.\n\n#### RegionServer Web Interface\n\nRegionServers starts a web-interface on port 16030 by default.\n\nThe RegionServer web UI lists online regions and their start/end keys, as well as point-in-time RegionServer metrics (requests, regions, storeFileIndexSize, compactionQueueSize, etc.).\n\nSee [HBase Metrics](/docs/operational-management/metrics-and-monitoring) for more information in metric definitions.\n\n#### zkcli\n\n`zkcli` is a very useful tool for investigating ZooKeeper-related issues. To invoke:\n\n```bash\n./hbase zkcli -server host:port <cmd> <args>\n```\n\nThe commands (and arguments) are:\n\n```text\n  connect host:port\n  get path [watch]\n  ls path [watch]\n  set path data [version]\n  delquota [-n|-b] path\n  quit\n  printwatches on|off\n  create [-s] [-e] path data acl\n  stat path [watch]\n  close\n  ls2 path [watch]\n  history\n  listquota path\n  setAcl path acl\n  getAcl path\n  sync path\n  redo cmdno\n  addauth scheme auth\n  delete path [version]\n  setquota -n|-b val path\n```\n\n#### Maintenance Mode\n\nIf the cluster has gotten stuck in some state and the standard techniques aren't making progress, it is possible to restart the cluster in \"maintenance mode.\" This mode features drastically reduced capabilities and surface area, making it easier to enact very low-level changes such as repairing/recovering the `hbase:meta` table.\n\nTo enter maintenance mode, set `hbase.master.maintenance_mode` to `true` either in your `hbase-site.xml` or via system propery when starting the master process (`-D...=true`). Entering and exiting this mode requires a service restart, however the typical use will be when HBase Master is already facing startup difficulties.\n\nWhen maintenance mode is enabled, the master will host all system tables - ensure that it has enough memory to do so. RegionServers will not be assigned any regions from user-space tables; in fact, they will go completely unused while in maintenance mode. Additionally, the master will not load any coprocessors, will not run any normalization or merge/split operations, and will not enforce quotas.\n\n### External Tools\n\n#### tail\n\n`tail` is the command line tool that lets you look at the end of a file. Add the `-f` option and it will refresh when new data is available. It's useful when you are wondering what's happening, for example, when a cluster is taking a long time to shutdown or startup as you can just fire a new terminal and tail the master log (and maybe a few RegionServers).\n\n#### top\n\n`top` is probably one of the most important tools when first trying to see what's running on a machine and how the resources are consumed. Here's an example from production system:\n\n```text\ntop - 14:46:59 up 39 days, 11:55,  1 user,  load average: 3.75, 3.57, 3.84\nTasks: 309 total,   1 running, 308 sleeping,   0 stopped,   0 zombie\nCpu(s):  4.5%us,  1.6%sy,  0.0%ni, 91.7%id,  1.4%wa,  0.1%hi,  0.6%si,  0.0%st\nMem:  24414432k total, 24296956k used,   117476k free,     7196k buffers\nSwap: 16008732k total,  14348k used, 15994384k free, 11106908k cached\n\n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM  TIME+  COMMAND\n15558 hadoop    18  -2 3292m 2.4g 3556 S   79 10.4   6523:52 java\n13268 hadoop    18  -2 8967m 8.2g 4104 S   21 35.1   5170:30 java\n 8895 hadoop    18  -2 1581m 497m 3420 S   11  2.1   4002:32 java\n...\n```\n\nHere we can see that the system load average during the last five minutes is 3.75, which very roughly means that on average 3.75 threads were waiting for CPU time during these 5 minutes. In general, the *perfect* utilization equals to the number of cores, under that number the machine is under utilized and over that the machine is over utilized. This is an important concept, see this article to understand it more: [http://www.linuxjournal.com/article/9001](http://www.linuxjournal.com/article/9001).\n\nApart from load, we can see that the system is using almost all its available RAM but most of it is used for the OS cache (which is good). The swap only has a few KBs in it and this is wanted, high numbers would indicate swapping activity which is the nemesis of performance of Java systems. Another way to detect swapping is when the load average goes through the roof (although this could also be caused by things like a dying disk, among others).\n\nThe list of processes isn't super useful by default, all we know is that 3 java processes are using about 111% of the CPUs. To know which is which, simply type `c` and each line will be expanded. Typing `1` will give you the detail of how each CPU is used instead of the average for all of them like shown here.\n\n#### jps\n\n`jps` is shipped with every JDK and gives the java process ids for the current user (if root, then it gives the ids for all users). Example:\n\n```bash\nhadoop@sv4borg12:~$ jps\n1322 TaskTracker\n17789 HRegionServer\n27862 Child\n1158 DataNode\n25115 HQuorumPeer\n2950 Jps\n19750 ThriftServer\n18776 jmx\n```\n\nIn order, we see a:\n\n* Hadoop TaskTracker, manages the local Childs\n* HBase RegionServer, serves regions\n* Child, its MapReduce task, cannot tell which type exactly\n* Hadoop TaskTracker, manages the local Childs\n* Hadoop DataNode, serves blocks\n* HQuorumPeer, a ZooKeeper ensemble member\n* Jps, well... it's the current process\n* ThriftServer, it's a special one will be running only if thrift was started\n* jmx, this is a local process that's part of our monitoring platform ( poorly named maybe). You probably don't have that.\n\nYou can then do stuff like checking out the full command line that started the process:\n\n```bash\nhadoop@sv4borg12:~$ ps aux | grep HRegionServer\nhadoop   17789  155 35.2 9067824 8604364 ?     S<l  Mar04 9855:48 /usr/java/jdk1.6.0_14/bin/java -Xmx8000m -XX:+DoEscapeAnalysis -XX:+AggressiveOpts -XX:+UseConcMarkSweepGC -XX:NewSize=64m -XX:MaxNewSize=64m -XX:CMSInitiatingOccupancyFraction=88 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/export1/hadoop/logs/gc-hbase.log -Dcom.sun.management.jmxremote.port=10102 -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.password.file=/home/hadoop/hbase/conf/jmxremote.password -Dcom.sun.management.jmxremote -Dhbase.log.dir=/export1/hadoop/logs -Dhbase.log.file=hbase-hadoop-regionserver-sv4borg12.log -Dhbase.home.dir=/home/hadoop/hbase -Dhbase.id.str=hadoop -Dhbase.root.logger=INFO,DRFA -Djava.library.path=/home/hadoop/hbase/lib/native/Linux-amd64-64 -classpath /home/hadoop/hbase/bin/../conf:[many jars]:/home/hadoop/hadoop/conf org.apache.hadoop.hbase.regionserver.HRegionServer start\n```\n\n#### jstack\n\n`jstack` is one of the most important tools when trying to figure out what a java process is doing apart from looking at the logs. It has to be used in conjunction with jps in order to give it a process id. It shows a list of threads, each one has a name, and they appear in the order that they were created (so the top ones are the most recent threads). Here are a few example:\n\nThe main thread of a RegionServer waiting for something to do from the master:\n\n```text\n\"regionserver60020\" prio=10 tid=0x0000000040ab4000 nid=0x45cf waiting on condition [0x00007f16b6a96000..0x00007f16b6a96a70]\njava.lang.Thread.State: TIMED_WAITING (parking)\n    at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00007f16cd5c2f30> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:1963)\n    at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:395)\n    at org.apache.hadoop.hbase.regionserver.HRegionServer.run(HRegionServer.java:647)\n    at java.lang.Thread.run(Thread.java:619)\n```\n\nThe MemStore flusher thread that is currently flushing to a file:\n\n```text\n\"regionserver60020.cacheFlusher\" daemon prio=10 tid=0x0000000040f4e000 nid=0x45eb in Object.wait() [0x00007f16b5b86000..0x00007f16b5b87af0]\njava.lang.Thread.State: WAITING (on object monitor)\n    at java.lang.Object.wait(Native Method)\n    at java.lang.Object.wait(Object.java:485)\n    at org.apache.hadoop.ipc.Client.call(Client.java:803)\n        - locked <0x00007f16cb14b3a8> (a org.apache.hadoop.ipc.Client$Call)\n    at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:221)\n    at $Proxy1.complete(Unknown Source)\n    at sun.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:82)\n    at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:59)\n    at $Proxy1.complete(Unknown Source)\n    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.closeInternal(DFSClient.java:3390)\n        - locked <0x00007f16cb14b470> (a org.apache.hadoop.hdfs.DFSClient$DFSOutputStream)\n    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.close(DFSClient.java:3304)\n    at org.apache.hadoop.fs.FSDataOutputStream$PositionCache.close(FSDataOutputStream.java:61)\n    at org.apache.hadoop.fs.FSDataOutputStream.close(FSDataOutputStream.java:86)\n    at org.apache.hadoop.hbase.io.hfile.HFile$Writer.close(HFile.java:650)\n    at org.apache.hadoop.hbase.regionserver.StoreFile$Writer.close(StoreFile.java:853)\n    at org.apache.hadoop.hbase.regionserver.Store.internalFlushCache(Store.java:467)\n        - locked <0x00007f16d00e6f08> (a java.lang.Object)\n    at org.apache.hadoop.hbase.regionserver.Store.flushCache(Store.java:427)\n    at org.apache.hadoop.hbase.regionserver.Store.access$100(Store.java:80)\n    at org.apache.hadoop.hbase.regionserver.Store$StoreFlusherImpl.flushCache(Store.java:1359)\n    at org.apache.hadoop.hbase.regionserver.HRegion.internalFlushcache(HRegion.java:907)\n    at org.apache.hadoop.hbase.regionserver.HRegion.internalFlushcache(HRegion.java:834)\n    at org.apache.hadoop.hbase.regionserver.HRegion.flushcache(HRegion.java:786)\n    at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.flushRegion(MemStoreFlusher.java:250)\n    at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.flushRegion(MemStoreFlusher.java:224)\n    at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.run(MemStoreFlusher.java:146)\n```\n\nA handler thread that's waiting for stuff to do (like put, delete, scan, etc.):\n\n```text\n\"IPC Server handler 16 on 60020\" daemon prio=10 tid=0x00007f16b011d800 nid=0x4a5e waiting on condition [0x00007f16afefd000..0x00007f16afefd9f0]\n   java.lang.Thread.State: WAITING (parking)\n          at sun.misc.Unsafe.park(Native Method)\n              - parking to wait for  <0x00007f16cd3f8dd8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n          at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158)\n          at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1925)\n          at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:358)\n          at org.apache.hadoop.hbase.ipc.HBaseServer$Handler.run(HBaseServer.java:1013)\n```\n\nAnd one that's busy doing an increment of a counter (it's in the phase where it's trying to create a scanner in order to read the last value):\n\n```text\n\"IPC Server handler 66 on 60020\" daemon prio=10 tid=0x00007f16b006e800 nid=0x4a90 runnable [0x00007f16acb77000..0x00007f16acb77cf0]\n   java.lang.Thread.State: RUNNABLE\n          at org.apache.hadoop.hbase.regionserver.KeyValueHeap.<init>(KeyValueHeap.java:56)\n          at org.apache.hadoop.hbase.regionserver.StoreScanner.<init>(StoreScanner.java:79)\n          at org.apache.hadoop.hbase.regionserver.Store.getScanner(Store.java:1202)\n          at org.apache.hadoop.hbase.regionserver.HRegion$RegionScanner.<init>(HRegion.java:2209)\n          at org.apache.hadoop.hbase.regionserver.HRegion.instantiateInternalScanner(HRegion.java:1063)\n          at org.apache.hadoop.hbase.regionserver.HRegion.getScanner(HRegion.java:1055)\n          at org.apache.hadoop.hbase.regionserver.HRegion.getScanner(HRegion.java:1039)\n          at org.apache.hadoop.hbase.regionserver.HRegion.getLastIncrement(HRegion.java:2875)\n          at org.apache.hadoop.hbase.regionserver.HRegion.incrementColumnValue(HRegion.java:2978)\n          at org.apache.hadoop.hbase.regionserver.HRegionServer.incrementColumnValue(HRegionServer.java:2433)\n          at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)\n          at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n          at java.lang.reflect.Method.invoke(Method.java:597)\n          at org.apache.hadoop.hbase.ipc.HBaseRPC$Server.call(HBaseRPC.java:560)\n          at org.apache.hadoop.hbase.ipc.HBaseServer$Handler.run(HBaseServer.java:1027)\n```\n\nA thread that receives data from HDFS:\n\n```text\n\"IPC Client (47) connection to sv4borg9/10.4.24.40:9000 from hadoop\" daemon prio=10 tid=0x00007f16a02d0000 nid=0x4fa3 runnable [0x00007f16b517d000..0x00007f16b517dbf0]\n   java.lang.Thread.State: RUNNABLE\n          at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)\n          at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:215)\n          at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:65)\n          at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:69)\n              - locked <0x00007f17d5b68c00> (a sun.nio.ch.Util$1)\n              - locked <0x00007f17d5b68be8> (a java.util.Collections$UnmodifiableSet)\n              - locked <0x00007f1877959b50> (a sun.nio.ch.EPollSelectorImpl)\n          at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:80)\n          at org.apache.hadoop.net.SocketIOWithTimeout$SelectorPool.select(SocketIOWithTimeout.java:332)\n          at org.apache.hadoop.net.SocketIOWithTimeout.doIO(SocketIOWithTimeout.java:157)\n          at org.apache.hadoop.net.SocketInputStream.read(SocketInputStream.java:155)\n          at org.apache.hadoop.net.SocketInputStream.read(SocketInputStream.java:128)\n          at java.io.FilterInputStream.read(FilterInputStream.java:116)\n          at org.apache.hadoop.ipc.Client$Connection$PingInputStream.read(Client.java:304)\n          at java.io.BufferedInputStream.fill(BufferedInputStream.java:218)\n          at java.io.BufferedInputStream.read(BufferedInputStream.java:237)\n              - locked <0x00007f1808539178> (a java.io.BufferedInputStream)\n          at java.io.DataInputStream.readInt(DataInputStream.java:370)\n          at org.apache.hadoop.ipc.Client$Connection.receiveResponse(Client.java:569)\n          at org.apache.hadoop.ipc.Client$Connection.run(Client.java:477)\n```\n\nAnd here is a master trying to recover a lease after a RegionServer died:\n\n```text\n\"LeaseChecker\" daemon prio=10 tid=0x00000000407ef800 nid=0x76cd waiting on condition [0x00007f6d0eae2000..0x00007f6d0eae2a70]\n--\n   java.lang.Thread.State: WAITING (on object monitor)\n          at java.lang.Object.wait(Native Method)\n          at java.lang.Object.wait(Object.java:485)\n          at org.apache.hadoop.ipc.Client.call(Client.java:726)\n          - locked <0x00007f6d1cd28f80> (a org.apache.hadoop.ipc.Client$Call)\n          at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:220)\n          at $Proxy1.recoverBlock(Unknown Source)\n          at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.processDatanodeError(DFSClient.java:2636)\n          at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.<init>(DFSClient.java:2832)\n          at org.apache.hadoop.hdfs.DFSClient.append(DFSClient.java:529)\n          at org.apache.hadoop.hdfs.DistributedFileSystem.append(DistributedFileSystem.java:186)\n          at org.apache.hadoop.fs.FileSystem.append(FileSystem.java:530)\n          at org.apache.hadoop.hbase.util.FSUtils.recoverFileLease(FSUtils.java:619)\n          at org.apache.hadoop.hbase.regionserver.wal.HLog.splitLog(HLog.java:1322)\n          at org.apache.hadoop.hbase.regionserver.wal.HLog.splitLog(HLog.java:1210)\n          at org.apache.hadoop.hbase.master.HMaster.splitLogAfterStartup(HMaster.java:648)\n          at org.apache.hadoop.hbase.master.HMaster.joinCluster(HMaster.java:572)\n          at org.apache.hadoop.hbase.master.HMaster.run(HMaster.java:503)\n```\n\n#### OpenTSDB\n\n[OpenTSDB](http://opentsdb.net) is an excellent alternative to Ganglia as it uses Apache HBase to store all the time series and doesn't have to downsample. Monitoring your own HBase cluster that hosts OpenTSDB is a good exercise.\n\nHere's an example of a cluster that's suffering from hundreds of compactions launched almost all around the same time, which severely affects the IO performance: (TODO: insert graph plotting compactionQueueSize)\n\nIt's a good practice to build dashboards with all the important graphs per machine and per cluster so that debugging issues can be done with a single quick look. For example, at StumbleUpon there's one dashboard per cluster with the most important metrics from both the OS and Apache HBase. You can then go down at the machine level and get even more detailed metrics.\n\n#### clusterssh+top\n\nclusterssh+top, it's like a poor man's monitoring system and it can be quite useful when you have only a few machines as it's very easy to setup. Starting clusterssh will give you one terminal per machine and another terminal in which whatever you type will be retyped in every window. This means that you can type `top` once and it will start it for all of your machines at the same time giving you full view of the current state of your cluster. You can also tail all the logs at the same time, edit files, etc.\n\n## Client\n\nFor more information on the HBase client, see [client](/docs/architecture/client).\n\n### ScannerTimeoutException or UnknownScannerException \\[!toc]\n\nThis is thrown if the time between RPC calls from the client to RegionServer exceeds the scan timeout. For example, if `Scan.setCaching` is set to 500, then there will be an RPC call to fetch the next batch of rows every 500 `.next()` calls on the ResultScanner because data is being transferred in blocks of 500 rows to the client. Reducing the setCaching value may be an option, but setting this value too low makes for inefficient processing on numbers of rows.\n\nSee [Scan Caching](/docs/performance#scan-caching).\n\n### Performance Differences in Thrift and Java APIs \\[!toc]\n\nPoor performance, or even `ScannerTimeoutExceptions`, can occur if `Scan.setCaching` is too high, as discussed in [ScannerTimeoutException or UnknownScannerException](/docs/troubleshooting#scannertimeoutexception-or-unknownscannerexception). If the Thrift client uses the wrong caching settings for a given workload, performance can suffer compared to the Java API. To set caching for a given scan in the Thrift client, use the `scannerGetList(scannerId, numRows)` method, where `numRows` is an integer representing the number of rows to cache. In one case, it was found that reducing the cache for Thrift scans from 1000 to 100 increased performance to near parity with the Java API given the same queries.\n\nSee also Jesse Andersen's [blog post](http://blog.cloudera.com/blog/2014/04/how-to-use-the-hbase-thrift-interface-part-3-using-scans/) about using Scans with Thrift.\n\n### `LeaseException` when calling `Scanner.next` \\[!toc]\n\nIn some situations clients that fetch data from a RegionServer get a LeaseException instead of the usual [ScannerTimeoutException or UnknownScannerException](/docs/troubleshooting#scannertimeoutexception-or-unknownscannerexception). Usually the source of the exception is `org.apache.hadoop.hbase.regionserver.Leases.removeLease(Leases.java:230)` (line number may vary). It tends to happen in the context of a slow/freezing `RegionServer#next` call. It can be prevented by having `hbase.rpc.timeout` > `hbase.client.scanner.timeout.period`. Harsh J investigated the issue as part of the mailing list thread [HBase, mail # user - Lease does not exist exceptions](https://mail-archives.apache.org/mod_mbox/hbase-user/201209.mbox/%3CCAOcnVr3R-LqtKhFsk8Bhrm-YW2i9O6J6Fhjz2h7q6_sxvwd2yw%40mail.gmail.com%3E)\n\n### Shell or client application throws lots of scary exceptions during normal operation \\[!toc]\n\nSince 0.20.0 the default log level for `org.apache.hadoop.hbase.*` is DEBUG.\n\nOn your clients, edit *\\$HBASE\\_HOME/conf/log4j.properties* and change this: `log4j.logger.org.apache.hadoop.hbase=DEBUG` to this: `log4j.logger.org.apache.hadoop.hbase=INFO`, or even `log4j.logger.org.apache.hadoop.hbase=WARN`.\n\n### Long Client Pauses With Compression \\[!toc]\n\nThis is a fairly frequent question on the Apache HBase dist-list. The scenario is that a client is typically inserting a lot of data into a relatively un-optimized HBase cluster. Compression can exacerbate the pauses, although it is not the source of the problem.\n\nSee [Table Creation: Pre-Creating Regions](/docs/performance#table-creation-pre-creating-regions) on the pattern for pre-creating regions and confirm that the table isn't starting with a single region.\n\nSee [HBase Configurations](/docs/performance#hbase-configurations) for cluster configuration, particularly `hbase.hstore.blockingStoreFiles`, `hbase.hregion.memstore.block.multiplier`, `MAX_FILESIZE` (region size), and `MEMSTORE_FLUSHSIZE.`\n\nA slightly longer explanation of why pauses can happen is as follows: Puts are sometimes blocked on the MemStores which are blocked by the flusher thread which is blocked because there are too many files to compact because the compactor is given too many small files to compact and has to compact the same data repeatedly. This situation can occur even with minor compactions. Compounding this situation, Apache HBase doesn't compress data in memory. Thus, the 64MB that lives in the MemStore could become a 6MB file after compression - which results in a smaller StoreFile. The upside is that more data is packed into the same region, but performance is achieved by being able to write larger files - which is why HBase waits until the flushsize before writing a new StoreFile. And smaller StoreFiles become targets for compaction. Without compression the files are much bigger and don't need as much compaction, however this is at the expense of I/O.\n\n### Secure Client Connect (\\[Caused by GSSException: No valid credentials provided...]) \\[!toc]\n\nYou may encounter the following error:\n\n```text\nSecure Client Connect ([Caused by GSSException: No valid credentials provided\n        (Mechanism level: Request is a replay (34) V PROCESS_TGS)])\n```\n\nThis issue is caused by bugs in the MIT Kerberos replay\\_cache component, [#1201](http://krbdev.mit.edu/rt/Ticket/Display.html?id=1201) and [#5924](http://krbdev.mit.edu/rt/Ticket/Display.html?id=5924). These bugs caused the old version of krb5-server to erroneously block subsequent requests sent from a Principal. This caused krb5-server to block the connections sent from one Client (one HTable instance with multi-threading connection instances for each RegionServer); Messages, such as `Request is a replay (34)`, are logged in the client log You can ignore the messages, because HTable will retry 5 \\* 10 (50) times for each failed connection by default. HTable will throw IOException if any connection to the RegionServer fails after the retries, so that the user client code for HTable instance can handle it further. NOTE: `HTable` is deprecated in HBase 1.0, in favor of `Table`.\n\nAlternatively, update krb5-server to a version which solves these issues, such as krb5-server-1.10.3. See JIRA [HBASE-10379](https://issues.apache.org/jira/browse/HBASE-10379) for more details.\n\n### ZooKeeper Client Connection Errors \\[!toc]\n\nErrors like this...\n\n```text\n11/07/05 11:26:41 WARN zookeeper.ClientCnxn: Session 0x0 for server null,\n unexpected error, closing socket connection and attempting reconnect\n java.net.ConnectException: Connection refused: no further information\n        at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)\n        at sun.nio.ch.SocketChannelImpl.finishConnect(Unknown Source)\n        at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1078)\n 11/07/05 11:26:43 INFO zookeeper.ClientCnxn: Opening socket connection to\n server localhost/127.0.0.1:2181\n 11/07/05 11:26:44 WARN zookeeper.ClientCnxn: Session 0x0 for server null,\n unexpected error, closing socket connection and attempting reconnect\n java.net.ConnectException: Connection refused: no further information\n        at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)\n        at sun.nio.ch.SocketChannelImpl.finishConnect(Unknown Source)\n        at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1078)\n 11/07/05 11:26:45 INFO zookeeper.ClientCnxn: Opening socket connection to\n server localhost/127.0.0.1:2181\n```\n\n...are either due to ZooKeeper being down, or unreachable due to network issues.\n\nThe utility [zkcli](/docs/troubleshooting#zkcli) may help investigate ZooKeeper issues.\n\n### Client running out of memory though heap size seems to be stable (but the off-heap/direct heap keeps growing) \\[!toc]\n\nYou are likely running into the issue that is described and worked through in the mail thread [HBase, mail # user - Suspected memory leak](https://lists.apache.org/thread.html/d12bbe56be95cf68478d1528263042730670ff39159a01eaf06d8bc8%401322622090%40%3Cuser.hbase.apache.org%3E) and continued over in [HBase, mail # dev - FeedbackRe: Suspected memory leak](https://lists.apache.org/thread.html/621dde35479215f0b07b23af93b8fac52ff4729949b5c9af18e3a85b%401322971078%40%3Cuser.hbase.apache.org%3E). A workaround is passing your client-side JVM a reasonable value for `-XX:MaxDirectMemorySize`. By default, the `MaxDirectMemorySize` is equal to your `-Xmx` max heapsize setting (if `-Xmx` is set). Try setting it to something smaller (for example, one user had success setting it to `1g` when they had a client-side heap of `12g`). If you set it too small, it will bring on `FullGCs` so keep it a bit hefty. You want to make this setting client-side only especially if you are running the new experimental server-side off-heap cache since this feature depends on being able to use big direct buffers (You may have to keep separate client-side and server-side config dirs).\n\n### Secure Client Cannot Connect (\\[Caused by GSSException: No valid credentials provided(Mechanism level: Failed to find any Kerberos tgt)]) \\[!toc]\n\nThere can be several causes that produce this symptom.\n\nFirst, check that you have a valid Kerberos ticket. One is required in order to set up communication with a secure Apache HBase cluster. Examine the ticket currently in the credential cache, if any, by running the `klist` command line utility. If no ticket is listed, you must obtain a ticket by running the `kinit` command with either a keytab specified, or by interactively entering a password for the desired principal.\n\nThen, consult the [Java Security Guide troubleshooting section](http://docs.oracle.com/javase/1.5.0/docs/guide/security/jgss/tutorials/Troubleshooting.html). The most common problem addressed there is resolved by setting `javax.security.auth.useSubjectCredsOnly` system property value to `false`.\n\nBecause of a change in the format in which MIT Kerberos writes its credentials cache, there is a bug in the Oracle JDK 6 Update 26 and earlier that causes Java to be unable to read the Kerberos credentials cache created by versions of MIT Kerberos 1.8.1 or higher. If you have this problematic combination of components in your environment, to work around this problem, first log in with `kinit` and then immediately refresh the credential cache with `kinit -R`. The refresh will rewrite the credential cache without the problematic formatting.\n\nPrior to JDK 1.4, the JCE was an unbundled product, and as such, the JCA and JCE were regularly referred to as separate, distinct components. As JCE is now bundled in the JDK 7.0, the distinction is becoming less apparent. Since the JCE uses the same architecture as the JCA, the JCE should be more properly thought of as a part of the JCA.\n\nYou may need to install the [Java Cryptography Extension](https://docs.oracle.com/javase/1.5.0/docs/guide/security/jce/JCERefGuide.html), or JCE because of JDK 1.5 or earlier version. Insure the JCE jars are on the classpath on both server and client systems.\n\nYou may also need to download the [unlimited strength JCE policy files](http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html). Uncompress and extract the downloaded file, and install the policy jars into *\\<java-home>/lib/security*.\n\n### Trouble shooting master registry issues \\[!toc]\n\n* For connectivity issues, usually an exception like \"MasterRegistryFetchException: Exception making rpc to masters...\" is logged in the client logs. The logging includes the list of master end points that were attempted by the client. The bottom part of the stack trace should include the underlying reason. If you suspect connectivity issues (ConnectionRefused?), make sure the master end points are accessible from client.\n* If there is a suspicion of higher load on the masters due to hedging of RPCs, it can be controlled by either reducing the hedging fan out (via *hbase.rpc.hedged.fanout*) or by restricting the set of masters that clients can access for the master registry purposes (via *hbase.masters*).\n\nRefer to [Master Registry (new as of 2.3.0)](/docs/architecture/client#masterregistry-rpc-hedging) and [Client configuration and dependencies connecting to an HBase cluster](/docs/configuration/default#client-configuration-and-dependencies-connecting-to-an-hbase-cluster) for more details.\n\n## MapReduce\n\n### You Think You're On The Cluster, But You're Actually Local \\[!toc]\n\nThis following stacktrace happened using `ImportTsv`, but things like this can happen on any job with a mis-configuration.\n\n```text\n    WARN mapred.LocalJobRunner: job_local_0001\njava.lang.IllegalArgumentException: Can't read partitions file\n       at org.apache.hadoop.hbase.mapreduce.hadoopbackport.TotalOrderPartitioner.setConf(TotalOrderPartitioner.java:111)\n       at org.apache.hadoop.util.ReflectionUtils.setConf(ReflectionUtils.java:62)\n       at org.apache.hadoop.util.ReflectionUtils.newInstance(ReflectionUtils.java:117)\n       at org.apache.hadoop.mapred.MapTask$NewOutputCollector.<init>(MapTask.java:560)\n       at org.apache.hadoop.mapred.MapTask.runNewMapper(MapTask.java:639)\n       at org.apache.hadoop.mapred.MapTask.run(MapTask.java:323)\n       at org.apache.hadoop.mapred.LocalJobRunner$Job.run(LocalJobRunner.java:210)\nCaused by: java.io.FileNotFoundException: File _partition.lst does not exist.\n       at org.apache.hadoop.fs.RawLocalFileSystem.getFileStatus(RawLocalFileSystem.java:383)\n       at org.apache.hadoop.fs.FilterFileSystem.getFileStatus(FilterFileSystem.java:251)\n       at org.apache.hadoop.fs.FileSystem.getLength(FileSystem.java:776)\n       at org.apache.hadoop.io.SequenceFile$Reader.<init>(SequenceFile.java:1424)\n       at org.apache.hadoop.io.SequenceFile$Reader.<init>(SequenceFile.java:1419)\n       at org.apache.hadoop.hbase.mapreduce.hadoopbackport.TotalOrderPartitioner.readPartitions(TotalOrderPartitioner.java:296)\n```\n\n...see the critical portion of the stack? It's...\n\n```text\nat org.apache.hadoop.mapred.LocalJobRunner$Job.run(LocalJobRunner.java:210)\n```\n\nLocalJobRunner means the job is running locally, not on the cluster.\n\nTo solve this problem, you should run your MR job with your `HADOOP_CLASSPATH` set to include the HBase dependencies. The \"hbase classpath\" utility can be used to do this easily. For example (substitute VERSION with your HBase version):\n\n```bash\nHADOOP_CLASSPATH=`hbase classpath` hadoop jar $HBASE_HOME/hbase-mapreduce-VERSION.jar rowcounter usertable\n```\n\nSee [HBase, MapReduce, and the CLASSPATH](/docs/mapreduce#hbase-mapreduce-and-the-classpath) for more information on HBase MapReduce jobs and classpaths.\n\n### Launching a job, you get java.lang.IllegalAccessError: com/google/protobuf/HBaseZeroCopyByteString or class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString \\[!toc]\n\nSee [HBASE-10304 Running an hbase job jar: IllegalAccessError: class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString](https://issues.apache.org/jira/browse/HBASE-10304) and [HBASE-11118 non environment variable solution for \"IllegalAccessError: class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString\"](https://issues.apache.org/jira/browse/HBASE-11118). The issue can also show up when trying to run spark jobs. See [HBASE-10877 HBase non-retriable exception list should be expanded](https://issues.apache.org/jira/browse/HBASE-10877).\n\n## NameNode\n\nFor more information on the NameNode, see [HDFS](/docs/architecture/hdfs).\n\n### HDFS Utilization of Tables and Regions\n\nTo determine how much space HBase is using on HDFS use the `hadoop` shell commands from the NameNode. For example...\n\n```bash\nhadoop fs -dus /hbase/\n```\n\n...returns the summarized disk utilization for all HBase objects.\n\n```bash\nhadoop fs -dus /hbase/myTable\n```\n\n...returns the summarized disk utilization for the HBase table 'myTable'.\n\n```bash\nhadoop fs -du /hbase/myTable\n```\n\n...returns a list of the regions under the HBase table 'myTable' and their disk utilization.\n\nFor more information on HDFS shell commands, see the [HDFS FileSystem Shell documentation](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/FileSystemShell.html).\n\n### Browsing HDFS for HBase Objects\n\nSometimes it will be necessary to explore the HBase objects that exist on HDFS. These objects could include the WALs (Write Ahead Logs), tables, regions, StoreFiles, etc. The easiest way to do this is with the NameNode web application that runs on port 50070. The NameNode web application will provide links to the all the DataNodes in the cluster so that they can be browsed seamlessly.\n\nThe HDFS directory structure of HBase tables in the cluster is...\n\n```text\n/hbase\n    /data\n        /<Namespace>                    (Namespaces in the cluster)\n            /<Table>                    (Tables in the cluster)\n                /<Region>               (Regions for the table)\n                    /<ColumnFamily>     (ColumnFamilies for the Region for the table)\n                        /<StoreFile>    (StoreFiles for the ColumnFamily for the Regions for the table)\n```\n\nThe HDFS directory structure of HBase WAL is..\n\n```text\n/hbase\n    /WALs\n        /<RegionServer>    (RegionServers)\n            /<WAL>         (WAL files for the RegionServer)\n```\n\nSee the [HDFS User Guide](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html) for other non-shell diagnostic utilities like `fsck`.\n\n#### Zero size WALs with data in them \\[!toc]\n\nProblem: when getting a listing of all the files in a RegionServer's *WALs* directory, one file has a size of 0 but it contains data.\n\nAnswer: It's an HDFS quirk. A file that's currently being written to will appear to have a size of 0 but once it's closed it will show its true size\n\n#### Use Cases \\[!toc]\n\nTwo common use-cases for querying HDFS for HBase objects is research the degree of uncompaction of a table. If there are a large number of StoreFiles for each ColumnFamily it could indicate the need for a major compaction. Additionally, after a major compaction if the resulting StoreFile is \"small\" it could indicate the need for a reduction of ColumnFamilies for the table.\n\n### Unexpected Filesystem Growth\n\nIf you see an unexpected spike in filesystem usage by HBase, two possible culprits are snapshots and WALs.\n\n**Snapshots**\\\nWhen you create a snapshot, HBase retains everything it needs to recreate the table's state at that time of the snapshot. This includes deleted cells or expired versions. For this reason, your snapshot usage pattern should be well-planned, and you should prune snapshots that you no longer need. Snapshots are stored in `/hbase/.hbase-snapshot`, and archives needed to restore snapshots are stored in `/hbase/archive/<tablename>/<region>/<column_family>/`.\n\n<Callout type=\"warn\">\n  **Do not** manage snapshots or archives manually via HDFS. HBase provides APIs and HBase Shell\n  commands for managing them. For more information, see\n  [ops.snapshots](/docs/operational-management/backup-and-snapshots#hbase-snapshots).\n</Callout>\n\n**WAL**\\\nWrite-ahead logs (WALs) are stored in subdirectories of the HBase root directory, typically `/hbase/`, depending on their status. Already-processed WALs are stored in `/hbase/oldWALs/` and corrupt WALs are stored in `/hbase/.corrupt/` for examination. If the size of one of these subdirectories is growing, examine the HBase server logs to find the root cause for why WALs are not being processed correctly.\\\nIf you use replication and `/hbase/oldWALs/` is using more space than you expect, remember that WALs are saved when replication is disabled, as long as there are peers.\n\n**Do not** manage WALs manually via HDFS.\n\n## Network\n\n### Network Spikes\n\nIf you are seeing periodic network spikes you might want to check the `compactionQueues` to see if major compactions are happening.\n\nSee [Managed Compactions](/docs/configuration/important#managed-compactions) for more information on managing compactions.\n\n### Loopback IP\n\nHBase expects the loopback IP Address to be 127.0.0.1.\n\n### Network Interfaces\n\nAre all the network interfaces functioning correctly? Are you sure? See the Troubleshooting Case Study in [Case Studies](/docs/troubleshooting#troubleshooting-case-studies).\n\n## RegionServer\n\nFor more information on the RegionServers, see [RegionServer](/docs/architecture/regionserver).\n\n### Startup Errors\n\n#### Master Starts, But RegionServers Do Not \\[!toc]\n\nThe Master believes the RegionServers have the IP of 127.0.0.1 - which is localhost and resolves to the master's own localhost.\n\nThe RegionServers are erroneously informing the Master that their IP addresses are 127.0.0.1.\n\nModify */etc/hosts* on the region servers, from...\n\n```text\n# Do not remove the following line, or various programs\n# that require network functionality will fail.\n127.0.0.1               fully.qualified.regionservername regionservername  localhost.localdomain localhost\n::1             localhost6.localdomain6 localhost6\n```\n\n... to (removing the master node's name from localhost)...\n\n```text\n# Do not remove the following line, or various programs\n# that require network functionality will fail.\n127.0.0.1               localhost.localdomain localhost\n::1             localhost6.localdomain6 localhost6\n```\n\n#### Compression Link Errors \\[!toc]\n\nSince compression algorithms such as LZO need to be installed and configured on each cluster this is a frequent source of startup error. If you see messages like this...\n\n```text\n11/02/20 01:32:15 ERROR lzo.GPLNativeCodeLoader: Could not load native gpl library\njava.lang.UnsatisfiedLinkError: no gplcompression in java.library.path\n        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1734)\n        at java.lang.Runtime.loadLibrary0(Runtime.java:823)\n        at java.lang.System.loadLibrary(System.java:1028)\n```\n\n... then there is a path issue with the compression libraries. See the Configuration section on [LZO compression configuration](/docs/compression#configure-hbase-for-compressors).\n\n#### RegionServer aborts due to lack of hsync for filesystem \\[!toc]\n\nIn order to provide data durability for writes to the cluster HBase relies on the ability to durably save state in a write ahead log. When using a version of Apache Hadoop Common's filesystem API that supports checking on the availability of needed calls, HBase will proactively abort the cluster if it finds it can't operate safely.\n\nFor RegionServer roles, the failure will show up in logs like this:\n\n```text\n2018-04-05 11:36:22,785 ERROR [regionserver/192.168.1.123:16020] wal.AsyncFSWALProvider: The RegionServer async write ahead log provider relies on the ability to call hflush and hsync for proper operation during component failures, but the current FileSystem does not support doing so. Please check the config value of 'hbase.wal.dir' and ensure it points to a FileSystem mount that has suitable capabilities for output streams.\n2018-04-05 11:36:22,799 ERROR [regionserver/192.168.1.123:16020] regionserver.HRegionServer: ***** ABORTING region server 192.168.1.123,16020,1522946074234: Unhandled: cannot get log writer *****\njava.io.IOException: cannot get log writer\n        at org.apache.hadoop.hbase.wal.AsyncFSWALProvider.createAsyncWriter(AsyncFSWALProvider.java:112)\n        at org.apache.hadoop.hbase.regionserver.wal.AsyncFSWAL.createWriterInstance(AsyncFSWAL.java:612)\n        at org.apache.hadoop.hbase.regionserver.wal.AsyncFSWAL.createWriterInstance(AsyncFSWAL.java:124)\n        at org.apache.hadoop.hbase.regionserver.wal.AbstractFSWAL.rollWriter(AbstractFSWAL.java:759)\n        at org.apache.hadoop.hbase.regionserver.wal.AbstractFSWAL.rollWriter(AbstractFSWAL.java:489)\n        at org.apache.hadoop.hbase.regionserver.wal.AsyncFSWAL.<init>(AsyncFSWAL.java:251)\n        at org.apache.hadoop.hbase.wal.AsyncFSWALProvider.createWAL(AsyncFSWALProvider.java:69)\n        at org.apache.hadoop.hbase.wal.AsyncFSWALProvider.createWAL(AsyncFSWALProvider.java:44)\n        at org.apache.hadoop.hbase.wal.AbstractFSWALProvider.getWAL(AbstractFSWALProvider.java:138)\n        at org.apache.hadoop.hbase.wal.AbstractFSWALProvider.getWAL(AbstractFSWALProvider.java:57)\n        at org.apache.hadoop.hbase.wal.WALFactory.getWAL(WALFactory.java:252)\n        at org.apache.hadoop.hbase.regionserver.HRegionServer.getWAL(HRegionServer.java:2105)\n        at org.apache.hadoop.hbase.regionserver.HRegionServer.buildServerLoad(HRegionServer.java:1326)\n        at org.apache.hadoop.hbase.regionserver.HRegionServer.tryRegionServerReport(HRegionServer.java:1191)\n        at org.apache.hadoop.hbase.regionserver.HRegionServer.run(HRegionServer.java:1007)\n        at java.lang.Thread.run(Thread.java:745)\nCaused by: org.apache.hadoop.hbase.util.CommonFSUtils$StreamLacksCapabilityException: hflush and hsync\n        at org.apache.hadoop.hbase.io.asyncfs.AsyncFSOutputHelper.createOutput(AsyncFSOutputHelper.java:69)\n        at org.apache.hadoop.hbase.regionserver.wal.AsyncProtobufLogWriter.initOutput(AsyncProtobufLogWriter.java:168)\n        at org.apache.hadoop.hbase.regionserver.wal.AbstractProtobufLogWriter.init(AbstractProtobufLogWriter.java:167)\n        at org.apache.hadoop.hbase.wal.AsyncFSWALProvider.createAsyncWriter(AsyncFSWALProvider.java:99)\n        ... 15 more\n```\n\nIf you are attempting to run in standalone mode and see this error, please walk back through the section [Quick Start - Standalone HBase](/docs/getting-started#quick-start---standalone-hbase) and ensure you have included **all** the given configuration settings.\n\n#### RegionServer aborts due to can not initialize access to HDFS \\[!toc]\n\nWe will try to use *AsyncFSWAL* for HBase-2.x as it has better performance while consuming less resources. But the problem for *AsyncFSWAL* is that it hacks into the internal of the DFSClient implementation, so it will easily be broken when upgrading hadoop, even for a simple patch release.\n\nIf you do not specify the wal provider, we will try to fall back to the old *FSHLog* if we fail to initialize *AsyncFSWAL*, but it may not always work. The failure will show up in logs like this:\n\n```text\n18/07/02 18:51:06 WARN concurrent.DefaultPromise: An exception was\nthrown by org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputHelper$13.operationComplete()\njava.lang.Error: Couldn't properly initialize access to HDFS\ninternals. Please update your WAL Provider to not make use of the\n'asyncfs' provider. See HBASE-16110 for more information.\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputSaslHelper.<clinit>(FanOutOneBlockAsyncDFSOutputSaslHelper.java:268)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputHelper.initialize(FanOutOneBlockAsyncDFSOutputHelper.java:661)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputHelper.access$300(FanOutOneBlockAsyncDFSOutputHelper.java:118)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputHelper$13.operationComplete(FanOutOneBlockAsyncDFSOutputHelper.java:720)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputHelper$13.operationComplete(FanOutOneBlockAsyncDFSOutputHelper.java:715)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:507)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:500)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:479)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:420)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)\n     at org.apache.hbase.thirdparty.io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:82)\n     at org.apache.hbase.thirdparty.io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.fulfillConnectPromise(AbstractEpollChannel.java:638)\n     at org.apache.hbase.thirdparty.io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.finishConnect(AbstractEpollChannel.java:676)\n     at org.apache.hbase.thirdparty.io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.epollOutReady(AbstractEpollChannel.java:552)\n     at org.apache.hbase.thirdparty.io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:394)\n     at org.apache.hbase.thirdparty.io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:304)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)\n     at org.apache.hbase.thirdparty.io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)\n     at java.lang.Thread.run(Thread.java:748)\n Caused by: java.lang.NoSuchMethodException:\norg.apache.hadoop.hdfs.DFSClient.decryptEncryptedDataEncryptionKey(org.apache.hadoop.fs.FileEncryptionInfo)\n     at java.lang.Class.getDeclaredMethod(Class.java:2130)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputSaslHelper.createTransparentCryptoHelper(FanOutOneBlockAsyncDFSOutputSaslHelper.java:232)\n     at org.apache.hadoop.hbase.io.asyncfs.FanOutOneBlockAsyncDFSOutputSaslHelper.<clinit>(FanOutOneBlockAsyncDFSOutputSaslHelper.java:262)\n     ... 18 more\n```\n\nIf you hit this error, please specify *FSHLog*, i.e, *filesystem*, explicitly in your config file.\n\n```xml\n<property>\n  <name>hbase.wal.provider</name>\n  <value>filesystem</value>\n</property>\n```\n\nAnd do not forget to send an email to the `user@hbase.apache.org` or `dev@hbase.apache.org` to report the failure and also your hadoop version, we will try to fix the problem ASAP in the next release.\n\n### Runtime Errors\n\n#### RegionServer Hanging \\[!toc]\n\nAre you running an old JVM (`< `1.6.0*u21?)? When you look at a thread dump, does it look like threads are BLOCKED but no one holds the lock all are blocked on? See [HBASE 3622 Deadlock in HBaseServer (JVM bug?)](https://issues.apache.org/jira/browse/HBASE-3622). Adding `-XX:+UseMembar` to the HBase `HBASE_OPTS` in \\_conf/hbase-env.sh* may fix it.\n\n#### java.io.IOException...(Too many open files) \\[!toc]\n\nIf you see log messages like this...\n\n```text\n2010-09-13 01:24:17,336 WARN org.apache.hadoop.hdfs.server.datanode.DataNode:\nDisk-related IOException in BlockReceiver constructor. Cause is java.io.IOException: Too many open files\n        at java.io.UnixFileSystem.createFileExclusively(Native Method)\n        at java.io.File.createNewFile(File.java:883)\n```\n\n... see the Getting Started section on [ulimit and nproc configuration](/docs/configuration/basic-prerequisites#example-ulimit-settings-on-ubuntu-toc).\n\n#### xceiverCount 258 exceeds the limit of concurrent xcievers 256 \\[!toc]\n\nThis typically shows up in the DataNode logs.\n\nTODO: add link.\nSee the Getting Started section on xceivers configuration.\n\n#### System instability, and the presence of \"java.lang.OutOfMemoryError: unable to createnew native thread in exceptions\" HDFS DataNode logs or that of any system daemon \\[!toc]\n\nSee the Getting Started section on ulimit and nproc configuration. The default on recent Linux distributions is 1024 - which is far too low for HBase.\n\n#### DFS instability and/or RegionServer lease timeouts \\[!toc]\n\nIf you see warning messages like this...\n\n```text\n2009-02-24 10:01:33,516 WARN org.apache.hadoop.hbase.util.Sleeper: We slept xxx ms, ten times longer than scheduled: 10000\n2009-02-24 10:01:33,516 WARN org.apache.hadoop.hbase.util.Sleeper: We slept xxx ms, ten times longer than scheduled: 15000\n2009-02-24 10:01:36,472 WARN org.apache.hadoop.hbase.regionserver.HRegionServer: unable to report to master for xxx milliseconds - retrying\n```\n\n... or see full GC compactions then you may be experiencing full GC's.\n\n#### \"No live nodes contain current block\" and/or YouAreDeadException \\[!toc]\n\nThese errors can happen either when running out of OS file handles or in periods of severe network problems where the nodes are unreachable.\n\nSee the Getting Started section on ulimit and nproc configuration and check your network.\n\n#### ZooKeeper SessionExpired events \\[!toc]\n\nMaster or RegionServers shutting down with messages like those in the logs:\n\n```text\nWARN org.apache.zookeeper.ClientCnxn: Exception\nclosing session 0x278bd16a96000f to sun.nio.ch.SelectionKeyImpl@355811ec\njava.io.IOException: TIMED OUT\n       at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:906)\nWARN org.apache.hadoop.hbase.util.Sleeper: We slept 79410ms, ten times longer than scheduled: 5000\nINFO org.apache.zookeeper.ClientCnxn: Attempting connection to server hostname/IP:PORT\nINFO org.apache.zookeeper.ClientCnxn: Priming connection to java.nio.channels.SocketChannel[connected local=/IP:PORT remote=hostname/IP:PORT]\nINFO org.apache.zookeeper.ClientCnxn: Server connection successful\nWARN org.apache.zookeeper.ClientCnxn: Exception closing session 0x278bd16a96000d to sun.nio.ch.SelectionKeyImpl@3544d65e\njava.io.IOException: Session Expired\n       at org.apache.zookeeper.ClientCnxn$SendThread.readConnectResult(ClientCnxn.java:589)\n       at org.apache.zookeeper.ClientCnxn$SendThread.doIO(ClientCnxn.java:709)\n       at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:945)\nERROR org.apache.hadoop.hbase.regionserver.HRegionServer: ZooKeeper session expired\n```\n\nThe JVM is doing a long running garbage collecting which is pausing every threads (aka \"stop the world\"). Since the RegionServer's local ZooKeeper client cannot send heartbeats, the session times out. By design, we shut down any node that isn't able to contact the ZooKeeper ensemble after getting a timeout so that it stops serving data that may already be assigned elsewhere.\n\n* Make sure you give plenty of RAM (in *hbase-env.sh*), the default of 1GB won't be able to sustain long running imports.\n* Make sure you don't swap, the JVM never behaves well under swapping.\n* Make sure you are not CPU starving the RegionServer thread. For example, if you are running a MapReduce job using 6 CPU-intensive tasks on a machine with 4 cores, you are probably starving the RegionServer enough to create longer garbage collection pauses.\n* Increase the ZooKeeper session timeout\n\nIf you wish to increase the session timeout, add the following to your *hbase-site.xml* to increase the timeout from the default of 60 seconds to 120 seconds.\n\n```xml\n<property>\n  <name>zookeeper.session.timeout</name>\n  <value>120000</value>\n</property>\n<property>\n  <name>hbase.zookeeper.property.tickTime</name>\n  <value>6000</value>\n</property>\n```\n\nBe aware that setting a higher timeout means that the regions served by a failed RegionServer will take at least that amount of time to be transferred to another RegionServer. For a production system serving live requests, we would instead recommend setting it lower than 1 minute and over-provision your cluster in order the lower the memory load on each machines (hence having less garbage to collect per machine).\n\nIf this is happening during an upload which only happens once (like initially loading all your data into HBase), consider bulk loading.\n\nSee [ZooKeeper, The Cluster Canary](/docs/troubleshooting#zookeeper-the-cluster-canary) for other general information about ZooKeeper troubleshooting.\n\n#### NotServingRegionException \\[!toc]\n\nThis exception is \"normal\" when found in the RegionServer logs at DEBUG level. This exception is returned back to the client and then the client goes back to `hbase:meta` to find the new location of the moved region.\n\nHowever, if the NotServingRegionException is logged ERROR, then the client ran out of retries and something probably wrong.\n\n#### Logs flooded with '2011-01-10 12:40:48,407 INFO org.apache.hadoop.io.compress.CodecPool: Gotbrand-new compressor' messages \\[!toc]\n\nWe are not using the native versions of compression libraries. See [HBASE-1900 Put back native support when hadoop 0.21 is released](https://issues.apache.org/jira/browse/HBASE-1900). Copy the native libs from hadoop under HBase lib dir or symlink them into place and the message should go away.\n\n#### Server handler X on 60020 caught: java.nio.channels.ClosedChannelException \\[!toc]\n\nIf you see this type of message it means that the region server was trying to read/send data from/to a client but it already went away. Typical causes for this are if the client was killed (you see a storm of messages like this when a MapReduce job is killed or fails) or if the client receives a SocketTimeoutException. It's harmless, but you should consider digging in a bit more if you aren't doing something to trigger them.\n\n### Snapshot Errors Due to Reverse DNS\n\nSeveral operations within HBase, including snapshots, rely on properly configured reverse DNS. Some environments, such as Amazon EC2, have trouble with reverse DNS. If you see errors like the following on your RegionServers, check your reverse DNS configuration:\n\n```text\n2013-05-01 00:04:56,356 DEBUG org.apache.hadoop.hbase.procedure.Subprocedure: Subprocedure 'backup1'\ncoordinator notified of 'acquire', waiting on 'reached' or 'abort' from coordinator.\n```\n\nIn general, the hostname reported by the RegionServer needs to be the same as the hostname the Master is trying to reach. You can see a hostname mismatch by looking for the following type of message in the RegionServer's logs at start-up.\n\n```text\n2013-05-01 00:03:00,614 INFO org.apache.hadoop.hbase.regionserver.HRegionServer: Master passed us hostname\nto use. Was=myhost-1234, Now=ip-10-55-88-99.ec2.internal\n```\n\n### Shutdown Errors\n\n## Master\n\nFor more information on the Master, see [master](/docs/architecture/master).\n\n### Startup Errors\n\n#### Master says that you need to run the HBase migrations script \\[!toc]\n\nUpon running that, the HBase migrations script says no files in root directory.\n\nHBase expects the root directory to either not exist, or to have already been initialized by HBase running a previous time. If you create a new directory for HBase using Hadoop DFS, this error will occur. Make sure the HBase root directory does not currently exist or has been initialized by a previous run of HBase. Sure fire solution is to just use Hadoop dfs to delete the HBase root and let HBase create and initialize the directory itself.\n\n#### Packet len6080218 is out of range! \\[!toc]\n\nIf you have many regions on your cluster and you see an error like that reported above in this sections title in your logs, see [HBASE-4246 Cluster with too many regions cannot withstand some master failover scenarios](https://issues.apache.org/jira/browse/HBASE-4246).\n\n#### Master fails to become active due to lack of hsync for filesystem \\[!toc]\n\nHBase's internal framework for cluster operations requires the ability to durably save state in a write ahead log. When using a version of Apache Hadoop Common's filesystem API that supports checking on the availability of needed calls, HBase will proactively abort the cluster if it finds it can't operate safely.\n\nFor Master roles, the failure will show up in logs like this:\n\n```text\n2018-04-05 11:18:44,653 ERROR [Thread-21] master.HMaster: Failed to become active master\njava.lang.IllegalStateException: The procedure WAL relies on the ability to hsync for proper operation during component failures, but the underlying filesystem does not support doing so. Please check the config value of 'hbase.procedure.store.wal.use.hsync' to set the desired level of robustness and ensure the config value of 'hbase.wal.dir' points to a FileSystem mount that can provide it.\n        at org.apache.hadoop.hbase.procedure2.store.wal.WALProcedureStore.rollWriter(WALProcedureStore.java:1034)\n        at org.apache.hadoop.hbase.procedure2.store.wal.WALProcedureStore.recoverLease(WALProcedureStore.java:374)\n        at org.apache.hadoop.hbase.procedure2.ProcedureExecutor.start(ProcedureExecutor.java:530)\n        at org.apache.hadoop.hbase.master.HMaster.startProcedureExecutor(HMaster.java:1267)\n        at org.apache.hadoop.hbase.master.HMaster.startServiceThreads(HMaster.java:1173)\n        at org.apache.hadoop.hbase.master.HMaster.finishActiveMasterInitialization(HMaster.java:881)\n        at org.apache.hadoop.hbase.master.HMaster.startActiveMasterManager(HMaster.java:2048)\n        at org.apache.hadoop.hbase.master.HMaster.lambda$run$0(HMaster.java:568)\n        at java.lang.Thread.run(Thread.java:745)\n```\n\nIf you are attempting to run in standalone mode and see this error, please walk back through the section [Quick Start - Standalone HBase](/docs/getting-started#quick-start---standalone-hbase) and ensure you have included **all** the given configuration settings.\n\n### Shutdown Errors\n\n## ZooKeeper\n\n### Startup Errors\n\n#### Could not find my address: xyz in list of ZooKeeper quorum servers \\[!toc]\n\nA ZooKeeper server wasn't able to start, throws that error. xyz is the name of your server.\n\nThis is a name lookup problem. HBase tries to start a ZooKeeper server on some machine but that machine isn't able to find itself in the `hbase.zookeeper.quorum` configuration.\n\nUse the hostname presented in the error message instead of the value you used. If you have a DNS server, you can set `hbase.zookeeper.dns.interface` and `hbase.zookeeper.dns.nameserver` in *hbase-site.xml* to make sure it resolves to the correct FQDN.\n\n### ZooKeeper, The Cluster Canary\n\nZooKeeper is the cluster's \"canary in the mineshaft\". It'll be the first to notice issues if any so making sure its happy is the short-cut to a humming cluster.\n\nSee the [ZooKeeper Operating Environment Troubleshooting](https://cwiki.apache.org/confluence/display/HADOOP2/ZooKeeper+Troubleshooting) page. It has suggestions and tools for checking disk and networking performance; i.e. the operating environment your ZooKeeper and HBase are running in.\n\nAdditionally, the utility [zkcli](/docs/troubleshooting#zkcli) may help investigate ZooKeeper issues.\n\n## Amazon EC2\n\n### ZooKeeper does not seem to work on Amazon EC2\n\nHBase does not start when deployed as Amazon EC2 instances. Exceptions like the below appear in the Master and/or RegionServer logs:\n\n```text\n  2009-10-19 11:52:27,030 INFO org.apache.zookeeper.ClientCnxn: Attempting\n  connection to server ec2-174-129-15-236.compute-1.amazonaws.com/10.244.9.171:2181\n  2009-10-19 11:52:27,032 WARN org.apache.zookeeper.ClientCnxn: Exception\n  closing session 0x0 to sun.nio.ch.SelectionKeyImpl@656dc861\n  java.net.ConnectException: Connection refused\n```\n\nSecurity group policy is blocking the ZooKeeper port on a public address. Use the internal EC2 host names when configuring the ZooKeeper quorum peer list.\n\n### Instability on Amazon EC2\n\nQuestions on HBase and Amazon EC2 come up frequently on the HBase dist-list.\n\n### Remote Java Connection into EC2 Cluster Not Working\n\nSee Andrew's answer here, up on the user list: [Remote Java client connection into EC2 instance](https://lists.apache.org/thread.html/666bfa863bc2eb2ec7bbe5ecfbee345e0cbf1d58aaa6c1636dfcb527%401269010842%40%3Cuser.hbase.apache.org%3E).\n\n## HBase and Hadoop version issues\n\n### ...cannot communicate with client version...\n\nIf you see something like the following in your logs ... 2012-09-24 10:20:52,168 FATAL org.apache.hadoop.hbase.master.HMaster: Unhandled exception. Starting shutdown. org.apache.hadoop.ipc.RemoteException: Server IPC version 7 cannot communicate with client version 4 ... ...are you trying to talk to an Hadoop 2.0.x from an HBase that has an Hadoop 1.0.x client? Use the HBase built against Hadoop 2.0 or rebuild your HBase passing the -Dhadoop.profile=2.0 attribute to Maven (See [Building against various Hadoop versions](/docs/building-and-developing/building#building-against-various-hadoop-versions) for more).\n\n## HBase and HDFS\n\nGeneral configuration guidance for Apache HDFS is out of the scope of this guide. Refer to the documentation available at [https://hadoop.apache.org/](https://hadoop.apache.org/) for extensive information about configuring HDFS. This section deals with HDFS in terms of HBase.\n\nIn most cases, HBase stores its data in Apache HDFS. This includes the HFiles containing the data, as well as the write-ahead logs (WALs) which store data before it is written to the HFiles and protect against RegionServer crashes. HDFS provides reliability and protection to data in HBase because it is distributed. To operate with the most efficiency, HBase needs data to be available locally. Therefore, it is a good practice to run an HDFS DataNode on each RegionServer.\n\n### Important Information and Guidelines for HBase and HDFS\n\n**HBase is a client of HDFS.**\\\nHBase is an HDFS client, using the HDFS `DFSClient` class, and references to this class appear in HBase logs with other HDFS client log messages.\n\n**Configuration is necessary in multiple places.**\\\nSome HDFS configurations relating to HBase need to be done at the HDFS (server) side. Others must be done within HBase (at the client side). Other settings need to be set at both the server and client side.\n\n**Write errors which affect HBase may be logged in the HDFS logs rather than HBase logs.**\\\nWhen writing, HDFS pipelines communications from one DataNode to another. HBase communicates to both the HDFS NameNode and DataNode, using the HDFS client classes. Communication problems between DataNodes are logged in the HDFS logs, not the HBase logs.\n\n**HBase communicates with HDFS using two different ports.**\\\nHBase communicates with DataNodes using the `ipc.Client` interface and the `DataNode` class. References to these will appear in HBase logs. Each of these communication channels use a different port (50010 and 50020 by default). The ports are configured in the HDFS configuration, via the `dfs.datanode.address` and `dfs.datanode.ipc.address` parameters.\n\n**Errors may be logged in HBase, HDFS, or both.**\\\nWhen troubleshooting HDFS issues in HBase, check logs in both places for errors.\n\n**HDFS takes a while to mark a node as dead. You can configure HDFS to avoid using stale DataNodes.**\\\nBy default, HDFS does not mark a node as dead until it is unreachable for 630 seconds. In Hadoop 1.1 and Hadoop 2.x, this can be alleviated by enabling checks for stale DataNodes, though this check is disabled by default. You can enable the check for reads and writes separately, via `dfs.namenode.avoid.read.stale.datanode` and `dfs.namenode.avoid.write.stale.datanode settings`. A stale DataNode is one that has not been reachable for `dfs.namenode.stale.datanode.interval` (default is 30 seconds). Stale datanodes are avoided, and marked as the last possible target for a read or write operation. For configuration details, see the HDFS documentation.\n\n**Settings for HDFS retries and timeouts are important to HBase.**\\\nYou can configure settings for various retries and timeouts. Always refer to the HDFS documentation for current recommendations and defaults. Some of the settings important to HBase are listed here. Defaults are current as of Hadoop 2.3. Check the Hadoop documentation for the most current values and recommendations.\n\n**The HBase Balancer and HDFS Balancer are incompatible**\\\nThe HDFS balancer attempts to spread HDFS blocks evenly among DataNodes. HBase relies on compactions to restore locality after a region split or failure. These two types of balancing do not work well together.\n\nIn the past, the generally accepted advice was to turn off the HDFS load balancer and rely on the HBase balancer, since the HDFS balancer would degrade locality. This advice is still valid if your HDFS version is lower than 2.7.1.\n\n[HDFS-6133](https://issues.apache.org/jira/browse/HDFS-6133) provides the ability to exclude favored-nodes (pinned) blocks from the HDFS load balancer, by setting the `dfs.datanode.block-pinning.enabled` property to `true` in the HDFS service configuration.\n\nHBase can be enabled to use the HDFS favored-nodes feature by switching the HBase balancer class (conf: `hbase.master.loadbalancer.class`) to `org.apache.hadoop.hbase.favored.FavoredNodeLoadBalancer` which is documented [here](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/favored/FavoredNodeLoadBalancer.html).\n\n<Callout type=\"info\">\n  HDFS-6133 is available in HDFS 2.7.0 and higher, but HBase does not support running on HDFS 2.7.0,\n  so you must be using HDFS 2.7.1 or higher to use this feature with HBase.\n</Callout>\n\n### Connection Timeouts\n\nConnection timeouts occur between the client (HBASE) and the HDFS DataNode. They may occur when establishing a connection, attempting to read, or attempting to write. The two settings below are used in combination, and affect connections between the DFSClient and the DataNode, the ipc.cClient and the DataNode, and communication between two DataNodes.\n\n`dfs.client.socket-timeout` (default: 60000)\\\nThe amount of time before a client connection times out when establishing a connection or reading. The value is expressed in milliseconds, so the default is 60 seconds.\n\n`dfs.datanode.socket.write.timeout` (default: 480000)\\\nThe amount of time before a write operation times out. The default is 8 minutes, expressed as milliseconds.\n\n### Typical Error Logs\n\nThe following types of errors are often seen in the logs.\n\n`INFO HDFS.DFSClient: Failed to connect to /xxx50010, add to deadNodes and continue java.net.SocketTimeoutException: 60000 millis timeout while waiting for channel to be ready for connect. ch : java.nio.channels.SocketChannel[connection-pending remote=/region-server-1:50010]`:: All DataNodes for a block are dead, and recovery is not possible. Here is the sequence of events that leads to this error:\n\n`INFO org.apache.hadoop.HDFS.DFSClient: Exception in createBlockOutputStream java.net.SocketTimeoutException: 69000 millis timeout while waiting for channel to be ready for connect. ch : java.nio.channels.SocketChannel[connection-pending remote=/ xxx:50010]`:: This type of error indicates a write issue. In this case, the master wants to split the log. It does not have a local DataNodes so it tries to connect to a remote DataNode, but the DataNode is dead.\n\n## Running unit or integration tests\n\n### Runtime exceptions from MiniDFSCluster when running tests\n\nIf you see something like the following\n\n```text\n...\njava.lang.NullPointerException: null\nat org.apache.hadoop.hdfs.MiniDFSCluster.startDataNodes\nat org.apache.hadoop.hdfs.MiniDFSCluster.<init>\nat org.apache.hadoop.hbase.MiniHBaseCluster.<init>\nat org.apache.hadoop.hbase.HBaseTestingUtility.startMiniDFSCluster\nat org.apache.hadoop.hbase.HBaseTestingUtility.startMiniCluster\n...\n```\n\nor\n\n```text\n...\njava.io.IOException: Shutting down\nat org.apache.hadoop.hbase.MiniHBaseCluster.init\nat org.apache.hadoop.hbase.MiniHBaseCluster.<init>\nat org.apache.hadoop.hbase.MiniHBaseCluster.<init>\nat org.apache.hadoop.hbase.HBaseTestingUtility.startMiniHBaseCluster\nat org.apache.hadoop.hbase.HBaseTestingUtility.startMiniCluster\n...\n```\n\n... then try issuing the command umask 022 before launching tests. This is a workaround for [HDFS-2556](https://issues.apache.org/jira/browse/HDFS-2556)\n\n## Case Studies\n\nFor Performance and Troubleshooting Case Studies, see [Apache HBase Case Studies](/docs/case-studies).\n\n## Cryptographic Features\n\n### sun.security.pkcs11.wrapper.PKCS11Exception: CKR\\_ARGUMENTS\\_BAD \\[!toc]\n\nThis problem manifests as exceptions ultimately caused by:\n\n```text\nCaused by: sun.security.pkcs11.wrapper.PKCS11Exception: CKR_ARGUMENTS_BAD\n  at sun.security.pkcs11.wrapper.PKCS11.C_DecryptUpdate(Native Method)\n  at sun.security.pkcs11.P11Cipher.implDoFinal(P11Cipher.java:795)\n```\n\nThis problem appears to affect some versions of OpenJDK 7 shipped by some Linux vendors. NSS is configured as the default provider. If the host has an x86\\_64 architecture, depending on if the vendor packages contain the defect, the NSS provider will not function correctly.\n\nTo work around this problem, find the JRE home directory and edit the file *lib/security/java.security*. Edit the file to comment out the line:\n\n```text\nsecurity.provider.1=sun.security.pkcs11.SunPKCS11 ${java.home}/lib/security/nss.cfg\n```\n\nThen renumber the remaining providers accordingly.\n\n## Operating System Specific Issues\n\n### Page Allocation Failure \\[!toc]\n\n<Callout type=\"info\">\n  This issue is known to affect CentOS 6.2 and possibly CentOS 6.5. It may also affect some versions\n  of Red Hat Enterprise Linux, according to\n  [https://bugzilla.redhat.com/show\\_bug.cgi?id=770545](https://bugzilla.redhat.com/show_bug.cgi?id=770545).\n</Callout>\n\nSome users have reported seeing the following error:\n\n```text\nkernel: java: page allocation failure. order:4, mode:0x20\n```\n\nRaising the value of `min_free_kbytes` was reported to fix this problem. This parameter is set to a percentage of the amount of RAM on your system, and is described in more detail at [https://docs.kernel.org/admin-guide/sysctl/vm.html#min-free-kbytes](https://docs.kernel.org/admin-guide/sysctl/vm.html#min-free-kbytes).\n\nTo find the current value on your system, run the following command:\n\n```bash\n[user@host]# cat /proc/sys/vm/min_free_kbytes\n```\n\nNext, raise the value. Try doubling, then quadrupling the value. Note that setting the value too low or too high could have detrimental effects on your system. Consult your operating system vendor for specific recommendations.\n\nUse the following command to modify the value of `min_free_kbytes`, substituting *VALUE* with your intended value:\n\n```bash\n[user@host]# echo <value> > /proc/sys/vm/min_free_kbytes\n```\n\n## JDK Issues\n\n### NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet \\[!toc]\n\nIf you see this in your logs:\n\n```text\nCaused by: java.lang.NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;\n  at org.apache.hadoop.hbase.master.ServerManager.findServerWithSameHostnamePortWithLock(ServerManager.java:393)\n  at org.apache.hadoop.hbase.master.ServerManager.checkAndRecordNewServer(ServerManager.java:307)\n  at org.apache.hadoop.hbase.master.ServerManager.regionServerStartup(ServerManager.java:244)\n  at org.apache.hadoop.hbase.master.MasterRpcServices.regionServerStartup(MasterRpcServices.java:304)\n  at org.apache.hadoop.hbase.protobuf.generated.RegionServerStatusProtos$RegionServerStatusService$2.callBlockingMethod(RegionServerStatusProtos.java:7910)\n  at org.apache.hadoop.hbase.ipc.RpcServer.call(RpcServer.java:2020)\n  ... 4 more\n```\n\nthen check if you compiled with jdk8 and tried to run it on jdk7. If so, this won't work. Run on jdk8 or recompile with jdk7. See [HBASE-10607 JDK8 NoSuchMethodError involving ConcurrentHashMap.keySet if running on JRE 7](https://issues.apache.org/jira/browse/HBASE-10607).\n\n### Full gc caused by mslab when using G1 \\[!toc]\n\nThe default size of chunk used by mslab is 2MB, when using G1, if heapRegionSize equals 4MB, these chunks are allocated as humongous objects, exclusively allocating one region, then the remaining 2MB become memory fragment.\n\nLots of memory fragment may lead to full gc even if the percent of used heap not high enough.\n\nThe G1HeapRegionSize calculated by initial\\_heap\\_size and max\\_heap\\_size, here are some cases for better understand:\n\n* xmx=10G -> region size 2M\n* xms=10G, xmx=10G -> region size 4M\n* xmx=20G -> region size 4M\n* xms=20G, xmx=20G -> region size 8M\n* xmx=30G -> region size 4M\n* xmx=32G -> region size 8M\n\nYou can avoid this problem by reducing the chunk size a bit to 2047KB as below.\n\n```properties\nhbase.hregion.memstore.mslab.chunksize 2096128\n```\n\n***\n\n# Case Studies\n\n## Overview\n\nThis chapter will describe a variety of performance and troubleshooting case studies that can provide a useful blueprint on diagnosing Apache HBase cluster issues.\n\nFor more information on Performance and Troubleshooting, see [Apache HBase Performance Tuning](/docs/performance) and [Troubleshooting and Debugging Apache HBase](/docs/troubleshooting).\n\n## Schema Design\n\nSee the schema design case studies here: [Schema Design Case Studies](/docs/regionserver-sizing#schema-design-case-studies)\n\n## Performance/Troubleshooting\n\n### Case Study #1 (Performance Issue On A Single Node)\n\n#### Scenario\n\nFollowing a scheduled reboot, one data node began exhibiting unusual behavior.\nRoutine MapReduce jobs run against HBase tables which regularly completed in five or six minutes began taking 30 or 40 minutes to finish.\nThese jobs were consistently found to be waiting on map and reduce tasks assigned to the troubled data node (e.g., the slow map tasks all had the same Input Split). The situation came to a head during a distributed copy, when the copy was severely prolonged by the lagging node.\n\n#### Hardware\n\nDatanodes:\n\n* Two 12-core processors\n* Six Enterprise SATA disks\n* 24GB of RAM\n* Two bonded gigabit NICs\n\nNetwork:\n\n* 10 Gigabit top-of-rack switches\n* 20 Gigabit bonded interconnects between racks.\n\n#### Hypotheses\n\n**HBase \"Hot Spot\" Region**\\\nWe hypothesized that we were experiencing a familiar point of pain: a \"hot spot\" region in an HBase table, where uneven key-space distribution can funnel a huge number of requests to a single HBase region, bombarding the RegionServer process and cause slow response time.\nExamination of the HBase Master status page showed that the number of HBase requests to the troubled node was almost zero.\nFurther, examination of the HBase logs showed that there were no region splits, compactions, or other region transitions in progress.\nThis effectively ruled out a \"hot spot\" as the root cause of the observed slowness.\n\n**HBase Region With Non-Local Data**\\\nOur next hypothesis was that one of the MapReduce tasks was requesting data from HBase that was not local to the DataNode, thus forcing HDFS to request data blocks from other servers over the network.\nExamination of the DataNode logs showed that there were very few blocks being requested over the network, indicating that the HBase region was correctly assigned, and that the majority of the necessary data was located on the node.\nThis ruled out the possibility of non-local data causing a slowdown.\n\n**Excessive I/O Wait Due To Swapping Or An Over-Worked Or Failing Hard Disk**\\\nAfter concluding that the Hadoop and HBase were not likely to be the culprits, we moved on to troubleshooting the DataNode's hardware.\nJava, by design, will periodically scan its entire memory space to do garbage collection.\nIf system memory is heavily overcommitted, the Linux kernel may enter a vicious cycle, using up all of its resources swapping Java heap back and forth from disk to RAM as Java tries to run garbage collection.\nFurther, a failing hard disk will often retry reads and/or writes many times before giving up and returning an error.\nThis can manifest as high iowait, as running processes wait for reads and writes to complete.\nFinally, a disk nearing the upper edge of its performance envelope will begin to cause iowait as it informs the kernel that it cannot accept any more data, and the kernel queues incoming data into the dirty write pool in memory.\nHowever, using `vmstat(1)` and `free(1)`, we could see that no swap was being used, and the amount of disk IO was only a few kilobytes per second.\n\n**Slowness Due To High Processor Usage**\\\nNext, we checked to see whether the system was performing slowly simply due to very high computational load. `top(1)` showed that the system load was higher than normal, but `vmstat(1)` and `mpstat(1)` showed that the amount of processor being used for actual computation was low.\n\n**Network Saturation (The Winner)**\\\nSince neither the disks nor the processors were being utilized heavily, we moved on to the performance of the network interfaces.\nThe DataNode had two gigabit ethernet adapters, bonded to form an active-standby interface. `ifconfig(8)` showed some unusual anomalies, namely interface errors, overruns, framing errors.\nWhile not unheard of, these kinds of errors are exceedingly rare on modern hardware which is operating as it should:\n\n```bash\n$ /sbin/ifconfig bond0\nbond0  Link encap:Ethernet  HWaddr 00:00:00:00:00:00\ninet addr:10.x.x.x  Bcast:10.x.x.255  Mask:255.255.255.0\nUP BROADCAST RUNNING MASTER MULTICAST  MTU:1500  Metric:1\nRX packets:2990700159 errors:12 dropped:0 overruns:1 frame:6          <--- Look Here! Errors!\nTX packets:3443518196 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:0\nRX bytes:2416328868676 (2.4 TB)  TX bytes:3464991094001 (3.4 TB)\n```\n\nThese errors immediately lead us to suspect that one or more of the ethernet interfaces might have negotiated the wrong line speed.\nThis was confirmed both by running an ICMP ping from an external host and observing round-trip-time in excess of 700ms, and by running `ethtool(8)` on the members of the bond interface and discovering that the active interface was operating at 100Mbs/, full duplex.\n\n```bash\n$ sudo ethtool eth0\nSettings for eth0:\nSupported ports: [ TP ]\nSupported link modes:   10baseT/Half 10baseT/Full\n                       100baseT/Half 100baseT/Full\n                       1000baseT/Full\nSupports auto-negotiation: Yes\nAdvertised link modes:  10baseT/Half 10baseT/Full\n                       100baseT/Half 100baseT/Full\n                       1000baseT/Full\nAdvertised pause frame use: No\nAdvertised auto-negotiation: Yes\nLink partner advertised link modes:  Not reported\nLink partner advertised pause frame use: No\nLink partner advertised auto-negotiation: No\nSpeed: 100Mb/s                                     <--- Look Here!  Should say 1000Mb/s!\nDuplex: Full\nPort: Twisted Pair\nPHYAD: 1\nTransceiver: internal\nAuto-negotiation: on\nMDI-X: Unknown\nSupports Wake-on: umbg\nWake-on: g\nCurrent message level: 0x00000003 (3)\nLink detected: yes\n```\n\nIn normal operation, the ICMP ping round trip time should be around 20ms, and the interface speed and duplex should read, \"1000MB/s\", and, \"Full\", respectively.\n\n#### Resolution\n\nAfter determining that the active ethernet adapter was at the incorrect speed, we used the `ifenslave(8)` command to make the standby interface the active interface, which yielded an immediate improvement in MapReduce performance, and a 10 times improvement in network throughput:\n\nOn the next trip to the datacenter, we determined that the line speed issue was ultimately caused by a bad network cable, which was replaced.\n\n### Case Study #2 (Performance Research 2012)\n\nInvestigation results of a self-described \"we're not sure what's wrong, but it seems slow\" problem. [http://gbif.blogspot.com/2012/03/hbase-performance-evaluation-continued.html](http://gbif.blogspot.com/2012/03/hbase-performance-evaluation-continued.html)\n\n### Case Study #3 (Performance Research 2010)\n\nInvestigation results of general cluster performance from 2010.\nAlthough this research is on an older version of the codebase, this writeup is still very useful in terms of approach. [https://web.archive.org/web/20180503124332/http://hstack.org/hbase-performance-testing/](https://web.archive.org/web/20180503124332/http://hstack.org/hbase-performance-testing/)\n\n### Case Study #4 (max.transfer.threads Config)\n\nCase study of configuring `max.transfer.threads` (previously known as `xcievers`) and diagnosing errors from misconfigurations. [http://www.larsgeorge.com/2012/03/hadoop-hbase-and-xceivers.html](http://www.larsgeorge.com/2012/03/hadoop-hbase-and-xceivers.html)\n\nSee also [`dfs.datanode.max.transfer.threads`](/docs/configuration/basic-prerequisites#dfsdatanodemaxtransferthreads).\n\n***\n\n# Operational Management\n\nThe subject of operations is related to the topics of [Troubleshooting and Debugging Apache HBase](/docs/troubleshooting), [Apache HBase Performance Tuning](/docs/performance), and [Apache HBase Configuration](/docs/configuration) but is a distinct topic in itself.\n\n## HBase Tools and Utilities\n\nHBase provides several tools for administration, analysis, and debugging of your cluster. The entry-point to most of these tools is the *bin/hbase* command, though some tools are available in the *dev-support/* directory.\n\nTo see usage instructions for *bin/hbase* command, run it with no arguments, or with the `-h` argument. These are the usage instructions for HBase 0.98.x. Some commands, such as `version`, `pe`, `ltt`, `clean`, are not available in previous versions.\n\n```text\n$ bin/hbase\nUsage: hbase [<options>] <command> [<args>]\nOptions:\n  --config DIR     Configuration direction to use. Default: ./conf\n  --hosts HOSTS    Override the list in 'regionservers' file\n  --auth-as-server Authenticate to ZooKeeper using servers configuration\n\nCommands:\nSome commands take arguments. Pass no args or -h for usage.\n  shell           Run the HBase shell\n  hbck            Run the HBase 'fsck' tool. Defaults read-only hbck1.\n                  Pass '-j /path/to/HBCK2.jar' to run hbase-2.x HBCK2.\n  snapshot        Tool for managing snapshots\n  wal             Write-ahead-log analyzer\n  hfile           Store file analyzer\n  zkcli           Run the ZooKeeper shell\n  master          Run an HBase HMaster node\n  regionserver    Run an HBase HRegionServer node\n  zookeeper       Run a ZooKeeper server\n  rest            Run an HBase REST server\n  thrift          Run the HBase Thrift server\n  thrift2         Run the HBase Thrift2 server\n  clean           Run the HBase clean up script\n  jshell          Run a jshell with HBase on the classpath\n  classpath       Dump hbase CLASSPATH\n  mapredcp        Dump CLASSPATH entries required by mapreduce\n  pe              Run PerformanceEvaluation\n  ltt             Run LoadTestTool\n  canary          Run the Canary tool\n  version         Print the version\n  backup          Backup tables for recovery\n  restore         Restore tables from existing backup image\n  regionsplitter  Run RegionSplitter tool\n  rowcounter      Run RowCounter tool\n  cellcounter     Run CellCounter tool\n  CLASSNAME       Run the class named CLASSNAME\n\n```\n\nSome of the tools and utilities below are Java classes which are passed directly to the *bin/hbase* command, as referred to in the last line of the usage instructions. Others, such as `hbase shell` ([The Apache HBase Shell](/docs/shell)), `hbase upgrade` ([Upgrading](/docs/upgrading)), and `hbase thrift` ([Thrift API and Filter Language](/docs/thrift-filter-language)), are documented elsewhere in this guide.\n\n## Canary\n\nThe Canary tool can help users \"canary-test\" the HBase cluster status. The default \"region mode\" fetches a row from every column-family of every regions. In \"regionserver mode\", the Canary tool will fetch a row from a random region on each of the cluster's RegionServers. In \"zookeeper mode\", the Canary will read the root znode on each member of the zookeeper ensemble.\n\nTo see usage, pass the `-help` parameter (if you pass no parameters, the Canary tool starts executing in the default region \"mode\" fetching a row from every region in the cluster).\n\n```text\n2018-10-16 13:11:27,037 INFO  [main] tool.Canary: Execution thread count=16\nUsage: canary [OPTIONS] [<TABLE1> [<TABLE2]...] | [<REGIONSERVER1> [<REGIONSERVER2]..]\nWhere [OPTIONS] are:\n -h,-help        show this help and exit.\n -regionserver   set 'regionserver mode'; gets row from random region on server\n -allRegions     get from ALL regions when 'regionserver mode', not just random one.\n -zookeeper      set 'zookeeper mode'; grab zookeeper.znode.parent on each ensemble member\n -daemon         continuous check at defined intervals.\n -interval <N>   interval between checks in seconds\n -e              consider table/regionserver argument as regular expression\n -f <B>          exit on first error; default=true\n -failureAsError treat read/write failure as error\n -t <N>          timeout for canary-test run; default=600000ms\n -writeSniffing  enable write sniffing\n -writeTable     the table used for write sniffing; default=hbase:canary\n -writeTableTimeout <N>  timeout for writeTable; default=600000ms\n -readTableTimeouts <tableName>=<read timeout>,<tableName>=<read timeout>,...\n            comma-separated list of table read timeouts (no spaces);\n            logs 'ERROR' if takes longer. default=600000ms\n -permittedZookeeperFailures <N>  Ignore first N failures attempting to\n            connect to individual zookeeper nodes in ensemble\n\n -D<configProperty>=<value> to assign or override configuration params\n -Dhbase.canary.read.raw.enabled=<true/false> Set to enable/disable raw scan; default=false\n\nCanary runs in one of three modes: region (default), regionserver, or zookeeper.\nTo sniff/probe all regions, pass no arguments.\nTo sniff/probe all regions of a table, pass tablename.\nTo sniff/probe regionservers, pass -regionserver, etc.\nSee http://hbase.apache.org/book.html#_canary for Canary documentation.\n```\n\n<Callout type=\"info\">\n  The `Sink` class is instantiated using the `hbase.canary.sink.class` configuration property.\n</Callout>\n\nThis tool will return non zero error codes to user for collaborating with other monitoring tools, such as Nagios. The error code definitions are:\n\n```java\nprivate static final int USAGE_EXIT_CODE = 1;\nprivate static final int INIT_ERROR_EXIT_CODE = 2;\nprivate static final int TIMEOUT_ERROR_EXIT_CODE = 3;\nprivate static final int ERROR_EXIT_CODE = 4;\nprivate static final int FAILURE_EXIT_CODE = 5;\n```\n\nHere are some examples based on the following given case: given two Table objects called test-01 and test-02 each with two column family cf1 and cf2 respectively, deployed on 3 RegionServers. See the following table.\n\n| RegionServer | test-01 | test-02 |\n| ------------ | ------- | ------- |\n| rs1          | r1      | r2      |\n| rs2          | r2      |         |\n| rs3          | r2      | r1      |\n\nFollowing are some example outputs based on the previous given case.\n\n### Canary test for every column family (store) of every region of every table\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary\n\n3/12/09 03:26:32 INFO tool.Canary: read from region test-01,,1386230156732.0e3c7d77ffb6361ea1b996ac1042ca9a. column family cf1 in 2ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-01,,1386230156732.0e3c7d77ffb6361ea1b996ac1042ca9a. column family cf2 in 2ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-01,0004883,1386230156732.87b55e03dfeade00f441125159f8ca87. column family cf1 in 4ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-01,0004883,1386230156732.87b55e03dfeade00f441125159f8ca87. column family cf2 in 1ms\n...\n13/12/09 03:26:32 INFO tool.Canary: read from region test-02,,1386559511167.aa2951a86289281beee480f107bb36ee. column family cf1 in 5ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-02,,1386559511167.aa2951a86289281beee480f107bb36ee. column family cf2 in 3ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-02,0004883,1386559511167.cbda32d5e2e276520712d84eaaa29d84. column family cf1 in 31ms\n13/12/09 03:26:32 INFO tool.Canary: read from region test-02,0004883,1386559511167.cbda32d5e2e276520712d84eaaa29d84. column family cf2 in 8ms\n\n```\n\nSo you can see, table test-01 has two regions and two column families, so the Canary tool in the default \"region mode\" will pick 4 small piece of data from 4 (2 region \\* 2 store) different stores. This is a default behavior.\n\n### Canary test for every column family (store) of every region of a specific table(s)\n\nYou can also test one or more specific tables by passing table names.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary test-01 test-02\n\n```\n\n### Canary test with RegionServer granularity\n\nIn \"regionserver mode\", the Canary tool will pick one small piece of data from each RegionServer (You can also pass one or more RegionServer names as arguments to the canary-test when in \"regionserver mode\").\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -regionserver\n\n13/12/09 06:05:17 INFO tool.Canary: Read from table:test-01 on region server:rs2 in 72ms\n13/12/09 06:05:17 INFO tool.Canary: Read from table:test-02 on region server:rs3 in 34ms\n13/12/09 06:05:17 INFO tool.Canary: Read from table:test-01 on region server:rs1 in 56ms\n\n```\n\n### Canary test with regular expression pattern\n\nYou can pass regexes for table names when in \"region mode\" or for servernames when in \"regionserver mode\". The below will test both table test-01 and test-02.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -e test-0[1-2]\n\n```\n\n### Run canary test as a \"daemon\"\n\nRun repeatedly with an interval defined via the option `-interval` (default value is 60 seconds). This daemon will stop itself and return non-zero error code if any error occur. To have the daemon keep running across errors, pass the -f flag with its value set to false (see usage above).\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -daemon\n\n```\n\nTo run repeatedly with 5 second intervals and not stop on errors, do the following.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -daemon -interval 5 -f false\n\n```\n\n### Force timeout if canary test stuck\n\nIn some cases the request is stuck and no response is sent back to the client. This can happen with dead RegionServers which the master has not yet noticed. Because of this we provide a timeout option to kill the canary test and return a non-zero error code. The below sets the timeout value to 60 seconds (the default value is 600 seconds).\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -t 60000\n\n```\n\n### Enable write sniffing in canary\n\nBy default, the canary tool only checks read operations. To enable the write sniffing, you can run the canary with the `-writeSniffing` option set. When write sniffing is enabled, the canary tool will create an hbase table and make sure the regions of the table are distributed to all region servers. In each sniffing period, the canary will try to put data to these regions to check the write availability of each region server.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -writeSniffing\n\n```\n\nThe default write table is `hbase:canary` and can be specified with the option `-writeTable`.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -writeSniffing -writeTable ns:canary\n\n```\n\nThe default value size of each put is 10 bytes. You can set it via the config key: `hbase.canary.write.value.size`.\n\n### Treat read / write failure as error\n\nBy default, the canary tool only logs read failures — due to e.g. RetriesExhaustedException, etc. — and will return the 'normal' exit code. To treat read/write failure as errors, you can run canary with the `-treatFailureAsError` option. When enabled, read/write failures will result in an error exit code.\n\n```bash\n$ ${HBASE_HOME}/bin/hbase canary -treatFailureAsError\n\n```\n\n### Running Canary in a Kerberos-enabled Cluster\n\nTo run the Canary in a Kerberos-enabled cluster, configure the following two properties in *hbase-site.xml*:\n\n* `hbase.client.keytab.file`\n* `hbase.client.kerberos.principal`\n\nKerberos credentials are refreshed every 30 seconds when Canary runs in daemon mode.\n\nTo configure the DNS interface for the client, configure the following optional properties in *hbase-site.xml*.\n\n* `hbase.client.dns.interface`\n* `hbase.client.dns.nameserver`\n\n**Example Canary in a Kerberos-Enabled Cluster**\\\nThis example shows each of the properties with valid values.\n\n```xml\n<property>\n  <name>hbase.client.kerberos.principal</name>\n  <value>hbase/_HOST@YOUR-REALM.COM</value>\n</property>\n<property>\n  <name>hbase.client.keytab.file</name>\n  <value>/etc/hbase/conf/keytab.krb5</value>\n</property>\n\n<property>\n  <name>hbase.client.dns.interface</name>\n  <value>default</value>\n</property>\n<property>\n  <name>hbase.client.dns.nameserver</name>\n  <value>default</value>\n</property>\n```\n\n## RegionSplitter\n\n```text\nusage: bin/hbase regionsplitter <TABLE> <SPLITALGORITHM>\nSPLITALGORITHM is the java class name of a class implementing\n                      SplitAlgorithm, or one of the special strings\n                      HexStringSplit or DecimalStringSplit or\n                      UniformSplit, which are built-in split algorithms.\n                      HexStringSplit treats keys as hexadecimal ASCII, and\n                      DecimalStringSplit treats keys as decimal ASCII, and\n                      UniformSplit treats keys as arbitrary bytes.\n -c <region count>        Create a new table with a pre-split number of\n                          regions\n -D <property=value>      Override HBase Configuration Settings\n -f <family:family:...>   Column Families to create with new table.\n                          Required with -c\n    --firstrow <arg>      First Row in Table for Split Algorithm\n -h                       Print this usage help\n    --lastrow <arg>       Last Row in Table for Split Algorithm\n -o <count>               Max outstanding splits that have unfinished\n                          major compactions\n -r                       Perform a rolling split of an existing region\n    --risky               Skip verification steps to complete\n                          quickly. STRONGLY DISCOURAGED for production\n                          systems.\n```\n\nFor additional detail, see [Manual Region Splitting](/docs/architecture/regions#manual-region-splitting).\n\n## Health Checker\n\nYou can configure HBase to run a script periodically and if it fails N times (configurable), have the server exit. See *HBASE-7351 Periodic health check script* for configurations and detail.\n\n## Driver\n\nSeveral frequently-accessed utilities are provided as `Driver` classes, and executed by the *bin/hbase* command. These utilities represent MapReduce jobs which run on your cluster. They are run in the following way, replacing *UtilityName* with the utility you want to run. This command assumes you have set the environment variable `HBASE_HOME` to the directory where HBase is unpacked on your server.\n\n```bash\n${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.mapreduce.UtilityName\n```\n\nThe following utilities are available:\n\n`LoadIncrementalHFiles`\\\nComplete a bulk data load.\n\n`CopyTable`\\\nExport a table from the local cluster to a peer cluster.\n\n`Export`\\\nWrite table data to HDFS.\n\n`Import`\\\nImport data written by a previous `Export` operation.\n\n`ImportTsv`\\\nImport data in TSV format.\n\n`RowCounter`\\\nCount rows in an HBase table.\n\n`CellCounter`\\\nCount cells in an HBase table.\n\n`replication.VerifyReplication`\\\nCompare the data from tables in two different clusters. WARNING: It doesn't work for incrementColumnValues'd cells since the timestamp is changed. Note that this command is in a different package than the others.\n\nEach command except `RowCounter` and `CellCounter` accept a single `--help` argument to print usage instructions.\n\n## HBase `hbck`\n\nThe `hbck` tool that shipped with hbase-1.x has been made read-only in hbase-2.x. It is not able to repair hbase-2.x clusters as hbase internals have changed. Nor should its assessments in read-only mode be trusted as it does not understand hbase-2.x operation.\n\nA new tool, [HBase `HBCK2`](/docs/operational-management/tools#hbase-hbck2), described in the next section, replaces `hbck`.\n\n## HBase `HBCK2`\n\n`HBCK2` is the successor to [HBase `HBCK`](/docs/operational-management/tools#hbase-hbck), the hbase-1.x fix tool (A.K.A `hbck1`). Use it in place of `hbck1` making repairs against hbase-2.x installs.\n\n`HBCK2` does not ship as part of hbase. It can be found as a subproject of the companion [hbase-operator-tools](https://github.com/apache/hbase-operator-tools) repository at [Apache HBase HBCK2 Tool](https://github.com/apache/hbase-operator-tools/tree/master/hbase-hbck2). `HBCK2` was moved out of hbase so it could evolve at a cadence apart from that of hbase core.\n\nSee the [HBCK2](https://github.com/apache/hbase-operator-tools/tree/master/hbase-hbck2) Home Page for how `HBCK2` differs from `hbck1`, and for how to build and use it.\n\nOnce built, you can run `HBCK2` as follows:\n\n```bash\n$ hbase hbck -j /path/to/HBCK2.jar\n\n```\n\nThis will generate `HBCK2` usage describing commands and options.\n\n## HFile Tool\n\nSee [HFile Tool](/docs/architecture/regions##architecture-regions-store-hfile-tool).\n\n## WAL Tools\n\nFor bulk replaying WAL files or *recovered.edits* files, see [WALPlayer](/docs/operational-management/tools#walplayer). For reading/verifying individual files, read on.\n\n### WALPrettyPrinter\n\nThe `WALPrettyPrinter` is a tool with configurable options to print the contents of a WAL or a *recovered.edits* file. You can invoke it via the HBase cli with the 'wal' command.\n\n```bash\n $ ./bin/hbase wal hdfs://example.org:9000/hbase/WALs/example.org,60020,1283516293161/10.10.21.10%3A60020.1283973724012\n```\n\n<Callout type=\"info\" title=\"WAL Printing in older versions of HBase\">\n  Prior to version 2.0, the `WALPrettyPrinter` was called the `HLogPrettyPrinter`, after an internal name for HBase's write ahead log. In those versions, you can print the contents of a WAL using the same configuration as above, but with the 'hlog' command.\n\n  ```bash\n   $ ./bin/hbase hlog hdfs://example.org:9000/hbase/.logs/example.org,60020,1283516293161/10.10.21.10%3A60020.1283973724012\n  ```\n</Callout>\n\n## Compression Tool\n\nSee [compression.test](/docs/compression#compressiontest).\n\n## CopyTable\n\nCopyTable is a utility that can copy part or of all of a table, either to the same cluster or another cluster. The target table must first exist. The usage is as follows:\n\n```bash\n$ ./bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable --help\n/bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable --help\nUsage: CopyTable [general options] [--starttime=X] [--endtime=Y] [--new.name=NEW] [--peer.adr=ADR] <tablename>\n\nOptions:\n rs.class     hbase.regionserver.class of the peer cluster,\n              specify if different from current cluster\n rs.impl      hbase.regionserver.impl of the peer cluster,\n startrow     the start row\n stoprow      the stop row\n starttime    beginning of the time range (unixtime in millis)\n              without endtime means from starttime to forever\n endtime      end of the time range.  Ignored if no starttime specified.\n versions     number of cell versions to copy\n new.name     new table's name\n peer.uri     The URI of the peer cluster\n peer.adr     Address of the peer cluster given in the format\n              hbase.zookeeer.quorum:hbase.zookeeper.client.port:zookeeper.znode.parent\n              Do not take effect if peer.uri is specified\n              Deprecated, please use peer.uri instead\n families     comma-separated list of families to copy\n              To copy from cf1 to cf2, give sourceCfName:destCfName.\n              To keep the same name, just give \"cfName\"\n all.cells    also copy delete markers and deleted cells\n\nArgs:\n tablename    Name of the table to copy\n\nExamples:\n To copy 'TestTable' to a cluster that uses replication for a 1 hour window:\n $ bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable --starttime=1265875194289 --endtime=1265878794289 --peer.adr=server1,server2,server3:2181:/hbase --families=myOldCf:myNewCf,cf2,cf3 TestTable\n\nFor performance consider the following general options:\n  It is recommended that you set the following to >=100. A higher value uses more memory but\n  decreases the round trip time to the server and may increase performance.\n    -Dhbase.client.scanner.caching=100\n  The following should always be set to false, to prevent writing data twice, which may produce\n  inaccurate results.\n    -Dmapred.map.tasks.speculative.execution=false\n```\n\nStarting from 3.0.0, we introduce a `peer.uri` option so the `peer.adr` option is deprecated. Please use connection URI for specifying HBase clusters. For all previous versions, you should still use the `peer.adr` option.\n\n<Callout type=\"info\" title=\"Scanner Caching\">\n  Caching for the input Scan is configured via `hbase.client.scanner.caching` in the job\n  configuration.\n</Callout>\n\n<Callout type=\"info\" title=\"Versions\">\n  By default, CopyTable utility only copies the latest version of row cells unless `--versions=n` is\n  explicitly specified in the command.\n</Callout>\n\n<Callout type=\"info\" title=\"Data Load\">\n  CopyTable does not perform a diff, it copies all Cells in between the specified startrow/stoprow\n  starttime/endtime range. This means that already existing cells with same values will still be\n  copied.\n</Callout>\n\nSee Jonathan Hsieh's [Online HBase Backups with CopyTable](https://blog.cloudera.com/blog/2012/06/online-hbase-backups-with-copytable-2/) blog post for more on `CopyTable`.\n\n## HashTable/SyncTable\n\nHashTable/SyncTable is a two steps tool for synchronizing table data, where each of the steps are implemented as MapReduce jobs. Similarly to CopyTable, it can be used for partial or entire table data syncing, under same or remote cluster. However, it performs the sync in a more efficient way than CopyTable. Instead of copying all cells in specified row key/time period range, HashTable (the first step) creates hashed indexes for batch of cells on source table and output those as results. On the next stage, SyncTable scans the source table and now calculates hash indexes for table cells, compares these hashes with the outputs of HashTable, then it just scans (and compares) cells for diverging hashes, only updating mismatching cells. This results in less network traffic/data transfers, which can be impacting when syncing large tables on remote clusters.\n\n### Step 1, HashTable\n\nFirst, run HashTable on the source table cluster (this is the table whose state will be copied to its counterpart).\n\nUsage:\n\n```bash\n$ ./bin/hbase org.apache.hadoop.hbase.mapreduce.HashTable --help\nUsage: HashTable [options] <tablename> <outputpath>\n\nOptions:\n batchsize         the target amount of bytes to hash in each batch\n                   rows are added to the batch until this size is reached\n                   (defaults to 8000 bytes)\n numhashfiles      the number of hash files to create\n                   if set to fewer than number of regions then\n                   the job will create this number of reducers\n                   (defaults to 1/100 of regions — at least 1)\n startrow          the start row\n stoprow           the stop row\n starttime         beginning of the time range (unixtime in millis)\n                   without endtime means from starttime to forever\n endtime           end of the time range.  Ignored if no starttime specified.\n scanbatch         scanner batch size to support intra row scans\n versions          number of cell versions to include\n families          comma-separated list of families to include\n ignoreTimestamps  if true, ignores cell timestamps\n\nArgs:\n tablename     Name of the table to hash\n outputpath    Filesystem path to put the output data\n\nExamples:\n To hash 'TestTable' in 32kB batches for a 1 hour window into 50 files:\n $ bin/hbase org.apache.hadoop.hbase.mapreduce.HashTable --batchsize=32000 --numhashfiles=50 --starttime=1265875194289 --endtime=1265878794289 --families=cf2,cf3 TestTable /hashes/testTable\n```\n\nThe **batchsize** property defines how much cell data for a given region will be hashed together in a single hash value. Sizing this properly has a direct impact on the sync efficiency, as it may lead to less scans executed by mapper tasks of SyncTable (the next step in the process). The rule of thumb is that, the smaller the number of cells out of sync (lower probability of finding a diff), larger batch size values can be determined.\n\n### Step 2, SyncTable\n\nOnce HashTable has completed on source cluster, SyncTable can be ran on target cluster. Just like replication and other synchronization jobs, it requires that all RegionServers/DataNodes on source cluster be accessible by NodeManagers on the target cluster (where SyncTable job tasks will be running).\n\nUsage:\n\n```bash\n$ ./bin/hbase org.apache.hadoop.hbase.mapreduce.SyncTable --help\nUsage: SyncTable [options] <sourcehashdir> <sourcetable> <targettable>\n\nOptions:\n sourceuri        Cluster connection uri of the source table\n                  (defaults to cluster in classpath's config)\n sourcezkcluster  ZK cluster key of the source table\n                  (defaults to cluster in classpath's config)\n                  Do not take effect if sourceuri is specifie\n                  Deprecated, please use sourceuri instead\n targeturi        Cluster connection uri of the target table\n                  (defaults to cluster in classpath's config)\n targetzkcluster  ZK cluster key of the target table\n                  (defaults to cluster in classpath's config)\n                  Do not take effect if targeturi is specified\n                  Deprecated, please use targeturi instead\n dryrun           if true, output counters but no writes\n                  (defaults to false)\n doDeletes        if false, does not perform deletes\n                  (defaults to true)\n doPuts           if false, does not perform puts\n                  (defaults to true)\n ignoreTimestamps if true, ignores cells timestamps while comparing\n                  cell values. Any missing cell on target then gets\n                  added with current time as timestamp\n                  (defaults to false)\n\nArgs:\n sourcehashdir    path to HashTable output dir for source table\n                  (see org.apache.hadoop.hbase.mapreduce.HashTable)\n sourcetable      Name of the source table to sync from\n targettable      Name of the target table to sync to\n\nExamples:\n For a dry run SyncTable of tableA from a remote source cluster\n to a local target cluster:\n $ bin/hbase org.apache.hadoop.hbase.mapreduce.SyncTable --dryrun=true --sourcezkcluster=zk1.example.com,zk2.example.com,zk3.example.com:2181:/hbase hdfs://nn:9000/hashes/tableA tableA tableA\n```\n\nStarting from 3.0.0, we introduce `sourceuri` and `targeturi` options so `sourcezkcluster` and `targetzkcluster` are deprecated. Please use connection URI for specifying HBase clusters. For all previous versions, you should still use `sourcezkcluster` and `targetzkcluster`.\n\nCell comparison takes ROW/FAMILY/QUALIFIER/TIMESTAMP/VALUE into account for equality. When syncing at the target, missing cells will be added with original timestamp value from source. That may cause unexpected results after SyncTable completes, for example, if missing cells on target have a delete marker with a timestamp T2 (say, a bulk delete performed by mistake), but source cells timestamps have an older value T1, then those cells would still be unavailable at target because of the newer delete marker timestamp. Since cell timestamps might not be relevant to all use cases, *ignoreTimestamps* option adds the flexibility to avoid using cells timestamp in the comparison. When using *ignoreTimestamps* set to true, this option must be specified for both HashTable and SyncTable steps.\n\nThe **dryrun** option is useful when a read only, diff report is wanted, as it will produce only COUNTERS indicating the differences, but will not perform any actual changes. It can be used as an alternative to VerifyReplication tool.\n\nBy default, SyncTable will cause target table to become an exact copy of source table (at least, for the specified startrow/stoprow or/and starttime/endtime).\n\nSetting doDeletes to false modifies default behaviour to not delete target cells that are missing on source. Similarly, setting doPuts to false modifies default behaviour to not add missing cells on target. Setting both doDeletes and doPuts to false would give same effect as setting dryrun to true.\n\n<Callout type=\"info\" title=\"Additional info on doDeletes/doPuts\">\n  \"doDeletes/doPuts\" were only added by\n  [HBASE-20305](https://issues.apache.org/jira/browse/HBASE-20305), so these may not be available on\n  all released versions. For major 1.x versions, minimum minor release including it is **1.4.10**.\n  For major 2.x versions, minimum minor release including it is **2.1.5**.\n</Callout>\n\n<Callout type=\"info\" title=\"Additional info on ignoreTimestamps\">\n  \"ignoreTimestamps\" was only added by\n  [HBASE-24302](https://issues.apache.org/jira/browse/HBASE-24302), so it may not be available on\n  all released versions. For major 1.x versions, minimum minor release including it is **1.4.14**.\n  For major 2.x versions, minimum minor release including it is **2.2.5**.\n</Callout>\n\n<Callout type=\"info\" title=\"Set doDeletes to false on Two-Way Replication scenarios\">\n  On Two-Way Replication or other scenarios where both source and target clusters can have data\n  ingested, it's advisable to always set doDeletes option to false, as any additional cell inserted\n  on SyncTable target cluster and not yet replicated to source would be deleted, and potentially\n  lost permanently.\n</Callout>\n\n<Callout type=\"info\" title=\"Set sourcezkcluster to the actual source cluster ZK quorum\">\n  Although not required, if sourcezkcluster is not set, SyncTable will connect to local HBase\n  cluster for both source and target, which does not give any meaningful result.\n</Callout>\n\n<Callout type=\"info\" title=\"Remote Clusters on different Kerberos Realms\">\n  Often, remote clusters may be deployed on different Kerberos Realms.\n  [HBASE-20586](https://issues.apache.org/jira/browse/HBASE-20586) added SyncTable support for cross\n  realm authentication, allowing a SyncTable process running on target cluster to connect to source\n  cluster and read both HashTable output files and the given HBase table when performing the\n  required comparisons.\n</Callout>\n\n## Export\n\nExport is a utility that will dump the contents of table to HDFS in a sequence file. The Export can be run via a Coprocessor Endpoint or MapReduce. Invoke via:\n\n**mapreduce-based Export**\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.mapreduce.Export TABLENAME OUTPUTDIR [VERSIONS [STARTTIME [ENDTIME]]]\n```\n\n**endpoint-based Export**\n\n<Callout type=\"info\">\n  Make sure the Export coprocessor is enabled by adding `org.apache.hadoop.hbase.coprocessor.Export`\n  to `hbase.coprocessor.region.classes`.\n</Callout>\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.coprocessor.Export TABLENAME OUTPUTDIR [VERSIONS [STARTTIME [ENDTIME]]]\n```\n\nThe outputdir is a HDFS directory that does not exist prior to the export. When done, the exported files will be owned by the user invoking the export command.\n\n**The Comparison of Endpoint-based Export And Mapreduce-based Export**\n\n|                           | Endpoint-based Export                                           | Mapreduce-based Export                                           |\n| ------------------------- | --------------------------------------------------------------- | ---------------------------------------------------------------- |\n| HBase version requirement | 2.0+                                                            | 0.2.1+                                                           |\n| Maven dependency          | hbase-endpoint                                                  | hbase-mapreduce (2.0+), hbase-server(prior to 2.0)               |\n| Requirement before dump   | mount the endpoint.Export on the target table                   | deploy the MapReduce framework                                   |\n| Read latency              | low, directly read the data from region                         | normal, traditional RPC scan                                     |\n| Read Scalability          | depend on number of regions                                     | depend on number of mappers (see TableInputFormatBase#getSplits) |\n| Timeout                   | operation timeout. configured by hbase.client.operation.timeout | scan timeout. configured by hbase.client.scanner.timeout.period  |\n| Permission requirement    | READ, EXECUTE                                                   | READ                                                             |\n| Fault tolerance           | no                                                              | depend on MapReduce                                              |\n\n<Callout type=\"info\">\n  To see usage instructions, run the command with no options. Available options include specifying\n  column families and applying filters during the export.\n</Callout>\n\nBy default, the `Export` tool only exports the newest version of a given cell, regardless of the number of versions stored. To export more than one version, replace ***\\<versions>*** with the desired number of versions.\n\nFor mapreduce based Export, if you want to export cell tags then set the following config property `hbase.client.rpc.codec` to `org.apache.hadoop.hbase.codec.KeyValueCodecWithTags`\n\nNote: caching for the input Scan is configured via `hbase.client.scanner.caching` in the job configuration.\n\n## Import\n\nImport is a utility that will load data that has been exported back into HBase. Invoke via:\n\n```bash\n$ bin/hbase -Dhbase.import.version=0.94 org.apache.hadoop.hbase.mapreduce.Import <tablename> <inputdir>\n```\n\n<Callout type=\"info\">\n  To see usage instructions, run the command with no options.\n</Callout>\n\nTo import 0.94 exported files in a 0.96 cluster or onwards, you need to set system property \"hbase.import.version\" when running the import command as below:\n\n```bash\n$ bin/hbase -Dhbase.import.version=0.94 org.apache.hadoop.hbase.mapreduce.Import TABLENAME INPUTDIR\n```\n\nIf you want to import cell tags then set the following config property `hbase.client.rpc.codec` to `org.apache.hadoop.hbase.codec.KeyValueCodecWithTags`\n\n## ImportTsv\n\nImportTsv is a utility that will load data in TSV format into HBase. It has two distinct usages: loading data from TSV format in HDFS into HBase via Puts, and preparing StoreFiles to be loaded via the `completebulkload`.\n\nTo load data via Puts (i.e., non-bulk loading):\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=a,b,c <tablename> <hdfs-inputdir>\n```\n\nTo generate StoreFiles for bulk-loading:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=a,b,c -Dimporttsv.bulk.output=hdfs://storefile-outputdir <tablename> <hdfs-data-inputdir>\n```\n\nThese generated StoreFiles can be loaded into HBase via [completebulkload](/docs/operational-management/tools#completebulkload).\n\n### ImportTsv Options\n\nRunning `ImportTsv` with no arguments prints brief usage information:\n\n```text\nUsage: importtsv -Dimporttsv.columns=a,b,c TABLENAME INPUTDIR\n\nImports the given input directory of TSV data into the specified table.\n\nThe column names of the TSV data must be specified using the -Dimporttsv.columns\noption. This option takes the form of comma-separated column names, where each\ncolumn name is either a simple column family, or a columnfamily:qualifier. The special\ncolumn name HBASE_ROW_KEY is used to designate that this column should be used\nas the row key for each imported record. You must specify exactly one column\nto be the row key, and you must specify a column name for every column that exists in the\ninput data.\n\nBy default importtsv will load data directly into HBase. To instead generate\nHFiles of data to prepare for a bulk data load, pass the option:\n  -Dimporttsv.bulk.output=/path/for/output\n  Note: the target table will be created with default column family descriptors if it does not already exist.\n\nOther options that may be specified with -D include:\n  -Dimporttsv.skip.bad.lines=false - fail if encountering an invalid line\n  '-Dimporttsv.separator=|' - eg separate on pipes instead of tabs\n  -Dimporttsv.timestamp=currentTimeAsLong - use the specified timestamp for the import\n  -Dimporttsv.mapper.class=my.Mapper - A user-defined Mapper to use instead of org.apache.hadoop.hbase.mapreduce.TsvImporterMapper\n\n```\n\n### ImportTsv Example\n\nFor example, assume that we are loading data into a table called 'datatsv' with a ColumnFamily called 'd' with two columns \"c1\" and \"c2\".\n\nAssume that an input file exists as follows:\n\n```text\nrow1    c1  c2\nrow2    c1  c2\nrow3    c1  c2\nrow4    c1  c2\nrow5    c1  c2\nrow6    c1  c2\nrow7    c1  c2\nrow8    c1  c2\nrow9    c1  c2\nrow10   c1  c2\n\n```\n\nFor ImportTsv to use this input file, the command line needs to look like this:\n\n```bash\n HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-mapreduce-VERSION.jar importtsv -Dimporttsv.columns=HBASE_ROW_KEY,d:c1,d:c2 -Dimporttsv.bulk.output=hdfs://storefileoutput datatsv hdfs://inputfile\n\n```\n\n... and in this example the first column is the rowkey, which is why the HBASE\\_ROW\\_KEY is used. The second and third columns in the file will be imported as \"d:c1\" and \"d:c2\", respectively.\n\n### ImportTsv Warning\n\nIf you have preparing a lot of data for bulk loading, make sure the target HBase table is pre-split appropriately.\n\n### See Also\n\nFor more information about bulk-loading HFiles into HBase, see [arch.bulk.load](/docs/architecture/bulk-loading)\n\n## CompleteBulkLoad\n\nThe `completebulkload` utility will move generated StoreFiles into an HBase table. This utility is often used in conjunction with output from [importtsv](/docs/operational-management/tools#importtsv).\n\nThere are two ways to invoke this utility, with explicit classname and via the driver:\n\n**Explicit Classname**\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.tool.LoadIncrementalHFiles hdfs://storefileoutput TABLENAME\n\n```\n\n**Driver**\n\n```bash\nHADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-mapreduce-VERSION.jar completebulkload hdfs://storefileoutput TABLENAME\n\n```\n\n### CompleteBulkLoad Warning\n\nData generated via MapReduce is often created with file permissions that are not compatible with the running HBase process. Assuming you're running HDFS with permissions enabled, those permissions will need to be updated before you run CompleteBulkLoad.\n\nFor more information about bulk-loading HFiles into HBase, see [arch.bulk.load](/docs/architecture/bulk-loading).\n\n## WALPlayer\n\nWALPlayer is a utility to replay WAL files into HBase.\n\nThe WAL can be replayed for a set of tables or all tables, and a timerange can be provided (in milliseconds). The WAL is filtered to this set of tables. The output can optionally be mapped to another set of tables.\n\nWALPlayer can also generate HFiles for later bulk importing, in that case only a single table and no mapping can be specified.\n\nFinally, you can use WALPlayer to replay the content of a Regions `recovered.edits` directory (the files under `recovered.edits` directory have the same format as WAL files).\n\n<Callout type=\"info\" title=\"WALPrettyPrinter\">\n  To read or verify single WAL files or *recovered.edits* files, since they share the WAL format,\n  see [WAL Tools](/docs/operational-management/tools#wal-tools).\n</Callout>\n\nInvoke via:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.mapreduce.WALPlayer [options] <WAL inputdir> [<tables> <tableMappings>]>\n```\n\nFor example:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.mapreduce.WALPlayer /backuplogdir oldTable1,oldTable2 newTable1,newTable2\n```\n\nWALPlayer, by default, runs as a mapreduce job. To NOT run WALPlayer as a mapreduce job on your cluster, force it to run all in the local process by adding the flags `-Dmapreduce.jobtracker.address=local` on the command line.\n\n### WALPlayer Options\n\nRunning `WALPlayer` with no arguments prints brief usage information:\n\n```text\nUsage: WALPlayer [options] <WAL inputdir> [<tables> <tableMappings>]\n <WAL inputdir>   directory of WALs to replay.\n <tables>         comma separated list of tables. If no tables specified,\n                  all are imported (even hbase:meta if present).\n <tableMappings>  WAL entries can be mapped to a new set of tables by passing\n                  <tableMappings>, a comma separated list of target tables.\n                  If specified, each table in <tables> must have a mapping.\nTo generate HFiles to bulk load instead of loading HBase directly, pass:\n -Dwal.bulk.output=/path/for/output\n Only one table can be specified, and no mapping allowed!\nTo specify a time range, pass:\n -Dwal.start.time=[date|ms]\n -Dwal.end.time=[date|ms]\n The start and the end date of timerange (inclusive). The dates can be\n expressed in milliseconds-since-epoch or yyyy-MM-dd'T'HH:mm:ss.SS format.\n E.g. 1234567890120 or 2009-02-13T23:32:30.12\nOther options:\n -Dmapreduce.job.name=jobName\n Use the specified mapreduce job name for the wal player\n -Dwal.input.separator=' '\n Change WAL filename separator (WAL dir names use default ','.)\nFor performance also consider the following options:\n  -Dmapreduce.map.speculative=false\n  -Dmapreduce.reduce.speculative=false\n```\n\n## RowCounter\n\n[RowCounter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html) is a mapreduce job to count all the rows of a table. This is a good utility to use as a sanity check to ensure that HBase can read all the blocks of a table if there are any concerns of metadata inconsistency. It will run the mapreduce all in a single process but it will run faster if you have a MapReduce cluster in place for it to exploit. It is possible to limit the time range of data to be scanned by using the `--starttime=[starttime]` and `--endtime=[endtime]` flags. The scanned data can be limited based on keys using the `--range=[startKey],[endKey][;[startKey],[endKey]...]` option.\n\n```bash\n$ bin/hbase rowcounter [options] <tablename> [--starttime=<start> --endtime=<end>] [--range=[startKey],[endKey][;[startKey],[endKey]...]] [<column1> <column2>...]\n```\n\nRowCounter only counts one version per cell.\n\nFor performance consider to use `-Dhbase.client.scanner.caching=100` and `-Dmapreduce.map.speculative=false` options.\n\n## CellCounter\n\nHBase ships another diagnostic mapreduce job called [CellCounter](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/mapreduce/CellCounter.html). Like RowCounter, it gathers more fine-grained statistics about your table. The statistics gathered by CellCounter are more fine-grained and include:\n\n* Total number of rows in the table.\n* Total number of CFs across all rows.\n* Total qualifiers across all rows.\n* Total occurrence of each CF.\n* Total occurrence of each qualifier.\n* Total number of versions of each qualifier.\n\nThe program allows you to limit the scope of the run. Provide a row regex or prefix to limit the rows to analyze. Specify a time range to scan the table by using the `--starttime=<starttime>` and `--endtime=<endtime>` flags.\n\nUse `hbase.mapreduce.scan.column.family` to specify scanning a single column family.\n\n```bash\n$ bin/hbase cellcounter TABLENAME OUTPUT_DIR [reportSeparator] [regex or prefix] [--starttime=STARTTIME --endtime=ENDTIME]\n```\n\nNote: just like RowCounter, caching for the input Scan is configured via `hbase.client.scanner.caching` in the job configuration.\n\n## mlockall\n\nIt is possible to optionally pin your servers in physical memory making them less likely to be swapped out in oversubscribed environments by having the servers call [mlockall](http://linux.die.net/man/2/mlockall) on startup. See [HBASE-4391 Add ability to start RS as root and call mlockall](https://issues.apache.org/jira/browse/HBASE-4391) for how to build the optional library and have it run on startup.\n\n## Offline Compaction Tool\n\n**CompactionTool** provides a way of running compactions (either minor or major) as an independent process from the RegionServer. It reuses same internal implementation classes executed by RegionServer compaction feature. However, since this runs on a complete separate independent java process, it releases RegionServers from the overhead involved in rewrite a set of hfiles, which can be critical for latency sensitive use cases.\n\nUsage:\n\n```\n$ ./bin/hbase org.apache.hadoop.hbase.regionserver.CompactionTool\n\nUsage: java org.apache.hadoop.hbase.regionserver.CompactionTool \\\n  [-compactOnce] [-major] [-mapred] [-D<property=value>]* files...\n\nOptions:\n mapred         Use MapReduce to run compaction.\n compactOnce    Execute just one compaction step. (default: while needed)\n major          Trigger major compaction.\n\nNote: -D properties will be applied to the conf used.\nFor example:\n To stop delete of compacted file, pass -Dhbase.compactiontool.delete=false\n To set tmp dir, pass -Dhbase.tmp.dir=ALTERNATE_DIR\n\nExamples:\n To compact the full 'TestTable' using MapReduce:\n $ hbase org.apache.hadoop.hbase.regionserver.CompactionTool -mapred hdfs://hbase/data/default/TestTable\n\n To compact column family 'x' of the table 'TestTable' region 'abc':\n $ hbase org.apache.hadoop.hbase.regionserver.CompactionTool hdfs://hbase/data/default/TestTable/abc/x\n```\n\nAs shown by usage options above, **CompactionTool** can run as a standalone client or a mapreduce job. When running as mapreduce job, each family dir is handled as an input split, and is processed by a separate map task.\n\nThe **compactionOnce** parameter controls how many compaction cycles will be performed until **CompactionTool** program decides to finish its work. If omitted, it will assume it should keep running compactions on each specified family as determined by the given compaction policy configured. For more info on compaction policy, see [compaction](/docs/architecture/regions#compaction).\n\nIf a major compaction is desired, **major** flag can be specified. If omitted, **CompactionTool** will assume minor compaction is wanted by default.\n\nIt also allows for configuration overrides with `-D` flag. In the usage section above, for example, `-Dhbase.compactiontool.delete=false` option will instruct compaction engine to not delete original files from temp folder.\n\nFiles targeted for compaction must be specified as parent hdfs dirs. It allows for multiple dirs definition, as long as each for these dirs are either a **family**, a **region**, or a **table** dir. If a table or region dir is passed, the program will recursively iterate through related sub-folders, effectively running compaction for each family found below the table/region level.\n\nSince these dirs are nested under **hbase** hdfs directory tree, **CompactionTool** requires hbase super user permissions in order to have access to required hfiles.\n\n<Callout type=\"info\" title=\"Running in MapReduce mode\">\n  MapReduce mode offers the ability to process each family dir in parallel, as a separate map task.\n  Generally, it would make sense to run in this mode when specifying one or more table dirs as\n  targets for compactions. The caveat, though, is that if number of families to be compacted become\n  too large, the related mapreduce job may have indirect impacts on **RegionServers** performance .\n  Since **NodeManagers** are normally co-located with RegionServers, such large jobs could compete\n  for IO/Bandwidth resources with the **RegionServers**.\n</Callout>\n\n<Callout type=\"info\" title=\"MajorCompaction completely disabled on RegionServers due performance impacts\">\n  **Major compactions** can be a costly operation (see\n  [compaction](/docs/architecture/regions#compaction)), and can indeed impact performance on\n  RegionServers, leading operators to completely disable it for critical low latency application.\n  **CompactionTool** could be used as an alternative in such scenarios, although, additional custom\n  application logic would need to be implemented, such as deciding scheduling and selection of\n  tables/regions/families target for a given compaction run.\n</Callout>\n\nFor additional details about CompactionTool, see also [CompactionTool](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/regionserver/CompactionTool.html).\n\n## `hbase clean`\n\nThe `hbase clean` command cleans HBase data from ZooKeeper, HDFS, or both. It is appropriate to use for testing. Run it with no options for usage instructions. The `hbase clean` command was introduced in HBase 0.98.\n\n```text\n$ bin/hbase clean\nUsage: hbase clean (--cleanZk|--cleanHdfs|--cleanAll)\nOptions:\n    --cleanZk   cleans hbase related data from zookeeper.\n    --cleanHdfs cleans hbase related data from hdfs.\n    --cleanAll  cleans hbase related data from both zookeeper and hdfs.\n```\n\n## `hbase pe`\n\nThe `hbase pe` command runs the PerformanceEvaluation tool, which is used for testing.\n\nThe PerformanceEvaluation tool accepts many different options and commands. For usage instructions, run the command with no options.\n\nThe PerformanceEvaluation tool has received many updates in recent HBase releases, including support for namespaces, support for tags, cell-level ACLs and visibility labels, multiget support for RPC calls, increased sampling sizes, an option to randomly sleep during testing, and ability to \"warm up\" the cluster before testing starts.\n\n## `hbase ltt`\n\nThe `hbase ltt` command runs the LoadTestTool utility, which is used for testing.\n\nYou must specify either `-init_only` or at least one of `-write`, `-update`, or `-read`. For general usage instructions, pass the `-h` option.\n\nThe LoadTestTool has received many updates in recent HBase releases, including support for namespaces, support for tags, cell-level ACLS and visibility labels, testing security-related features, ability to specify the number of regions per server, tests for multi-get RPC calls, and tests relating to replication.\n\n## Pre-Upgrade validator\n\nPre-Upgrade validator tool can be used to check the cluster for known incompatibilities before upgrading from HBase 1 to HBase 2.\n\n```bash\n$ bin/hbase pre-upgrade command ...\n```\n\n### Coprocessor validation\n\nHBase supports co-processors for a long time, but the co-processor API can be changed between major releases. Co-processor validator tries to determine whether the old co-processors are still compatible with the actual HBase version.\n\n```bash\n$ bin/hbase pre-upgrade validate-cp [-jar ...] [-class ... | -table ... | -config]\nOptions:\n -e            Treat warnings as errors.\n -jar <arg>    Jar file/directory of the coprocessor.\n -table <arg>  Table coprocessor(s) to check.\n -class <arg>  Coprocessor class(es) to check.\n -config         Scan jar for observers.\n```\n\nThe co-processor classes can be explicitly declared by `-class` option, or they can be obtained from HBase configuration by `-config` option. Table level co-processors can be also checked by `-table` option. The tool searches for co-processors on its classpath, but it can be extended by the `-jar` option. It is possible to test multiple classes with multiple `-class`, multiple tables with multiple `-table` options as well as adding multiple jars to the classpath with multiple `-jar` options.\n\nThe tool can report errors and warnings. Errors mean that HBase won't be able to load the coprocessor, because it is incompatible with the current version of HBase. Warnings mean that the co-processors can be loaded, but they won't work as expected. If `-e` option is given, then the tool will also fail for warnings.\n\nPlease note that this tool cannot validate every aspect of jar files, it just does some static checks.\n\nFor example:\n\n```bash\n$ bin/hbase pre-upgrade validate-cp -jar my-coprocessor.jar -class MyMasterObserver -class MyRegionObserver\n```\n\nIt validates `MyMasterObserver` and `MyRegionObserver` classes which are located in `my-coprocessor.jar`.\n\n```bash\n$ bin/hbase pre-upgrade validate-cp -table .*\n```\n\nIt validates every table level co-processors where the table name matches to `.*` regular expression.\n\n### DataBlockEncoding validation\n\nHBase 2.0 removed `PREFIX_TREE` Data Block Encoding from column families. For further information please check [*prefix-tree* encoding removed](/docs/upgrading/paths#prefix-tree-encoding-removed-toc). To verify that none of the column families are using incompatible Data Block Encodings in the cluster run the following command.\n\n```bash\n$ bin/hbase pre-upgrade validate-dbe\n```\n\nThis check validates all column families and print out any incompatibilities. For example:\n\n```\n2018-07-13 09:58:32,028 WARN  [main] tool.DataBlockEncodingValidator: Incompatible DataBlockEncoding for table: t, cf: f, encoding: PREFIX_TREE\n```\n\nWhich means that Data Block Encoding of table `t`, column family `f` is incompatible. To fix, use `alter` command in HBase shell:\n\n```ruby\nalter 't', { NAME => 'f', DATA_BLOCK_ENCODING => 'FAST_DIFF' }\n```\n\nPlease also validate HFiles, which is described in the next section.\n\n### HFile Content validation\n\nEven though Data Block Encoding is changed from `PREFIX_TREE` it is still possible to have HFiles that contain data encoded that way. To verify that HFiles are readable with HBase 2 please use *HFile content validator*.\n\n```bash\n$ bin/hbase pre-upgrade validate-hfile\n```\n\nThe tool will log the corrupt HFiles and details about the root cause. If the problem is about PREFIX\\_TREE encoding it is necessary to change encodings before upgrading to HBase 2.\n\nThe following log message shows an example of incorrect HFiles.\n\n```text\n2018-06-05 16:20:46,976 WARN  [hfilevalidator-pool1-t3] hbck.HFileCorruptionChecker: Found corrupt HFile hdfs://example.com:9000/hbase/data/default/t/72ea7f7d625ee30f959897d1a3e2c350/prefix/7e6b3d73263c4851bf2b8590a9b3791e\norg.apache.hadoop.hbase.io.hfile.CorruptHFileException: Problem reading HFile Trailer from file hdfs://example.com:9000/hbase/data/default/t/72ea7f7d625ee30f959897d1a3e2c350/prefix/7e6b3d73263c4851bf2b8590a9b3791e\n    ...\nCaused by: java.io.IOException: Invalid data block encoding type in file info: PREFIX_TREE\n    ...\nCaused by: java.lang.IllegalArgumentException: No enum constant org.apache.hadoop.hbase.io.encoding.DataBlockEncoding.PREFIX_TREE\n    ...\n2018-06-05 16:20:47,322 INFO  [main] tool.HFileContentValidator: Corrupted file: hdfs://example.com:9000/hbase/data/default/t/72ea7f7d625ee30f959897d1a3e2c350/prefix/7e6b3d73263c4851bf2b8590a9b3791e\n2018-06-05 16:20:47,383 INFO  [main] tool.HFileContentValidator: Corrupted file: hdfs://example.com:9000/hbase/archive/data/default/t/56be41796340b757eb7fff1eb5e2a905/f/29c641ae91c34fc3bee881f45436b6d1\n```\n\n#### Fixing PREFIX\\_TREE errors\n\nIt's possible to get `PREFIX_TREE` errors after changing Data Block Encoding to a supported one. It can happen because there are some HFiles which still encoded with `PREFIX_TREE` or there are still some snapshots.\n\nFor fixing HFiles, please run a major compaction on the table (it was `default:t` according to the log message):\n\n```ruby\nmajor_compact 't'\n```\n\nHFiles can be referenced from snapshots, too. It's the case when the HFile is located under `archive/data`. The first step is to determine which snapshot references that HFile (the name of the file was `29c641ae91c34fc3bee881f45436b6d1` according to the logs):\n\n```bash\nfor snapshot in $(hbase snapshotinfo -list-snapshots 2> /dev/null | tail -n -1 | cut -f 1 -d \\|);\ndo\n  echo \"checking snapshot named '${snapshot}'\";\n  hbase snapshotinfo -snapshot \"${snapshot}\" -files 2> /dev/null | grep 29c641ae91c34fc3bee881f45436b6d1;\ndone\n```\n\nThe output of this shell script is:\n\n```text\nchecking snapshot named 't_snap'\n   1.0 K t/56be41796340b757eb7fff1eb5e2a905/f/29c641ae91c34fc3bee881f45436b6d1 (archive)\n```\n\nWhich means `t_snap` snapshot references the incompatible HFile. If the snapshot is still needed, then it has to be recreated with HBase shell:\n\n```text\n# creating a new namespace for the cleanup process\ncreate_namespace 'pre_upgrade_cleanup'\n\n# creating a new snapshot\nclone_snapshot 't_snap', 'pre_upgrade_cleanup:t'\nalter 'pre_upgrade_cleanup:t', { NAME => 'f', DATA_BLOCK_ENCODING => 'FAST_DIFF' }\nmajor_compact 'pre_upgrade_cleanup:t'\n\n# removing the invalid snapshot\ndelete_snapshot 't_snap'\n\n# creating a new snapshot\nsnapshot 'pre_upgrade_cleanup:t', 't_snap'\n\n# removing temporary table\ndisable 'pre_upgrade_cleanup:t'\ndrop 'pre_upgrade_cleanup:t'\ndrop_namespace 'pre_upgrade_cleanup'\n```\n\nFor further information, please refer to [HBASE-20649](https://issues.apache.org/jira/browse/HBASE-20649?focusedCommentId=16535476#comment-16535476).\n\n## Data Block Encoding Tool\n\nTests various compression algorithms with different data block encoder for key compression on an existing HFile. Useful for testing, debugging and benchmarking.\n\nYou must specify `-f` which is the full path of the HFile.\n\nThe result shows both the performance (MB/s) of compression/decompression and encoding/decoding, and the data savings on the HFile.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.regionserver.DataBlockEncodingTool\nUsages: hbase org.apache.hadoop.hbase.regionserver.DataBlockEncodingTool\nOptions:\n        -f HFile to analyse (REQUIRED)\n        -n Maximum number of key/value pairs to process in a single benchmark run.\n        -b Whether to run a benchmark to measure read throughput.\n        -c If this is specified, no correctness testing will be done.\n        -a What kind of compression algorithm use for test. Default value: GZ.\n        -t Number of times to run each benchmark. Default value: 12.\n        -omit Number of first runs of every benchmark to omit from statistics. Default value: 2.\n```\n\n## HBase Conf Tool\n\nHBase Conf tool can be used to print out the current value of a configuration. It can be used by passing the configuration key on the command-line.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.util.HBaseConfTool <configuration_key>\n```\n\n## Node Management\n\n## Node Management\n\n### Node Decommission\n\nYou can stop an individual RegionServer by running the following script in the HBase directory on the particular node:\n\n```bash\n$ ./bin/hbase-daemon.sh stop regionserver\n```\n\nThe RegionServer will first close all regions and then shut itself down. On shutdown, the RegionServer's ephemeral node in ZooKeeper will expire. The master will notice the RegionServer gone and will treat it as a 'crashed' server; it will reassign the nodes the RegionServer was carrying.\n\n<Callout type=\"info\" title=\"Disable the Load Balancer before Decommissioning a node\">\n  If the load balancer runs while a node is shutting down, then there could be contention between\n  the Load Balancer and the Master's recovery of the just decommissioned RegionServer. Avoid any\n  problems by disabling the balancer first. See the \"Load Balancer\" info section below.\n</Callout>\n\n<Callout type=\"info\" title=\"Kill Node Tool\">\n  In hbase-2.0, in the bin directory, we added a script named *considerAsDead.sh* that can be used\n  to kill a regionserver. Hardware issues could be detected by specialized monitoring tools before\n  the zookeeper timeout has expired. *considerAsDead.sh* is a simple function to mark a RegionServer\n  as dead. It deletes all the znodes of the server, starting the recovery process. Plug in the\n  script into your monitoring/fault detection tools to initiate faster failover. Be careful how you\n  use this disruptive tool. Copy the script if you need to make use of it in a version of hbase\n  previous to hbase-2.0.\n</Callout>\n\nA downside to the above stop of a RegionServer is that regions could be offline for a good period of time. Regions are closed in order. If many regions on the server, the first region to close may not be back online until all regions close and after the master notices the RegionServer's znode gone. A node can be asked to gradually shed its load and then shutdown itself using the *graceful\\_stop.sh* script. Here is its usage:\n\n```\n$ ./bin/graceful_stop.sh\nUsage: graceful_stop.sh [--config <conf-dir>] [-e] [--restart [--reload]] [--thrift] [--rest] [-n |--noack] [--maxthreads <number of threads>] [--movetimeout <timeout in seconds>] [-nob |--nobalancer] [-d |--designatedfile <file path>] [-x |--excludefile <file path>] <hostname>\n thrift         If we should stop/start thrift before/after the hbase stop/start\n rest           If we should stop/start rest before/after the hbase stop/start\n restart        If we should restart after graceful stop\n reload         Move offloaded regions back on to the restarted server\n n|noack        Enable noAck mode in RegionMover. This is a best effort mode for moving regions\n maxthreads xx  Limit the number of threads used by the region mover. Default value is 1.\n movetimeout xx Timeout for moving regions. If regions are not moved by the timeout value,exit with error. Default value is INT_MAX.\n hostname       Hostname of server we are to stop\n e|failfast     Set -e so exit immediately if any command exits with non-zero status\n nob|nobalancer Do not manage balancer states. This is only used as optimization in rolling_restart.sh to avoid multiple calls to hbase shell\n d|designatedfile xx Designated file with <hostname:port> per line as unload targets\n x|excludefile xx Exclude file should have <hostname:port> per line. We do not unload regions to hostnames given in exclude file\n```\n\nTo decommission a loaded RegionServer, run the following: \\$ ./bin/graceful\\_stop.sh HOSTNAME where `HOSTNAME` is the host carrying the RegionServer you would decommission.\n\n<Callout type=\"info\" title=\"On HOSTNAME\">\n  The `HOSTNAME` passed to *graceful\\_stop.sh* must match the hostname that hbase is using to\n  identify RegionServers. HBase uses fully-qualified domain names usually. Check the list of\n  RegionServers in the master UI for how HBase is referring to servers. Whatever HBase is using,\n  this is what you should pass the *graceful\\_stop.sh* decommission script. If you pass IPs, the\n  script is not yet smart enough to make a hostname (or FQDN) of it and so it will fail when it\n  checks if server is currently running; the graceful unloading of regions will not run.\n</Callout>\n\nThe *graceful\\_stop.sh* script will move the regions off the decommissioned RegionServer one at a time to minimize region churn. It will verify the region deployed in the new location before it will moves the next region and so on until the decommissioned server is carrying zero regions. At this point, the *graceful\\_stop.sh* tells the RegionServer `stop`. The master will at this point notice the RegionServer gone but all regions will have already been redeployed and because the RegionServer went down cleanly, there will be no WAL logs to split.\n\n<Callout type=\"info\" title=\"Load Balancer\">\n  It is assumed that the Region Load Balancer is disabled while the `graceful_stop` script runs (otherwise the balancer and the decommission script will end up fighting over region deployments). Use the shell to disable the balancer:\n\n  ```ruby\n  hbase(main):001:0> balance_switch false\n  true\n  0 row(s) in 0.3590 seconds\n  ```\n\n  This turns the balancer OFF. To reenable, do:\n\n  ```ruby\n  hbase(main):001:0> balance_switch true\n  false\n  0 row(s) in 0.3590 seconds\n  ```\n\n  The `graceful_stop` will check the balancer and if enabled, will turn it off before it goes to work. If it exits prematurely because of error, it will not have reset the balancer. Hence, it is better to manage the balancer apart from `graceful_stop` reenabling it after you are done w/ graceful\\_stop.\n</Callout>\n\n#### Decommissioning several Regions Servers concurrently\n\nIf you have a large cluster, you may want to decommission more than one machine at a time by gracefully stopping multiple RegionServers concurrently. To gracefully drain multiple regionservers at the same time, RegionServers can be put into a \"draining\" state. This is done by marking a RegionServer as a draining node by creating an entry in ZooKeeper under the *hbase\\_root/draining* znode. This znode has format `name,port,startcode` just like the regionserver entries under *hbase\\_root/rs* znode.\n\nWithout this facility, decommissioning multiple nodes may be non-optimal because regions that are being drained from one region server may be moved to other regionservers that are also draining. Marking RegionServers to be in the draining state prevents this from happening. See this [blog post](http://inchoate-clatter.blogspot.com/2012/03/hbase-ops-automation.html) for more details.\n\n#### Bad or Failing Disk\n\nIt is good having [dfs.datanode.failed.volumes.tolerated](/docs/configuration/important#dfsdatanodefailedvolumestolerated) set if you have a decent number of disks per machine for the case where a disk plain dies. But usually disks do the \"John Wayne\" — i.e. take a while to go down spewing errors in *dmesg* — or for some reason, run much slower than their companions. In this case you want to decommission the disk. You have two options. You can [decommission the datanode](https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsDataNodeAdminGuide.html) or, less disruptive in that only the bad disks data will be rereplicated, can stop the datanode, unmount the bad volume (You can't umount a volume while the datanode is using it), and then restart the datanode (presuming you have set dfs.datanode.failed.volumes.tolerated > 0). The regionserver will throw some errors in its logs as it recalibrates where to get its data from — it will likely roll its WAL log too — but in general but for some latency spikes, it should keep on chugging.\n\n<Callout type=\"info\" title=\"Short Circuit Reads\">\n  If you are doing short-circuit reads, you will have to move the regions off the regionserver\n  before you stop the datanode; when short-circuiting reading, though chmod'd so regionserver cannot\n  have access, because it already has the files open, it will be able to keep reading the file\n  blocks from the bad disk even though the datanode is down. Move the regions back after you restart\n  the datanode.\n</Callout>\n\n### Rolling Restart\n\nSome cluster configuration changes require either the entire cluster, or the RegionServers, to be restarted in order to pick up the changes. In addition, rolling restarts are supported for upgrading to a minor or maintenance release, and to a major release if at all possible. See the release notes for release you want to upgrade to, to find out about limitations to the ability to perform a rolling upgrade.\n\nThere are multiple ways to restart your cluster nodes, depending on your situation. These methods are detailed below.\n\n#### Using the `rolling-restart.sh` Script\n\nHBase ships with a script, *bin/rolling-restart.sh*, that allows you to perform rolling restarts on the entire cluster, the master only, or the RegionServers only. The script is provided as a template for your own script, and is not explicitly tested. It requires password-less SSH login to be configured and assumes that you have deployed using a tarball. The script requires you to set some environment variables before running it. Examine the script and modify it to suit your needs.\n\n***rolling-restart.sh* General Usage**\n\n```bash\n$ ./bin/rolling-restart.sh --help\nUsage: rolling-restart.sh [--config <hbase-confdir>] [--rs-only] [--master-only] [--graceful] [--maxthreads xx]\n```\n\n**Rolling Restart on RegionServers Only**\\\nTo perform a rolling restart on the RegionServers only, use the `--rs-only` option. This might be necessary if you need to reboot the individual RegionServer or if you make a configuration change that only affects RegionServers and not the other HBase processes.\n\n**Rolling Restart on Masters Only**\\\nTo perform a rolling restart on the active and backup Masters, use the `--master-only` option. You might use this if you know that your configuration change only affects the Master and not the RegionServers, or if you need to restart the server where the active Master is running.\n\n**Graceful Restart**\\\nIf you specify the `--graceful` option, RegionServers are restarted using the *bin/graceful\\_stop.sh* script, which moves regions off a RegionServer before restarting it. This is safer, but can delay the restart.\n\nLimiting the Number of Threads\\\nTo limit the rolling restart to using only a specific number of threads, use the `--maxthreads` option.\n\n#### Manual Rolling Restart\n\nTo retain more control over the process, you may wish to manually do a rolling restart across your cluster. This uses the `graceful-stop.sh` command [decommission](/docs/operational-management/node#node-decommission). In this method, you can restart each RegionServer individually and then move its old regions back into place, retaining locality. If you also need to restart the Master, you need to do it separately, and restart the Master before restarting the RegionServers using this method. The following is an example of such a command. You may need to tailor it to your environment. This script does a rolling restart of RegionServers only. It disables the load balancer before moving the regions.\n\n```bash\n$ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i; done &> /tmp/log.txt &;\n```\n\nMonitor the output of the */tmp/log.txt* file to follow the progress of the script.\n\n#### Logic for Crafting Your Own Rolling Restart Script\n\nUse the following guidelines if you want to create your own rolling restart script.\n\n1. Extract the new release, verify its configuration, and synchronize it to all nodes of your cluster using `rsync`, `scp`, or another secure synchronization mechanism.\n\n2. Restart the master first. You may need to modify these commands if your new HBase directory is different from the old one, such as for an upgrade.\n\n   ```bash\n   $ ./bin/hbase-daemon.sh stop master; ./bin/hbase-daemon.sh start master\n   ```\n\n3. Gracefully restart each RegionServer, using a script such as the following, from the Master.\n\n   ```bash\n   $ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i; done &> /tmp/log.txt &\n   ```\n\n   If you are running Thrift or REST servers, pass the --thrift or --rest options. For other available options, run the `bin/graceful-stop.sh --help` command.\n\n   It is important to drain HBase regions slowly when restarting multiple RegionServers. Otherwise, multiple regions go offline simultaneously and must be reassigned to other nodes, which may also go offline soon. This can negatively affect performance. You can inject delays into the script above, for instance, by adding a Shell command such as `sleep`. To wait for 5 minutes between each RegionServer restart, modify the above script to the following:\n\n   ```bash\n   $ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i & sleep 5m; done &> /tmp/log.txt &\n   ```\n\n4. Restart the Master again, to clear out the dead servers list and re-enable the load balancer.\n\n### Adding a New Node\n\nAdding a new regionserver in HBase is essentially free, you simply start it like this: `$ ./bin/hbase-daemon.sh start regionserver` and it will register itself with the master. Ideally you also started a DataNode on the same machine so that the RS can eventually start to have local files. If you rely on ssh to start your daemons, don't forget to add the new hostname in *conf/regionservers* on the master.\n\nAt this point the region server isn't serving data because no regions have moved to it yet. If the balancer is enabled, it will start moving regions to the new RS. On a small/medium cluster this can have a very adverse effect on latency as a lot of regions will be offline at the same time. It is thus recommended to disable the balancer the same way it's done when decommissioning a node and move the regions manually (or even better, using a script that moves them one by one).\n\nThe moved regions will all have 0% locality and won't have any blocks in cache so the region server will have to use the network to serve requests. Apart from resulting in higher latency, it may also be able to use all of your network card's capacity. For practical purposes, consider that a standard 1GigE NIC won't be able to read much more than *100MB/s*. In this case, or if you are in a OLAP environment and require having locality, then it is recommended to major compact the moved regions.\n\n## Metrics & Monitoring\n\n## HBase Metrics\n\nHBase emits metrics which adhere to the [Hadoop Metrics](https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/Metrics.html) API. Starting with HBase 0.95\\[^1], HBase is configured to emit a default set of metrics with a default sampling period of every 10 seconds. You can use HBase metrics in conjunction with Ganglia. You can also filter which metrics are emitted and extend the metrics framework to capture custom metrics appropriate for your environment.\n\n### Metric Setup\n\nFor HBase 0.95 and newer, HBase ships with a default metrics configuration, or ***sink***. This includes a wide variety of individual metrics, and emits them every 10 seconds by default. To configure metrics for a given region server, edit the *conf/hadoop-metrics2-hbase.properties* file. Restart the region server for the changes to take effect.\n\nTo change the sampling rate for the default sink, edit the line beginning with `*.period`. To filter which metrics are emitted or to extend the metrics framework, see [https://hadoop.apache.org/docs/current/api/org/apache/hadoop/metrics2/package-summary.html](https://hadoop.apache.org/docs/current/api/org/apache/hadoop/metrics2/package-summary.html)\n\n<Callout type=\"info\" title=\"HBase Metrics and Ganglia\">\n  By default, HBase emits a large number of metrics per region server. Ganglia may have difficulty\n  processing all these metrics. Consider increasing the capacity of the Ganglia server or reducing\n  the number of metrics emitted by HBase. See [Metrics\n  Filtering](https://hadoop.apache.org/docs/current/api/org/apache/hadoop/metrics2/package-summary.html#filtering).\n</Callout>\n\n### Disabling Metrics\n\nTo disable metrics for a region server, edit the *conf/hadoop-metrics2-hbase.properties* file and comment out any uncommented lines. Restart the region server for the changes to take effect.\n\n### Enabling Metrics Servlets\n\nHBase exposes the metrics in many formats such as JSON, prometheus-format through different servlets (`/jmx`, `/metrics`, `/prometheus`). Any of these servlets can be enabled or disabled by the configuration property `hbase.http.metrics.servlets`. The value for the property should be a comma separated list of the servlet aliases which are `{jmx, metrics, prometheus}`. `/jmx`, `/metrics`, `/prometheus` are enabled by default. To get metrics using these servlets access the URL `http://SERVER_HOSTNAME:SERVER_WEB_UI_PORT/endpoint`. Where endpoint is one of `/jmx`, `/metrics`, or `/prometheus`. Eg. `http://my.rs.xyz.com:16030/prometheus`\n\n### Prometheus servlets\n\nHBase exposes the metrics in prometheus friendly format through a servlet, `/prometheus`. Currently `/prometheus` exposes all the available metrics.\n\n### Discovering Available Metrics\n\nRather than listing each metric which HBase emits by default, you can browse through the available metrics, either as a JSON output or via JMX. Different metrics are exposed for the Master process and each region server process.\n\n**Procedure: Access a JSON Output of Available Metrics**\n\n<Steps>\n  <Step>\n    After starting HBase, access the region server's web UI, at http\\://REGIONSERVER\\_HOSTNAME:16030 by default.\n  </Step>\n\n  <Step>\n    Click the **Metrics Dump** link near the top. The metrics for the region server are presented as a dump of the JMX bean in JSON format. This will dump out all metrics names and their values. To include metrics descriptions in the listing — this can be useful when you are exploring what is available — add a query string of `?description=true` so your URL becomes http\\://REGIONSERVER\\_HOSTNAME:16030/jmx?description=true. Not all beans and attributes have descriptions.\n  </Step>\n\n  <Step>\n    To view metrics for the Master, connect to the Master's web UI instead (defaults to [http://localhost:16010](http://localhost:16010)) and click its **Metrics Dump** link. To include metrics descriptions in the listing — this can be useful when you are exploring what is available — add a query string of `?description=true` so your URL becomes http\\://REGIONSERVER\\_HOSTNAME:16010/jmx?description=true. Not all beans and attributes have descriptions.\n  </Step>\n</Steps>\n\nYou can use many different tools to view JMX content by browsing MBeans. This procedure uses `jvisualvm`, which is an application usually available in the JDK.\n\n**Procedure: Browse the JMX Output of Available Metrics**\n\n<Steps>\n  <Step>\n    Start HBase, if it is not already running.\n  </Step>\n\n  <Step>\n    Run the command `jvisualvm` command on a host with a GUI display. You can launch it from the command line or another method appropriate for your operating system.\n  </Step>\n\n  <Step>\n    Be sure the **VisualVM-MBeans** plugin is installed. Browse to **Tools → Plugins**. Click **Installed** and check whether the plugin is listed. If not, click **Available Plugins**, select it, and click Install. When finished, click Close.\n  </Step>\n\n  <Step>\n    To view details for a given HBase process, double-click the process in the **Local** sub-tree in the left-hand panel. A detailed view opens in the right-hand panel. Click the **MBeans** tab which appears as a tab in the top of the right-hand panel.\n  </Step>\n\n  <Step>\n    To access the HBase metrics, navigate to the appropriate sub-bean: .\\* Master: .\\* RegionServer:\n  </Step>\n\n  <Step>\n    The name of each metric and its current value is displayed in the **Attributes** tab. For a view which includes more details, including the description of each attribute, click the **Metadata** tab.\n  </Step>\n</Steps>\n\n### Units of Measure for Metrics\n\nDifferent metrics are expressed in different units, as appropriate. Often, the unit of measure is in the name (as in the metric `shippedKBs`). Otherwise, use the following guidelines. When in doubt, you may need to examine the source for a given metric.\n\n* Metrics that refer to a point in time are usually expressed as a timestamp.\n* Metrics that refer to an age (such as `ageOfLastShippedOp`) are usually expressed in milliseconds.\n* Metrics that refer to memory sizes are in bytes.\n* Sizes of queues (such as `sizeOfLogQueue`) are expressed as the number of items in the queue. Determine the size by multiplying by the block size (default is 64 MB in HDFS).\n* Metrics that refer to things like the number of a given type of operations (such as `logEditsRead`) are expressed as an integer.\n\n### Most Important Master Metrics\n\nNote: Counts are usually over the last metrics reporting interval.\n\n**hbase.master.numRegionServers**\\\nNumber of live regionservers\n\n**hbase.master.numDeadRegionServers**\\\nNumber of dead regionservers\n\n**hbase.master.ritCount**\\\nThe number of regions in transition\n\n**hbase.master.ritCountOverThreshold**\\\nThe number of regions that have been in transition longer than a threshold time (default: 60 seconds)\n\n**hbase.master.ritOldestAge**\\\nThe age of the longest region in transition, in milliseconds\n\n### Most Important RegionServer Metrics\n\nNote: Counts are usually over the last metrics reporting interval.\n\n**hbase.regionserver.regionCount**\\\nThe number of regions hosted by the regionserver\n\n**hbase.regionserver.storeFileCount**\\\nThe number of store files on disk currently managed by the regionserver\n\n**hbase.regionserver.storeFileSize**\\\nAggregate size of the store files on disk\n\n**hbase.regionserver.hlogFileCount**\\\nThe number of write ahead logs not yet archived\n\n**hbase.regionserver.totalRequestCount**\\\nThe total number of requests received\n\n**hbase.regionserver.readRequestCount**\\\nThe number of read requests received\n\n**hbase.regionserver.writeRequestCount**\\\nThe number of write requests received\n\n**hbase.regionserver.numOpenConnections**\\\nThe number of open connections at the RPC layer\n\n**hbase.regionserver.numActiveHandler**\\\nThe number of RPC handlers actively servicing requests\n\n**hbase.regionserver.numCallsInGeneralQueue**\\\nThe number of currently enqueued user requests\n\n**hbase.regionserver.numCallsInReplicationQueue**\\\nThe number of currently enqueued operations received from replication\n\n**hbase.regionserver.numCallsInPriorityQueue**\\\nThe number of currently enqueued priority (internal housekeeping) requests\n\n**hbase.regionserver.flushQueueLength**\\\nCurrent depth of the memstore flush queue. If increasing, we are falling behind with clearing memstores out to HDFS.\n\n**hbase.regionserver.updatesBlockedTime**\\\nNumber of milliseconds updates have been blocked so the memstore can be flushed\n\n**hbase.regionserver.compactionQueueLength**\\\nCurrent depth of the compaction request queue. If increasing, we are falling behind with storefile compaction.\n\n**hbase.regionserver.blockCacheHitCount**\\\nThe number of block cache hits\n\n**hbase.regionserver.blockCacheMissCount**\\\nThe number of block cache misses\n\n**hbase.regionserver.blockCacheExpressHitPercent**\\\nThe percent of the time that requests with the cache turned on hit the cache\n\n**hbase.regionserver.percentFilesLocal**\\\nPercent of store file data that can be read from the local DataNode, 0-100\n\n**hbase.regionserver.\\<op>\\_\\<measure>**\\\nOperation latencies, where \\<op> is one of Append, Delete, Mutate, Get, Replay, Increment; and where \\<measure> is one of min, max, mean, median, 75th\\_percentile, 95th\\_percentile, 99th\\_percentile\n\n**hbase.regionserver.slow\\<op>Count**\\\nThe number of operations we thought were slow, where \\<op> is one of the list above\n\n**hbase.regionserver.GcTimeMillis**\\\nTime spent in garbage collection, in milliseconds\n\n**hbase.regionserver.GcTimeMillisParNew**\\\nTime spent in garbage collection of the young generation, in milliseconds\n\n**hbase.regionserver.GcTimeMillisConcurrentMarkSweep**\\\nTime spent in garbage collection of the old generation, in milliseconds\n\n**hbase.regionserver.authenticationSuccesses**\\\nNumber of client connections where authentication succeeded\n\n**hbase.regionserver.authenticationFailures**\\\nNumber of client connection authentication failures\n\n**hbase.regionserver.mutationsWithoutWALCount**\\\nCount of writes submitted with a flag indicating they should bypass the write ahead log\n\n### Meta Table Load Metrics\n\nHBase meta table metrics collection feature is available in HBase 1.4+ but it is disabled by default, as it can affect the performance of the cluster. When it is enabled, it helps to monitor client access patterns by collecting the following statistics:\n\n* number of get, put and delete operations on the `hbase:meta` table\n* number of get, put and delete operations made by the top-N clients\n* number of operations related to each table\n* number of operations related to the top-N regions\\\n  **When to use the feature**\\\n  This feature can help to identify hot spots in the meta table by showing the regions or tables where the meta info is modified (e.g. by create, drop, split or move tables) or retrieved most frequently. It can also help to find misbehaving client applications by showing which clients are using the meta table most heavily, which can for example suggest the lack of meta table buffering or the lack of re-using open client connections in the client application.\n\n<Callout type=\"warn\" title=\"Possible side-effects of enabling this feature\">\n  Having large number of clients and regions in the cluster can cause the registration and tracking\n  of a large amount of metrics, which can increase the memory and CPU footprint of the HBase region\n  server handling the `hbase:meta` table. It can also cause the significant increase of the JMX dump\n  size, which can affect the monitoring or log aggregation system you use beside HBase. It is\n  recommended to turn on this feature only during debugging.\n</Callout>\n\n**Where to find the metrics in JMX**\\\nEach metric attribute name will start with the ‘MetaTable\\_' prefix. For all the metrics you will see five different JMX attributes: count, mean rate, 1 minute rate, 5 minute rate and 15 minute rate. You will find these metrics in JMX under the following MBean: `Hadoop → HBase → RegionServer → Coprocessor.Region.CP_org.apache.hadoop.hbase.coprocessor.MetaTableMetrics`.\n\n**Examples: some Meta Table metrics you can see in your JMX dump**\n\n```json\n{\n  \"MetaTable_get_request_count\": 77309,\n  \"MetaTable_put_request_mean_rate\": 0.06339092997186495,\n  \"MetaTable_table_MyTestTable_request_15min_rate\": 1.1020599841623246,\n  \"MetaTable_client_/172.30.65.42_lossy_request_count\": 1786\n  \"MetaTable_client_/172.30.65.45_put_request_5min_rate\": 0.6189810954855728,\n  \"MetaTable_region_1561131112259.c66e4308d492936179352c80432ccfe0._lossy_request_count\": 38342,\n  \"MetaTable_region_1561131043640.5bdffe4b9e7e334172065c853cf0caa6._lossy_request_1min_rate\": 0.04925099917433935,\n}\n```\n\n**Configuration**\\\nTo turn on this feature, you have to enable a custom coprocessor by adding the following section to hbase-site.xml. This coprocessor will run on all the HBase RegionServers, but will be active (i.e. consume memory / CPU) only on the server, where the `hbase:meta` table is located. It will produce JMX metrics which can be downloaded from the web UI of the given RegionServer or by a simple REST call. These metrics will not be present in the JMX dump of the other RegionServers.\n\n**Enabling the Meta Table Metrics feature**\n\n```xml\n<property>\n    <name>hbase.coprocessor.region.classes</name>\n    <value>org.apache.hadoop.hbase.coprocessor.MetaTableMetrics</value>\n</property>\n```\n\n<Callout type=\"info\" title=\"How the top-N metrics are calculated?\">\n  The 'top-N' type of metrics will be counted using the Lossy Counting Algorithm (as defined in [Motwani, R; Manku, G.S (2002). \"Approximate frequency counts over data streams\"](http://www.vldb.org/conf/2002/S10P03.pdf)), which is designed to identify elements in a data stream whose frequency count exceed a user-given threshold. The frequency computed by this algorithm is not always accurate but has an error threshold that can be specified by the user as a configuration parameter. The run time space required by the algorithm is inversely proportional to the specified error threshold, hence larger the error parameter, the smaller the footprint and the less accurate are the metrics.\n\n  You can specify the error rate of the algorithm as a floating-point value between 0 and 1 (exclusive), it's default value is 0.02. Having the error rate set to `E` and having `N` as the total number of meta table operations, then (assuming the uniform distribution of the activity of low frequency elements) at most `7 / E` meters will be kept and each kept element will have a frequency higher than `E * N`.\n\n  An example: Let's assume we are interested in the HBase clients that are most active in accessing the meta table. When there was 1,000,000 operations on the meta table so far and the error rate parameter is set to 0.02, then we can assume that only at most 350 client IP address related counters will be present in JMX and each of these clients accessed the meta table at least 20,000 times.\n\n  ```xml\n  <property>\n      <name>hbase.util.default.lossycounting.errorrate</name>\n      <value>0.02</value>\n  </property>\n  ```\n</Callout>\n\n## HBase Monitoring\n\n### Overview\n\nThe following metrics are arguably the most important to monitor for each RegionServer for \"macro monitoring\", preferably with a system like [OpenTSDB](http://opentsdb.net/). If your cluster is having performance issues it's likely that you'll see something unusual with this group.\n\n#### HBase \\[!toc]\n\n* See [rs metrics](/docs/operational-management/metrics-and-monitoring#most-important-regionserver-metrics)\n\n#### OS \\[!toc]\n\n* IO Wait\n* User CPU\n\n#### Java \\[!toc]\n\n* GC\n\n### Slow Query Log\n\nThe HBase slow query log consists of parseable JSON structures describing the properties of those client operations (Gets, Puts, Deletes, etc.) that either took too long to run, or produced too much output. The thresholds for \"too long to run\" and \"too much output\" are configurable, as described below. The output is produced inline in the main region server logs so that it is easy to discover further details from context with other logged events. It is also prepended with identifying tags `(responseTooSlow)`, `(responseTooLarge)`, `(operationTooSlow)`, and `(operationTooLarge)` in order to enable easy filtering with grep, in case the user desires to see only slow queries.\n\n#### Configuration\n\nThere are four configuration knobs that can be used to adjust the thresholds for when queries are logged. Two of these knobs control the size and time thresholds for all queries. Because Scans can often be larger and slower than other types of queries, there are two additional knobs which can control size and time thresholds for Scans specifically.\n\n* `hbase.ipc.warn.response.time` Maximum number of milliseconds that a query can be run without being logged. Defaults to 10000, or 10 seconds. Can be set to -1 to disable logging by time.\n* `hbase.ipc.warn.response.size` Maximum byte size of response that a query can return without being logged. Defaults to 100 megabytes. Can be set to -1 to disable logging by size.\n* `hbase.ipc.warn.response.time.scan` Maximum number of milliseconds that a Scan can be run without being logged. Defaults to the `hbase.ipc.warn.response.time` value. Can be set to -1 to disable logging by time.\n* `hbase.ipc.warn.response.size.scan` Maximum byte size of response that a Scan can return without being logged. Defaults to the `hbase.ipc.warn.response.size` value. Can be set to -1 to disable logging by size.\n\n#### Metrics\n\nThe slow query log exposes to metrics to JMX.\n\n* `hadoop.regionserver_rpc_slowResponse` a global metric reflecting the durations of all responses that triggered logging.\n* `hadoop.regionserver_rpc_methodName.aboveOneSec` A metric reflecting the durations of all responses that lasted for more than one second.\n\n#### Output\n\nThe output is tagged with operation e.g. `(operationTooSlow)` if the call was a client operation, such as a Put, Get, or Delete, which we expose detailed fingerprint information for. If not, it is tagged `(responseTooSlow)` and still produces parseable JSON output, but with less verbose information solely regarding its duration and size in the RPC itself. `TooLarge` is substituted for `TooSlow` if the response size triggered the logging, with `TooLarge` appearing even in the case that both size and duration triggered logging.\n\n#### Example\n\n```text\n2011-09-08 10:01:25,824 WARN org.apache.hadoop.ipc.HBaseServer: (operationTooSlow): {\"tables\":{\"riley2\":{\"puts\":[{\"totalColumns\":11,\"families\":{\"actions\":[{\"timestamp\":1315501284459,\"qualifier\":\"0\",\"vlen\":9667580},{\"timestamp\":1315501284459,\"qualifier\":\"1\",\"vlen\":10122412},{\"timestamp\":1315501284459,\"qualifier\":\"2\",\"vlen\":11104617},{\"timestamp\":1315501284459,\"qualifier\":\"3\",\"vlen\":13430635}]},\"row\":\"cfcd208495d565ef66e7dff9f98764da:0\"}],\"families\":[\"actions\"]}},\"processingtimems\":956,\"client\":\"10.47.34.63:33623\",\"starttimems\":1315501284456,\"queuetimems\":0,\"totalPuts\":1,\"class\":\"HRegionServer\",\"responsesize\":0,\"method\":\"multiPut\"}\n```\n\nNote that everything inside the \"tables\" structure is output produced by MultiPut's fingerprint, while the rest of the information is RPC-specific, such as processing time and client IP/port. Other client operations follow the same pattern and the same general structure, with necessary differences due to the nature of the individual operations. In the case that the call is not a client operation, that detailed fingerprint information will be completely absent.\n\nThis particular example, for example, would indicate that the likely cause of slowness is simply a very large (on the order of 100MB) multiput, as we can tell by the \"vlen,\" or value length, fields of each put in the multiPut.\n\n#### Get Slow Response Log from shell\n\nWhen an individual RPC exceeds a configurable time bound we log a complaint by way of the logging subsystem\n\ne.g.\n\n```text\n2019-10-02 10:10:22,195 WARN [,queue=15,port=60020] ipc.RpcServer - (responseTooSlow):\n{\"call\":\"Scan(org.apache.hadoop.hbase.protobuf.generated.ClientProtos$ScanRequest)\",\n\"starttimems\":1567203007549,\n\"responsesize\":6819737,\n\"method\":\"Scan\",\n\"param\":\"region { type: REGION_NAME value: \\\"t1,\\\\000\\\\000\\\\215\\\\f)o\\\\\\\\\\\\024\\\\302\\\\220\\\\000\\\\000\\\\000\\\\000\\\\000\\\\001\\\\000\\\\000\\\\000\\\\000\\\\000\\\\006\\\\000\\\\000\\\\000\\\\000\\\\000\\\\005\\\\000\\\\000<TRUNCATED>\",\n\"processingtimems\":28646,\n\"client\":\"10.253.196.215:41116\",\n\"queuetimems\":22453,\n\"class\":\"HRegionServer\"}\n```\n\nUnfortunately often the request parameters are truncated as per above Example. The truncation is unfortunate because it eliminates much of the utility of the warnings. For example, the region name, the start and end keys, and the filter hierarchy are all important clues for debugging performance problems caused by moderate to low selectivity queries or queries made at a high rate.\n\nHBASE-22978 introduces maintaining an in-memory ring buffer of requests that were judged to be too slow in addition to the responseTooSlow logging. The in-memory representation can be complete. There is some chance a high rate of requests will cause information on other interesting requests to be overwritten before it can be read. This is an acceptable trade off.\n\nIn order to enable the in-memory ring buffer at RegionServers, we need to enable config:\n\n```text\nhbase.regionserver.slowlog.buffer.enabled\n```\n\nOne more config determines the size of the ring buffer:\n\n```text\nhbase.regionserver.slowlog.ringbuffer.size\n```\n\nCheck the config section for the detailed description.\n\nThis config would be disabled by default. Turn it on and these shell commands would provide expected results from the ring-buffers.\n\nshell commands to retrieve slowlog responses from RegionServers:\n\n```text\nRetrieve latest SlowLog Responses maintained by each or specific RegionServers.\nSpecify '*' to include all RS otherwise array of server names for specific\nRS. A server name is the host, port plus startcode of a RegionServer.\ne.g.: host187.example.com,60020,1289493121758 (find servername in\nmaster ui or when you do detailed status in shell)\n\nProvide optional filter parameters as Hash.\nDefault Limit of each server for providing no of slow log records is 10. User can specify\nmore limit by 'LIMIT' param in case more than 10 records should be retrieved.\n\nExamples:\n\n  hbase> get_slowlog_responses '*'                                 => get slowlog responses from all RS\n  hbase> get_slowlog_responses '*', {'LIMIT' => 50}                => get slowlog responses from all RS\n                                                                      with 50 records limit (default limit: 10)\n  hbase> get_slowlog_responses ['SERVER_NAME1', 'SERVER_NAME2']    => get slowlog responses from SERVER_NAME1,\n                                                                      SERVER_NAME2\n  hbase> get_slowlog_responses '*', {'REGION_NAME' => 'hbase:meta,,1'}\n                                                                   => get slowlog responses only related to meta\n                                                                      region\n  hbase> get_slowlog_responses '*', {'TABLE_NAME' => 't1'}         => get slowlog responses only related to t1 table\n  hbase> get_slowlog_responses '*', {'CLIENT_IP' => '192.162.1.40:60225', 'LIMIT' => 100}\n                                                                   => get slowlog responses with given client\n                                                                      IP address and get 100 records limit\n                                                                      (default limit: 10)\n  hbase> get_slowlog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1'}\n                                                                   => get slowlog responses with given region name\n                                                                      or table name\n  hbase> get_slowlog_responses '*', {'USER' => 'user_name', 'CLIENT_IP' => '192.162.1.40:60225'}\n                                                                   => get slowlog responses that match either\n                                                                      provided client IP address or user name\n```\n\nAll of above queries with filters have default OR operation applied i.e. all records with any of the provided filters applied will be returned. However, we can also apply AND operator i.e. all records that match all (not any) of the provided filters should be returned.\n\n```ruby\n  hbase> get_slowlog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1', 'FILTER_BY_OP' => 'AND'}\n                                                                   => get slowlog responses with given region name\n                                                                      and table name, both should match\n\n  hbase> get_slowlog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1', 'FILTER_BY_OP' => 'OR'}\n                                                                   => get slowlog responses with given region name\n                                                                      or table name, any one can match\n\n  hbase> get_slowlog_responses '*', {'TABLE_NAME' => 't1', 'CLIENT_IP' => '192.163.41.53:52781', 'FILTER_BY_OP' => 'AND'}\n                                                                   => get slowlog responses with given region name\n                                                                      and client IP address, both should match\n```\n\nSince OR is the default filter operator, without providing 'FILTER\\_BY\\_OP', query will have same result as providing 'FILTER\\_BY\\_OP' ⇒ 'OR'.\n\nSometimes output can be long pretty printed json for user to scroll in a single screen and hence user might prefer redirecting output of get\\_slowlog\\_responses to a file.\n\nExample:\n\n```bash\necho \"get_slowlog_responses '*'\" | hbase shell > xyz.out 2>&1\n```\n\nSimilar to slow RPC logs, client can also retrieve large RPC logs. Sometimes, slow logs important to debug perf issues turn out to be larger in size.\n\n```ruby\n  hbase> get_largelog_responses '*'                                 => get largelog responses from all RS\n  hbase> get_largelog_responses '*', {'LIMIT' => 50}                => get largelog responses from all RS\n                                                                       with 50 records limit (default limit: 10)\n  hbase> get_largelog_responses ['SERVER_NAME1', 'SERVER_NAME2']    => get largelog responses from SERVER_NAME1,\n                                                                       SERVER_NAME2\n  hbase> get_largelog_responses '*', {'REGION_NAME' => 'hbase:meta,,1'}\n                                                                    => get largelog responses only related to meta\n                                                                       region\n  hbase> get_largelog_responses '*', {'TABLE_NAME' => 't1'}         => get largelog responses only related to t1 table\n  hbase> get_largelog_responses '*', {'CLIENT_IP' => '192.162.1.40:60225', 'LIMIT' => 100}\n                                                                    => get largelog responses with given client\n                                                                       IP address and get 100 records limit\n                                                                       (default limit: 10)\n  hbase> get_largelog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1'}\n                                                                    => get largelog responses with given region name\n                                                                       or table name\n  hbase> get_largelog_responses '*', {'USER' => 'user_name', 'CLIENT_IP' => '192.162.1.40:60225'}\n                                                                    => get largelog responses that match either\n                                                                       provided client IP address or user name\n\n  hbase> get_largelog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1', 'FILTER_BY_OP' => 'AND'}\n                                                                   => get largelog responses with given region name\n                                                                      and table name, both should match\n\n  hbase> get_largelog_responses '*', {'REGION_NAME' => 'hbase:meta,,1', 'TABLE_NAME' => 't1', 'FILTER_BY_OP' => 'OR'}\n                                                                   => get largelog responses with given region name\n                                                                      or table name, any one can match\n\n  hbase> get_largelog_responses '*', {'TABLE_NAME' => 't1', 'CLIENT_IP' => '192.163.41.53:52781', 'FILTER_BY_OP' => 'AND'}\n                                                                   => get largelog responses with given region name\n                                                                      and client IP address, both should match\n```\n\nshell command to clear slow/largelog responses from RegionServer:\n\n```\nClears SlowLog Responses maintained by each or specific RegionServers.\nSpecify array of server names for specific RS. A server name is\nthe host, port plus startcode of a RegionServer.\ne.g.: host187.example.com,60020,1289493121758 (find servername in\nmaster ui or when you do detailed status in shell)\n\nExamples:\n\n  hbase> clear_slowlog_responses                                     => clears slowlog responses from all RS\n  hbase> clear_slowlog_responses ['SERVER_NAME1', 'SERVER_NAME2']    => clears slowlog responses from SERVER_NAME1,\n                                                                        SERVER_NAME2\n```\n\n#### Get Slow/Large Response Logs from System table hbase:slowlog\n\nThe above section provides details about Admin APIs:\n\n* get\\_slowlog\\_responses\n* get\\_largelog\\_responses\n* clear\\_slowlog\\_responses\n\nAll of the above APIs access online in-memory ring buffers from individual RegionServers and accumulate logs from ring buffers to display to end user. However, since the logs are stored in memory, after RegionServer is restarted, all the objects held in memory of that RegionServer will be cleaned up and previous logs are lost. What if we want to persist all these logs forever? What if we want to store them in such a manner that operator can get all historical records with some filters? e.g get me all large/slow RPC logs that are triggered by user1 and are related to region: cluster\\_test,cccccccc,1589635796466.aa45e1571d533f5ed0bb31cdccaaf9cf. ?\n\nIf we have a system table that stores such logs in increasing (not so strictly though) order of time, it can definitely help operators debug some historical events (scan, get, put, compaction, flush etc) with detailed inputs.\n\nConfig which enabled system table to be created and store all log events is `hbase.regionserver.slowlog.systable.enabled`.\n\nThe default value for this config is `false`. If provided `true` (Note: `hbase.regionserver.slowlog.buffer.enabled` should also be `true`), a cron job running in every RegionServer will persist the slow/large logs into table hbase:slowlog. By default cron job runs every 10 min. Duration can be configured with key: `hbase.slowlog.systable.chore.duration`. By default, RegionServer will store upto 1000(config key: `hbase.regionserver.slowlog.systable.queue.size`) slow/large logs in an internal queue and the chore will retrieve these logs from the queue and perform batch insertion in hbase:slowlog.\n\nhbase:slowlog has single ColumnFamily: `info` `info` contains multiple qualifiers which are the same attributes present as part of `get_slowlog_responses` API response.\n\n* info:call\\_details\n* info:client\\_address\n* info:method\\_name\n* info:param\n* info:processing\\_time\n* info:queue\\_time\n* info:region\\_name\n* info:response\\_size\n* info:server\\_class\n* info:start\\_time\n* info:type\n* info:username\n\nAnd example of 2 rows from hbase:slowlog scan result:\n\n```text\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:call_details, timestamp=2020-05-16T14:58:14.211Z, value=Scan(org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos$ScanRequest)\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:client_address, timestamp=2020-05-16T14:58:14.211Z, value=172.20.10.2:57347\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:method_name, timestamp=2020-05-16T14:58:14.211Z, value=Scan\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:param, timestamp=2020-05-16T14:58:14.211Z, value=region { type: REGION_NAME value: \"hbase:meta,,1\" } scan { column { family: \"info\" } attribute { name: \"_isolationle\n                                                             vel_\" value: \"\\x5C000\" } start_row: \"cluster_test,33333333,99999999999999\" stop_row: \"cluster_test,,\" time_range { from: 0 to: 9223372036854775807 } max_versions: 1 cache_blocks\n                                                             : true max_result_size: 2097152 reversed: true caching: 10 include_stop_row: true readType: PREAD } number_of_rows: 10 close_scanner: false client_handles_partials: true client_\n                                                             handles_heartbeats: true track_scan_metrics: false\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:processing_time, timestamp=2020-05-16T14:58:14.211Z, value=18\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:queue_time, timestamp=2020-05-16T14:58:14.211Z, value=0\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:region_name, timestamp=2020-05-16T14:58:14.211Z, value=hbase:meta,,1\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:response_size, timestamp=2020-05-16T14:58:14.211Z, value=1575\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:server_class, timestamp=2020-05-16T14:58:14.211Z, value=HRegionServer\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:start_time, timestamp=2020-05-16T14:58:14.211Z, value=1589640743732\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:type, timestamp=2020-05-16T14:58:14.211Z, value=ALL\n \\x024\\xC1\\x03\\xE9\\x04\\xF5@                                  column=info:username, timestamp=2020-05-16T14:58:14.211Z, value=user2\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:call_details, timestamp=2020-05-16T14:59:58.764Z, value=Scan(org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos$ScanRequest)\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:client_address, timestamp=2020-05-16T14:59:58.764Z, value=172.20.10.2:57348\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:method_name, timestamp=2020-05-16T14:59:58.764Z, value=Scan\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:param, timestamp=2020-05-16T14:59:58.764Z, value=region { type: REGION_NAME value: \"cluster_test,cccccccc,1589635796466.aa45e1571d533f5ed0bb31cdccaaf9cf.\" } scan { a\n                                                             ttribute { name: \"_isolationlevel_\" value: \"\\x5C000\" } start_row: \"cccccccc\" time_range { from: 0 to: 9223372036854775807 } max_versions: 1 cache_blocks: true max_result_size: 2\n                                                             097152 caching: 2147483647 include_stop_row: false } number_of_rows: 2147483647 close_scanner: false client_handles_partials: true client_handles_heartbeats: true track_scan_met\n                                                             rics: false\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:processing_time, timestamp=2020-05-16T14:59:58.764Z, value=24\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:queue_time, timestamp=2020-05-16T14:59:58.764Z, value=0\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:region_name, timestamp=2020-05-16T14:59:58.764Z, value=cluster_test,cccccccc,1589635796466.aa45e1571d533f5ed0bb31cdccaaf9cf.\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:response_size, timestamp=2020-05-16T14:59:58.764Z, value=211227\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:server_class, timestamp=2020-05-16T14:59:58.764Z, value=HRegionServer\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:start_time, timestamp=2020-05-16T14:59:58.764Z, value=1589640743932\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:type, timestamp=2020-05-16T14:59:58.764Z, value=ALL\n \\x024\\xC1\\x06X\\x81\\xF6\\xEC                                  column=info:username, timestamp=2020-05-16T14:59:58.764Z, value=user1\n```\n\nOperator can use ColumnValueFilter to filter records based on region\\_name, username, client\\_address etc.\n\nTime range based queries will also be very useful. Example:\n\n```bash\nscan 'hbase:slowlog', { TIMERANGE => [1589621394000, 1589637999999] }\n```\n\n### Block Cache Monitoring\n\nStarting with HBase 0.98, the HBase Web UI includes the ability to monitor and report on the performance of the block cache. To view the block cache reports, see the Block Cache section of the region server UI. Following are a few examples of the reporting capabilities.\n\n***Basic Info shows the cache implementation.***\n<img alt=\"bc basic\" src={__img10} placeholder=\"blur\" />\n\n***Config shows all cache configuration options.***\n<img alt=\"bc config\" src={__img11} placeholder=\"blur\" />\n\n***Stats shows statistics about the performance of the cache.***\n<img alt=\"bc stats\" src={__img12} placeholder=\"blur\" />\n\n***L1 and L2 show information about the L1 and L2 caches.***\n<img alt=\"bc l1\" src={__img13} placeholder=\"blur\" />\n\nThis is not an exhaustive list of all the screens and reports available. Have a look in the Web UI.\n\n### Snapshot Space Usage Monitoring\n\nStarting with HBase 0.95, Snapshot usage information on individual snapshots was shown in the HBase Master Web UI. This was further enhanced starting with HBase 1.3 to show the total Storefile size of the Snapshot Set. The following metrics are shown in the Master Web UI with HBase 1.3 and later.\n\n* Shared Storefile Size is the Storefile size shared between snapshots and active tables.\n* Mob Storefile Size is the Mob Storefile size shared between snapshots and active tables.\n* Archived Storefile Size is the Storefile size in Archive.\n\nThe format of Archived Storefile Size is NNN(MMM). NNN is the total Storefile size in Archive, MMM is the total Storefile size in Archive that is specific to the snapshot (not shared with other snapshots and tables).\n\n***Master Snapshot Overview***\n<img alt=\"master-snapshot\" src={__img14} placeholder=\"blur\" />\n\n***Snapshot Storefile Stats Example 1***\n<img alt=\"1 snapshot\" src={__img15} placeholder=\"blur\" />\n\n***Snapshot Storefile Stats Example 2***\n<img alt=\"2 snapshot\" src={__img16} placeholder=\"blur\" />\n\n***Empty Snapshot Storfile Stats Example***\n<img alt=\"empty snapshots\" src={__img17} placeholder=\"blur\" />\n\n## Cluster Replication\n\n## Cluster Replication\n\nHBase provides a cluster replication mechanism which allows you to keep one cluster's state synchronized with that of another cluster, using the write-ahead log (WAL) of the source cluster to propagate the changes. Some use cases for cluster replication include:\n\n* Backup and disaster recovery\n* Data aggregation\n* Geographic data distribution\n* Online data ingestion combined with offline data analytics\n\n<Callout type=\"info\">\n  Replication is enabled at the granularity of the column family. Before enabling replication for a\n  column family, create the table and all column families to be replicated, on the destination\n  cluster.\n</Callout>\n\n<Callout type=\"info\">\n  Replication is asynchronous as we send WAL to another cluster in background, which means that when\n  you want to do recovery through replication, you could loss some data. To address this problem, we\n  have introduced a new feature called synchronous replication. As the mechanism is a bit different\n  so we use a separated section to describe it. Please see [Synchronous\n  Replication](/docs/sync-replication).\n</Callout>\n\n<Callout type=\"info\">\n  At present, there is compatibility problem if Replication and WAL Compression are used together.\n  If you need to use Replication, it is recommended to set the\n  `hbase.regionserver.wal.enablecompression` property to `false`. See\n  ([HBASE-26849](https://issues.apache.org/jira/browse/HBASE-26849)) for details.\n</Callout>\n\n### Replication Overview\n\nCluster replication uses a source-push methodology. An HBase cluster can be a source (also called master or active, meaning that it is the originator of new data), a destination (also called slave or passive, meaning that it receives data via replication), or can fulfill both roles at once. Replication is asynchronous, and the goal of replication is eventual consistency. When the source receives an edit to a column family with replication enabled, that edit is propagated to all destination clusters using the WAL for that for that column family on the RegionServer managing the relevant region.\n\nWhen data is replicated from one cluster to another, the original source of the data is tracked via a cluster ID which is part of the metadata. In HBase 0.96 and newer ([HBASE-7709](https://issues.apache.org/jira/browse/HBASE-7709)), all clusters which have already consumed the data are also tracked. This prevents replication loops.\n\nThe WALs for each region server must be kept in HDFS as long as they are needed to replicate data to any slave cluster. Each region server reads from the oldest log it needs to replicate and keeps track of its progress processing WALs inside ZooKeeper to simplify failure recovery. The position marker which indicates a slave cluster's progress, as well as the queue of WALs to process, may be different for every slave cluster.\n\nThe clusters participating in replication can be of different sizes. The master cluster relies on randomization to attempt to balance the stream of replication on the slave clusters. It is expected that the slave cluster has storage capacity to hold the replicated data, as well as any data it is responsible for ingesting. If a slave cluster does run out of room, or is inaccessible for other reasons, it throws an error and the master retains the WAL and retries the replication at intervals.\n\n<Callout type=\"warn\" title=\"Consistency Across Replicated Clusters\">\n  How your application builds on top of the HBase API matters when replication is in play. HBase's replication system provides at-least-once delivery of client edits for an enabled column family to each configured destination cluster. In the event of failure to reach a given destination, the replication system will retry sending edits in a way that might repeat a given message. HBase provides two ways of replication, one is the original replication and the other is serial replication. In the previous way of replication, there is not a guaranteed order of delivery for client edits. In the event of a RegionServer failing, recovery of the replication queue happens independent of recovery of the individual regions that server was previously handling. This means that it is possible for the not-yet-replicated edits to be serviced by a RegionServer that is currently slower to replicate than the one that handles edits from after the failure.\n\n  The combination of these two properties (at-least-once delivery and the lack of message ordering) means that some destination clusters may end up in a different state if your application makes use of operations that are not idempotent, e.g. Increments.\n\n  To solve the problem, HBase now supports serial replication, which sends edits to destination cluster as the order of requests from client. See [Serial Replication](/docs/operational-management/cluster-replication#serial-replication).\n</Callout>\n\n<Callout type=\"info\" title=\"Terminology Changes\">\n  Previously, terms such as **master-master**, **master-slave**, and **cyclical** were used to\n  describe replication relationships in HBase. These terms added confusion, and have been abandoned\n  in favor of discussions about cluster topologies appropriate for different scenarios.\n</Callout>\n\n#### Cluster Topologies\n\n* A central source cluster might propagate changes out to multiple destination clusters, for failover or due to geographic distribution.\n* A source cluster might push changes to a destination cluster, which might also push its own changes back to the original cluster.\n* Many different low-latency clusters might push changes to one centralized cluster for backup or resource-intensive data analytics jobs. The processed data might then be replicated back to the low-latency clusters.\n\nMultiple levels of replication may be chained together to suit your organization's needs. The following diagram shows a hypothetical scenario. Use the arrows to follow the data paths.\n\n***Example of a Complex Cluster Replication Configuration***\n<img alt=\"hbase replication diagram\" src={__img18} placeholder=\"blur\" />\n\nHBase replication borrows many concepts from the **statement-based replication** design used by MySQL. Instead of SQL statements, entire WALEdits (consisting of multiple cell inserts coming from Put and Delete operations on the clients) are replicated in order to maintain atomicity.\n\n### Managing and Configuring Cluster Replication\n\n#### Cluster Configuration Overview\n\n1. Configure and start the source and destination clusters. Create tables with the same names and column families on both the source and destination clusters, so that the destination cluster knows where to store data it will receive.\n2. All hosts in the source and destination clusters should be reachable to each other.\n3. If both clusters use the same ZooKeeper cluster, you must use a different `zookeeper.znode.parent`, because they cannot write in the same folder.\n4. On the source cluster, in HBase Shell, add the destination cluster as a peer, using the `add_peer` command.\n5. On the source cluster, in HBase Shell, enable the table replication, using the `enable_table_replication` command.\n6. Check the logs to see if replication is taking place. If so, you will see messages like the following, coming from the ReplicationSource.\n\n```java\nLOG.info(\"Replicating \"+clusterId + \" -> \" + peerClusterId);\n```\n\n#### Serial Replication Configuration\n\nSee [Serial Replication](/docs/operational-management/cluster-replication#serial-replication)\n\n#### Cluster Management Commands\n\n**add\\_peer `<ID>` `<CLUSTER_KEY>`**\\\nAdds a replication relationship between two clusters.\n\n* ID — a unique string, which must not contain a hyphen.\n* CLUSTER\\_KEY: composed using the following template, with appropriate place-holders: `hbase.zookeeper.quorum:hbase.zookeeper.property.clientPort:zookeeper.znode.parent`. This value can be found on the Master UI info page.\n* STATE(optional): ENABLED or DISABLED, default value is ENABLED\n\n**list\\_peers**\\\nlist all replication relationships known by this cluster\n\n**enable\\_peer `<ID>`**\\\nEnable a previously-disabled replication relationship\n\n**disable\\_peer `<ID>`**\\\nDisable a replication relationship. HBase will no longer send edits to that peer cluster, but it still keeps track of all the new WALs that it will need to replicate if and when it is re-enabled. WALs are retained when enabling or disabling replication as long as peers exist.\n\n**remove\\_peer `<ID>`**\\\nDisable and remove a replication relationship. HBase will no longer send edits to that peer cluster or keep track of WALs.\n\n**enable\\_table\\_replication `<TABLE_NAME>`**\\\nEnable the table replication switch for all its column families. If the table is not found in the destination cluster then it will create one with the same name and column families.\n\n**disable\\_table\\_replication `<TABLE_NAME>`**\\\nDisable the table replication switch for all its column families.\n\n**peer\\_modification\\_switch `<enable_or_disable>`, `<drain_procedures>`**\\\nEnabled/Disable peer modification operations, such as adding/removing replication peers. The second parameter means whether you want to wait until all existing peer modification procedures to finish before returning when disabling peer modification.\n\n**peer\\_modification\\_enabled**\\\nCheck whether peer modification is enabled.\n\n### Migrate Across Different Replication Peer Storages\n\nStarting from 2.6.0, we introduce a file system based `ReplicationPeerStorage`, which stores the replication peer state with files on HFile file system, instead of znodes on ZooKeeper. And we have also implemented a tool to copy replication peer state across different replication peer storages.\n\n```bash\n./bin/hbase copyreppeers <SRC_REPLICATION_PEER_STORAGE> <DST_REPLICATION_PEER_STORAGE>\n```\n\nTo support doing the migrate online, we introduce a shell command called `peer_modification_switch`.\n\n```ruby\nhbase> peer_modification_switch false, true\n```\n\nUse the above command can disable peer modification operations. The second `true` means you want to wait until all the existing replication peer modification procedures to finish before returning. After disabling the peer modification, it is safe for you to copy replication peer state with the above tool, and then update all the *hbase-site.xml* files in the cluster to specify the new replication peer storage, and finally trigger an online configuration update to load the new replication peer storage.\n\n## Serial Replication\n\nNote: this feature is introduced in HBase 2.1\n\n**Function of serial replication**\\\nSerial replication supports to push logs to the destination cluster in the same order as logs reach to the source cluster.\n\n### Why need serial replication?\n\nIn replication of HBase, we push mutations to destination cluster by reading WAL in each region server. We have a queue for WAL files so we can read them in order of creation time. However, when region-move or RS failure occurs in source cluster, the hlog entries that are not pushed before region-move or RS-failure will be pushed by original RS(for region move) or another RS which takes over the remained hlog of dead RS(for RS failure), and the new entries for the same region(s) will be pushed by the RS which now serves the region(s), but they push the hlog entries of a same region concurrently without coordination.\n\nThis treatment can possibly lead to data inconsistency between source and destination clusters:\n\n1. there are put and then delete written to source cluster.\n2. due to region-move / RS-failure, they are pushed by different replication-source threads to peer cluster.\n3. if delete is pushed to peer cluster before put, and flush and major-compact occurs in peer cluster before put is pushed to peer cluster, the delete is collected and the put remains in peer cluster, but in source cluster the put is masked by the delete, hence data inconsistency between source and destination clusters.\n\n### Serial replication configuration\n\nSet the serial flag to true for a repliation peer. And the default serial flag is false.\n\n* Add a new replication peer which serial flag is true\n\n  ```ruby\n  hbase> add_peer '1', CLUSTER_KEY => \"server1.cie.com:2181:/hbase\", SERIAL => true\n  ```\n\n* Set a replication peer's serial flag to false\n\n  ```ruby\n  hbase> set_peer_serial '1', false\n  ```\n\n* Set a replication peer's serial flag to true\n\n  ```ruby\n  hbase> set_peer_serial '1', true\n  ```\n\nThe serial replication feature had been done firstly in [HBASE-9465](https://issues.apache.org/jira/browse/HBASE-9465) and then reverted and redone in [HBASE-20046](https://issues.apache.org/jira/browse/HBASE-20046). You can find more details in these issues.\n\n### Verifying Replicated Data\n\nThe `VerifyReplication` MapReduce job, which is included in HBase, performs a systematic comparison of replicated data between two different clusters. Run the VerifyReplication job on the master cluster, supplying it with the peer ID and table name to use for validation. You can limit the verification further by specifying a time range or specific families. The job's short name is `verifyrep`. To run the job, use a command like the following:\n\n```bash\n$ HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` \"${HADOOP_HOME}/bin/hadoop\" jar \"${HBASE_HOME}/hbase-mapreduce-VERSION.jar\" verifyrep --starttime=<timestamp> --endtime=<timestamp> --families=<myFam> <ID> <tableName>\n```\n\n* The `VerifyReplication` command prints out `GOODROWS` and `BADROWS` counters to indicate rows that did and did not replicate correctly.\n\n### Detailed Information About Cluster Replication\n\n***Replication Architecture Overview***\n<img alt=\"replication overview\" src={__img19} placeholder=\"blur\" />\n\n#### Life of a WAL Edit\n\nA single WAL edit goes through several steps in order to be replicated to a slave cluster.\n\n1. An HBase client uses a Put or Delete operation to manipulate data in HBase.\n2. The region server writes the request to the WAL in a way allows it to be replayed if it is not written successfully.\n3. If the changed cell corresponds to a column family that is scoped for replication, the edit is added to the queue for replication.\n4. In a separate thread, the edit is read from the log, as part of a batch process. Only the KeyValues that are eligible for replication are kept. Replicable KeyValues are part of a column family whose schema is scoped GLOBAL, are not part of a catalog such as `hbase:meta`, did not originate from the target slave cluster, and have not already been consumed by the target slave cluster.\n5. The edit is tagged with the master's UUID and added to a buffer. When the buffer is filled, or the reader reaches the end of the file, the buffer is sent to a random region server on the slave cluster.\n6. The region server reads the edits sequentially and separates them into buffers, one buffer per table. After all edits are read, each buffer is flushed using [Table](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Table.html), HBase's normal client. The master's UUID and the UUIDs of slaves which have already consumed the data are preserved in the edits they are applied, in order to prevent replication loops.\n7. In the master, the offset for the WAL that is currently being replicated is registered in ZooKeeper.\n8. The first three steps, where the edit is inserted, are identical.\n9. Again in a separate thread, the region server reads, filters, and edits the log edits in the same way as above. The slave region server does not answer the RPC call.\n10. The master sleeps and tries again a configurable number of times.\n11. If the slave region server is still not available, the master selects a new subset of region server to replicate to, and tries again to send the buffer of edits.\n12. Meanwhile, the WALs are rolled and stored in a queue in ZooKeeper. Logs that are **archived** by their region server, by moving them from the region server's log directory to a central log directory, will update their paths in the in-memory queue of the replicating thread.\n13. When the slave cluster is finally available, the buffer is applied in the same way as during normal processing. The master region server will then replicate the backlog of logs that accumulated during the outage.\n\n**Spreading Queue Failover Load**\\\nWhen replication is active, a subset of region servers in the source cluster is responsible for shipping edits to the sink. This responsibility must be failed over like all other region server functions should a process or node crash. The following configuration settings are recommended for maintaining an even distribution of replication activity over the remaining live servers in the source cluster:\n\n* Set `replication.source.maxretriesmultiplier` to `300`.\n* Set `replication.source.sleepforretries` to `1` (1 second). This value, combined with the value of `replication.source.maxretriesmultiplier`, causes the retry cycle to last about 5 minutes.\n* Set `replication.sleep.before.failover` to `30000` (30 seconds) in the source cluster site configuration.\n\n**Preserving Tags During Replication**\\\nBy default, the codec used for replication between clusters strips tags, such as cell-level ACLs, from cells. To prevent the tags from being stripped, you can use a different codec which does not strip them. Configure `hbase.replication.rpc.codec` to use `org.apache.hadoop.hbase.codec.KeyValueCodecWithTags`, on both the source and sink RegionServers involved in the replication. This option was introduced in [HBASE-10322](https://issues.apache.org/jira/browse/HBASE-10322).\n\n#### Replication Internals\n\n**Replication State Storage**\\\nIn HBASE-15867, we abstract two interfaces for storing replication state, `ReplicationPeerStorage` and `ReplicationQueueStorage`. The former one is for storing the replication peer related states, and the latter one is for storing the replication queue related states. HBASE-15867 is only half done, as although we have abstract these two interfaces, we still only have zookeeper based implementations.\n\nAnd in HBASE-27110, we have implemented a file system based replication peer storage, to store replication peer state on file system. Of course you can still use the zookeeper based replication peer storage.\n\nAnd in HBASE-27109, we have changed the replication queue storage from zookeeper based to hbase table based. See the below `Replication Queue State` in hbase:replication table section for more details.\n\n**Replication State in ZooKeeper**\\\nBy default, the state is contained in the base node */hbase/replication*. Usually this nodes contains two child nodes, the peers znode is for storing replication peer state, and the rs znodes is for storing replication queue state. And if you choose the file system based replication peer storage, you will not see the peers znode. And starting from 3.0.0, we have moved the replication queue state to `hbase:replication` table (see below), so you will not see the rs znode.\n\n**The `Peers` Znode**\\\nThe `peers` znode is stored in */hbase/replication/peers* by default. It consists of a list of all peer replication clusters, along with the status of each of them. The value of each peer is its cluster key, which is provided in the HBase Shell. The cluster key contains a list of ZooKeeper nodes in the cluster's quorum, the client port for the ZooKeeper quorum, and the base znode for HBase in HDFS on that cluster. Starting from 3.0.0, you can also specify connection URI as a cluster key. See [Connection URI](/docs/architecture/client#connection-uri) for more details about connection URI.\n\n**The `RS` Znode**\\\nThe `rs` znode contains a list of WAL logs which need to be replicated. This list is divided into a set of queues organized by region server and the peer cluster the region server is shipping the logs to. The rs znode has one child znode for each region server in the cluster. The child znode name is the region server's hostname, client port, and start code. This list includes both live and dead region servers.\n\n**The hbase:replication Table**\\\nAfter 3.0.0, the `Queue` has been stored in the hbase:replication table, where the row key is `<PeerId>-<ServerName>[/<SourceServerName>]`, the WAL group will be the qualifier, and the serialized ReplicationGroupOffset will be the value. The ReplicationGroupOffset includes the wal file of the corresponding queue (`<PeerId>-<ServerName>[/<SourceServerName>]`) and its offset. Because we track replication offset per queue instead of per file, we only need to store one replication offset per queue.\n\n**Other implementations for `ReplicationPeerStorage`**\\\nStarting from 2.6.0, we introduce a file system based `ReplicationPeerStorage`, which stores the replication peer state with files on HFile file system, instead of znodes on ZooKeeper. The layout is almost the same with znodes on zookeeper, the main difference is that, the HFile file system may not support atomic rename, so we use two files to store the state and when reading we will read them both and compare the timestamp to find out the newer one. So typically, you will see two peer config files. And for enable/disable state, we just touch a disabled file if the peer is disabled, and remove the file when enabling the peer.\n\n#### Choosing Region Servers to Replicate To\n\nWhen a master cluster region server initiates a replication source to a slave cluster, it first connects to the slave's ZooKeeper ensemble using the provided cluster key . It then scans the *rs/* directory to discover all the available sinks (region servers that are accepting incoming streams of edits to replicate) and randomly chooses a subset of them using a configured ratio which has a default value of 10%. For example, if a slave cluster has 150 machines, 15 will be chosen as potential recipient for edits that this master cluster region server sends. Because this selection is performed by each master region server, the probability that all slave region servers are used is very high, and this method works for clusters of any size. For example, a master cluster of 10 machines replicating to a slave cluster of 5 machines with a ratio of 10% causes the master cluster region servers to choose one machine each at random.\n\nA ZooKeeper watcher is placed on the `$zookeeper.znode.parent/rs` node of the slave cluster by each of the master cluster's region servers. This watch is used to monitor changes in the composition of the slave cluster. When nodes are removed from the slave cluster, or if nodes go down or come back up, the master cluster's region servers will respond by selecting a new pool of slave region servers to replicate to.\n\n#### Keeping Track of Logs(based on ZooKeeper)\n\nEach master cluster region server has its own znode in the replication znodes hierarchy. It contains one znode per peer cluster (if 5 slave clusters, 5 znodes are created), and each of these contain a queue of WALs to process. Each of these queues will track the WALs created by that region server, but they can differ in size. For example, if one slave cluster becomes unavailable for some time, the WALs should not be deleted, so they need to stay in the queue while the others are processed. See [rs.failover.details](/docs/operational-management/cluster-replication#region-server-failover) for an example.\n\nWhen a source is instantiated, it contains the current WAL that the region server is writing to. During log rolling, the new file is added to the queue of each slave cluster's znode just before it is made available. This ensures that all the sources are aware that a new log exists before the region server is able to append edits into it, but this operations is now more expensive. The queue items are discarded when the replication thread cannot read more entries from a file (because it reached the end of the last block) and there are other files in the queue. This means that if a source is up to date and replicates from the log that the region server writes to, reading up to the \"end\" of the current file will not delete the item in the queue.\n\nA log can be archived if it is no longer used or if the number of logs exceeds `hbase.regionserver.maxlogs` because the insertion rate is faster than regions are flushed. When a log is archived, the source threads are notified that the path for that log changed. If a particular source has already finished with an archived log, it will just ignore the message. If the log is in the queue, the path will be updated in memory. If the log is currently being replicated, the change will be done atomically so that the reader doesn't attempt to open the file when has already been moved. Because moving a file is a NameNode operation , if the reader is currently reading the log, it won't generate any exception.\n\n#### Keeping Track of Logs(based on hbase table)\n\nAfter 3.0.0, for table based implementation, we have server name in row key, which means we will have lots of rows for a given peer.\n\nFor a normal replication queue, the WAL files belong to the region server that is still alive, all the WAL files are kept in memory, so we do not need to get the WAL files from replication queue storage. And for a recovered replication queue, we could get the WAL files of the dead region server by listing the old WAL directory on HDFS. So theoretically, we do not need to store every WAL file in replication queue storage. And what's more, we store the created time(usually) in the WAL file name, so for all the WAL files in a WAL group, we can sort them(actually we will sort them in the current replication framework), which means we only need to store one replication offset per queue. When starting a recovered replication queue, we will skip all the files before this offset, and start replicating from this offset.\n\nFor ReplicationLogCleaner, all the files before this offset can be deleted, otherwise not.\n\n#### Reading, Filtering and Sending Edits\n\nBy default, a source attempts to read from a WAL and ship log entries to a sink as quickly as possible. Speed is limited by the filtering of log entries Only KeyValues that are scoped GLOBAL and that do not belong to catalog tables will be retained. Speed is also limited by total size of the list of edits to replicate per slave, which is limited to 64 MB by default. With this configuration, a master cluster region server with three slaves would use at most 192 MB to store data to replicate. This does not account for the data which was filtered but not garbage collected.\n\nOnce the maximum size of edits has been buffered or the reader reaches the end of the WAL, the source thread stops reading and chooses at random a sink to replicate to (from the list that was generated by keeping only a subset of slave region servers). It directly issues a RPC to the chosen region server and waits for the method to return. If the RPC was successful, the source determines whether the current file has been emptied or it contains more data which needs to be read. If the file has been emptied, the source deletes the znode in the queue. Otherwise, it registers the new offset in the log's znode. If the RPC threw an exception, the source will retry 10 times before trying to find a different sink.\n\n#### Cleaning Logs\n\nIf replication is not enabled, the master's log-cleaning thread deletes old logs using a configured TTL. This TTL-based method does not work well with replication, because archived logs which have exceeded their TTL may still be in a queue. The default behavior is augmented so that if a log is past its TTL, the cleaning thread looks up every queue until it finds the log, while caching queues it has found. If the log is not found in any queues, the log will be deleted. The next time the cleaning process needs to look for a log, it starts by using its cached list.\n\n<Callout type=\"info\">\n  WALs are saved when replication is enabled or disabled as long as peers exist.\n</Callout>\n\n#### Region Server Failover\n\nWhen no region servers are failing, keeping track of the logs in ZooKeeper adds no value. Unfortunately, region servers do fail, and since ZooKeeper is highly available, it is useful for managing the transfer of the queues in the event of a failure. Each of the master cluster region servers keeps a watcher on every other region server, in order to be notified when one dies (just as the master does). When a failure happens, they all race to create a znode called `lock` inside the dead region server's znode that contains its queues. The region server that creates it successfully then transfers all the queues to its own znode, one at a time since ZooKeeper does not support renaming queues. After queues are all transferred, they are deleted from the old location. The znodes that were recovered are renamed with the ID of the slave cluster appended with the name of the dead server.\n\nNext, the master cluster region server creates one new source thread per copied queue, and each of the source threads follows the read/filter/ship pattern. The main difference is that those queues will never receive new data, since they do not belong to their new region server. When the reader hits the end of the last log, the queue's znode is deleted and the master cluster region server closes that replication source.\n\nAnd starting from 2.5.0, the failover logic has been moved to SCP, where we add a SERVER\\_CRASH\\_CLAIM\\_REPLICATION\\_QUEUES step in SCP to claim the replication queues for a dead server. And starting from 3.0.0, where we changed the replication queue storage from zookeeper to table, the update to the replication queue storage is async, so we also need an extra step to add the missing replication queues before claiming.\n\n#### The replication queue claiming (based on ZooKeeper)\n\nGiven a master cluster with 3 region servers replicating to a single slave with id `2`, the following hierarchy represents what the znodes layout could be at some point in time. The region servers' znodes all contain a `peers` znode which contains a single queue. The znode names in the queues represent the actual file names on HDFS in the form `address,port.timestamp`.\n\n```text\n/hbase/replication/rs/\n  1.1.1.1,60020,123456780/\n    2/\n      1.1.1.1,60020.1234  (Contains a position)\n      1.1.1.1,60020.1265\n  1.1.1.2,60020,123456790/\n    2/\n      1.1.1.2,60020.1214  (Contains a position)\n      1.1.1.2,60020.1248\n      1.1.1.2,60020.1312\n  1.1.1.3,60020,    123456630/\n    2/\n      1.1.1.3,60020.1280  (Contains a position)\n```\n\nAssume that 1.1.1.2 loses its ZooKeeper session. The survivors will race to create a lock, and, arbitrarily, 1.1.1.3 wins. It will then start transferring all the queues to its local peers znode by appending the name of the dead server. Right before 1.1.1.3 is able to clean up the old znodes, the layout will look like the following:\n\n```text\n/hbase/replication/rs/\n  1.1.1.1,60020,123456780/\n    2/\n      1.1.1.1,60020.1234  (Contains a position)\n      1.1.1.1,60020.1265\n  1.1.1.2,60020,123456790/\n    lock\n    2/\n      1.1.1.2,60020.1214  (Contains a position)\n      1.1.1.2,60020.1248\n      1.1.1.2,60020.1312\n  1.1.1.3,60020,123456630/\n    2/\n      1.1.1.3,60020.1280  (Contains a position)\n\n    2-1.1.1.2,60020,123456790/\n      1.1.1.2,60020.1214  (Contains a position)\n      1.1.1.2,60020.1248\n      1.1.1.2,60020.1312\n```\n\nSome time later, but before 1.1.1.3 is able to finish replicating the last WAL from 1.1.1.2, it dies too. Some new logs were also created in the normal queues. The last region server will then try to lock 1.1.1.3's znode and will begin transferring all the queues. The new layout will be:\n\n```text\n/hbase/replication/rs/\n  1.1.1.1,60020,123456780/\n    2/\n      1.1.1.1,60020.1378  (Contains a position)\n\n    2-1.1.1.3,60020,123456630/\n      1.1.1.3,60020.1325  (Contains a position)\n      1.1.1.3,60020.1401\n\n    2-1.1.1.2,60020,123456790-1.1.1.3,60020,123456630/\n      1.1.1.2,60020.1312  (Contains a position)\n  1.1.1.3,60020,123456630/\n    lock\n    2/\n      1.1.1.3,60020.1325  (Contains a position)\n      1.1.1.3,60020.1401\n\n    2-1.1.1.2,60020,123456790/\n      1.1.1.2,60020.1312  (Contains a position)\n```\n\n#### The replication queue claiming(based on hbase table)\n\nGiven a master cluster with 3 region servers replicating to a single slave with id `2`, the following info represents what the storage layout of queue in the hbase:replication at some point in time. Row key is `<PeerId>-<ServerName>[/<SourceServerName>]`, and value is WAL && Offset.\n\n```text\n  <PeerId>-<ServerName>[/<SourceServerName>]                        WAL && Offset\n  2-1.1.1.1,60020,123456780                            1.1.1.1,60020.1234  (Contains a position)\n  2-1.1.1.2,60020,123456790                            1.1.1.2,60020.1214  (Contains a position)\n  2-1.1.1.3,60020,123456630                            1.1.1.3,60020.1280  (Contains a position)\n```\n\nAssume that 1.1.1.2 failed. The survivors will claim queue of that, and, arbitrarily, 1.1.1.3 wins. It will claim all the queue of 1.1.1.2, including removing the row of a replication queue, and inserting a new row(where we change the server name to the region server which claims the queue). Finally, the layout will look like the following:\n\n```text\n  <PeerId>-<ServerName>[/<SourceServerName>]                        WAL && Offset\n  2-1.1.1.1,60020,123456780                            1.1.1.1,60020.1234  (Contains a position)\n  2-1.1.1.3,60020,123456630                            1.1.1.3,60020.1280  (Contains a position)\n  2-1.1.1.3,60020,123456630 1.1.1.2,60020,123456790    1.1.1.2,60020.1214  (Contains a position)\n```\n\n### Replication Metrics\n\nThe following metrics are exposed at the global region server level and at the peer level:\n\n`source.sizeOfLogQueue`\\\nnumber of WALs to process (excludes the one which is being processed) at the Replication source\n\n`source.shippedOps`\\\nnumber of mutations shipped\n\n`source.logEditsRead`\\\nnumber of mutations read from WALs at the replication source\n\n`source.ageOfLastShippedOp`\\\nage of last batch that was shipped by the replication source\n\n`source.completedLogs`\\\nThe number of write-ahead-log files that have completed their acknowledged sending to the peer associated with this source. Increments to this metric are a part of normal operation of HBase replication.\n\n`source.completedRecoverQueues`\\\nThe number of recovery queues this source has completed sending to the associated peer. Increments to this metric are a part of normal recovery of HBase replication in the face of failed Region Servers.\n\n`source.uncleanlyClosedLogs`\\\nThe number of write-ahead-log files the replication system considered completed after reaching the end of readable entries in the face of an uncleanly closed file.\n\n`source.ignoredUncleanlyClosedLogContentsInBytes`\\\nWhen a write-ahead-log file is not closed cleanly, there will likely be some entry that has been partially serialized. This metric contains the number of bytes of such entries the HBase replication system believes were remaining at the end of files skipped in the face of an uncleanly closed file. Those bytes should either be in different file or represent a client write that was not acknowledged.\n\n`source.restartedLogReading`\\\nThe number of times the HBase replication system detected that it failed to correctly parse a cleanly closed write-ahead-log file. In this circumstance, the system replays the entire log from the beginning, ensuring that no edits fail to be acknowledged by the associated peer. Increments to this metric indicate that the HBase replication system is having difficulty correctly handling failures in the underlying distributed storage system. No dataloss should occur, but you should check Region Server log files for details of the failures.\n\n`source.repeatedLogFileBytes`\\\nWhen the HBase replication system determines that it needs to replay a given write-ahead-log file, this metric is incremented by the number of bytes the replication system believes had already been acknowledged by the associated peer prior to starting over.\n\n`source.closedLogsWithUnknownFileLength`\\\nIncremented when the HBase replication system believes it is at the end of a write-ahead-log file but it can not determine the length of that file in the underlying distributed storage system. Could indicate dataloss since the replication system is unable to determine if the end of readable entries lines up with the expected end of the file. You should check Region Server log files for details of the failures.\n\n### Replication Configuration Options\n\n| Option                                  | Description                                                                                                   | Default                      |\n| --------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ---------------------------- |\n| zookeeper.znode.parent                  | The name of the base ZooKeeper znode used for HBase                                                           | /hbase                       |\n| zookeeper.znode.replication             | The name of the base znode used for replication                                                               | replication                  |\n| zookeeper.znode.replication.peers       | The name of the peer znode                                                                                    | peers                        |\n| zookeeper.znode.replication.peers.state | The name of peer-state znode                                                                                  | peer-state                   |\n| zookeeper.znode.replication.rs          | The name of the rs znode                                                                                      | rs                           |\n| replication.sleep.before.failover       | How many milliseconds a worker should sleep before attempting to replicate a dead region server's WAL queues. |                              |\n| replication.executor.workers            | The number of region servers a given region server should attempt to failover simultaneously.                 | 1                            |\n| hbase.replication.peer.storage.impl     | The replication peer storage implementation                                                                   | zookeeper                    |\n| hbase.replication.peers.directory       | The directory for storing replication peer state, when filesystem replication peer storage is specified       | peers                        |\n| hbase.replication.queue.table.name      | The table for storing replication queue state                                                                 | hbase:replication            |\n| hbase.replication.queue.storage.impl    | The replication queue storage implementation                                                                  | TableReplicationQueueStorage |\n\n### Monitoring Replication Status\n\nYou can use the HBase Shell command `status 'replication'` to monitor the replication status on your cluster. The command has three variations:\n\n* `status 'replication'` — prints the status of each source and its sinks, sorted by hostname.\n* `status 'replication', 'source'` — prints the status for each replication source, sorted by hostname.\n* `status 'replication', 'sink'` — prints the status for each replication sink, sorted by hostname.\n\n#### Understanding the output\n\nThe command output will vary according to the state of replication. For example right after a restart and if destination peer is not reachable, no replication source threads would be running, so no metrics would get displayed:\n\n```text\nhbase01.home:\nSOURCE: PeerID=1\nNormal Queue: 1\nNo Reader/Shipper threads runnning yet.\nSINK: TimeStampStarted=1591985197350, Waiting for OPs...\n```\n\nUnder normal circumstances, a healthy, active-active replication deployment would show the following:\n\n```text\n    hbase01.home:\n      SOURCE: PeerID=1\n         Normal Queue: 1\n           AgeOfLastShippedOp=0, TimeStampOfLastShippedOp=Fri Jun 12 18:49:23 BST 2020, SizeOfLogQueue=1, EditsReadFromLogQueue=1, OpsShippedToTarget=1, TimeStampOfNextToReplicate=Fri Jun 12 18:49:23 BST 2020, Replication Lag=0\n      SINK: TimeStampStarted=1591983663458, AgeOfLastAppliedOp=0, TimeStampsOfLastAppliedOp=Fri Jun 12 18:57:18 BST 2020\n```\n\nThe definition for each of these metrics is detailed below:\n\n| Type   | Metric Name                | Description                                                                                                                        |\n| ------ | -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |\n| Source | AgeOfLastShippedOp         | How long last successfully shipped edit took to effectively get replicated on target.                                              |\n| Source | TimeStampOfLastShippedOp   | The actual date of last successful edit shipment.                                                                                  |\n| Source | SizeOfLogQueue             | Number of wal files on this given queue.                                                                                           |\n| Source | EditsReadFromLogQueue      | How many edits have been read from this given queue since this source thread started.                                              |\n| Source | OpsShippedToTarget         | How many edits have been shipped to target since this source thread started.                                                       |\n| Source | TimeStampOfNextToReplicate | Date of the current edit been attempted to replicate.                                                                              |\n| Source | Replication Lag            | The elapsed time (in millis), since the last edit to replicate was read by this source thread and effectively replicated to target |\n| Sink   | TimeStampStarted           | Date (in millis) of when this Sink thread started.                                                                                 |\n| Sink   | AgeOfLastAppliedOp         | How long it took to apply the last successful shipped edit.                                                                        |\n| Sink   | TimeStampsOfLastAppliedOp  | Date of last successful applied edit.                                                                                              |\n\nGrowing values for `Source.TimeStampsOfLastAppliedOp` and/or `Source.Replication Lag` would indicate replication delays. If those numbers keep going up, while `Source.TimeStampOfLastShippedOp`, `Source.EditsReadFromLogQueue`, `Source.OpsShippedToTarget` or `Source.TimeStampOfNextToReplicate` do not change at all, then replication flow is failing to progress, and there might be problems within clusters communication. This could also happen if replication is manually paused (via hbase shell `disable_peer` command, for example), but data keeps getting ingested in the source cluster tables.\n\n### Replication Observability Framework\n\nThe core idea is to create `replication marker rows` periodically and insert them into WAL. These marker rows will help track the replication delays/bugs back to the `originating region server, WAL and timestamp of occurrence`. This tracker rows' WAL entries are interleaved with the regular table WAL entries and have a very high chance of running into the same replication delays/bugs that the user tables are seeing. Details as follows:\n\n#### REPLICATION.WALEVENTTRACKER table\n\nCreate a new table called `REPLICATION.WALEVENTTRACKER` table and persist all the WAL events (like `ACTIVE`, `ROLLING`, `ROLLED`) to this table.\\\nThe properties of this table are: Replication is set to 0, Block Cache is Disabled, Max versions is 1, TTL is 1 year.\n\nThis table has single ColumnFamily: `info`\\\n`info` contains multiple qualifiers:\n\n* `info:region_server_name`\n* `info:wal_name`\n* `info:timestamp`\n* `info:wal_state`\n* `info:wal_length`\n\nWhenever we roll a WAL (`old-wal-name` → `new-wal-name`), it will create 3 rows in this table.\\\n`<region_server_name>, <old-wal-name>, <current timestamp>, <ROLLING>, <length of old-wal-name>`\\\n`<region_server_name>, <old-wal-name>, <current timestamp>, <ROLLED>, <length of old-wal-name>`\\\n`<region_server_name>, <new-wal-name>, <current timestamp>, <ACTIVE>, 0`\n\n**Configuration**\\\nTo enable persisting WAL events, there is a configuration property: `hbase.regionserver.wal.event.tracker.enabled` (defaults to false)\n\n#### REPLICATION.SINK\\_TRACKER table\n\nCreate a new table called `REPLICATION.SINK_TRACKER`.\\\nThe properties of this table are: Replication is set to 0, Block Cache is Disabled, Max versions is 1, TTL is 1 year.\n\nThis table has single ColumnFamily: `info`\\\n`info` contains multiple qualifiers:\n\n* `info:region_server_name`\n* `info:wal_name`\n* `info:timestamp`\n* `info:offset`\n\n**Configuration**\\\nTo create the above table, there is a configuration property: `hbase.regionserver.replication.sink.tracker.enabled` (defaults to false)\n\n#### ReplicationMarker Chore\n\nWe introduced a new chore called `ReplicationMarkerChore` which will create the marker rows periodically into active WAL. The marker rows has the following metadata: `region_server_name, wal_name, timestamp and offset within WAL`. These markers are replicated (with special handling) and they are persisted into a sink side table `REPLICATION.SINK_TRACKER`.\n\n**Configuration:**\\\n`ReplicationMarkerChore` is enabled with configuration property: `hbase.regionserver.replication.marker.enabled` (defaults to false) and the period at which it creates marker rows is controlled by `hbase.regionserver.replication.marker.chore.duration` (defaults to 30 seconds). Sink cluster can choose to process these marker rows and persist to `REPLICATION.SINK_TRACKER` table or it can ignore these rows. This behavior is controlled by configuration property `hbase.regionserver.replication.sink.tracker.enabled` (defaults to false). If set to false, it will ignore the marker rows.\n\n#### How to enable end-to-end feature ?\n\nTo use this whole feature, we will need to enable the above configuration properties in 2 phases/releases.\\\nIn first phase/release, set the following configuration properties to `true`:\n\n* `hbase.regionserver.wal.event.tracker.enabled`: This will just persist all the WAL events to REPLICATION.WALEVENTTRACKER table.\n* `hbase.regionserver.replication.sink.tracker.enabled`: This will create REPLICATION.SINK\\_TRACKER table and will process special marker rows coming from source cluster.\n\nIn second phase/release, set the following configuration property to `true`:\n\n* `hbase.regionserver.replication.marker.enabled`: This will create marker rows periodically and sink cluster will persist these marker rows in `REPLICATION.SINK_TRACKER` table.\n\n## Running Multiple Workloads on a Single Cluster\n\nHBase provides the following mechanisms for managing the performance of a cluster handling multiple workloads:\n\n* [Quotas](/docs/operational-management/running-multiple-workloads-on-a-single-cluster#quotas)\n* [Request Queues](/docs/operational-management/running-multiple-workloads-on-a-single-cluster#request-queues)\n* [Multiple-Typed Queues](/docs/operational-management/running-multiple-workloads-on-a-single-cluster#multiple-typed-queues)\n\n## Quotas\n\nHBASE-11598 introduces RPC quotas, which allow you to throttle requests based on the following limits:\n\n1. [The number or size of requests(read, write, or read+write) in a given timeframe](/docs/operational-management/running-multiple-workloads-on-a-single-cluster#setting-request-quotas)\n2. [The number of tables allowed in a namespace](/docs/operational-management/running-multiple-workloads-on-a-single-cluster#setting-namespace-quotas)\n\nThese limits can be enforced for a specified user, table, or namespace.\n\n### Enabling Quotas\n\nQuotas are disabled by default. To enable the feature, set the `hbase.quota.enabled` property to `true` in *hbase-site.xml* file for all cluster nodes.\n\n### General Quota Syntax\n\n1. THROTTLE\\_TYPE can be expressed as READ, WRITE, or the default type(read + write).\n2. Timeframes can be expressed in the following units: `sec`, `min`, `hour`, `day`\n3. Request sizes can be expressed in the following units: `B` (bytes), `K` (kilobytes), `M` (megabytes), `G` (gigabytes), `T` (terabytes), `P` (petabytes)\n4. Numbers of requests are expressed as an integer followed by the string `req`\n5. Limits relating to time are expressed as req/time or size/time. For instance `10req/day` or `100P/hour`.\n6. Numbers of tables or regions are expressed as integers.\n\n### Setting Request Quotas\n\nYou can set quota rules ahead of time, or you can change the throttle at runtime. The change will propagate after the quota refresh period has expired. This expiration period defaults to 5 minutes. To change it, modify the `hbase.quota.refresh.period` property in `hbase-site.xml`. This property is expressed in milliseconds and defaults to `300000`.\n\n```ruby\n# Limit user u1 to 10 requests per second\nhbase> set_quota TYPE => THROTTLE, USER => 'u1', LIMIT => '10req/sec'\n\n# Limit user u1 to 10 read requests per second\nhbase> set_quota TYPE => THROTTLE, THROTTLE_TYPE => READ, USER => 'u1', LIMIT => '10req/sec'\n\n# Limit user u1 to 10 M per day everywhere\nhbase> set_quota TYPE => THROTTLE, USER => 'u1', LIMIT => '10M/day'\n\n# Limit user u1 to 10 M write size per sec\nhbase> set_quota TYPE => THROTTLE, THROTTLE_TYPE => WRITE, USER => 'u1', LIMIT => '10M/sec'\n\n# Limit user u1 to 5k per minute on table t2\nhbase> set_quota TYPE => THROTTLE, USER => 'u1', TABLE => 't2', LIMIT => '5K/min'\n\n# Limit user u1 to 10 read requests per sec on table t2\nhbase> set_quota TYPE => THROTTLE, THROTTLE_TYPE => READ, USER => 'u1', TABLE => 't2', LIMIT => '10req/sec'\n\n# Remove an existing limit from user u1 on namespace ns2\nhbase> set_quota TYPE => THROTTLE, USER => 'u1', NAMESPACE => 'ns2', LIMIT => NONE\n\n# Limit all users to 10 requests per hour on namespace ns1\nhbase> set_quota TYPE => THROTTLE, NAMESPACE => 'ns1', LIMIT => '10req/hour'\n\n# Limit all users to 10 T per hour on table t1\nhbase> set_quota TYPE => THROTTLE, TABLE => 't1', LIMIT => '10T/hour'\n\n# Remove all existing limits from user u1\nhbase> set_quota TYPE => THROTTLE, USER => 'u1', LIMIT => NONE\n\n# List all quotas for user u1 in namespace ns2\nhbase> list_quotas USER => 'u1, NAMESPACE => 'ns2'\n\n# List all quotas for namespace ns2\nhbase> list_quotas NAMESPACE => 'ns2'\n\n# List all quotas for table t1\nhbase> list_quotas TABLE => 't1'\n\n# list all quotas\nhbase> list_quotas\n```\n\nYou can also place a global limit and exclude a user or a table from the limit by applying the `GLOBAL_BYPASS` property.\n\n```ruby\nhbase> set_quota NAMESPACE => 'ns1', LIMIT => '100req/min'               # a per-namespace request limit\nhbase> set_quota USER => 'u1', GLOBAL_BYPASS => true                     # user u1 is not affected by the limit\n```\n\n### Enabling, Disabling, and Checking RPC Throttling\n\nHBase provides shell commands to control RPC throttling at runtime. When throttling is disabled, HBase will not apply any request throttling. This can be useful in production environments that require temporary unthrottled operation.\n\nThe following HBase shell commands are available:\n\n```ruby\n# Enable RPC throttling\nhbase> enable_rpc_throttle\n\n# Disable RPC throttling\nhbase> disable_rpc_throttle\n\n# Check whether RPC throttling is enabled\nhbase> rpc_throttle_enabled\n```\n\n`enable_rpc_throttle` and `disable_rpc_throttle` return the previous RPC throttling state as a boolean value. `rpc_throttle_enabled` returns the current state.\n\n<Callout type=\"info\">\n  If no quotas are configured, RPC throttling is not applied, and enabling or disabling throttling\n  will always return false.\n</Callout>\n\n### Setting Namespace Quotas\n\nYou can specify the maximum number of tables or regions allowed in a given namespace, either when you create the namespace or by altering an existing namespace, by setting the `hbase.namespace.quota.maxtables property` on the namespace.\n\n### Limiting Tables Per Namespace\n\n```ruby\n# Create a namespace with a max of 5 tables\nhbase> create_namespace 'ns1', {'hbase.namespace.quota.maxtables'=>'5'}\n\n# Alter an existing namespace to have a max of 8 tables\nhbase> alter_namespace 'ns2', {METHOD => 'set', 'hbase.namespace.quota.maxtables'=>'8'}\n\n# Show quota information for a namespace\nhbase> describe_namespace 'ns2'\n\n# Alter an existing namespace to remove a quota\nhbase> alter_namespace 'ns2', {METHOD => 'unset', NAME=>'hbase.namespace.quota.maxtables'}\n```\n\n### Limiting Regions Per Namespace\n\n```ruby\n# Create a namespace with a max of 10 regions\nhbase> create_namespace 'ns1', {'hbase.namespace.quota.maxregions'=>'10'}\n\n# Show quota information for a namespace\nhbase> describe_namespace 'ns1'\n\n# Alter an existing namespace to have a max of 20 tables\nhbase> alter_namespace 'ns2', {METHOD => 'set', 'hbase.namespace.quota.maxregions'=>'20'}\n\n# Alter an existing namespace to remove a quota\nhbase> alter_namespace 'ns2', {METHOD => 'unset', NAME=> 'hbase.namespace.quota.maxregions'}\n```\n\n## Request Queues\n\nIf no throttling policy is configured, when the RegionServer receives multiple requests, they are now placed into a queue waiting for a free execution slot (HBASE-6721). The simplest queue is a FIFO queue, where each request waits for all previous requests in the queue to finish before running. Fast or interactive queries can get stuck behind large requests.\n\nIf you are able to guess how long a request will take, you can reorder requests by pushing the long requests to the end of the queue and allowing short requests to preempt them. Eventually, you must still execute the large requests and prioritize the new requests behind them. The short requests will be newer, so the result is not terrible, but still suboptimal compared to a mechanism which allows large requests to be split into multiple smaller ones.\n\nHBASE-10993 introduces such a system for deprioritizing long-running scanners. There are two types of queues, `fifo` and `deadline`. To configure the type of queue used, configure the `hbase.ipc.server.callqueue.type` property in `hbase-site.xml`. There is no way to estimate how long each request may take, so de-prioritization only affects scans, and is based on the number of “next” calls a scan request has made. An assumption is made that when you are doing a full table scan, your job is not likely to be interactive, so if there are concurrent requests, you can delay long-running scans up to a limit tunable by setting the `hbase.ipc.server.queue.max.call.delay` property. The slope of the delay is calculated by a simple square root of `(numNextCall * weight)` where the weight is configurable by setting the `hbase.ipc.server.scan.vtime.weight` property.\n\n## Multiple-Typed Queues\n\nYou can also prioritize or deprioritize different kinds of requests by configuring a specified number of dedicated handlers and queues. You can segregate the scan requests in a single queue with a single handler, and all the other available queues can service short `Get` requests.\n\nYou can adjust the IPC queues and handlers based on the type of workload, using static tuning options. This approach is an interim first step that will eventually allow you to change the settings at runtime, and to dynamically adjust values based on the load.\n\n### Multiple Queues\n\nTo avoid contention and separate different kinds of requests, configure the `hbase.ipc.server.callqueue.handler.factor` property, which allows you to increase the number of queues and control how many handlers can share the same queue., allows admins to increase the number of queues and decide how many handlers share the same queue.\n\nUsing more queues reduces contention when adding a task to a queue or selecting it from a queue. You can even configure one queue per handler. The trade-off is that if some queues contain long-running tasks, a handler may need to wait to execute from that queue rather than stealing from another queue which has waiting tasks.\n\n### Read and Write Queues\n\nWith multiple queues, you can now divide read and write requests, giving more priority (more queues) to one or the other type. Use the `hbase.ipc.server.callqueue.read.ratio` property to choose to serve more reads or more writes.\n\n### Get and Scan Queues\n\nSimilar to the read/write split, you can split gets and scans by tuning the `hbase.ipc.server.callqueue.scan.ratio` property to give more priority to gets or to scans. A scan ratio of `0.1` will give more queue/handlers to the incoming gets, which means that more gets can be processed at the same time and that fewer scans can be executed at the same time. A value of `0.9` will give more queue/handlers to scans, so the number of scans executed will increase and the number of gets will decrease.\n\n## Space Quotas\n\n[HBASE-16961](https://issues.apache.org/jira/browse/HBASE-16961) introduces a new type of quotas for HBase to leverage: filesystem quotas. These \"space\" quotas limit the amount of space on the filesystem that HBase namespaces and tables can consume. If a user, malicious or ignorant, has the ability to write data into HBase, with enough time, that user can effectively crash HBase (or worse HDFS) by consuming all available space. When there is no filesystem space available, HBase crashes because it can no longer create/sync data to the write-ahead log.\n\nThis feature allows a for a limit to be set on the size of a table or namespace. When a space quota is set on a namespace, the quota's limit applies to the sum of usage of all tables in that namespace. When a table with a quota exists in a namespace with a quota, the table quota takes priority over the namespace quota. This allows for a scenario where a large limit can be placed on a collection of tables, but a single table in that collection can have a fine-grained limit set.\n\nThe existing `set_quota` and `list_quota` HBase shell commands can be used to interact with space quotas. Space quotas are quotas with a `TYPE` of `SPACE` and have `LIMIT` and `POLICY` attributes. The `LIMIT` is a string that refers to the amount of space on the filesystem that the quota subject (e.g. the table or namespace) may consume. For example, valid values of `LIMIT` are `'10G'`, `'2T'`, or `'256M'`. The `POLICY` refers to the action that HBase will take when the quota subject's usage exceeds the `LIMIT`. The following are valid `POLICY` values.\n\n* `NO_INSERTS` - No new data may be written (e.g. `Put`, `Increment`, `Append`).\n* `NO_WRITES` - Same as `NO_INSERTS` but `Deletes` are also disallowed.\n* `NO_WRITES_COMPACTIONS` - Same as `NO_WRITES` but compactions are also disallowed.\n  * This policy only prevents user-submitted compactions. System can still run compactions.\n* `DISABLE` - The table(s) are disabled, preventing all read/write access.\n\n### Setting simple space quotas\n\n```ruby\n# Sets a quota on the table 't1' with a limit of 1GB, disallowing Puts/Increments/Appends when the table exceeds 1GB\nhbase> set_quota TYPE => SPACE, TABLE => 't1', LIMIT => '1G', POLICY => NO_INSERTS\n\n# Sets a quota on the namespace 'ns1' with a limit of 50TB, disallowing Puts/Increments/Appends/Deletes\nhbase> set_quota TYPE => SPACE, NAMESPACE => 'ns1', LIMIT => '50T', POLICY => NO_WRITES\n\n# Sets a quota on the table 't3' with a limit of 2TB, disallowing any writes and compactions when the table exceeds 2TB.\nhbase> set_quota TYPE => SPACE, TABLE => 't3', LIMIT => '2T', POLICY => NO_WRITES_COMPACTIONS\n\n# Sets a quota on the table 't2' with a limit of 50GB, disabling the table when it exceeds 50GB\nhbase> set_quota TYPE => SPACE, TABLE => 't2', LIMIT => '50G', POLICY => DISABLE\n```\n\nConsider the following scenario to set up quotas on a namespace, overriding the quota on tables in that namespace\n\n### Table and Namespace space quotas\n\n```ruby\nhbase> create_namespace 'ns1'\nhbase> create 'ns1:t1'\nhbase> create 'ns1:t2'\nhbase> create 'ns1:t3'\nhbase> set_quota TYPE => SPACE, NAMESPACE => 'ns1', LIMIT => '100T', POLICY => NO_INSERTS\nhbase> set_quota TYPE => SPACE, TABLE => 'ns1:t2', LIMIT => '200G', POLICY => NO_WRITES\nhbase> set_quota TYPE => SPACE, TABLE => 'ns1:t3', LIMIT => '20T', POLICY => NO_WRITES\n```\n\nIn the above scenario, the tables in the namespace `ns1` will not be allowed to consume more than 100TB of space on the filesystem among each other. The table 'ns1:t2' is only allowed to be 200GB in size, and will disallow all writes when the usage exceeds this limit. The table 'ns1:t3' is allowed to grow to 20TB in size and also will disallow all writes then the usage exceeds this limit. Because there is no table quota on 'ns1:t1', this table can grow up to 100TB, but only if 'ns1:t2' and 'ns1:t3' have a usage of zero bytes. Practically, it's limit is 100TB less the current usage of 'ns1:t2' and 'ns1:t3'.\n\n## Disabling Automatic Space Quota Deletion\n\nBy default, if a table or namespace is deleted that has a space quota, the quota itself is also deleted. In some cases, it may be desirable for the space quota to not be automatically deleted. In these cases, the user may configure the system to not delete any space quota automatically via hbase-site.xml.\n\n```xml\n<property>\n  <name>hbase.quota.remove.on.table.delete</name>\n  <value>false</value>\n</property>\n```\n\nThe value is set to `true` by default.\n\n## HBase Snapshots with Space Quotas\n\nOne common area of unintended-filesystem-use with HBase is via HBase snapshots. Because snapshots exist outside of the management of HBase tables, it is not uncommon for administrators to suddenly realize that hundreds of gigabytes or terabytes of space is being used by HBase snapshots which were forgotten and never removed.\n\n[HBASE-17748](https://issues.apache.org/jira/browse/HBASE-17748) is the umbrella JIRA issue which expands on the original space quota functionality to also include HBase snapshots. While this is a confusing subject, the implementation attempts to present this support in as reasonable and simple of a manner as possible for administrators. This feature does not make any changes to administrator interaction with space quotas, only in the internal computation of table/namespace usage. Table and namespace usage will automatically incorporate the size taken by a snapshot per the rules defined below.\n\nAs a review, let's cover a snapshot's lifecycle: a snapshot is metadata which points to a list of HFiles on the filesystem. This is why creating a snapshot is a very cheap operation; no HBase table data is actually copied to perform a snapshot. Cloning a snapshot into a new table or restoring a table is a cheap operation for the same reason; the new table references the files which already exist on the filesystem without a copy. To include snapshots in space quotas, we need to define which table \"owns\" a file when a snapshot references the file (\"owns\" refers to encompassing the filesystem usage of that file).\n\nConsider a snapshot which was made against a table. When the snapshot refers to a file and the table no longer refers to that file, the \"originating\" table \"owns\" that file. When multiple snapshots refer to the same file and no table refers to that file, the snapshot with the lowest-sorting name (lexicographically) is chosen and the table which that snapshot was created from \"owns\" that file. HFiles are not \"double-counted\" hen a table and one or more snapshots refer to that HFile.\n\nWhen a table is \"rematerialized\" (via `clone_snapshot` or `restore_snapshot`), a similar problem of file ownership arises. In this case, while the rematerialized table references a file which a snapshot also references, the table does not \"own\" the file. The table from which the snapshot was created still \"owns\" that file. When the rematerialized table is compacted or the snapshot is deleted, the rematerialized table will uniquely refer to a new file and \"own\" the usage of that file. Similarly, when a table is duplicated via a snapshot and `restore_snapshot`, the new table will not consume any quota size until the original table stops referring to the files, either due to a compaction on the original table, a compaction on the new table, or the original table being deleted.\n\nOne new HBase shell command was added to inspect the computed sizes of each snapshot in an HBase instance.\n\n```ruby\nhbase> list_snapshot_sizes\nSNAPSHOT                                      SIZE\n t1.s1                                        1159108\n```\n\n## Backup & Snapshots\n\n## HBase Backup\n\nThere are two broad strategies for performing HBase backups: backing up with a full cluster shutdown, and backing up on a live cluster. Each approach has pros and cons.\n\nFor additional information, see [HBase Backup Options](https://web.archive.org/web/20160110232448/http://blog.sematext.com/2011/03/11/hbase-backup-options/) over on the Sematext Blog.\n\n### Full Shutdown Backup\n\nSome environments can tolerate a periodic full shutdown of their HBase cluster, for example if it is being used a back-end analytic capacity and not serving front-end web-pages. The benefits are that the NameNode/Master are RegionServers are down, so there is no chance of missing any in-flight changes to either StoreFiles or metadata. The obvious con is that the cluster is down. The steps include:\n\n#### Stop HBase\n\n#### Distcp\n\nDistcp could be used to either copy the contents of the HBase directory in HDFS to either the same cluster in another directory, or to a different cluster.\\\nNote: Distcp works in this situation because the cluster is down and there are no in-flight edits to files. Distcp-ing of files in the HBase directory is not generally recommended on a live cluster.\n\n#### Restore (if needed)\n\nThe backup of the hbase directory from HDFS is copied onto the 'real' hbase directory via distcp. The act of copying these files creates new HDFS metadata, which is why a restore of the NameNode edits from the time of the HBase backup isn't required for this kind of restore, because it's a restore (via distcp) of a specific HDFS directory (i.e., the HBase part) not the entire HDFS file-system.\n\n### Live Cluster Backup - Replication\n\nThis approach assumes that there is a second cluster. See the HBase page on [replication](/docs/operational-management/cluster-replication) for more information.\n\n### Live Cluster Backup - CopyTable\n\nThe [copytable](/docs/operational-management/tools#copytable) utility could either be used to copy data from one table to another on the same cluster, or to copy data to another table on another cluster.\n\nSince the cluster is up, there is a risk that edits could be missed in the copy process.\n\n### Live Cluster Backup - Export\n\nThe [export](/docs/operational-management/tools#export) approach dumps the content of a table to HDFS on the same cluster. To restore the data, the [import](/docs/operational-management/tools#import) utility would be used.\n\nSince the cluster is up, there is a risk that edits could be missed in the export process. If you want to know more about HBase back-up and restore see the page on [Backup and Restore](/docs/backup-restore).\n\n## HBase Snapshots\n\nHBase Snapshots allow you to take a copy of a table (both contents and metadata)with a very small performance impact. A Snapshot is an immutable collection of table metadata and a list of HFiles that comprised the table at the time the Snapshot was taken. A \"clone\" of a snapshot creates a new table from that snapshot, and a \"restore\" of a snapshot returns the contents of a table to what it was when the snapshot was created. The \"clone\" and \"restore\" operations do not require any data to be copied, as the underlying HFiles (the files which contain the data for an HBase table) are not modified with either action. Simiarly, exporting a snapshot to another cluster has little impact on RegionServers of the local cluster.\n\nPrior to version 0.94.6, the only way to backup or to clone a table is to use CopyTable/ExportTable, or to copy all the hfiles in HDFS after disabling the table. The disadvantages of these methods are that you can degrade region server performance (Copy/Export Table) or you need to disable the table, that means no reads or writes; and this is usually unacceptable.\n\n### Configuration\n\nTo turn on the snapshot support just set the `hbase.snapshot.enabled` property to true. (Snapshots are enabled by default in 0.95+ and off by default in 0.94.6+)\n\n```xml\n<property>\n  <name>hbase.snapshot.enabled</name>\n  <value>true</value>\n</property>\n```\n\n### Take a Snapshot\n\nYou can take a snapshot of a table regardless of whether it is enabled or disabled. The snapshot operation doesn't involve any data copying.\n\n```bash\n$ ./bin/hbase shell\nhbase> snapshot 'myTable', 'myTableSnapshot-122112'\n\n```\n\n#### Take a Snapshot Without Flushing\n\nThe default behavior is to perform a flush of data in memory before the snapshot is taken. This means that data in memory is included in the snapshot. In most cases, this is the desired behavior. However, if your set-up can tolerate data in memory being excluded from the snapshot, you can use the `SKIP_FLUSH` option of the `snapshot` command to disable and flushing while taking the snapshot.\n\n```ruby\nhbase> snapshot 'mytable', 'snapshot123', {SKIP_FLUSH => true}\n```\n\n<Callout type=\"warn\">\n  There is no way to determine or predict whether a very concurrent insert or update will be\n  included in a given snapshot, whether flushing is enabled or disabled. A snapshot is only a\n  representation of a table during a window of time. The amount of time the snapshot operation will\n  take to reach each Region Server may vary from a few seconds to a minute, depending on the\n  resource load and speed of the hardware or network, among other factors. There is also no way to\n  know whether a given insert or update is in memory or has been flushed.\n</Callout>\n\n#### Take a Snapshot With TTL\n\nSnapshots have a lifecycle that is independent from the table from which they are created. Although data in a table may be stored with TTL the data files containing them become frozen by the snapshot. Space consumed by expired cells will not be reclaimed by normal table housekeeping like compaction. While this is expected it can be inconvenient at scale. When many snapshots are under management and the data in various tables is expired by TTL some notion of optional TTL (and optional default TTL) for snapshots could be useful.\n\n```ruby\nhbase> snapshot 'mytable', 'snapshot1234', {TTL => 86400}\n```\n\nThe above command creates snapshot `snapshot1234` with TTL of 86400 sec (24 hours) and hence, the snapshot is supposed to be cleaned up after 24 hours\n\n#### Default Snapshot TTL:\n\n* User specified default TTL with config `hbase.master.snapshot.ttl`\n* FOREVER if `hbase.master.snapshot.ttl` is not set\n\nWhile creating a snapshot, if TTL in seconds is not explicitly specified, the above logic will be followed to determine the TTL. If no configs are changed, the default behavior is that all snapshots will be retained forever (until manual deletion). If a different default TTL behavior is desired, `hbase.master.snapshot.ttl` can be set to a default TTL in seconds. Any snapshot created without an explicit TTL will take this new value.\n\n<Callout type=\"info\">\n  If `hbase.master.snapshot.ttl` is set, a snapshot with an explicit \\{TTL ⇒ 0} or \\{TTL ⇒ -1} will also take this value. In this case, a TTL \\< -1 (such as \\{TTL ⇒ -2}) should be used to indicate FOREVER.\n</Callout>\n\nTo summarize concisely,\n\n1. Snapshot with TTL value \\< -1 will stay forever regardless of any server side config changes (until deleted manually by user).\n2. Snapshot with TTL value > 0 will be deleted automatically soon after TTL expires.\n3. Snapshot created without specifying TTL will always have TTL value represented by config `hbase.master.snapshot.ttl`. Default value of this config is 0, which represents: keep the snapshot forever (until deleted manually by user).\n4. From client side, TTL value 0 or -1 should never be explicitly provided because they will be treated same as snapshot without TTL (same as above point 3) and hence will use TTL as per value represented by config `hbase.master.snapshot.ttl`.\n\n#### Take a snapshot with custom MAX\\_FILESIZE\n\nOptionally, snapshots can be created with a custom max file size configuration that will be used by cloned tables, instead of the global `hbase.hregion.max.filesize` configuration property. This is mostly useful when exporting snapshots between different clusters. If the HBase cluster where the snapshot is originally taken has a much larger value set for `hbase.hregion.max.filesize` than one or more clusters where the snapshot is being exported to, a storm of region splits may occur when restoring the snapshot on destination clusters. Specifying `MAX_FILESIZE` on properties passed to `snapshot` command will save informed value into the table's `MAX_FILESIZE` decriptor at snapshot creation time. If the table already defines `MAX_FILESIZE` descriptor, this property would be ignored and have no effect.\n\n```ruby\nsnapshot 'table01', 'snap01', {MAX_FILESIZE => 21474836480}\n```\n\n#### Enable/Disable Snapshot Auto Cleanup on running cluster:\n\nBy default, snapshot auto cleanup based on TTL would be enabled for any new cluster. At any point in time, if snapshot cleanup is supposed to be stopped due to some snapshot restore activity or any other reason, it is advisable to disable it using shell command:\n\n```ruby\nhbase> snapshot_cleanup_switch false\n```\n\nWe can re-enable it using:\n\n```ruby\nhbase> snapshot_cleanup_switch true\n```\n\nThe shell command with switch false would disable snapshot auto cleanup activity based on TTL and return the previous state of the activity(true: running already, false: disabled already)\n\nA sample output for above commands:\n\n```text\nPrevious snapshot cleanup state : true\nTook 0.0069 seconds\n=> \"true\"\n```\n\nWe can query whether snapshot auto cleanup is enabled for cluster using:\n\n```ruby\nhbase> snapshot_cleanup_enabled\n```\n\nThe command would return output in true/false.\n\n### Listing Snapshots\n\nList all snapshots taken (by printing the names and relative information).\n\n```bash\n$ ./bin/hbase shell\nhbase> list_snapshots\n```\n\n### Deleting Snapshots\n\nYou can remove a snapshot, and the files retained for that snapshot will be removed if no longer needed.\n\n```bash\n$ ./bin/hbase shell\nhbase> delete_snapshot 'myTableSnapshot-122112'\n```\n\n### Clone a table from snapshot\n\nFrom a snapshot you can create a new table (clone operation) with the same data that you had when the snapshot was taken. The clone operation, doesn't involve data copies, and a change to the cloned table doesn't impact the snapshot or the original table.\n\n```bash\n$ ./bin/hbase shell\nhbase> clone_snapshot 'myTableSnapshot-122112', 'myNewTestTable'\n```\n\n### Restore a snapshot\n\nThe restore operation requires the table to be disabled, and the table will be restored to the state at the time when the snapshot was taken, changing both data and schema if required.\n\n```bash\n$ ./bin/hbase shell\nhbase> disable 'myTable'\nhbase> restore_snapshot 'myTableSnapshot-122112'\n```\n\n<Callout type=\"info\">\n  Since Replication works at log level and snapshots at file-system level, after a restore, the\n  replicas will be in a different state from the master. If you want to use restore, you need to\n  stop replication and redo the bootstrap.\n</Callout>\n\nIn case of partial data-loss due to misbehaving client, instead of a full restore that requires the table to be disabled, you can clone the table from the snapshot and use a Map-Reduce job to copy the data that you need, from the clone to the main one.\n\n### Snapshots operations and ACLs\n\nIf you are using security with the AccessController Coprocessor (See [hbase.accesscontrol.configuration](/docs/security/data-access#access-control-labels-acls)), only a global administrator can take, clone, or restore a snapshot, and these actions do not capture the ACL rights. This means that restoring a table preserves the ACL rights of the existing table, while cloning a table creates a new table that has no ACL rights until the administrator adds them.\n\n### Export to another cluster\n\nThe ExportSnapshot tool copies all the data related to a snapshot (hfiles, logs, snapshot metadata) to another cluster. The tool executes a Map-Reduce job, similar to distcp, to copy files between the two clusters, and since it works at file-system level the hbase cluster does not have to be online.\n\nTo copy a snapshot called MySnapshot to an HBase cluster srv2 (hdfs\\:///srv2:8082/hbase) using 16 mappers:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.snapshot.ExportSnapshot -snapshot MySnapshot -copy-to hdfs://srv2:8082/hbase -mappers 16\n```\n\n#### Limiting Bandwidth Consumption\n\nYou can limit the bandwidth consumption when exporting a snapshot, by specifying the `-bandwidth` parameter, which expects an integer representing megabytes per second. The following example limits the above example to 200 MB/sec.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.snapshot.ExportSnapshot -snapshot MySnapshot -copy-to hdfs://srv2:8082/hbase -mappers 16 -bandwidth 200\n```\n\n## Storing Snapshots in an Amazon S3 Bucket\n\nYou can store and retrieve snapshots from Amazon S3, using the following procedure.\n\n<Callout type=\"info\">\n  You can also store snapshots in Microsoft Azure Blob Storage. See [Storing Snapshots in Microsoft\n  Azure Blob\n  Storage](/docs/operational-management/backup-and-snapshots#storing-snapshots-in-microsoft-azure-blob-storage).\n</Callout>\n\n### Prerequisites\n\n* You must be using HBase 1.0 or higher and Hadoop 2.6.1 or higher, which is the first configuration that uses the Amazon AWS SDK.\n* You must use the `s3a://` protocol to connect to Amazon S3. The older `s3n://` and `s3://` protocols have various limitations and do not use the Amazon AWS SDK.\n* The `s3a://` URI must be configured and available on the server where you run the commands to export and restore the snapshot.\n\nAfter you have fulfilled the prerequisites, take the snapshot like you normally would. Afterward, you can export it using the `org.apache.hadoop.hbase.snapshot.ExportSnapshot` command like the one below, substituting your own `s3a://` path in the `copy-from` or `copy-to` directive and substituting or modifying other options as required:\n\n```bash\n$ hbase org.apache.hadoop.hbase.snapshot.ExportSnapshot \\\n    -snapshot MySnapshot \\\n    -copy-from hdfs://srv2:8082/hbase \\\n    -copy-to s3a://<bucket>/<namespace>/hbase \\\n    -chuser MyUser \\\n    -chgroup MyGroup \\\n    -chmod 700 \\\n    -mappers 16\n```\n\n```bash\n$ hbase org.apache.hadoop.hbase.snapshot.ExportSnapshot \\\n    -snapshot MySnapshot\n    -copy-from s3a://<bucket>/<namespace>/hbase \\\n    -copy-to hdfs://srv2:8082/hbase \\\n    -chuser MyUser \\\n    -chgroup MyGroup \\\n    -chmod 700 \\\n    -mappers 16\n```\n\nYou can also use the `org.apache.hadoop.hbase.snapshot.SnapshotInfo` utility with the `s3a://` path by including the `-remote-dir` option.\n\n```bash\n$ hbase org.apache.hadoop.hbase.snapshot.SnapshotInfo \\\n    -remote-dir s3a://<bucket>/<namespace>/hbase \\\n    -list-snapshots\n```\n\n## Storing Snapshots in Microsoft Azure Blob Storage\n\nYou can store snapshots in Microsoft Azure Blog Storage using the same techniques as in [Storing Snapshots in an Amazon S3 Bucket](/docs/operational-management/backup-and-snapshots#storing-snapshots-in-an-amazon-s3-bucket).\n\n### Prerequisites\n\n* You must be using HBase 1.2 or higher with Hadoop 2.7.1 or higher. No version of HBase supports Hadoop 2.7.0.\n* Your hosts must be configured to be aware of the Azure blob storage filesystem. See [https://hadoop.apache.org/docs/r2.7.1/hadoop-azure/index.html](https://hadoop.apache.org/docs/r2.7.1/hadoop-azure/index.html).\n\nAfter you meet the prerequisites, follow the instructions in [Storing Snapshots in an Amazon S3 Bucket](/docs/operational-management/backup-and-snapshots#storing-snapshots-in-an-amazon-s3-bucket), replacingthe protocol specifier with `wasb://` or `wasbs://`.\n\n## Storing Snapshots in Aliyun Object Storage Service\n\nYou can store snapshots in Aliyun Object Storage Service(Aliyun OSS) using the same techniques as in [Storing Snapshots in an Amazon S3 Bucket](/docs/operational-management/backup-and-snapshots#storing-snapshots-in-an-amazon-s3-bucket).\n\n### Prerequisites\n\n* You must be using HBase 1.2 or higher with Hadoop 2.9.1 or higher.\n* Your hosts must be configured to be aware of the Aliyun oss filesystem. See [https://hadoop.apache.org/docs/stable/hadoop-aliyun/tools/hadoop-aliyun/index.html](https://hadoop.apache.org/docs/stable/hadoop-aliyun/tools/hadoop-aliyun/index.html).\n\nAfter you meet the prerequisites, follow the instructions in [Storing Snapshots in an Amazon S3 Bucket](/docs/operational-management/backup-and-snapshots#storing-snapshots-in-an-amazon-s3-bucket), replacing the protocol specifier with `oss://`.\n\n## Table Rename\n\nIn versions 0.90.x of hbase and earlier, we had a simple script that would rename the hdfs table directory and then do an edit of the hbase:meta table replacing all mentions of the old table name with the new. The script was called `./bin/rename_table.rb`. The script was deprecated and removed mostly because it was unmaintained and the operation performed by the script was brutal.\n\nAs of hbase 0.94.x, you can use the snapshot facility renaming a table. Here is how you would do it using the hbase shell:\n\n```ruby\nhbase shell> disable 'tableName'\nhbase shell> snapshot 'tableName', 'tableSnapshot'\nhbase shell> clone_snapshot 'tableSnapshot', 'newTableName'\nhbase shell> delete_snapshot 'tableSnapshot'\nhbase shell> drop 'tableName'\n```\n\nor in code it would be as follows:\n\n```java\nvoid rename(Admin admin, String oldTableName, TableName newTableName) {\n  String snapshotName = randomName();\n  admin.disableTable(oldTableName);\n  admin.snapshot(snapshotName, oldTableName);\n  admin.cloneSnapshot(snapshotName, newTableName);\n  admin.deleteSnapshot(snapshotName);\n  admin.deleteTable(oldTableName);\n}\n```\n\n## Region & Capacity Management\n\n## Region Management\n\n### Major Compaction\n\nMajor compactions can be requested via the HBase shell or [Admin.majorCompact](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/Admin.html#majorCompact\\(org.apache.hadoop.hbase.TableName\\)).\n\nNote: major compactions do NOT do region merges. See [compaction](/docs/architecture/regions#compaction) for more information about compactions.\n\n### Merge\n\nMerge is a utility that can merge adjoining regions in the same table (see org.apache.hadoop.hbase.util.Merge).\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.util.Merge <tablename> <region1> <region2>\n```\n\nIf you feel you have too many regions and want to consolidate them, Merge is the utility you need. Merge must run be done when the cluster is down. See the [O'Reilly HBase Book](https://web.archive.org/web/20111231002503/http://ofps.oreilly.com/titles/9781449396107/performance.html) for an example of usage.\n\nYou will need to pass 3 parameters to this application. The first one is the table name. The second one is the fully qualified name of the first region to merge, like \"table\\_name,\\x0A,1342956111995.7cef47f192318ba7ccc75b1bbf27a82b.\". The third one is the fully qualified name for the second region to merge.\n\nAdditionally, there is a Ruby script attached to [HBASE-1621](https://issues.apache.org/jira/browse/HBASE-1621) for region merging.\n\n## Capacity Planning and Region Sizing\n\nThere are several considerations when planning the capacity for an HBase cluster and performing the initial configuration. Start with a solid understanding of how HBase handles data internally.\n\n### Node count and hardware/VM configuration\n\n#### Physical data size\n\nPhysical data size on disk is distinct from logical size of your data and is affected by the following:\n\n* Increased by HBase overhead\n* See [keyvalue](/docs/architecture/regions#keyvalue) and [keysize](/docs/regionserver-sizing#try-to-minimize-row-and-column-sizes). At least 24 bytes per key-value (cell), can be more. Small keys/values means more relative overhead.\n* KeyValue instances are aggregated into blocks, which are indexed. Indexes also have to be stored. Blocksize is configurable on a per-ColumnFamily basis. See [regions.arch](/docs/architecture/regions).\n* Decreased by [compression](/docs/compression) and data block encoding, depending on data. You might want to test what compression and encoding (if any) make sense for your data.\n* Increased by size of region server \\[wal]/docs/architecture/regionserver#write-ahead-log-wal (usually fixed and negligible - less than half of RS memory size, per RS).\n* Increased by HDFS replication - usually x3.\n\nAside from the disk space necessary to store the data, one RS may not be able to serve arbitrarily large amounts of data due to some practical limits on region count and size (see [ops.capacity.regions](/docs/operational-management/region-and-capacity#determining-region-count-and-size)).\n\n#### Read/Write throughput\n\nNumber of nodes can also be driven by required throughput for reads and/or writes. The throughput one can get per node depends a lot on data (esp. key/value sizes) and request patterns, as well as node and system configuration. Planning should be done for peak load if it is likely that the load would be the main driver of the increase of the node count. PerformanceEvaluation and [ycsb](/docs/ycsb) tools can be used to test single node or a test cluster.\n\nFor write, usually 5-15Mb/s per RS can be expected, since every region server has only one active WAL. There's no good estimate for reads, as it depends vastly on data, requests, and cache hit rate. [perf.casestudy](/docs/performance#performance-case-studies) might be helpful.\n\n#### JVM GC limitations\n\nRS cannot currently utilize very large heap due to cost of GC. There's also no good way of running multiple RS-es per server (other than running several VMs per machine). Thus, \\~20-24Gb or less memory dedicated to one RS is recommended. GC tuning is required for large heap sizes. See [gcpause](/docs/performance#long-gc-pauses), [trouble.log.gc](/docs/troubleshooting#jvm-garbage-collection-logs) and elsewhere (TODO: where?)\n\n### Determining region count and size\n\nGenerally less regions makes for a smoother running cluster (you can always manually split the big regions later (if necessary) to spread the data, or request load, over the cluster); 20-200 regions per RS is a reasonable range. The number of regions cannot be configured directly (unless you go for fully [disable.splitting](/docs/configuration/important#managed-splitting)); adjust the region size to achieve the target region size given table size.\n\nWhen configuring regions for multiple tables, note that most region settings can be set on a per-table basis via [TableDescriptorBuilder](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/client/TableDescriptorBuilder.html), as well as shell commands. These settings will override the ones in `hbase-site.xml`. That is useful if your tables have different workloads/use cases.\n\nAlso note that in the discussion of region sizes here, *HDFS replication factor is not (and should not be) taken into account, whereas other factors [ops.capacity.nodes.datasize](/docs/operational-management/region-and-capacity#physical-data-size) should be.* So, if your data is compressed and replicated 3 ways by HDFS, \"9 Gb region\" means 9 Gb of compressed data. HDFS replication factor only affects your disk usage and is invisible to most HBase code.\n\n#### Viewing the Current Number of Regions\n\nYou can view the current number of regions for a given table using the HMaster UI. In the **Tables** section, the number of online regions for each table is listed in the **Online Regions** column. This total only includes the in-memory state and does not include disabled or offline regions.\n\n#### Number of regions per RS - upper bound\n\nIn production scenarios, where you have a lot of data, you are normally concerned with the maximum number of regions you can have per server. [too many regions](/docs/architecture/regions#why-should-i-keep-my-region-count-low) has technical discussion on the subject. Basically, the maximum number of regions is mostly determined by memstore memory usage. Each region has its own memstores; these grow up to a configurable size; usually in 128-256 MB range, see [hbase.hregion.memstore.flush.size](/docs/configuration/default#hbasehregionmemstoreflushsize-toc). One memstore exists per column family (so there's only one per region if there's one CF in the table). The RS dedicates some fraction of total memory to its memstores (see [hbase.regionserver.global.memstore.size](/docs/configuration/default#hbaseregionserverglobalmemstoresize-toc)). If this memory is exceeded (too much memstore usage), it can cause undesirable consequences such as unresponsive server or compaction storms. A good starting point for the number of regions per RS (assuming one table) is:\n\n```text\n((RS memory) * (total memstore fraction)) / ((memstore size)*(# column families))\n```\n\nThis formula is pseudo-code. Here are two formulas using the actual tunable parameters, first for HBase 0.98+ and second for HBase 0.94.x.\n\n**HBase 0.98.x**\n\n```text\n((RS Xmx) * hbase.regionserver.global.memstore.size) / (hbase.hregion.memstore.flush.size * (# column families))\n```\n\n**HBase 0.94.x**\n\n```text\n((RS Xmx) * hbase.regionserver.global.memstore.upperLimit) / (hbase.hregion.memstore.flush.size * (# column families))+\n```\n\nIf a given RegionServer has 16 GB of RAM, with default settings, the formula works out to 16384\\*0.4/128 \\~ 51 regions per RS is a starting point. The formula can be extended to multiple tables; if they all have the same configuration, just use the total number of families.\n\nThis number can be adjusted; the formula above assumes all your regions are filled at approximately the same rate. If only a fraction of your regions are going to be actively written to, you can divide the result by that fraction to get a larger region count. Then, even if all regions are written to, all region memstores are not filled evenly, and eventually jitter appears even if they are (due to limited number of concurrent flushes). Thus, one can have as many as 2-3 times more regions than the starting point; however, increased numbers carry increased risk.\n\nFor write-heavy workload, memstore fraction can be increased in configuration at the expense of block cache; this will also allow one to have more regions.\n\n#### Number of regions per RS - lower bound\n\nHBase scales by having regions across many servers. Thus if you have 2 regions for 16GB data, on a 20 node machine your data will be concentrated on just a few machines - nearly the entire cluster will be idle. This really can't be stressed enough, since a common problem is loading 200MB data into HBase and then wondering why your awesome 10 node cluster isn't doing anything.\n\nOn the other hand, if you have a very large amount of data, you may also want to go for a larger number of regions to avoid having regions that are too large.\n\n#### Maximum region size\n\nFor large tables in production scenarios, maximum region size is mostly limited by compactions - very large compactions, esp. major, can degrade cluster performance. Currently, the recommended maximum region size is 10-20Gb, and 5-10Gb is optimal. For older 0.90.x codebase, the upper-bound of regionsize is about 4Gb, with a default of 256Mb.\n\nThe size at which the region is split into two is generally configured via [hbase.hregion.max.filesize](/docs/configuration/default#hbasehregionmaxfilesize-toc); for details, see [arch.region.splits](/docs/architecture/regions#region-splits).\n\nIf you cannot estimate the size of your tables well, when starting off, it's probably best to stick to the default region size, perhaps going smaller for hot tables (or manually split hot regions to spread the load over the cluster), or go with larger region sizes if your cell sizes tend to be largish (100k and up).\n\nIn HBase 0.98, experimental stripe compactions feature was added that would allow for larger regions, especially for log data. See [ops.stripe](/docs/architecture/regions#experimental-stripe-compactions).\n\n#### Total data size per region server\n\nAccording to above numbers for region size and number of regions per region server, in an optimistic estimate 10 GB x 100 regions per RS will give up to 1TB served per region server, which is in line with some of the reported multi-PB use cases. However, it is important to think about the data vs cache size ratio at the RS level. With 1TB of data per server and 10 GB block cache, only 1% of the data will be cached, which may barely cover all block indices.\n\n### Initial configuration and tuning\n\nFirst, see [important configurations](/docs/configuration/important). Note that some configurations, more than others, depend on specific scenarios. Pay special attention to:\n\n* [hbase.regionserver.handler.count](/docs/configuration/default#hbaseregionserverhandlercount-toc) - request handler thread count, vital for high-throughput workloads.\n* [config.wals](/docs/configuration/important#configuring-the-size-and-number-of-wal-files) - the blocking number of WAL files depends on your memstore configuration and should be set accordingly to prevent potential blocking when doing high volume of writes.\n\nThen, there are some considerations when setting up your cluster and tables.\n\n#### Compactions\n\nDepending on read/write volume and latency requirements, optimal compaction settings may be different. See [compaction](/docs/architecture/regions#compaction) for some details.\n\nWhen provisioning for large data sizes, however, it's good to keep in mind that compactions can affect write throughput. Thus, for write-intensive workloads, you may opt for less frequent compactions and more store files per regions. Minimum number of files for compactions (`hbase.hstore.compaction.min`) can be set to higher value; [hbase.hstore.blockingStoreFiles](/docs/configuration/default#hbasehstoreblockingStoreFiles-toc) should also be increased, as more files might accumulate in such case. You may also consider manually managing compactions: [managed.compactions](/docs/configuration/important#managed-compactions)\n\n#### Pre-splitting the table\n\nBased on the target number of the regions per RS (see [ops.capacity.regions.count](/docs/operational-management/region-and-capacity#number-of-regions-per-rs---upper-bound)) and number of RSes, one can pre-split the table at creation time. This would both avoid some costly splitting as the table starts to fill up, and ensure that the table starts out already distributed across many servers.\n\nIf the table is expected to grow large enough to justify that, at least one region per RS should be created. It is not recommended to split immediately into the full target number of regions (e.g. 50 \\* number of RSes), but a low intermediate value can be chosen. For multiple tables, it is recommended to be conservative with presplitting (e.g. pre-split 1 region per RS at most), especially if you don't know how much each table will grow. If you split too much, you may end up with too many regions, with some tables having too many small regions.\n\nFor pre-splitting howto, see [manual region splitting decisions](/docs/architecture/regions#manual-region-splitting) and [precreate.regions](/docs/performance#table-creation-pre-creating-regions).\n\n## RegionServer Grouping\n\nRegionServer Grouping (A.K.A `rsgroup`) is an advanced feature for partitioning regionservers into distinctive groups for strict isolation. It should only be used by users who are sophisticated enough to understand the full implications and have a sufficient background in managing HBase clusters. It was developed by Yahoo! and they run it at scale on their large grid cluster. See [HBase at Yahoo! Scale](http://www.slideshare.net/HBaseCon/keynote-apache-hbase-at-yahoo-scale).\n\nRSGroups can be defined and managed with both admin methods and shell commands. A server can be added to a group with hostname and port pair and tables can be moved to this group so that only regionservers in the same rsgroup can host the regions of the table. The group for a table is stored in its TableDescriptor, the property name is `hbase.rsgroup.name`. You can also set this property on a namespace, so it will cause all the tables under this namespace to be placed into this group. RegionServers and tables can only belong to one rsgroup at a time. By default, all tables and regionservers belong to the `default` rsgroup. System tables can also be put into a rsgroup using the regular APIs. A custom balancer implementation tracks assignments per rsgroup and makes sure to move regions to the relevant regionservers in that rsgroup. The rsgroup information is stored in a regular HBase table, and a zookeeper-based read-only cache is used at cluster bootstrap time.\n\nTo enable, add the following to your hbase-site.xml and restart your Master:\n\n```xml\n<property>\n  <name>hbase.balancer.rsgroup.enabled</name>\n  <value>true</value>\n</property>\n```\n\nThen use the admin/shell *rsgroup* methods/commands to create and manipulate RegionServer groups: e.g. to add a rsgroup and then add a server to it. To see the list of rsgroup commands available in the hbase shell type:\n\n```bash\n hbase(main):008:0> help 'rsgroup'\n Took 0.5610 seconds\n```\n\nHigh level, you create a rsgroup that is other than the `default` group using *add\\_rsgroup* command. You then add servers and tables to this group with the *move\\_servers\\_rsgroup* and *move\\_tables\\_rsgroup* commands. If necessary, run a balance for the group if tables are slow to migrate to the groups dedicated server with the *balance\\_rsgroup* command (Usually this is not needed). To monitor effect of the commands, see the `Tables` tab toward the end of the Master UI home page. If you click on a table, you can see what servers it is deployed across. You should see here a reflection of the grouping done with your shell commands. View the master log if issues.\n\nHere is example using a few of the rsgroup commands. To add a group, do as follows:\n\n```bash\n hbase(main):008:0> add_rsgroup 'my_group'\n Took 0.5610 seconds\n```\n\n<Callout type=\"info\" title=\"RegionServer Groups must be Enabled\">\n  If you have not enabled the rsgroup feature and you call any of the rsgroup admin methods or shell\n  commands the call will fail with a `DoNotRetryIOException` with a detail message that says the\n  rsgroup feature is disabled.\n</Callout>\n\nAdd a server (specified by hostname + port) to the just-made group using the *move\\_servers\\_rsgroup* command as follows:\n\n```bash\n hbase(main):010:0> move_servers_rsgroup 'my_group',['k.att.net:51129']\n```\n\n<Callout type=\"info\" title=\"Hostname and Port vs ServerName\">\n  The rsgroup feature refers to servers in a cluster with hostname and port only. It does not make\n  use of the HBase ServerName type identifying RegionServers; i.e. hostname + port + starttime to\n  distinguish RegionServer instances. The rsgroup feature keeps working across RegionServer restarts\n  so the starttime of ServerName — and hence the ServerName type — is not appropriate.\n  Administration\n</Callout>\n\nServers come and go over the lifetime of a Cluster. Currently, you must manually align the servers referenced in rsgroups with the actual state of nodes in the running cluster. What we mean by this is that if you decommission a server, then you must update rsgroups as part of your server decommission process removing references. Notice that, by calling `clearDeadServers` manually will also remove the dead servers from any rsgroups, but the problem is that we will lost track of the dead servers after master restarts, which means you still need to update the rsgroup by your own.\n\nPlease use `Admin.removeServersFromRSGroup` or shell command *remove\\_servers\\_rsgroup* to remove decommission servers from rsgroup.\n\nThe `default` group is not like other rsgroups in that it is dynamic. Its server list mirrors the current state of the cluster; i.e. if you shutdown a server that was part of the `default` rsgroup, and then do a *get\\_rsgroup* `default` to list its content in the shell, the server will no longer be listed. For non-default groups, though a mode may be offline, it will persist in the non-default group's list of servers. But if you move the offline server from the non-default rsgroup to default, it will not show in the `default` list. It will just be dropped.\n\n### Best Practice\n\nThe authors of the rsgroup feature, the Yahoo! HBase Engineering team, have been running it on their grid for a good while now and have come up with a few best practices informed by their experience.\n\n#### Isolate System Tables\n\nEither have a system rsgroup where all the system tables are or just leave the system tables in `default` rsgroup and have all user-space tables are in non-default rsgroups.\n\n#### Dead Nodes\n\nYahoo! Have found it useful at their scale to keep a special rsgroup of dead or questionable nodes; this is one means of keeping them out of the running until repair.\n\nBe careful replacing dead nodes in an rsgroup. Ensure there are enough live nodes before you start moving out the dead. Move in good live nodes first if you have to.\n\n### Troubleshooting\n\nViewing the Master log will give you insight on rsgroup operation.\n\nIf it appears stuck, restart the Master process.\n\n### Remove RegionServer Grouping\n\nSimply disable RegionServer Grouping feature is easy, just remove the 'hbase.balancer.rsgroup.enabled' from hbase-site.xml or explicitly set it to false in hbase-site.xml.\n\n```xml\n<property>\n  <name>hbase.balancer.rsgroup.enabled</name>\n  <value>false</value>\n</property>\n```\n\nBut if you change the 'hbase.balancer.rsgroup.enabled' to true, the old rsgroup configs will take effect again. So if you want to completely remove the RegionServer Grouping feature from a cluster, so that if the feature is re-enabled in the future, the old meta data will not affect the functioning of the cluster, there are more steps to do.\n\n* Move all tables in non-default rsgroups to `default` regionserver group\n\n  ```text\n  #Reassigning table t1 from non default group - hbase shell\n  hbase(main):005:0> move_tables_rsgroup 'default',['t1']\n  ```\n\n* Move all regionservers in non-default rsgroups to `default` regionserver group\n\n  ```text\n  #Reassigning all the servers in the non-default rsgroup to default - hbase shell\n  hbase(main):008:0> move_servers_rsgroup 'default',['rs1.xxx.com:16206','rs2.xxx.com:16202','rs3.xxx.com:16204']\n  ```\n\n* Remove all non-default rsgroups. `default` rsgroup created implicitly doesn't have to be removed\n\n  ```text\n  #removing non default rsgroup - hbase shell\n  hbase(main):009:0> remove_rsgroup 'group2'\n  ```\n\n* Remove the changes made in `hbase-site.xml` and restart the cluster\n\n* Drop the table `hbase:rsgroup` from `hbase`\n\n  ```text\n  #Through hbase shell drop table hbase:rsgroup\n  hbase(main):001:0> disable 'hbase:rsgroup'\n  0 row(s) in 2.6270 seconds\n\n  hbase(main):002:0> drop 'hbase:rsgroup'\n  0 row(s) in 1.2730 seconds\n  ```\n\n* Remove znode `rsgroup` from the cluster ZooKeeper using zkCli.sh\n\n  ```text\n  #From ZK remove the node /hbase/rsgroup through zkCli.sh\n  rmr /hbase/rsgroup\n  ```\n\n### ACL\n\nTo enable ACL, add the following to your hbase-site.xml and restart your Master:\n\n```xml\n<property>\n  <name>hbase.security.authorization</name>\n  <value>true</value>\n<property>\n```\n\n### Migrating From Old Implementation\n\nThe coprocessor `org.apache.hadoop.hbase.rsgroup.RSGroupAdminEndpoint` is deprected, but for compatible, if you want the pre 3.0.0 hbase client/shell to communicate with the new hbase cluster, you still need to add this coprocessor to master.\n\nThe `hbase.rsgroup.grouploadbalancer.class` config has been deprecated, as now the top level load balancer will always be `RSGroupBasedLoadBalaner`, and the `hbase.master.loadbalancer.class` config is for configuring the balancer within a group. This also means you should not set `hbase.master.loadbalancer.class` to `RSGroupBasedLoadBalaner` any more even if rsgroup feature is enabled.\n\nAnd we have done some special changes for compatibility. First, if coprocessor `org.apache.hadoop.hbase.rsgroup.RSGroupAdminEndpoint` is specified, the `hbase.balancer.rsgroup.enabled` flag will be set to true automatically to enable rs group feature. Second, we will load `hbase.rsgroup.grouploadbalancer.class` prior to `hbase.master.loadbalancer.class`. And last, if you do not set `hbase.rsgroup.grouploadbalancer.class` but only set `hbase.master.loadbalancer.class` to `RSGroupBasedLoadBalancer`, we will load the default load balancer to avoid infinite nesting. This means you do not need to change anything when upgrading if you have already enabled rs group feature.\n\nThe main difference comparing to the old implementation is that, now the rsgroup for a table is stored in `TableDescriptor`, instead of in `RSGroupInfo`, so the `getTables` method of `RSGroupInfo` has been deprecated. And if you use the `Admin` methods to get the `RSGroupInfo`, its `getTables` method will always return empty. This is because that in the old implementation, this method is a bit broken as you can set rsgroup on namespace and make all the tables under this namespace into this group but you can not get these tables through `RSGroupInfo.getTables`. Now you should use the two new methods `listTablesInRSGroup` and `getConfiguredNamespacesAndTablesInRSGroup` in `Admin` to get tables and namespaces in a rsgroup.\n\nOf course the behavior for the old RSGroupAdminEndpoint is not changed, we will fill the tables field of the RSGroupInfo before returning, to make it compatible with old hbase client/shell.\n\nWhen upgrading, the migration between the RSGroupInfo and TableDescriptor will be done automatically. It will take sometime, but it is fine to restart master in the middle, the migration will continue after restart. And during the migration, the rs group feature will still work and in most cases the region will not be misplaced(since this is only a one time job and will not last too long so we have not test it very seriously to make sure the region will not be misplaced always, so we use the word 'in most cases'). The implementation is a bit tricky, you can see the code in `RSGroupInfoManagerImpl.migrate` if interested.\n\n## Region Normalizer\n\nThe Region Normalizer tries to make Regions all in a table about the same in size. It does this by first calculating total table size and average size per region. It splits any region that is larger than twice this size. Any region that is much smaller is merged into an adjacent region. The Normalizer runs on a regular schedule, which is configurable. It can also be disabled entirely via a runtime \"switch\". It can be run manually via the shell or Admin API call. Even if normally disabled, it is good to run manually after the cluster has been running a while or say after a burst of activity such as a large delete.\n\nThe Normalizer works well for bringing a table's region boundaries into alignment with the reality of data distribution after an initial effort at pre-splitting a table. It is also a nice compliment to the data TTL feature when the schema includes timestamp in the rowkey, as it will automatically merge away regions whose contents have expired.\n\n(The bulk of the below detail was copied wholesale from the blog by Romil Choksi at [HBase Region Normalizer](https://community.cloudera.com/t5/Community-Articles/HBase-Region-Normalizer/ta-p/247266)).\n\nThe Region Normalizer is feature available since HBase-1.2. It runs a set of pre-calculated merge/split actions to resize regions that are either too large or too small compared to the average region size for a given table. Region Normalizer when invoked computes a normalization 'plan' for all of the tables in HBase. System tables (such as hbase:meta, hbase:namespace, Phoenix system tables etc) and user tables with normalization disabled are ignored while computing the plan. For normalization enabled tables, normalization plan is carried out in parallel across multiple tables.\n\nNormalizer can be enabled or disabled globally for the entire cluster using the ‘normalizer\\_switch' command in the HBase shell. Normalization can also be controlled on a per table basis, which is disabled by default when a table is created. Normalization for a table can be enabled or disabled by setting the NORMALIZATION\\_ENABLED table attribute to true or false.\n\nTo check normalizer status and enable/disable normalizer\n\n```bash\nhbase(main):001:0> normalizer_enabled\ntrue\n0 row(s) in 0.4870 seconds\n\nhbase(main):002:0> normalizer_switch false\ntrue\n0 row(s) in 0.0640 seconds\n\nhbase(main):003:0> normalizer_enabled\nfalse\n0 row(s) in 0.0120 seconds\n\nhbase(main):004:0> normalizer_switch true\nfalse\n0 row(s) in 0.0200 seconds\n\nhbase(main):005:0> normalizer_enabled\ntrue\n0 row(s) in 0.0090 seconds\n```\n\nWhen enabled, Normalizer is invoked in the background every 5 mins (by default), which can be configured using `hbase.normalization.period` in `hbase-site.xml`. Normalizer can also be invoked manually/programmatically at will using HBase shell's `normalize` command. HBase by default uses `SimpleRegionNormalizer`, but users can design their own normalizer as long as they implement the RegionNormalizer Interface. Details about the logic used by `SimpleRegionNormalizer` to compute its normalization plan can be found [here](https://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.html).\n\nThe below example shows a normalization plan being computed for an user table, and merge action being taken as a result of the normalization plan computed by SimpleRegionNormalizer.\n\nConsider an user table with some pre-split regions having 3 equally large regions (about 100K rows) and 1 relatively small region (about 25K rows). Following is the snippet from an hbase meta table scan showing each of the pre-split regions for the user table.\n\n```\ntable_p8ddpd6q5z,,1469494305548.68b9892220865cb6048 column=info:regioninfo, timestamp=1469494306375, value={ENCODED => 68b9892220865cb604809c950d1adf48, NAME => 'table_p8ddpd6q5z,,1469494305548.68b989222 09c950d1adf48.   0865cb604809c950d1adf48.', STARTKEY => '', ENDKEY => '1'}\n....\ntable_p8ddpd6q5z,1,1469494317178.867b77333bdc75a028 column=info:regioninfo, timestamp=1469494317848, value={ENCODED => 867b77333bdc75a028bb4c5e4b235f48, NAME => 'table_p8ddpd6q5z,1,1469494317178.867b7733 bb4c5e4b235f48.  3bdc75a028bb4c5e4b235f48.', STARTKEY => '1', ENDKEY => '3'}\n....\ntable_p8ddpd6q5z,3,1469494328323.98f019a753425e7977 column=info:regioninfo, timestamp=1469494328486, value={ENCODED => 98f019a753425e7977ab8636e32deeeb, NAME => 'table_p8ddpd6q5z,3,1469494328323.98f019a7 ab8636e32deeeb.  53425e7977ab8636e32deeeb.', STARTKEY => '3', ENDKEY => '7'}\n....\ntable_p8ddpd6q5z,7,1469494339662.94c64e748979ecbb16 column=info:regioninfo, timestamp=1469494339859, value={ENCODED => 94c64e748979ecbb166f6cc6550e25c6, NAME => 'table_p8ddpd6q5z,7,1469494339662.94c64e74 6f6cc6550e25c6.   8979ecbb166f6cc6550e25c6.', STARTKEY => '7', ENDKEY => '8'}\n....\ntable_p8ddpd6q5z,8,1469494339662.6d2b3f5fd1595ab8e7 column=info:regioninfo, timestamp=1469494339859, value={ENCODED => 6d2b3f5fd1595ab8e7c031876057b1ee, NAME => 'table_p8ddpd6q5z,8,1469494339662.6d2b3f5f c031876057b1ee.   d1595ab8e7c031876057b1ee.', STARTKEY => '8', ENDKEY => ''}\n```\n\nInvoking the normalizer using 'normalize' int the HBase shell, the below log snippet from HMaster log shows the normalization plan computed as per the logic defined for SimpleRegionNormalizer. Since the total region size (in MB) for the adjacent smallest regions in the table is less than the average region size, the normalizer computes a plan to merge these two regions.\n\n```\n2016-07-26 07:08:26,928 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] master.HMaster: Skipping normalization for table: hbase:namespace, as it's either system table or doesn't have auto\nnormalization turned on\n2016-07-26 07:08:26,928 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] master.HMaster: Skipping normalization for table: hbase:backup, as it's either system table or doesn't have auto normalization turned on\n2016-07-26 07:08:26,928 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] master.HMaster: Skipping normalization for table: hbase:meta, as it's either system table or doesn't have auto normalization turned on\n2016-07-26 07:08:26,928 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] master.HMaster: Skipping normalization for table: table_h2osxu3wat, as it's either system table or doesn't have autonormalization turned on\n2016-07-26 07:08:26,928 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] normalizer.SimpleRegionNormalizer: Computing normalization plan for table: table_p8ddpd6q5z, number of regions: 5\n2016-07-26 07:08:26,929 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] normalizer.SimpleRegionNormalizer: Table table_p8ddpd6q5z, total aggregated regions size: 12\n2016-07-26 07:08:26,929 DEBUG [B.fifo.QRpcServer.handler=20,queue=2,port=20000] normalizer.SimpleRegionNormalizer: Table table_p8ddpd6q5z, average region size: 2.4\n2016-07-26 07:08:26,929 INFO  [B.fifo.QRpcServer.handler=20,queue=2,port=20000] normalizer.SimpleRegionNormalizer: Table table_p8ddpd6q5z, small region size: 0 plus its neighbor size: 0, less thanthe avg size 2.4, merging them\n2016-07-26 07:08:26,971 INFO  [B.fifo.QRpcServer.handler=20,queue=2,port=20000] normalizer.MergeNormalizationPlan: Executing merging normalization plan: MergeNormalizationPlan{firstRegion={ENCODED=> d51df2c58e9b525206b1325fd925a971, NAME => 'table_p8ddpd6q5z,,1469514755237.d51df2c58e9b525206b1325fd925a971.', STARTKEY => '', ENDKEY => '1'}, secondRegion={ENCODED => e69c6b25c7b9562d078d9ad3994f5330, NAME => 'table_p8ddpd6q5z,1,1469514767669.e69c6b25c7b9562d078d9ad3994f5330.',\nSTARTKEY => '1', ENDKEY => '3'}}\n```\n\nRegion normalizer as per it's computed plan, merged the region with start key as ‘' and end key as ‘1', with another region having start key as ‘1' and end key as ‘3'. Now, that these regions have been merged we see a single new region with start key as ‘' and end key as ‘3'\n\n```text\ntable_p8ddpd6q5z,,1469516907210.e06c9b83c4a252b130e column=info:mergeA, timestamp=1469516907431,\nvalue=PBUF\\x08\\xA5\\xD9\\x9E\\xAF\\xE2*\\x12\\x1B\\x0A\\x07default\\x12\\x10table_p8ddpd6q5z\\x1A\\x00\"\\x011(\\x000\\x00 ea74d246741ba.   8\\x00\ntable_p8ddpd6q5z,,1469516907210.e06c9b83c4a252b130e column=info:mergeB, timestamp=1469516907431,\nvalue=PBUF\\x08\\xB5\\xBA\\x9F\\xAF\\xE2*\\x12\\x1B\\x0A\\x07default\\x12\\x10table_p8ddpd6q5z\\x1A\\x011\"\\x013(\\x000\\x0 ea74d246741ba.   08\\x00\ntable_p8ddpd6q5z,,1469516907210.e06c9b83c4a252b130e column=info:regioninfo, timestamp=1469516907431, value={ENCODED => e06c9b83c4a252b130eea74d246741ba, NAME => 'table_p8ddpd6q5z,,1469516907210.e06c9b83c ea74d246741ba.   4a252b130eea74d246741ba.', STARTKEY => '', ENDKEY => '3'}\n....\ntable_p8ddpd6q5z,3,1469514778736.bf024670a847c0adff column=info:regioninfo, timestamp=1469514779417, value={ENCODED => bf024670a847c0adffb74b2e13408b32, NAME => 'table_p8ddpd6q5z,3,1469514778736.bf024670 b74b2e13408b32.  a847c0adffb74b2e13408b32.' STARTKEY => '3', ENDKEY => '7'}\n....\ntable_p8ddpd6q5z,7,1469514790152.7c5a67bc755e649db2 column=info:regioninfo, timestamp=1469514790312, value={ENCODED => 7c5a67bc755e649db22f49af6270f1e1, NAME => 'table_p8ddpd6q5z,7,1469514790152.7c5a67bc 2f49af6270f1e1.  755e649db22f49af6270f1e1.', STARTKEY => '7', ENDKEY => '8'}\n....\ntable_p8ddpd6q5z,8,1469514790152.58e7503cda69f98f47 column=info:regioninfo, timestamp=1469514790312, value={ENCODED => 58e7503cda69f98f4755178e74288c3a, NAME => 'table_p8ddpd6q5z,8,1469514790152.58e7503c 55178e74288c3a.  da69f98f4755178e74288c3a.', STARTKEY => '8', ENDKEY => ''}\n```\n\nA similar example can be seen for an user table with 3 smaller regions and 1 relatively large region. For this example, we have an user table with 1 large region containing 100K rows, and 3 relatively smaller regions with about 33K rows each. As seen from the normalization plan, since the larger region is more than twice the average region size it ends being split into two regions – one with start key as ‘1' and end key as ‘154717' and the other region with start key as '154717' and end key as ‘3'\n\n```text\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] master.HMaster: Skipping normalization for table: hbase:backup, as it's either system table or doesn't have auto normalization turned on\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Computing normalization plan for table: table_p8ddpd6q5z, number of regions: 4\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Table table_p8ddpd6q5z, total aggregated regions size: 12\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Table table_p8ddpd6q5z, average region size: 3.0\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: No normalization needed, regions look good for table: table_p8ddpd6q5z\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Computing normalization plan for table: table_h2osxu3wat, number of regions: 5\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Table table_h2osxu3wat, total aggregated regions size: 7\n2016-07-26 07:39:45,636 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Table table_h2osxu3wat, average region size: 1.4\n2016-07-26 07:39:45,636 INFO  [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SimpleRegionNormalizer: Table table_h2osxu3wat, large region table_h2osxu3wat,1,1469515926544.27f2fdbb2b6612ea163eb6b40753c3db. has size 4, more than twice avg size, splitting\n2016-07-26 07:39:45,640 INFO [B.fifo.QRpcServer.handler=7,queue=1,port=20000] normalizer.SplitNormalizationPlan: Executing splitting normalization plan: SplitNormalizationPlan{regionInfo={ENCODED => 27f2fdbb2b6612ea163eb6b40753c3db, NAME => 'table_h2osxu3wat,1,1469515926544.27f2fdbb2b6612ea163eb6b40753c3db.', STARTKEY => '1', ENDKEY => '3'}, splitPoint=null}\n2016-07-26 07:39:45,656 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] master.HMaster: Skipping normalization for table: hbase:namespace, as it's either system table or doesn't have auto normalization turned on\n2016-07-26 07:39:45,656 DEBUG [B.fifo.QRpcServer.handler=7,queue=1,port=20000] master.HMaster: Skipping normalization for table: hbase:meta, as it's either system table or doesn't\nhave auto normalization turned on ..............\n2016-07-26 07:39:46,246 DEBUG [AM.ZK.Worker-pool2-t278] master.RegionStates: Onlined 54de97dae764b864504704c1c8d3674a on hbase-test-rc-5.openstacklocal,16020,1469419333913 {ENCODED => 54de97dae764b864504704c1c8d3674a, NAME => 'table_h2osxu3wat,1,1469518785661.54de97dae764b864504704c1c8d3674a.', STARTKEY => '1', ENDKEY => '154717'}\n2016-07-26 07:39:46,246 INFO  [AM.ZK.Worker-pool2-t278] master.RegionStates: Transition {d6b5625df331cfec84dce4f1122c567f state=SPLITTING_NEW, ts=1469518786246, server=hbase-test-rc-5.openstacklocal,16020,1469419333913} to {d6b5625df331cfec84dce4f1122c567f state=OPEN, ts=1469518786246,\nserver=hbase-test-rc-5.openstacklocal,16020,1469419333913}\n2016-07-26 07:39:46,246 DEBUG [AM.ZK.Worker-pool2-t278] master.RegionStates: Onlined d6b5625df331cfec84dce4f1122c567f on hbase-test-rc-5.openstacklocal,16020,1469419333913 {ENCODED => d6b5625df331cfec84dce4f1122c567f, NAME => 'table_h2osxu3wat,154717,1469518785661.d6b5625df331cfec84dce4f1122c567f.', STARTKEY => '154717', ENDKEY => '3'}\n```\n\n## Auto Region Reopen\n\nWe can leak store reader references if a coprocessor or core function somehow opens a scanner, or wraps one, and then does not take care to call close on the scanner or the wrapped instance. Leaked store files can not be removed even after it is invalidated via compaction. A reasonable mitigation for a reader reference leak would be a fast reopen of the region on the same server. This will release all resources, like the refcount, leases, etc. The clients should gracefully ride over this like any other region in transition. By default this auto reopen of region feature would be disabled. To enabled it, please provide high ref count value for config `hbase.regions.recovery.store.file.ref.count`.\n\nPlease refer to config descriptions for `hbase.master.regions.recovery.check.interval` and `hbase.regions.recovery.store.file.ref.count`.\n\n***\n\n# Building and Developing\n\nThis chapter contains information and guidelines for building and releasing HBase code and documentation.\nBeing familiar with these guidelines will help the HBase committers to use your contributions more easily.\n\n## Getting Involved\n\nApache HBase gets better only when people contribute! If you are looking to contribute to Apache HBase, look for [issues in JIRA tagged with the label 'beginner'](https://issues.apache.org/jira/issues/?jql=project%20%3D%20HBASE%20AND%20labels%20in%20\\(beginner\\)%20AND%20status%20in%20\\(Open%2C%20%22In%20Progress%22%2C%20Reopened\\)).\nThese are issues HBase contributors have deemed worthy but not of immediate priority and a good way to ramp on HBase internals.\nSee [What label\nis used for issues that are good on ramps for new contributors?](https://lists.apache.org/thread.html/b122265f4e4054cf08f8cd38609fb06af72f398c44f9086b05ef4e21%401407246237%40%3Cdev.hbase.apache.org%3E) from the dev mailing list for background.\n\nBefore you get started submitting code to HBase, please refer to [Developer Guidelines](/docs/building-and-developing/developer-guidelines).\n\nAs Apache HBase is an Apache Software Foundation project, see [The Apache Software Foundation](/docs/asf) for more information about how the ASF functions.\n\n## Mailing Lists\n\nSign up for the dev-list and the user-list.\nSee the [mailing lists](/mailing-lists) page.\nPosing questions - and helping to answer other people's questions - is encouraged! There are varying levels of experience on both lists so patience and politeness are encouraged (and please stay on topic.)\n\n## Slack\n\nThe Apache HBase project uses the #hbase channel on the official\n[https://the-asf.slack.com/\\[ASF](https://the-asf.slack.com/\\[ASF) Slack Workspace] for real-time questions and discussion.\nAll committers of any Apache projects can join the channel directly, for others, please mail\n[dev@hbase.apache.org](mailto:dev@hbase.apache.org) to request an invite.\n\n## Internet Relay Chat (IRC)\n\n(NOTE: Our IRC channel seems to have been deprecated in favor of the above Slack channel)\n\nFor real-time questions and discussions, use the `#hbase` IRC channel on the [FreeNode](https://freenode.net/) IRC network.\nFreeNode offers a web-based client, but most people prefer a native client, and several clients are available for each operating system.\n\n## Jira\n\nCheck for existing issues in [Jira](https://issues.apache.org/jira/projects/HBASE/issues).\nIf it's either a new feature request, enhancement, or a bug, file a ticket.\n\nWe track multiple types of work in JIRA:\n\n* Bug: Something is broken in HBase itself.\n* Test: A test is needed, or a test is broken.\n* New feature: You have an idea for new functionality. It's often best to bring\n  these up on the mailing lists first, and then write up a design specification\n  that you add to the feature request JIRA.\n* Improvement: A feature exists, but could be tweaked or augmented. It's often\n  best to bring these up on the mailing lists first and have a discussion, then\n  summarize or link to the discussion if others seem interested in the\n  improvement.\n* Wish: This is like a new feature, but for something you may not have the\n  background to flesh out yourself.\n\nBugs and tests have the highest priority and should be actionable.\n\n### Guidelines for reporting effective issues\n\n* *Search for duplicates*: Your issue may have already been reported. Have a\n  look, realizing that someone else might have worded the summary differently.\n\n  Also search the mailing lists, which may have information about your problem\n  and how to work around it. Don't file an issue for something that has already\n  been discussed and resolved on a mailing list, unless you strongly disagree\n  with the resolution *and* are willing to help take the issue forward.\n\n  * *Discuss in public*: Use the mailing lists to discuss what you've discovered\n    and see if there is something you've missed. Avoid using back channels, so\n    that you benefit from the experience and expertise of the project as a whole.\n  * *Don't file on behalf of others*: You might not have all the context, and you\n    don't have as much motivation to see it through as the person who is actually\n    experiencing the bug. It's more helpful in the long term to encourage others\n    to file their own issues. Point them to this material and offer to help out\n    the first time or two.\n  * *Write a good summary*: A good summary includes information about the problem,\n    the impact on the user or developer, and the area of the code.\n    * Good: `Address new license dependencies from hadoop3-alpha4`\n    * Room for improvement: `Canary is broken`\n      If you write a bad title, someone else will rewrite it for you. This is time\n      they could have spent working on the issue instead.\n  * *Give context in the description*: It can be good to think of this in multiple\n    parts:\n    * What happens or doesn't happen?\n    * How does it impact you?\n    * How can someone else reproduce it?\n    * What would \"fixed\" look like?\\\n      You don't need to know the answers for all of these, but give as much\n      information as you can. If you can provide technical information, such as a\n      Git commit SHA that you think might have caused the issue or a build failure\n      on builds.apache.org where you think the issue first showed up, share that\n      info.\n  * **Fill in all relevant fields**: These fields help us filter, categorize, and\n    find things.\n  * **One bug, one issue, one patch**: To help with back-porting, don't split issues\n    or fixes among multiple bugs.\n  * **Add value if you can**: Filing issues is great, even if you don't know how to\n    fix them. But providing as much information as possible, being willing to\n    triage and answer questions, and being willing to test potential fixes is even\n    better! We want to fix your issue as quickly as you want it to be fixed.\n  * **Don't be upset if we don't fix it**: Time and resources are finite. In some\n    cases, we may not be able to (or might choose not to) fix an issue, especially\n    if it is an edge case or there is a workaround. Even if it doesn't get fixed,\n    the JIRA is a public record of it, and will help others out if they run into\n    a similar issue in the future.\n\n### Working on an issue\n\nTo check for existing issues which you can tackle as a beginner, search for [issues in JIRA tagged with the label 'beginner'](https://issues.apache.org/jira/issues/?jql=project%20%3D%20HBASE%20AND%20labels%20in%20\\(beginner\\)%20AND%20status%20in%20\\(Open%2C%20%22In%20Progress%22%2C%20Reopened\\)).\n\nJIRA Priorites:\n\n* **Blocker**: Should only be used if the issue WILL cause data loss or cluster instability reliably.\n* **Critical**: The issue described can cause data loss or cluster instability in some cases.\n* **Major**: Important but not tragic issues, like updates to the client API that will add a lot of much-needed functionality or significant bugs that need to be fixed but that don't cause data loss.\n* **Minor**: Useful enhancements and annoying but not damaging bugs.\n* **Trivial**: Useful enhancements but generally cosmetic.\n\nCode Blocks in Jira Comments:\n\nA commonly used macro in Jira is `{code}`. Everything inside the tags is preformatted, as in this example.\n\n```text\n{code}\ncode snippet\n{code}\n```\n\n## Apache HBase Repositories\n\nApache HBase consists of multiple repositories which are hosted on [Apache GitBox](https://gitbox.apache.org/).\nThese are the following:\n\n* [hbase](https://gitbox.apache.org/repos/asf?p=hbase.git) - main Apache HBase repository\n* [hbase-connectors](https://gitbox.apache.org/repos/asf?p=hbase-connectors.git) - connectors to Apache Kafka and Apache Spark\n* [hbase-operator-tools](https://gitbox.apache.org/repos/asf?p=hbase-operator-tools.git) - operability and supportability tools, such as [HBase HBCK2](/docs/operational-management/tools#hbase-hbck2)\n* [hbase-site](https://gitbox.apache.org/repos/asf?p=hbase-site.git) - hbase.apache.org website\n* [hbase-thirdparty](https://gitbox.apache.org/repos/asf?p=hbase-thirdparty.git) - relocated versions of popular third-party libraries\n\n## IDEs\n\n## Eclipse\n\n### Code Formatting\n\nUnder the *dev-support/* folder, you will find *hbase\\_eclipse\\_formatter.xml*.\nWe encourage you to have this formatter in place in eclipse when editing HBase code.\n\nGo to `Preferences->Java->Code Style->Formatter->Import` to load the xml file.\nGo to `Preferences->Java->Editor->Save Actions`, and make sure 'Format source code' and 'Format\nedited lines' is selected.\n\nIn addition to the automatic formatting, make sure you follow the style guidelines explained in\n[Code Formatting Conventions](/docs/building-and-developing/developer-guidelines#code-formatting-conventions).\n\n### Eclipse Git Plugin\n\nIf you cloned the project via git, download and install the Git plugin (EGit). Attach to your local git repo (via the Git Repositories window) and you'll be able to see file revision history, generate patches, etc.\n\n### HBase Project Setup in Eclipse using `m2eclipse`\n\nThe easiest way is to use the `m2eclipse` plugin for Eclipse.\nEclipse Indigo or newer includes +m2eclipse+, or you can download it from [http://www.eclipse.org/m2e/](http://www.eclipse.org/m2e/). It provides Maven integration for Eclipse, and even lets you use the direct Maven commands from within Eclipse to compile and test your project.\n\nTo import the project, click and select the HBase root directory. `m2eclipse` locates all the hbase modules for you.\n\nIf you install `m2eclipse` and import HBase in your workspace, do the following to fix your eclipse Build Path.\n\n* Remove *target* folder\n* Add *target/generated-sources/java* folder.\n* Remove from your Build Path the exclusions on the *src/main/resources* and *src/test/resources* to avoid error message in the console, such as the following:\n  ```text\n  Failed to execute goal\n  org.apache.maven.plugins:maven-antrun-plugin:1.6:run (default) on project hbase:\n  'An Ant BuildException has occurred: Replace: source file .../target/classes/hbase-default.xml\n  doesn't exist\n  ```\n  This will also reduce the eclipse build cycles and make your life easier when developing.\n\n### HBase Project Setup in Eclipse Using the Command Line\n\nInstead of using `m2eclipse`, you can generate the Eclipse files from the command line.\n\n* First, run the following command, which builds HBase.\n  You only need to do this once.\n\n  ```bash\n  mvn clean install -DskipTests\n  ```\n\n* Close Eclipse, and execute the following command from the terminal, in your local HBase project directory, to generate new *.project* and *.classpath* files.\n\n  ```bash\n  mvn eclipse:eclipse\n  ```\n\n* Reopen Eclipse and import the *.project* file in the HBase directory to a workspace.\n\n### Maven Classpath Variable\n\nThe `$M2_REPO` classpath variable needs to be set up for the project.\nThis needs to be set to your local Maven repository, which is usually *\\~/.m2/repository*\n\nIf this classpath variable is not configured, you will see compile errors in Eclipse like this:\n\n```text\nDescription        Resource        Path        Location        Type\nThe project cannot be built until build path errors are resolved        hbase                Unknown        Java Problem\nUnbound classpath variable: 'M2_REPO/asm/asm/3.1/asm-3.1.jar' in project 'hbase'        hbase                Build path        Build Path Problem\nUnbound classpath variable: 'M2_REPO/com/google/guava/guava/r09/guava-r09.jar' in project 'hbase'        hbase                Build path        Build Path Problem\nUnbound classpath variable: 'M2_REPO/com/google/protobuf/protobuf-java/2.3.0/protobuf-java-2.3.0.jar' in project 'hbase'        hbase                Build path        Build Path Problem Unbound classpath variable:\n```\n\n### Eclipse Known Issues\n\nEclipse will currently complain about *Bytes.java*.\nIt is not possible to turn these errors off.\n\n```text\nDescription        Resource        Path        Location        Type\nAccess restriction: The method arrayBaseOffset(Class) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar        Bytes.java        /hbase/src/main/java/org/apache/hadoop/hbase/util        line 1061        Java Problem\nAccess restriction: The method arrayIndexScale(Class) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar        Bytes.java        /hbase/src/main/java/org/apache/hadoop/hbase/util        line 1064        Java Problem\nAccess restriction: The method getLong(Object, long) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar        Bytes.java        /hbase/src/main/java/org/apache/hadoop/hbase/util        line 1111        Java Problem\n```\n\n### Eclipse - More Information\n\nFor additional information on setting up Eclipse for HBase development on Windows, see [Michael Morello's blog](http://michaelmorello.blogspot.com/2011/09/hbase-subversion-eclipse-windows.html) on the topic.\n\n## IntelliJ IDEA\n\nA functional development environment can be setup around an IntelliJ IDEA installation that has the\nplugins necessary for building Java projects with Maven.\n\n* Use either File > New > \"Project from Existing Sources...\" or \"Project From Version Control..\"\n* Depending on your version of IntelliJ, you may need to choose Maven as the \"project\" or \"model\"\n  type.\n\nThe following plugins are recommended:\n\n* Maven, bundled. This allows IntelliJ to resolve dependencies and recognize the project structure.\n* EditorConfig, bundled. This will apply project whitespace settings found in the\n  `.editorconfig` file available on branches with\n  [HBASE-23234](https://issues.apache.org/jira/browse/HBASE-23234) or later.\n* [Checkstyle-IDEA](https://plugins.jetbrains.com/plugin/1065-checkstyle-idea/). Configure this\n  against the configuration file found under `hbase-checkstyle/src/main/resources/hbase/checkstyle.xml`\n  (If the Intellij checkstyle plugin complains parsing the volunteered hbase `checkstyle.xml`, make\n  sure the plugin's `version` popup menu matches the hbase checkstyle version. Find the current\n  checkstyle version as a property in `pom.xml`.\n  This plugin will highlight style errors in the IDE, so you can fix them before they get flagged during the\n  pre-commit process.\n* [Protobuf Support](https://plugins.jetbrains.com/plugin/8277-protobuf-support/). HBase uses\n  [Protocol Buffers](https://developers.google.com/protocol-buffers/) in a number of places where\n  serialization is required. This plugin is helpful when editing these object definitions.\n* [MDX](https://plugins.jetbrains.com/plugin/14944-mdx). HBase uses\n  [MDX](https://mdxjs.com) (just extended markdown) for building it's project documentation. This plugin is helpful\n  when editing this book.\n\n## Other IDEs\n\nIf you'd have another environment with which you'd like to develop on HBase, please consider\ndocumenting your setup process here.\n\n## Building Apache HBase\n\n## Basic Compile\n\nHBase is compiled using Maven. You must use at least Maven 3.0.4. To check your Maven version, run\nthe command `mvn -version`.\n\n### JDK Version Requirements\n\nHBase has Java version compiler requirements that vary by release branch. At compilation time,\nHBase has the same version requirements as it does for runtime. See [Java](/docs/configuration/basic-prerequisites#configuration-basic-prerequisites-java) for a complete\nsupport matrix of Java version by HBase version.\n\n### Maven Build Commands\n\nAll commands are executed from the local HBase project directory.\n\n#### Package\n\nThe simplest command to compile HBase from its java source code is to use the `package` target, which builds JARs with the compiled files.\n\n```bash\nmvn package -DskipTests\n```\n\nOr, to clean up before compiling:\n\n```bash\nmvn clean package -DskipTests\n```\n\nWith Eclipse set up as explained above in [Eclipse](/docs/building-and-developing#eclipse), you can also use the **Build** command in Eclipse.\nTo create the full installable HBase package takes a little bit more work, so read on.\n\n#### Compile\n\nThe `compile` target does not create the JARs with the compiled files.\n\n```bash\nmvn compile\n```\n\n```bash\nmvn clean compile\n```\n\n#### Install\n\nTo install the JARs in your *\\~/.m2/* directory, use the `install` target.\n\n```bash\nmvn install\n```\n\n```bash\nmvn clean install\n```\n\n```bash\nmvn clean install -DskipTests\n```\n\n#### Building HBase 2.x on Apple Silicon\n\nBuilding a non-master branch requires protoc 2.5.0 binary which is not available for Apple Silicon.\nHBASE-27741 added a workaround to the build to fall back to osx-x86\\_64 version of protoc automatically by `apple-silicon-workaround` Maven profile.\nThe intention is that this change will permit the build to proceed with the x86 version of `protoc`, making use of the Rosetta instruction translation service built into the OS.\nIf you'd like to provide and make use of your own aarch\\_64 `protoc`, you can disable this profile on the command line by adding `-P'!apple-silicon-workaround'`, or through configuration in your `settings.xml`.\n\nYou can use the following commands to build protoc on your Apple Silicon machine.\n\n```bash\ncurl -sSL https://github.com/protocolbuffers/protobuf/releases/download/v2.5.0/protobuf-2.5.0.tar.gz | tar zx -\ncd protobuf-2.5.0\ncurl -L -O https://gist.githubusercontent.com/liusheng/64aee1b27de037f8b9ccf1873b82c413/raw/118c2fce733a9a62a03281753572a45b6efb8639/protobuf-2.5.0-arm64.patch\npatch -p1 < protobuf-2.5.0-arm64.patch\n./configure --disable-shared\nmake\nmvn install:install-file -DgroupId=com.google.protobuf -DartifactId=protoc -Dversion=2.5.0 -Dclassifier=osx-aarch_64 -Dpackaging=exe -Dfile=src/protoc\n```\n\n### Running all or individual Unit Tests\n\nSee the [Running tests](/docs/building-and-developing/tests#running-tests) section in [Unit Tests](/docs/building-and-developing/tests#building-and-developing-unit-tests)\n\n### Building against various Hadoop versions\n\nHBase supports building against Apache Hadoop versions: 2.y and 3.y (early release artifacts).\nExactly which version of Hadoop is used by default varies by release branch. See the section\n[Hadoop](/docs/configuration/basic-prerequisites#hadoop) for the complete breakdown of supported Hadoop version by HBase release.\n\nThe mechanism for selecting a Hadoop version at build time is identical across all releases. Which\nversion of Hadoop is default varies. We manage Hadoop major version selection by way of Maven\nprofiles. Due to the peculiarities of Maven profile mutual exclusion, the profile that builds\nagainst a particular Hadoop version is activated by setting a property, *not* the usual profile\nactivation. Hadoop version profile activation is summarized by the following table.\n\n#### Hadoop Profile Activation by HBase Release\n\n|            | Hadoop2 Activation  | Hadoop3 Activation     |\n| ---------- | ------------------- | ---------------------- |\n| HBase 1.3+ | *active by default* | `-Dhadoop.profile=3.0` |\n| HBase 3.0+ | *not supported*     | *active by default*    |\n\n<Callout type=\"warn\">\n  Please note that where a profile is active by default, `hadoop.profile` must NOT be provided.\n</Callout>\n\nOnce the Hadoop major version profile is activated, the exact Hadoop version can be\nspecified by overriding the appropriate property value. For Hadoop2 versions, the property name\nis `hadoop-two.version`. With Hadoop3 versions, the property name is `hadoop-three.version`.\n\n#### Example 1: Building HBase 1.7 against Hadoop 2.10.0\n\nFor example, to build HBase 1.7 against Hadoop 2.10.0, the profile is set for Hadoop2 by default,\nso only `hadoop-two.version` must be specified:\n\n```bash\ngit checkout branch-1\nmvn -Dhadoop-two.version=2.10.0 ...\n```\n\n#### Example 2: Building HBase 2.3 or 2.4 against Hadoop 3.4.0-SNAPSHOT\n\nThis is how a developer might check the compatibility of HBase 2.3 or 2.4 against an unreleased\nHadoop version (currently 3.4). Both the Hadoop3 profile and version must be specified:\n\n```bash\ngit checkout branch-2.4\nmvn -Dhadoop.profile=3.0 -Dhadoop-three.version=3.4.0-SNAPSHOT ...\n```\n\n#### Example 3: Building HBase 3.0 against Hadoop 3.4.0-SNAPSHOT\n\nThe same developer might want also to check the development version of HBase (currently 3.0)\nagainst the development version of Hadoop (currently 3.4). In this case, the Hadoop3 profile is\nactive by default, so only `hadoop-three.version` must be specified:\n\n```bash\ngit checkout master\nmvn -Dhadoop-three.version=3.4.0-SNAPSHOT ...\n```\n\n### Building with JDK11 and Hadoop3\n\nHBase manages JDK-specific build settings using Maven profiles. The profile appropriate to the JDK\nin use is automatically activated. Building and running on JDK8 supports both Hadoop2 and Hadoop3.\nFor JDK11, only Hadoop3 is supported. Thus, the Hadoop3 profile must be active when building on\nJDK11, and the artifacts used when running HBase on JDK11 must be compiled against Hadoop3.\nFurthermore, the JDK11 profile requires a minimum Hadoop version of 3.2.0. This value is specified\nby the JDK11 profile, but it can be overridden using the `hadoop-three.version` property as normal.\nFor details on Hadoop profile activation by HBase branch, see\n[Building against various Hadoop versions](/docs/building-and-developing/building#building-against-various-hadoop-versions). See [Java](/docs/configuration/basic-prerequisites#configuration-basic-prerequisites-java) for a complete\nsupport matrix of Java version by HBase version.\n\n#### Example 1: Building HBase 2.3 or 2.4 with JDK11\n\nTo build HBase 2.3 or 2.4 with JDK11, the Hadoop3 profile must be activated explicitly.\n\n```bash\ngit checkout branch-2.4\nJAVA_HOME=/usr/lib/jvm/java-11 mvn -Dhadoop.profile=3.0 ...\n```\n\n#### Example 2: Building HBase 3.0 with JDK11\n\nFor HBase 3.0, the Hadoop3 profile is active by default, no additional properties need be\nspecified.\n\n```bash\ngit checkout master\nJAVA_HOME=/usr/lib/jvm/java-11 mvn ...\n```\n\n### Building and testing in an IDE with JDK11 and Hadoop3\n\nContinuing the discussion from the [earlier section](/docs/building-and-developing/building#building-with-jdk11-and-hadoop3), building and\ntesting with JDK11 and Hadoop3 within an IDE may require additional configuration. Specifically,\nmake sure the JVM version used by the IDE is a JDK11, the active JDK Maven profile is for JDK11,\nand the Maven profile for JDK8 is NOT active. Likewise, ensure the Hadoop3 Maven profile is active\nand the Hadoop2 Maven profile is NOT active.\n\n### Build Protobuf\n\nYou may need to change the protobuf definitions that reside in the *hbase-protocol* module or other modules.\n\nPrevious to hbase-2.0.0, protobuf definition files were sprinkled across all hbase modules but now all\nto do with protobuf must reside in the hbase-protocol module; we are trying to contain our protobuf\nuse so we can freely change versions without upsetting any downstream project use of protobuf.\n\nThe protobuf files are located in *hbase-protocol/src/main/protobuf*.\nFor the change to be effective, you will need to regenerate the classes.\n\n```bash\nmvn package -pl hbase-protocol -am\n```\n\nSimilarly, protobuf definitions for internal use are located in the *hbase-protocol-shaded* module.\n\n```bash\nmvn package -pl hbase-protocol-shaded -am\n```\n\nTypically, protobuf code generation is done using the native `protoc` binary. In our build we use a maven plugin for\nconvenience; however, the plugin may not be able to retrieve appropriate binaries for all platforms. If you find yourself\non a platform where protoc fails, you will have to compile protoc from source, and run it independent of our maven build.\nYou can disable the inline code generation by specifying `-Dprotoc.skip` in your maven arguments, allowing your build to proceed further.\n\n<Callout type=\"info\">\n  If you need to manually generate your protobuf files, you should not use `clean` in subsequent\n  maven calls, as that will delete the newly generated files.\n</Callout>\n\nRead the *hbase-protocol/README.txt* for more details\n\n### Build Thrift\n\nYou may need to change the thrift definitions that reside in the *hbase-thrift* module or other modules.\n\nThe thrift files are located in *hbase-thrift/src/main/resources*.\nFor the change to be effective, you will need to regenerate the classes.\nYou can use maven profile `compile-thrift` to do this.\n\n```bash\nmvn compile -Pcompile-thrift\n```\n\nYou may also want to define `thrift.path` for the thrift binary, using the following command:\n\n```bash\nmvn compile -Pcompile-thrift -Dthrift.path=/opt/local/bin/thrift\n```\n\n### Build a Tarball\n\nYou can build a tarball without going through the release process described in [Releasing Apache HBase](/docs/building-and-developing/releasing), by running the following command:\n\n```bash\nmvn -DskipTests clean install && mvn -DskipTests package assembly:single\n```\n\nThe distribution tarball is built in `hbase-assembly/target/hbase-<version>-bin.tar.gz`.\n\nYou can install or deploy the tarball by having the assembly:single goal before install or deploy in the maven command:\n\n```bash\nmvn -DskipTests package assembly:single install\n```\n\n```bash\nmvn -DskipTests package assembly:single deploy\n```\n\n### Build Gotchas\n\n#### Maven Site failure\n\nIf you see `Unable to find resource 'VM_global_library.vm'`, ignore it.\nIt's not an error.\nIt is [officially ugly](https://issues.apache.org/jira/browse/MSITE-286) though.\n\n## Build On Linux Aarch64\n\nHBase runs on both Windows and UNIX-like systems, and it should run on any platform\nthat runs a supported version of Java. This should include JVMs on x86\\_64 and aarch64.\nThe documentation below describes how to build hbase on aarch64 platform.\n\n### Set Environment Variables\n\nManually install Java and Maven on aarch64 servers if they are not installed,\nand set environment variables. For example:\n\n```bash\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-arm64\nexport MAVEN_HOME=/opt/maven\nexport PATH=${MAVEN_HOME}/bin:${JAVA_HOME}/bin:${PATH}\n```\n\n### Use Protobuf Supported On Aarch64\n\nNow HBase uses protobuf of two versions. Version '3.11.4' of protobuf that hbase uses\ninternally and version '2.5.0' as external usage.\nPackage protoc-2.5.0 does not work on aarch64 platform, we should add maven\nprofile '-Paarch64' when building. It downloads protoc-2.5.0 package from maven\nrepository which we made on aarch64 platform locally.\n\n```bash\nmvn clean install -Paarch64 -DskipTests\n```\n\n<Callout type=\"info\">\n  Protobuf is released with aarch64 protoc since version '3.5.0', and we are planning to upgrade\n  protobuf later, then we don't have to add the profile '-Paarch64' anymore.\n</Callout>\n\n## Releasing Apache HBase\n\n<Callout type=\"info\" title=\"Building against HBase 1.x\">\n  See old refguides for how to build HBase 1.x. The below is for building hbase2.\n</Callout>\n\n## Making a Release Candidate\n\nOnly committers can make releases of hbase artifacts.\n\n**Before You Begin**\n\nCheck to be sure recent builds have been passing for the branch from where you\nare going to take your release. You should also have tried recent branch tips\nout on a cluster under load, perhaps by running the `hbase-it` integration test\nsuite for a few hours to 'burn in' the near-candidate bits.\n\nYou will need a published signing key added to the hbase\n[KEYS](https://dist.apache.org/repos/dist/release/hbase/KEYS) file.\n(For how to add a KEY, see *Step 1.* in [How To Release](https://cwiki.apache.org/confluence/display/HADOOP2/HowToRelease),\nthe Hadoop version of this document).\n\nNext make sure JIRA is properly primed, that all issues targeted against\nthe prospective release have been resolved and are present in git on the\nparticular branch. If any outstanding issues, move them out of the release by\nadjusting the fix version to remove this pending release as a target.\nAny JIRA with a fix version that matches the release candidate\ntarget release will be included in the generated *CHANGES.md/RELEASENOTES.md*\nfiles that ship with the release so make sure JIRA is correct before you begin.\n\nAfter doing the above, you can move to the manufacture of an RC.\n\nBuilding an RC is involved so we've scripted it. The script builds in a Docker\ncontainer to ensure we have a consistent environment building. It will ask you\nfor passwords for apache and for your gpg signing key so it can sign and commit\non your behalf. The passwords are passed to gpg-agent in the container and\npurged along with the container when the build is done.\n\nThe script will:\n\n* Set version to the release version\n* Updates RELEASENOTES.md and CHANGES.md\n* Tag the RC\n* Set version to next SNAPSHOT version.\n* Builds, signs, and hashes all artifacts.\n* Generates the api compatibility report\n* Pushes release tgzs to the dev dir in a apache dist.\n* Pushes to repository.apache.org staging.\n* Creates vote email template.\n\nThe *dev-support/create-release/do-release-docker.sh* Release Candidate (RC)\nGenerating script is maintained in the master branch but can generate RCs\nfor any 2.x+ branch (The script does not work against branch-1). Check out\nand update the master branch when making RCs. See\n*dev-support/create-release/README.txt* for how to configure your\nenvironment and run the script.\n\n<Callout type=\"info\">\n  *dev-support/create-release/do-release-docker.sh* supercedes the previous *dev-support/make\\_rc.sh*\n  script. It is more comprehensive automating all steps, rather than a portion, building a RC.\n</Callout>\n\n### Release Candidate Procedure\n\nHere we outline the steps involved generating a Release Candidate, the steps\nautomated by the *dev-support/create-release/do-release-docker.sh* script\ndescribed in the previous section. Running these steps manually tends to\nbe error-prone so is not recommended. The below is informational only.\n\nThe process below makes use of various tools, mainly *git* and *maven*.\n\n<Callout type=\"info\" title=\"Specifying the Heap Space for Maven\">\n  You may run into OutOfMemoryErrors building, particularly building the site and\n  documentation. Up the heap for Maven by setting the `MAVEN_OPTS` variable.\n  You can prefix the variable to the Maven command, as in the following example:\n\n  ```bash\n  MAVEN_OPTS=\"-Xmx4g -XX:MaxPermSize=256m\" mvn package\n  ```\n\n  You could also set this in an environment variable or alias in your shell.\n</Callout>\n\n<Steps>\n  <Step>\n    #### Example *\\~/.m2/settings.xml* File\n\n    Publishing to maven requires you sign the artifacts you want to upload.\n    For the build to sign them for you, you a properly configured *settings.xml*\n    in your local repository under *.m2*, such as the following.\n\n    ```xml\n    <settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0\n                          http://maven.apache.org/xsd/settings-1.0.0.xsd\">\n      <servers>\n        <!- To publish a snapshot of some part of Maven -->\n        <server>\n          <id>apache.snapshots.https</id>\n          <username>YOUR_APACHE_ID\n          </username>\n          <password>YOUR_APACHE_PASSWORD\n          </password>\n        </server>\n        <!-- To publish a website using Maven -->\n        <!-- To stage a release of some part of Maven -->\n        <server>\n          <id>apache.releases.https</id>\n          <username>YOUR_APACHE_ID\n          </username>\n          <password>YOUR_APACHE_PASSWORD\n          </password>\n        </server>\n      </servers>\n      <profiles>\n        <profile>\n          <id>apache-release</id>\n          <properties>\n        <gpg.keyname>YOUR_KEYNAME</gpg.keyname>\n        <!--Keyname is something like this ... 00A5F21E... do `gpg ——list-keys` to find it-->\n        <gpg.passphrase>YOUR_KEY_PASSWORD\n        </gpg.passphrase>\n          </properties>\n        </profile>\n      </profiles>\n    </settings>\n    ```\n  </Step>\n\n  <Step>\n    #### Update the *CHANGES.md* and *RELEASENOTES.md* files and the POM files.\n\n    Update *CHANGES.md* with the changes since the last release. Be careful with where you put\n    headings and license. Respect the instructions and warning you find in current\n    *CHANGES.md* and *RELEASENOTES.md* since these two files are processed by tooling that is\n    looking for particular string sequences. See [HBASE-21399](https://issues.apache.org/jira/browse/HBASE-21399)\n    for description on how to make use of yetus generating additions to\n    *CHANGES.md* and *RELEASENOTES.md* (RECOMMENDED!). Adding JIRA fixes, make sure the\n    URL to the JIRA points to the proper location which lists fixes for this release.\n\n    Next, adjust the version in all the POM files appropriately.\n    If you are making a release candidate, you must remove the `-SNAPSHOT` label from all versions\n    in all pom.xml files.\n    If you are running this receipe to publish a snapshot, you must keep the `-SNAPSHOT` suffix on the hbase version.\n    The [Versions Maven Plugin](http://www.mojohaus.org/versions-maven-plugin/) can be of use here.\n    To set a version in all the many poms of the hbase multi-module project, use a command like the following:\n\n    ```bash\n    $ mvn clean org.codehaus.mojo:versions-maven-plugin:2.5:set -DnewVersion=2.1.0-SNAPSHOT\u001a\n    ```\n\n    Make sure all versions in poms are changed! Checkin the *CHANGES.md*, *RELEASENOTES.md*, and\n    any maven version changes.\n  </Step>\n\n  <Step>\n    #### Update the documentation.\n\n    Update the documentation under *hbase-website/app/page/\\_docs/docs/\\_mdx/(multi-page)*.\n    This usually involves copying the latest from master branch and making version-particular\n    adjustments to suit this release candidate version. Commit your changes.\n  </Step>\n\n  <Step>\n    #### Clean the checkout dir\n\n    ```bash\n    $ mvn clean\n    $ git clean -f -x -d\n    ```\n  </Step>\n\n  <Step>\n    #### Run Apache-Rat\n\n    Check licenses are good\n\n    ```bash\n    $ mvn apache-rat:check\n    ```\n\n    If the above fails, check the rat log.\n\n    ```bash\n    $ grep 'Rat check' patchprocess/mvn_apache_rat.log\n    ```\n  </Step>\n\n  <Step>\n    #### Create a release tag.\n\n    Presuming you have run basic tests, the rat check, passes and all is\n    looking good, now is the time to tag the release candidate (You\n    always remove the tag if you need to redo). To tag, do\n    what follows substituting in the version appropriate to your build.\n    All tags should be signed tags; i.e. pass the *-s* option (See\n    [Signing Your Work](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work)\n    for how to set up your git environment for signing).\n\n    ```bash\n    $ git tag -s 2.0.0-alpha4-RC0 -m \"Tagging the 2.0.0-alpha4 first Releae Candidate (Candidates start at zero)\"\n    ```\n\n    Or, if you are making a release, tags should have a *rel/* prefix to ensure\n    they are preserved in the Apache repo as in:\n\n    ```bash\n    +$ git tag -s rel/2.0.0-alpha4 -m \"Tagging the 2.0.0-alpha4 Release\"\n    ```\n\n    Push the (specific) tag (only) so others have access.\n\n    ```bash\n    $ git push origin 2.0.0-alpha4-RC0\n    ```\n\n    For how to delete tags, see\n    [How to Delete a Tag](http://www.manikrathee.com/how-to-delete-a-tag-in-git.html). Covers\n    deleting tags that have not yet been pushed to the remote Apache\n    repo as well as delete of tags pushed to Apache.\n  </Step>\n\n  <Step>\n    #### Build the source tarball.\n\n    Now, build the source tarball. Lets presume we are building the source\n    tarball for the tag *2.0.0-alpha4-RC0* into */tmp/hbase-2.0.0-alpha4-RC0/*\n    (This step requires that the mvn and git clean steps described above have just been done).\n\n    ```bash\n    $ git archive --format=tar.gz --output=\"/tmp/hbase-2.0.0-alpha4-RC0/hbase-2.0.0-alpha4-src.tar.gz\" --prefix=\"hbase-2.0.0-alpha4/\" $git_tag\n    ```\n\n    Above we generate the hbase-2.0.0-alpha4-src.tar.gz tarball into the\n    */tmp/hbase-2.0.0-alpha4-RC0* build output directory (We don't want the *RC0* in the name or prefix.\n    These bits are currently a release candidate but if the VOTE passes, they will become the release so we do not taint\n    the artifact names with *RCX*).\n  </Step>\n\n  <Step>\n    #### Build the binary tarball.\n\n    Next, build the binary tarball. Add the `-Prelease` profile when building.\n    It runs the license apache-rat check among other rules that help ensure\n    all is wholesome. Do it in two steps.\n\n    First install into the local repository\n\n    ```bash\n    $ mvn clean install -DskipTests -Prelease\n    ```\n\n    Next, generate documentation and assemble the tarball. Be warned,\n    this next step can take a good while, a couple of hours generating site\n    documentation.\n\n    ```bash\n    $ mvn install -DskipTests site assembly:single -Prelease\n    ```\n\n    Otherwise, the build complains that hbase modules are not in the maven repository\n    when you try to do it all in one step, especially on a fresh repository.\n    It seems that you need the install goal in both steps.\n\n    Extract the generated tarball — you'll find it under\n    *hbase-assembly/target* and check it out.\n    Look at the documentation, see if it runs, etc.\n    If good, copy the tarball beside the source tarball in the\n    build output directory.\n  </Step>\n\n  <Step>\n    #### Deploy to the Maven Repository.\n\n    Next, deploy HBase to the Apache Maven repository. Add the\n    apache-release`profile when running the`mvn deploy\\` command.\n    This profile comes from the Apache parent pom referenced by our pom files.\n    It does signing of your artifacts published to Maven, as long as the\n    *settings.xml* is configured correctly, as described in [Example \\~/.m2/settings.xml File](/docs/building-and-developing/releasing#example-m2settingsxml-file).\n    This step depends on the local repository having been populate\n    by the just-previous bin tarball build.\n\n    ```bash\n    $ mvn deploy -DskipTests -Papache-release -Prelease\n    ```\n\n    This command copies all artifacts up to a temporary staging Apache mvn repository in an 'open' state.\n    More work needs to be done on these maven artifacts to make them generally available.\n\n    We do not release HBase tarball to the Apache Maven repository. To avoid deploying the tarball, do not\n    include the `assembly:single` goal in your `mvn deploy` command. Check the deployed artifacts as described in the next section.\n\n    <Callout type=\"info\" title=\"make_rc.sh\">\n      If you ran the old *dev-support/make\\_rc.sh* script, this is as far as it takes you. To finish the\n      release, take up the script from here on out.\n    </Callout>\n  </Step>\n\n  <Step>\n    #### Make the Release Candidate available.\n\n    The artifacts are in the maven repository in the staging area in the 'open' state.\n    While in this 'open' state you can check out what you've published to make sure all is good.\n    To do this, log in to Apache's Nexus at [repository.apache.org](https://repository.apache.org) using your Apache ID.\n    Find your artifacts in the staging repository. Click on 'Staging Repositories' and look for a new one ending in \"hbase\" with a status of 'Open', select it.\n    Use the tree view to expand the list of repository contents and inspect if the artifacts you expect are present. Check the POMs.\n    As long as the staging repo is open you can re-upload if something is missing or built incorrectly.\n\n    If something is seriously wrong and you would like to back out the upload, you can use the 'Drop' button to drop and delete the staging repository.\n    Sometimes the upload fails in the middle. This is another reason you might have to 'Drop' the upload from the staging repository.\n\n    If it checks out, close the repo using the 'Close' button. The repository must be closed before a public URL to it becomes available. It may take a few minutes for the repository to close. Once complete you'll see a public URL to the repository in the Nexus UI. You may also receive an email with the URL. Provide the URL to the temporary staging repository in the email that announces the release candidate.\n    (Folks will need to add this repo URL to their local poms or to their local *settings.xml* file to pull the published release candidate artifacts.)\n\n    When the release vote concludes successfully, return here and click the 'Release' button to release the artifacts to central. The release process will automatically drop and delete the staging repository.\n\n    <Callout type=\"info\" title=\"hbase-downstreamer\">\n      See the [hbase-downstreamer](https://github.com/saintstack/hbase-downstreamer) test for a simple\n      example of a project that is downstream of HBase an depends on it. Check it out and run its simple\n      test to make sure maven artifacts are properly deployed to the maven repository. Be sure to edit\n      the pom to point to the proper staging repository. Make sure you are pulling from the repository\n      when tests run and that you are not getting from your local repository, by either passing the `-U`\n      flag or deleting your local repo content and check maven is pulling from remote out of the staging\n      repository.\n    </Callout>\n\n    See [Publishing Maven Artifacts](https://www.apache.org/dev/publishing-maven-artifacts.html) for some pointers on this maven staging process.\n\n    If the HBase version ends in `-SNAPSHOT`, the artifacts go elsewhere.\n    They are put into the Apache snapshots repository directly and are immediately available.\n    Making a SNAPSHOT release, this is what you want to happen.\n\n    At this stage, you have two tarballs in your 'build output directory' and a set of artifacts\n    in a staging area of the maven repository, in the 'closed' state.\n    Next sign, fingerprint and then 'stage' your release candiate build output directory via svnpubsub by committing\n    your directory to [The dev distribution directory](https://dist.apache.org/repos/dist/dev/hbase/)\n    (See comments on [HBASE-10554 Please delete old releases from mirroring system](https://issues.apache.org/jira/browse/HBASE-10554)\n    but in essence it is an svn checkout of [dev/hbase](https://dist.apache.org/repos/dist/dev/hbase) — releases are at\n    [release/hbase](https://dist.apache.org/repos/dist/release/hbase)). In the *version directory* run the following commands:\n\n    ```bash\n    $ for i in *.tar.gz; do echo $i; gpg --print-md MD5 $i > $i.md5 ; done\n    $ for i in *.tar.gz; do echo $i; gpg --print-md SHA512 $i > $i.sha ; done\n    $ for i in *.tar.gz; do echo $i; gpg --armor --output $i.asc --detach-sig $i  ; done\n    $ cd ..\n    # Presuming our 'build output directory' is named 0.96.0RC0, copy it to the svn checkout of the dist dev dir\n    # in this case named hbase.dist.dev.svn\n    $ cd /Users/stack/checkouts/hbase.dist.dev.svn\n    $ svn info\n    Path: .\n    Working Copy Root Path: /Users/stack/checkouts/hbase.dist.dev.svn\n    URL: https://dist.apache.org/repos/dist/dev/hbase\n    Repository Root: https://dist.apache.org/repos/dist\n    Repository UUID: 0d268c88-bc11-4956-87df-91683dc98e59\n    Revision: 15087\n    Node Kind: directory\n    Schedule: normal\n    Last Changed Author: ndimiduk\n    Last Changed Rev: 15045\n    Last Changed Date: 2016-08-28 11:13:36 -0700 (Sun, 28 Aug 2016)\n    $ mv 0.96.0RC0 /Users/stack/checkouts/hbase.dist.dev.svn\n    $ svn add 0.96.0RC0\n    $ svn commit ...\n    ```\n\n    Ensure it actually gets published by checking [https://dist.apache.org/repos/dist/dev/hbase/](https://dist.apache.org/repos/dist/dev/hbase/).\n\n    Announce the release candidate on the mailing list and call a vote.\n  </Step>\n</Steps>\n\n### Publishing a SNAPSHOT to maven\n\nMake sure your *settings.xml* is set up properly (see [Example \\~/.m2/settings.xml File](/docs/building-and-developing/releasing#example-m2settingsxml-file)).\nMake sure the hbase version includes `-SNAPSHOT` as a suffix.\nFollowing is an example of publishing SNAPSHOTS of a release that had an hbase version of 0.96.0 in its poms.\n\n```bash\n$ mvn clean install -DskipTests  javadoc:aggregate site assembly:single -Prelease\n$ mvn -DskipTests  deploy -Papache-release\n```\n\nThe *make\\_rc.sh* script mentioned above (see [Making a Release Candidate](/docs/building-and-developing/releasing#making-a-release-candidate)) can help you publish `SNAPSHOTS`.\nMake sure your `hbase.version` has a `-SNAPSHOT` suffix before running the script.\nIt will put a snapshot up into the apache snapshot repository for you.\n\n## Voting on Release Candidates\n\nEveryone is encouraged to try and vote on HBase release candidates.\nOnly the votes of PMC members are binding.\nPMC members, please read this WIP doc on policy voting for a release candidate, [Release Policy](https://github.com/rectang/asfrelease/blob/master/release.md).\n\n> Before casting +1 binding votes, individuals are required to\n> download the signed source code package onto their own hardware, compile it as\n> provided, and test the resulting executable on their own platform, along with also\n> validating cryptographic signatures and verifying that the package meets the\n> requirements of the ASF policy on releases.\n\nRegards the latter, run `mvn apache-rat:check` to verify all files are suitably licensed.\nSee [HBase, mail # dev - On recent discussion clarifying ASF release policy](https://mail-archives.apache.org/mod_mbox/hbase-dev/201406.mbox/%3CCA%2BRK%3D_B8EP0JMFV%2Bdt-k1g%3DBmedzyq2z1GSqrnMMiH6%3DcdoiAA%40mail.gmail.com%3E)\nfor how we arrived at this process.\n\nTo help with the release verification, please follow the guideline below and vote based on the your verification.\n\n## Baseline Verifications for Voting Release Candidates\n\nAlthough contributors have their own checklist for verifications, the following items are usually used for voting on release candidates.\n\n* CHANGES.md if any\n\n* RELEASENOTES.md (release notes) if any\n\n* Generated API compatibility report\n  * For what should be compatible please refer the [versioning guideline](/docs/upgrading/version-number), especially for items with marked as high severity\n\n* Use `hbase-vote.sh` to perform sanity checks for checksum, signatures, files are licensed, built from source, and unit tests.\n\n  * `hbase-vote.sh` shell script is available under `dev-support` directory of HBase source. Following are the usage details.\n\n  ```bash\n  ./dev-support/hbase-vote.sh -h\n  hbase-vote. A script for standard vote which verifies the following items\n  1. Checksum of sources and binaries\n  2. Signature of sources and binaries\n  3. Rat check\n  4. Built from source\n  5. Unit tests\n\n  Usage: hbase-vote.sh -s | --source <url> [-k | --key <signature>] [-f | --keys-file-url <url>] [-o | --output-dir </path/to/use>] [-P runSmallTests] [-D property[=value]]\n        hbase-vote.sh -h | --help\n\n    -h | --help                   Show this screen.\n    -s | --source '<url>'         A URL pointing to the release candidate sources and binaries\n                                  e.g. https://dist.apache.org/repos/dist/dev/hbase/hbase-<version>RC0/\n    -k | --key '<signature>'      A signature of the public key, e.g. 9AD2AE49\n    -f | --keys-file-url '<url>'   the URL of the key file, default is\n                                  https://downloads.apache.org/hbase/KEYS\n    -o | --output-dir '</path>'   directory which has the stdout and stderr of each verification target\n    -P |                          list of maven profiles to activate for test UT/IT, i.e. <-P runSmallTests> Defaults to runAllTests\n    -D |                          list of maven properties to set for the mvn invocations, i.e. <-D hadoop.profile=3.0> Defaults to unset\n  ```\n\n* If you see any unit test failures, please call out the solo test result and whether it's part of flaky (nightly) tests dashboard, e.g. [dashboard of master branch](https://builds.apache.org/view/H-L/view/HBase/job/HBase-Find-Flaky-Tests/job/master/lastSuccessfulBuild/artifact/dashboard.html) (please change the test branch accordingly).\n\n## Additional Verifications for Voting Release Candidates\n\nOther than the common verifications, contributors may call out additional concerns, e.g. for a specific feature by running end to end tests on a distributed environment. This is optional and always encouraged.\n\n* Start a distributed HBase cluster and call out the test result of specific workload on cluster. e.g.\n  * Run basic table operations, e.g. `create/put/get/scan/flush/list/disable/drop`\n  * Run built-in tests, e.g. `LoadTestTool` (LTT) and `IntegrationTestBigLinkedList` (ITBLL)\n\n## Announcing Releases\n\nOnce an RC has passed successfully and the needed artifacts have been staged for disribution, you'll need to let everyone know about our shiny new release. It's not a requirement, but to make things easier for release managers we have a template you can start with. Be sure you replace \\_version\\_ and other markers with the relevant version numbers. You should manually verify all links before sending.\n\n```text\nThe HBase team is happy to announce the immediate availability of HBase _version_.\n\nApache HBase™ is an open-source, distributed, versioned, non-relational database.\nApache HBase gives you low latency random access to billions of rows with\nmillions of columns atop non-specialized hardware. To learn more about HBase,\nsee https://hbase.apache.org/.\n\nHBase _version_ is the _nth_ minor release in the HBase _major_.x line, which aims to\nimprove the stability and reliability of HBase. This release includes roughly\nXXX resolved issues not covered by previous _major_.x releases.\n\nNotable new features include:\n- List text descriptions of features that fit on one line\n- Including if JDK or Hadoop support versions changes\n- If the \"stable\" pointer changes, call that out\n- For those with obvious JIRA IDs, include them (HBASE-YYYYY)\n\nThe full list of issues can be found in the included CHANGES.md and RELEASENOTES.md,\nor via our issue tracker:\n\n    https://s.apache.org/hbase-_version_-jira\n\nTo download please follow the links and instructions on our website:\n\n    https://hbase.apache.org/downloads.html\n\n\nQuestion, comments, and problems are always welcome at: dev@hbase.apache.org.\n\nThanks to all who contributed and made this release possible.\n\nCheers,\nThe HBase Dev Team\n```\n\nYou should sent this message to the following lists: [dev@hbase.apache.org](mailto:dev@hbase.apache.org), [user@hbase.apache.org](mailto:user@hbase.apache.org), [announce@apache.org](mailto:announce@apache.org). If you'd like a spot check before sending, feel free to ask via jira or the dev list.\n\n## Generating the HBase Reference Guide\n\nThe manual is marked up using [MDX](https://mdxjs.com/) (just extended markdown).\nThen we render markdown into HTML content by using [Fumadocs](https://fumadocs.dev/).\nTo build run `mvn site` from the root or `hbase-website` directory.\nSee [appendix contributing to documentation](/docs/contributing-to-documentation) for more information on building the documentation.\n\n## Updating hbase.apache.org\n\n## Contributing to hbase.apache.org\n\nSee [appendix contributing to documentation](/docs/contributing-to-documentation) for more information on contributing to the documentation or website.\n\n## Publishing hbase.apache.org\n\nSee [Publishing the HBase Website and Documentation](/docs/contributing-to-documentation#publishing-the-hbase-website-and-documentation) for instructions on publishing the website and documentation.\n\n## Tests\n\nDevelopers, at a minimum, should familiarize themselves with the unit test detail; unit tests in HBase have a character not usually seen in other projects.\n\nThis information is about unit tests for HBase itself.\nFor developing unit tests for your HBase applications, see [Unit Testing HBase Applications](/docs/unit-testing).\n\n## Apache HBase Modules\n\nAs of 0.96, Apache HBase is split into multiple modules.\nThis creates \"interesting\" rules for how and where tests are written.\nIf you are writing code for `hbase-server`, see [Unit Tests](/docs/building-and-developing/tests#building-and-developing-unit-tests) for how to write your tests.\nThese tests can spin up a minicluster and will need to be categorized.\nFor any other module, for example `hbase-common`, the tests must be strict unit tests and just test the class under test - no use of the HBaseTestingUtility or minicluster is allowed (or even possible given the dependency tree).\n\nStarting from 3.0.0, HBaseTestingUtility is renamed to HBaseTestingUtil and marked as IA.Private. Of course the API is still the same.\n\n### Testing the HBase Shell\n\nThe HBase shell and its tests are predominantly written in jruby.\n\nIn order to make these tests run as a part of the standard build, there are a few JUnit test classes that take care of loading the jruby implemented tests and running them.\nThe tests were split into separate classes to accomodate class level timeouts (see [Unit Tests](/docs/building-and-developing/tests#building-and-developing-unit-tests) for specifics).\nYou can run all of these tests from the top level with:\n\n```bash\nmvn clean test -Dtest=Test*Shell\n```\n\nIf you have previously done a `mvn install`, then you can instruct maven to run only the tests in the hbase-shell module with:\n\n```bash\nmvn clean test -pl hbase-shell\n```\n\nAlternatively, you may limit the shell tests that run using the system variable `shell.test`.\nThis value should specify the ruby literal equivalent of a particular test case by name.\nFor example, the tests that cover the shell commands for altering tables are contained in the test case `AdminAlterTableTest` and you can run them with:\n\n```bash\nmvn clean test -pl hbase-shell -Dshell.test=/AdminAlterTableTest/\n```\n\nYou may also use a [Ruby Regular Expression\nliteral](https://docs.ruby-lang.org/en/master/syntax/literals_rdoc.html#label-Regexp+Literals) (in the `/pattern/` style) to select a set of test cases.\nYou can run all of the HBase admin related tests, including both the normal administration and the security administration, with the command:\n\n```bash\nmvn clean test -pl hbase-shell -Dshell.test=/.*Admin.*Test/\n```\n\nIn the event of a test failure, you can see details by examining the XML version of the surefire report results\n\n```bash\nvim hbase-shell/target/surefire-reports/TEST-org.apache.hadoop.hbase.client.TestShell.xml\n```\n\n### Running Tests in other Modules\n\nIf the module you are developing in has no other dependencies on other HBase modules, then you can cd into that module and just run:\n\n```bash\nmvn test\n```\n\nwhich will just run the tests IN THAT MODULE.\nIf there are other dependencies on other modules, then you will have run the command from the ROOT HBASE DIRECTORY.\nThis will run the tests in the other modules, unless you specify to skip the tests in that module.\nFor instance, to skip the tests in the hbase-server module, you would run:\n\n```bash\nmvn clean test -PskipServerTests\n```\n\nfrom the top level directory to run all the tests in modules other than hbase-server.\nNote that you can specify to skip tests in multiple modules as well as just for a single module.\nFor example, to skip the tests in `hbase-server` and `hbase-common`, you would run:\n\n```bash\nmvn clean test -PskipServerTests -PskipCommonTests\n```\n\nAlso, keep in mind that if you are running tests in the `hbase-server` module you will need to apply the maven profiles discussed in [Running tests](/docs/building-and-developing/tests#running-tests) to get the tests to run properly.\n\n## Unit Tests\n\nApache HBase unit tests must carry a Category annotation and\nas of `hbase-2.0.0`, must be stamped with the HBase `ClassRule`.\nHere is an example of what a Test Class looks like with a\nCategory and ClassRule included:\n\n```java\n...\n@Category(SmallTests.class)\npublic class TestHRegionInfo {\n  @ClassRule\n  public static final HBaseClassTestRule CLASS_RULE =\n      HBaseClassTestRule.forClass(TestHRegionInfo.class);\n\n  @Test\n  public void testCreateHRegionInfoName() throws Exception {\n    // ...\n  }\n}\n```\n\nHere the Test Class is `TestHRegionInfo`. The `CLASS_RULE` has\nthe same form in every test class only the `.class` you pass\nis that of the local test; i.e. in the TestTimeout Test Class, you'd\npass `TestTimeout.class` to the `CLASS_RULE` instead of the\n`TestHRegionInfo.class` we have above. The `CLASS_RULE`\nis where we'll enforce timeouts (currently set at a hard-limit of\nthirteen! minutes for all tests — 780 seconds) and other cross-unit test facility.\nThe test is in the `SmallTest` Category.\n\nCategories can be arbitrary and provided as a list but each test MUST\ncarry one from the following list of sizings: `small`, `medium`, `large`, and\n`integration`. The test sizing is designated using the JUnit\n[categories](https://github.com/junit-team/junit4/wiki/Categories): `SmallTests`, `MediumTests`, `LargeTests`, `IntegrationTests`.\nJUnit Categories are denoted using java annotations (a special unit test looks\nfor the presence of the @Category annotation in all unit tess and will fail if it\nfinds a test suite missing a sizing marking).\n\nThe first three categories, `small`, `medium`, and `large`, are for test cases which run when you\ntype `$ mvn test`.\nIn other words, these three categorizations are for HBase unit tests.\nThe `integration` category is not for unit tests, but for integration tests.\nThese are normally run when you invoke `$ mvn verify`.\nIntegration tests are described in [Integration Tests](/docs/building-and-developing/tests#building-and-developing-integration-tests).\n\nKeep reading to figure which annotation of the set `small`, `medium`, and `large`\nto put on your new HBase test case.\n\n### Categorizing Tests\n\n#### Small Tests:\n\n*Small* test cases are executed in separate JVM and each test suite/test class should\nrun in 15 seconds or less; i.e. a [junit test fixture](https://en.wikipedia.org/wiki/JUnit), a java object made\nup of test methods, should finish in under 15 seconds, no matter how many or how few test methods\nit has. These test cases should not use a minicluster as a minicluster starts many services,\nmost unrelated to what is being tested.\n\n#### Medium Tests:\n\n*Medium* test cases are executed in separate JVM and individual test suites or test classes or in\njunit parlance, [test fixture](https://en.wikipedia.org/wiki/JUnit), should run in 50 seconds\nor less. These test cases can use a mini cluster. Since we start up a JVM per test fixture (and\noften a cluster too), be sure to make the startup pay by writing test fixtures that do a lot of\ntesting running tens of seconds perhaps combining test rather than spin up a jvm (and cluster)\nper test method; this practice will help w/ overall test times.\n\n#### Large Tests:\n\n*Large* test cases are everything else. They are typically large-scale tests, regression tests\nfor specific bugs, timeout tests, or performance tests. No large test suite can take longer than\nthirteen minutes. It will be killed as timed out. Cast your test as an Integration Test if it needs\nto run longer.\n\n#### Integration Tests:\n\n*Integration* tests are system level tests.\nSee [Integration Tests](/docs/building-and-developing/tests#building-and-developing-integration-tests) for more info.\nIf you invoke `$ mvn test` on integration tests, there is no timeout for the test.\n\n## Running tests\n\nThe state of tests on the hbase branches varies. Some branches keep good test hygiene and all tests pass\nreliably with perhaps an unlucky sporadic flakey test failure. On other branches, the case may be less so with\nfrequent flakies and even broken tests in need of attention that fail 100% of the time. Try and figure\nthe state of tests on the branch you are currently interested in; the current state of nightly\n[apache jenkins builds](https://builds.apache.org/view/H-L/view/HBase/job/HBase%20Nightly/) is a good\nplace to start. Tests on master branch are generally not in the best of condition as releases\nare less frequent off master. This can make it hard landing patches especially given our dictum that\npatches land on master branch first.\n\nThe full test suite can take from 5-6 hours on an anemic VM with 4 CPUs and minimal\nparallelism to 50 minutes or less on a linux machine with dozens of CPUs and plenty of\nRAM.\n\nWhen you go to run the full test suite, make sure you up the test runner user nproc\n(`ulimit -u` — make sure it > 6000 or more if more parallelism) and the number of\nopen files (`ulimit -n` — make sure it > 10240 or more) limits on your system.\nErrors because the test run hits\nlimits are often only opaquely related to the constraint. You can see the current\nuser settings by running `ulimit -a`.\n\n### Default: small and medium category tests\n\nRunning `mvn test` will execute all small tests in a single JVM (no fork) and then medium tests in a\nforked, separate JVM for each test instance (For definition of 'small' test and so on, see\n[Unit Tests](/docs/building-and-developing/tests#building-and-developing-unit-tests)). Medium tests are NOT executed if there is an error in a\nsmall test. Large tests are NOT executed.\n\n### Running all tests\n\nRunning `mvn test -P runAllTests` will execute small tests in a single JVM, then medium and large tests\nin a forked, separate JVM for each test. Medium and large tests are NOT executed if there is an error in\na small test.\n\n### Running a single test or all tests in a package\n\nTo run an individual test, e.g. `MyTest`, rum `mvn test -Dtest=MyTest` You can also pass multiple,\nindividual tests as a comma-delimited list:\n\n```bash\nmvn test  -Dtest=MyTest1,MyTest2,MyTest3\n```\n\nYou can also pass a package, which will run all tests under the package:\n\n```bash\nmvn test '-Dtest=org.apache.hadoop.hbase.client.*'\n```\n\nWhen `-Dtest` is specified, the `localTests` profile will be used.\nEach junit test is executed in a separate JVM (A fork per test class).\nThere is no parallelization when tests are running in this mode.\nYou will see a new message at the end of the -report: `\"[INFO] Tests are skipped\"`.\nIt's harmless. However, you need to make sure the sum of\n`Tests run:` in the `Results:` section of test reports matching the number of tests\nyou specified because no error will be reported when a non-existent test case is specified.\n\n### Other test invocation permutations\n\nRunning `mvn test -P runSmallTests` will execute \"small\" tests only, using a single JVM.\n\nRunning `mvn test -P runMediumTests` will execute \"medium\" tests only, launching a new JVM for each test-class.\n\nRunning `mvn test -P runLargeTests` will execute \"large\" tests only, launching a new JVM for each test-class.\n\nFor convenience, you can run `mvn test -P runDevTests` to execute both small and medium tests, using a single JVM.\n\n### Running tests faster\n\nBy default, `$ mvn test -P runAllTests` runs all tests using a quarter of the CPUs available on machine\nhosting the test run (see `surefire.firstPartForkCount` and `surefire.secondPartForkCount` in the top-level\nhbase `pom.xml` which default to 0.25C, or 1/4 of CPU count). Up these counts to get the build to run faster.\nYou can also have hbase modules\nrun their tests in parrallel when the dependency graph allows by passing `--threads=N` when you invoke\nmaven, where `N` is the amount of parallelism wanted.\nmaven, where `N` is the amount of *module* parallelism wanted.\n\nFor example, allowing that you want to use all cores on a machine to run tests,\nyou could start up the maven test run with:\n\n```bash\n$ x=\"1.0C\";  mvn -Dsurefire.firstPartForkCount=$x -Dsurefire.secondPartForkCount=$x test -PrunAllTests\n```\n\nIf a 32 core machine, you should see periods during which 32 forked jvms appear in your process listing each running unit tests.\nYour milage may vary. Dependent on hardware, overcommittment of CPU and/or memory can bring the test suite crashing down,\nusually complaining with a spew of test system exits and incomplete test report xml files. Start gently, with the default fork\nand move up gradually.\n\nAdding the `--threads=N`, maven will run N maven modules in parallel (when module inter-dependencies allow). Be aware, if you have\nset the forkcount to `1.0C`, and the `--threads` count to '2', the number of concurrent test runners can approach\n2 \\* CPU, a count likely to overcommit the host machine (with attendant test exits failures).\n\nYou will need \\~2.2GB of memory per forked JVM plus the memory used by maven itself (3-4G).\n\n#### RAM Disk\n\nTo increase the speed, you can as well use a ramdisk. 2-3G should be sufficient. Be sure to\ndelete the files between each test run. The typical way to configure a ramdisk on Linux is:\n\n```bash\n$ sudo mkdir /ram2G\nsudo mount -t tmpfs -o size=2048M tmpfs /ram2G\n```\n\nYou can then use it to run all HBase tests on 2.0 with the command:\n\n```bash\nmvn test -PrunAllTests -Dtest.build.data.basedirectory=/ram2G\n```\n\n### hbasetests.sh\n\nIt's also possible to use the script `hbasetests.sh`.\nThis script runs the medium and large tests in parallel with two maven instances, and provides a single report.\nThis script does not use the hbase version of surefire so no parallelization is being done other than the two maven instances the script sets up.\nIt must be executed from the directory which contains the *pom.xml*.\n\nFor example running `./dev-support/hbasetests.sh` will execute small and medium tests.\nRunning `./dev-support/hbasetests.sh runAllTests` will execute all tests.\nRunning `./dev-support/hbasetests.sh replayFailed` will rerun the failed tests a second time, in a separate jvm and without parallelisation.\n\n### Test Timeouts\n\nThe HBase unit test sizing Categorization timeouts are not strictly enforced.\n\nAny test that runs longer than ten minutes will be timedout/killed.\n\nAs of hbase-2.0.0, we have purged all per-test-method timeouts: i.e.\n\n```java\n...\n  @Test(timeout=30000)\n  public void testCreateHRegionInfoName() throws Exception {\n    // ...\n  }\n```\n\nThey are discouraged and don't make much sense given we are timing\nbase of how long the whole Test Fixture/Class/Suite takes and\nthat the variance in how long a test method takes varies wildly\ndependent upon context (loaded Apache Infrastructure versus\ndeveloper machine with nothing else running on it).\n\n### Test Resource Checker\n\nA custom Maven SureFire plugin listener checks a number of resources before and after each HBase unit test runs and logs its findings at the end of the test output files which can be found in *target/surefire-reports* per Maven module (Tests write test reports named for the test class into this directory.\nCheck the *\\*-out.txt* files). The resources counted are the number of threads, the number of file descriptors, etc.\nIf the number has increased, it adds a *LEAK?* comment in the logs.\nAs you can have an HBase instance running in the background, some threads can be deleted/created without any specific action in the test.\nHowever, if the test does not work as expected, or if the test should not impact these resources, it's worth checking these log lines `...hbase.ResourceChecker(157): before...` and `...hbase.ResourceChecker(157): after...`.\nFor example:\n\n```text\n2012-09-26 09:22:15,315 INFO [pool-1-thread-1]\nhbase.ResourceChecker(157): after:\nregionserver.TestColumnSeeking#testReseeking Thread=65 (was 65),\nOpenFileDescriptor=107 (was 107), MaxFileDescriptor=10240 (was 10240),\nConnectionCount=1 (was 1)\n```\n\n## Writing Tests\n\n### General rules\n\n* As much as possible, tests should be written as category small tests.\n* All tests must be written to support parallel execution on the same machine, hence they should not use shared resources as fixed ports or fixed file names.\n* Tests should not overlog.\n  More than 100 lines/second makes the logs complex to read and use i/o that are hence not available for the other tests.\n* Tests can be written with `HBaseTestingUtility`.\n  This class offers helper functions to create a temp directory and do the cleanup, or to start a cluster.\n\n### Categories and execution time\n\n* All tests must be categorized, if not they could be skipped.\n* All tests should be written to be as fast as possible.\n* See [Unit Tests](/docs/building-and-developing/tests#building-and-developing-unit-tests) for test case categories and corresponding timeouts.\n  This should ensure a good parallelization for people using it, and ease the analysis when the test fails.\n\n### Sleeps in tests\n\nWhenever possible, tests should not use `Thread.sleep`, but rather waiting for the real event they need.\nThis is faster and clearer for the reader.\nTests should not do a `Thread.sleep` without testing an ending condition.\nThis allows understanding what the test is waiting for.\nMoreover, the test will work whatever the machine performance is.\nSleep should be minimal to be as fast as possible.\nWaiting for a variable should be done in a 40ms sleep loop.\nWaiting for a socket operation should be done in a 200 ms sleep loop.\n\n### Tests using a cluster\n\nTests using a HRegion do not have to start a cluster: A region can use the local file system.\nStart/stopping a cluster cost around 10 seconds.\nThey should not be started per test method but per test class.\nStarted cluster must be shutdown using `HBaseTestingUtility#shutdownMiniCluster`, which cleans the directories.\nAs most as possible, tests should use the default settings for the cluster.\nWhen they don't, they should document it.\nThis will allow to share the cluster later.\n\n### Tests Skeleton Code\n\nHere is a test skeleton code with Categorization and a Category-based timeout rule to copy and paste and use as basis for test contribution.\n\n```java\n/**\n * Describe what this testcase tests. Talk about resources initialized in @BeforeClass (before\n * any test is run) and before each test is run, etc.\n */\n// Specify the category as explained in Unit Tests section.\n@Category(SmallTests.class)\npublic class TestExample {\n  // Replace the TestExample.class in the below with the name of your test fixture class.\n  private static final Log LOG = LogFactory.getLog(TestExample.class);\n\n  // Handy test rule that allows you subsequently get the name of the current method. See\n  // down in 'testExampleFoo()' where we use it to log current test's name.\n  @Rule public TestName testName = new TestName();\n\n  // The below rule does two things. It decides the timeout based on the category\n  // (small/medium/large) of the testcase. This @Rule requires that the full testcase runs\n  // within this timeout irrespective of individual test methods' times. The second\n  // feature is we'll dump in the log when the test is done a count of threads still\n  // running.\n  @Rule public static TestRule timeout = CategoryBasedTimeout.builder().\n    withTimeout(this.getClass()).withLookingForStuckThread(true).build();\n\n  @Before\n  public void setUp() throws Exception {\n  }\n\n  @After\n  public void tearDown() throws Exception {\n  }\n\n  @Test\n  public void testExampleFoo() {\n    LOG.info(\"Running test \" + testName.getMethodName());\n  }\n}\n```\n\n## Integration Tests\n\nHBase integration/system tests are tests that are beyond HBase unit tests.\nThey are generally long-lasting, sizeable (the test can be asked to 1M rows or 1B rows), targetable (they can take configuration that will point them at the ready-made cluster they are to run against; integration tests do not include cluster start/stop code), and verifying success, integration tests rely on public APIs only; they do not attempt to examine server internals asserting success/fail.\nIntegration tests are what you would run when you need to more elaborate proofing of a release candidate beyond what unit tests can do.\nThey are not generally run on the Apache Continuous Integration build server, however, some sites opt to run integration tests as a part of their continuous testing on an actual cluster.\n\nIntegration tests currently live under the *src/test* directory in the hbase-it submodule and will match the regex: **IntegrationTest*.java*.\nAll integration tests are also annotated with `@Category(IntegrationTests.class)`.\n\nIntegration tests can be run in two modes: using a mini cluster, or against an actual distributed cluster.\nMaven failsafe is used to run the tests using the mini cluster.\nIntegrationTestsDriver class is used for executing the tests against a distributed cluster.\nIntegration tests SHOULD NOT assume that they are running against a mini cluster, and SHOULD NOT use private API's to access cluster state.\nTo interact with the distributed or mini cluster uniformly, `IntegrationTestingUtility`, and `HBaseCluster` classes, and public client API's can be used.\n\nOn a distributed cluster, integration tests that use ChaosMonkey or otherwise manipulate services thru cluster manager (e.g.\nrestart regionservers) use SSH to do it.\nTo run these, test process should be able to run commands on remote end, so ssh should be configured accordingly (for example, if HBase runs under hbase user in your cluster, you can set up passwordless ssh for that user and run the test also under it). To facilitate that, `hbase.it.clustermanager.ssh.user`, `hbase.it.clustermanager.ssh.opts` and `hbase.it.clustermanager.ssh.cmd` configuration settings can be used.\n\"User\" is the remote user that cluster manager should use to perform ssh commands.\n\"Opts\" contains additional options that are passed to SSH (for example, \"-i /tmp/my-key\"). Finally, if you have some custom environment setup, \"cmd\" is the override format for the entire tunnel (ssh) command.\nThe default string is \\{`/usr/bin/ssh %1$s %2$s%3$s%4$s \"%5$s\"`} and is a good starting point.\nThis is a standard Java format string with 5 arguments that is used to execute the remote command.\nThe argument 1 (%1\\$s) is SSH options set the via opts setting or via environment variable, 2 is SSH user name, 3 is \"@\" if username is set or \"\" otherwise, 4 is the target host name, and 5 is the logical command to execute (that may include single quotes, so don't use them). For example, if you run the tests under non-hbase user and want to ssh as that user and change to hbase on remote machine, you can use:\n\n```bash\n/usr/bin/ssh %1$s %2$s%3$s%4$s \"su hbase - -c \\\"%5$s\\\"\"\n```\n\nThat way, to kill RS (for example) integration tests may run:\n\n```bash\n{/usr/bin/ssh some-hostname \"su hbase - -c \\\"ps aux | ... | kill ...\\\"\"}\n```\n\nThe command is logged in the test logs, so you can verify it is correct for your environment.\n\nTo disable the running of Integration Tests, pass the following profile on the command line `-PskipIntegrationTests`.\nFor example,\n\n```bash\n$ mvn clean install test -Dtest=TestZooKeeper  -PskipIntegrationTests\n```\n\n### Running integration tests against mini cluster\n\nHBase 0.92 added a `verify` maven target.\nInvoking it, for example by doing `mvn verify`, will run all the phases up to and including the verify phase via the maven [failsafe\nplugin](https://maven.apache.org/plugins/maven-failsafe-plugin/), running all the above mentioned HBase unit tests as well as tests that are in the HBase integration test group.\nAfter you have completed `mvn install -DskipTests` You can run just the integration tests by invoking:\n\n```bash\ncd hbase-it\nmvn verify\n```\n\nIf you just want to run the integration tests in top-level, you need to run two commands.\nFirst:\n\n```bash\nmvn failsafe:integration-test\n```\n\nThis actually runs ALL the integration tests.\n\n<Callout type=\"info\">\n  This command will always output `BUILD SUCCESS` even if there are test failures.\n</Callout>\n\nAt this point, you could grep the output by hand looking for failed tests.\nHowever, maven will do this for us; just use:\n\n```bash\nmvn failsafe:verify\n```\n\nThe above command basically looks at all the test results (so don't remove the 'target' directory) for test failures and reports the results.\n\n#### Running a subset of Integration tests\n\nThis is very similar to how you specify running a subset of unit tests (see above), but use the property `it.test` instead of `test`.\nTo just run `IntegrationTestClassXYZ.java`, use:\n\n```bash\nmvn failsafe:integration-test -Dit.test=IntegrationTestClassXYZ -DfailIfNoTests=false\n```\n\nThe next thing you might want to do is run groups of integration tests, say all integration tests that are named IntegrationTestClassX\\*.java:\n\n```bash\nmvn failsafe:integration-test -Dit.test=*ClassX* -DfailIfNoTests=false\n```\n\nThis runs everything that is an integration test that matches **ClassX**. This means anything matching: \"**\\*/IntegrationTest\\*ClassX**\". You can also run multiple groups of integration tests using comma-delimited lists (similar to unit tests). Using a list of matches still supports full regex matching for each of the groups. This would look something like:\n\n```bash\nmvn failsafe:integration-test -Dit.test=*ClassX*,*ClassY -DfailIfNoTests=false\n```\n\n### Running integration tests against distributed cluster\n\nIf you have an already-setup HBase cluster, you can launch the integration tests by invoking the class `IntegrationTestsDriver`.\nYou may have to run test-compile first.\nThe configuration will be picked by the bin/hbase script.\n\n```bash\nmvn test-compile\n```\n\nThen launch the tests with:\n\n```bash\nbin/hbase [--config config_dir] org.apache.hadoop.hbase.IntegrationTestsDriver\n```\n\nPass `-h` to get usage on this sweet tool.\nRunning the IntegrationTestsDriver without any argument will launch tests found under `hbase-it/src/test`, having `@Category(IntegrationTests.class)` annotation, and a name starting with `IntegrationTests`.\nSee the usage, by passing -h, to see how to filter test classes.\nYou can pass a regex which is checked against the full class name; so, part of class name can be used.\nIntegrationTestsDriver uses Junit to run the tests.\nCurrently there is no support for running integration tests against a distributed cluster using maven (see [HBASE-6201](https://issues.apache.org/jira/browse/HBASE-6201)).\n\nThe tests interact with the distributed cluster by using the methods in the `DistributedHBaseCluster` (implementing `HBaseCluster`) class, which in turn uses a pluggable `ClusterManager`.\nConcrete implementations provide actual functionality for carrying out deployment-specific and environment-dependent tasks (SSH, etc). The default `ClusterManager` is `HBaseClusterManager`, which uses SSH to remotely execute start/stop/kill/signal commands, and assumes some posix commands (ps, etc). Also assumes the user running the test has enough \"power\" to start/stop servers on the remote machines.\nBy default, it picks up `HBASE_SSH_OPTS`, `HBASE_HOME`, `HBASE_CONF_DIR` from the env, and uses `bin/hbase-daemon.sh` to carry out the actions.\nCurrently tarball deployments, deployments which uses *hbase-daemons.sh*, and [Apache Ambari](https://incubator.apache.org/ambari/) deployments are supported.\n*/etc/init.d/* scripts are not supported for now, but it can be easily added.\nFor other deployment options, a ClusterManager can be implemented and plugged in.\n\nSome integration tests define a *main* method as entry point, and can be run on its' own, rather than using the test driver. For example, the *itbll* test can be run as follows:\n\n```bash\nbin/hbase org.apache.hadoop.hbase.test.IntegrationTestBigLinkedList loop 2 1 100000 /temp 1 1000 50 1 0\n```\n\n<Callout type=\"info\">\n  The *hbase* script assumes all integration tests with exposed *main* methods to be run against a\n  distributed cluster will follow the **IntegrationTest** regex naming pattern mentioned above, in\n  order to proper set test dependencies into the classpath.\n</Callout>\n\n### Destructive integration / system tests (ChaosMonkey)\n\nHBase 0.96 introduced a tool named `ChaosMonkey`, modeled after\n[same-named tool by Netflix's Chaos Monkey tool](https://netflix.github.io/chaosmonkey/).\nChaosMonkey simulates real-world\nfaults in a running cluster by killing or disconnecting random servers, or injecting\nother failures into the environment. You can use ChaosMonkey as a stand-alone tool\nto run a policy while other tests are running. In some environments, ChaosMonkey is\nalways running, in order to constantly check that high availability and fault tolerance\nare working as expected.\n\nChaosMonkey defines **Actions** and **Policies**.\n\n#### Actions:\n\nActions are predefined sequences of events, such as the following:\n\n* Restart active master (sleep 5 sec)\n* Restart random regionserver (sleep 5 sec)\n* Restart random regionserver (sleep 60 sec)\n* Restart META regionserver (sleep 5 sec)\n* Restart ROOT regionserver (sleep 5 sec)\n* Batch restart of 50% of regionservers (sleep 5 sec)\n* Rolling restart of 100% of regionservers (sleep 5 sec)\n\n#### Policies:\n\nA policy is a strategy for executing one or more actions. The default policy\nexecutes a random action every minute based on predefined action weights.\nA given policy will be executed until ChaosMonkey is interrupted.\n\nMost ChaosMonkey actions are configured to have reasonable defaults, so you can run\nChaosMonkey against an existing cluster without any additional configuration. The\nfollowing example runs ChaosMonkey with the default configuration:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.chaos.util.ChaosMonkeyRunner\n\n12/11/19 23:21:57 INFO util.ChaosMonkey: Using ChaosMonkey Policy: class org.apache.hadoop.hbase.util.ChaosMonkey$PeriodicRandomActionPolicy, period:60000\n12/11/19 23:21:57 INFO util.ChaosMonkey: Sleeping for 26953 to add jitter\n12/11/19 23:22:24 INFO util.ChaosMonkey: Performing action: Restart active master\n12/11/19 23:22:24 INFO util.ChaosMonkey: Killing master:master.example.com,60000,1353367210440\n12/11/19 23:22:24 INFO hbase.HBaseCluster: Aborting Master: master.example.com,60000,1353367210440\n12/11/19 23:22:24 INFO hbase.ClusterManager: Executing remote command: ps aux | grep master | grep -v grep | tr -s ' ' | cut -d ' ' -f2 | xargs kill -s SIGKILL , hostname:master.example.com\n12/11/19 23:22:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:\n12/11/19 23:22:25 INFO hbase.HBaseCluster: Waiting service:master to stop: master.example.com,60000,1353367210440\n12/11/19 23:22:25 INFO hbase.ClusterManager: Executing remote command: ps aux | grep master | grep -v grep | tr -s ' ' | cut -d ' ' -f2 , hostname:master.example.com\n12/11/19 23:22:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:\n12/11/19 23:22:25 INFO util.ChaosMonkey: Killed master server:master.example.com,60000,1353367210440\n12/11/19 23:22:25 INFO util.ChaosMonkey: Sleeping for:5000\n12/11/19 23:22:30 INFO util.ChaosMonkey: Starting master:master.example.com\n12/11/19 23:22:30 INFO hbase.HBaseCluster: Starting Master on: master.example.com\n12/11/19 23:22:30 INFO hbase.ClusterManager: Executing remote command: /homes/enis/code/hbase-0.94/bin/../bin/hbase-daemon.sh --config /homes/enis/code/hbase-0.94/bin/../conf start master , hostname:master.example.com\n12/11/19 23:22:31 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:starting master, logging to /homes/enis/code/hbase-0.94/bin/../logs/hbase-enis-master-master.example.com.out\n....\n12/11/19 23:22:33 INFO util.ChaosMonkey: Started master: master.example.com,60000,1353367210440\n12/11/19 23:22:33 INFO util.ChaosMonkey: Sleeping for:51321\n12/11/19 23:23:24 INFO util.ChaosMonkey: Performing action: Restart random region server\n12/11/19 23:23:24 INFO util.ChaosMonkey: Killing region server:rs3.example.com,60020,1353367027826\n12/11/19 23:23:24 INFO hbase.HBaseCluster: Aborting RS: rs3.example.com,60020,1353367027826\n12/11/19 23:23:24 INFO hbase.ClusterManager: Executing remote command: ps aux | grep regionserver | grep -v grep | tr -s ' ' | cut -d ' ' -f2 | xargs kill -s SIGKILL , hostname:rs3.example.com\n12/11/19 23:23:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:\n12/11/19 23:23:25 INFO hbase.HBaseCluster: Waiting service:regionserver to stop: rs3.example.com,60020,1353367027826\n12/11/19 23:23:25 INFO hbase.ClusterManager: Executing remote command: ps aux | grep regionserver | grep -v grep | tr -s ' ' | cut -d ' ' -f2 , hostname:rs3.example.com\n12/11/19 23:23:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:\n12/11/19 23:23:25 INFO util.ChaosMonkey: Killed region server:rs3.example.com,60020,1353367027826. Reported num of rs:6\n12/11/19 23:23:25 INFO util.ChaosMonkey: Sleeping for:60000\n12/11/19 23:24:25 INFO util.ChaosMonkey: Starting region server:rs3.example.com\n12/11/19 23:24:25 INFO hbase.HBaseCluster: Starting RS on: rs3.example.com\n12/11/19 23:24:25 INFO hbase.ClusterManager: Executing remote command: /homes/enis/code/hbase-0.94/bin/../bin/hbase-daemon.sh --config /homes/enis/code/hbase-0.94/bin/../conf start regionserver , hostname:rs3.example.com\n12/11/19 23:24:26 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:starting regionserver, logging to /homes/enis/code/hbase-0.94/bin/../logs/hbase-enis-regionserver-rs3.example.com.out\n\n12/11/19 23:24:27 INFO util.ChaosMonkey: Started region server:rs3.example.com,60020,1353367027826. Reported num of rs:6\n```\n\nThe output indicates that ChaosMonkey started the default `PeriodicRandomActionPolicy`\npolicy, which is configured with all the available actions. It chose to run `RestartActiveMaster` and `RestartRandomRs` actions.\n\n### ChaosMonkey without SSH\n\nChaos monkey can be run without SSH using the Chaos service and ZNode cluster manager. HBase ships\nwith many cluster managers, available in the `hbase-it/src/test/java/org/apache/hadoop/hbase/` directory.\n\nSet the following property in hbase configuration to switch to `ZNodeClusterManager`:\n\n```xml\n<property>\n  <name>hbase.it.clustermanager.class</name>\n  <value>org.apache.hadoop.hbase.ZNodeClusterManager</value>\n</property>\n```\n\nStart chaos agent on all hosts where you want to test chaos scenarios.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.chaos.ChaosService -c start\n```\n\nStart chaos monkey runner from any one host, preferrably an edgenode.\nAn example log while running chaos monkey with default policy `PeriodicRandomActionPolicy` is as shown below:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.chaos.util.ChaosMonkeyRunner\n\nINFO  [main] hbase.HBaseCommonTestingUtility: Instantiating org.apache.hadoop.hbase.ZNodeClusterManager\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe] zookeeper.ZooKeeper: Initiating client connection, connectString=host1.example.com:2181,host2.example.com:2181,host3.example.com:2181 sessionTimeout=90000 watcher=org.apache.hadoop.hbase.zookeeper.ReadOnlyZKClient$$Lambda$19/2106254492@1a39cf8\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe] zookeeper.ClientCnxnSocket: jute.maxbuffer value is 4194304 Bytes\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe] zookeeper.ClientCnxn: zookeeper.request.timeout value is 0. feature enabled=\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe-SendThread(host2.example.com:2181)] zookeeper.ClientCnxn: Opening socket connection to server host2.example.com/10.20.30.40:2181. Will not attempt to authenticate using SASL (unknown error)\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe-SendThread(host2.example.com:2181)] zookeeper.ClientCnxn: Socket connection established, initiating session, client: /10.20.30.40:35164, server: host2.example.com/10.20.30.40:2181\nINFO  [ReadOnlyZKClient-host1.example.com:2181,host2.example.com:2181,host3.example.com:2181@0x003d43fe-SendThread(host2.example.com:2181)] zookeeper.ClientCnxn: Session establishment complete on server host2.example.com/10.20.30.40:2181, sessionid = 0x101de9204670877, negotiated timeout = 60000\nINFO  [main] policies.Policy: Using ChaosMonkey Policy class org.apache.hadoop.hbase.chaos.policies.PeriodicRandomActionPolicy, period=60000 ms\n [ChaosMonkey-2] policies.Policy: Sleeping for 93741 ms to add jitter\nINFO  [ChaosMonkey-0] policies.Policy: Sleeping for 9752 ms to add jitter\nINFO  [ChaosMonkey-1] policies.Policy: Sleeping for 65562 ms to add jitter\nINFO  [ChaosMonkey-3] policies.Policy: Sleeping for 38777 ms to add jitter\nINFO  [ChaosMonkey-0] actions.CompactRandomRegionOfTableAction: Performing action: Compact random region of table usertable, major=false\nINFO  [ChaosMonkey-0] policies.Policy: Sleeping for 59532 ms\nINFO  [ChaosMonkey-3] client.ConnectionImplementation: Getting master connection state from TTL Cache\nINFO  [ChaosMonkey-3] client.ConnectionImplementation: Getting master state using rpc call\nINFO  [ChaosMonkey-3] actions.DumpClusterStatusAction: Cluster status\nMaster: host1.example.com,16000,1678339058222\nNumber of backup masters: 0\nNumber of live region servers: 3\n  host1.example.com,16020,1678794551244\n  host2.example.com,16020,1678341258970\n  host3.example.com,16020,1678347834336\nNumber of dead region servers: 0\nNumber of unknown region servers: 0\nAverage load: 123.6666666666666\nNumber of requests: 118645157\nNumber of regions: 2654\nNumber of regions in transition: 0\nINFO  [ChaosMonkey-3] policies.Policy: Sleeping for 89614 ms\n```\n\nFor info on more customisations we can see help for the `ChaosMonkeyRunner`. For example we can pass the table name on which the chaos operations to be performed etc.\nBelow is the output of the help command, listing all the supported options.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.chaos.util.ChaosMonkeyRunner --help\n\nusage: hbase org.apache.hadoop.hbase.chaos.util.ChaosMonkeyRunner <options>\nOptions:\n -c <arg>             Name of extra configurations file to find on CLASSPATH\n -m,--monkey <arg>    Which chaos monkey to run\n -monkeyProps <arg>   The properties file for specifying chaos monkey properties.\n -tableName <arg>     Table name in the test to run chaos monkey against\n -familyName <arg>    Family name in the test to run chaos monkey against\n```\n\nFor example, running the following will start `ServerKillingMonkeyFactory` that chooses among actions to rolling batch restart RS, graceful rolling restart RS one at a time, restart active master, force balancer run etc.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.chaos.util.ChaosMonkeyRunner -m org.apache.hadoop.hbase.chaos.factories.ServerKillingMonkeyFactory\n```\n\n### Available Policies\n\nHBase ships with several ChaosMonkey policies, available in the\n`hbase/hbase-it/src/test/java/org/apache/hadoop/hbase/chaos/policies/` directory.\n\n### Configuring Individual ChaosMonkey Actions\n\nChaosMonkey integration tests can be configured per test run.\nCreate a Java properties file in the HBase CLASSPATH and pass it to ChaosMonkey using\nthe `-monkeyProps` configuration flag. Configurable properties, along with their default\nvalues if applicable, are listed in the `org.apache.hadoop.hbase.chaos.factories.MonkeyConstants`\nclass. For properties that have defaults, you can override them by including them\nin your properties file.\n\nThe following example uses a properties file called `monkey.properties`.\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.IntegrationTestIngest -m slowDeterministic -monkeyProps monkey.properties\n```\n\nThe above command will start the integration tests and chaos monkey. It will look for the\nproperties file *monkey.properties* on the HBase CLASSPATH; e.g. inside the HBASE *conf* dir.\n\nHere is an example chaos monkey file:\n\n#### Example ChaosMonkey Properties File\n\n```properties\nsdm.action1.period=120000\nsdm.action2.period=40000\nmove.regions.sleep.time=80000\nmove.regions.max.time=1000000\nmove.regions.sleep.time=80000\nbatch.restart.rs.ratio=0.4f\n```\n\nPeriods/time are expressed in milliseconds.\n\nHBase 1.0.2 and newer adds the ability to restart HBase's underlying ZooKeeper quorum or\nHDFS nodes. To use these actions, you need to configure some new properties, which\nhave no reasonable defaults because they are deployment-specific, in your ChaosMonkey\nproperties file, which may be `hbase-site.xml` or a different properties file.\n\n```xml\n<property>\n  <name>hbase.it.clustermanager.hadoop.home</name>\n  <value>$HADOOP_HOME</value>\n</property>\n<property>\n  <name>hbase.it.clustermanager.zookeeper.home</name>\n  <value>$ZOOKEEPER_HOME</value>\n</property>\n<property>\n  <name>hbase.it.clustermanager.hbase.user</name>\n  <value>hbase</value>\n</property>\n<property>\n  <name>hbase.it.clustermanager.hadoop.hdfs.user</name>\n  <value>hdfs</value>\n</property>\n<property>\n  <name>hbase.it.clustermanager.zookeeper.user</name>\n  <value>zookeeper</value>\n</property>\n```\n\n### Customizing Destructive ChaosMonkey Actions\n\nThe session above shows how to setup custom configurations for the *slowDeterministic* monkey\npolicy. This is a policy that pre-defines a set of destructive actions of varying gravity for a\nrunning cluster. These actions are grouped into three categories: *light weight*, *mid weight* and\n*heavy weight*. Although it's possible to define some properties for the different actions\n(such as timeouts, frequency, etc), the actions themselves are not configurable.\n\nFor certain deployments, it may be interesting to define its own test strategy, either less or more\naggressive than the pre-defined set of actions provided by *slowDeterministic*. For such cases,\nthe *configurableSlowDeterministic* policy can be used. It allows for a customizable set of\n*heavy weight* actions to be defined in the *monkey.properties* properties file:\n\n```properties\nbatch.restart.rs.ratio=0.3f\nheavy.actions=RestartRandomRsAction(500000);MoveRandomRegionOfTableAction(360000,$table_name);SplitAllRegionOfTableAction($table_name)\n```\n\nThe above properties file definition instructs chaos monkey to perform a RegionServer crash every 8 minutes,\na random region move every 6 minutes, and at least one split of all table regions.\n\nTo run this policy, just specify *configurableSlowDeterministic* as the monkey policy to run, together\nwith a property file containing the *heavy.actions* property definition:\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.IntegrationTestIngest -m configurableSlowDeterministic -monkeyProps monkey.properties\n```\n\nWhen specifying monkey actions, make sure to define all required constructor parameters. For actions\nthat require a table name parameter, the *\\$table\\_name* placeholder can be specified, and it will\nautomatically resort to the table created by the integration test run.\n\nIf *heavy.actions* property is omitted in the properties file, *configurableSlowDeterministic* will\njust run as the *slowDeterministic* policy\n(it will execute all the heavy weight actions defined by *slowDeterministic* policy).\n\n## Developer Guidelines\n\n## Branches\n\nWe use Git for source code management and latest development happens on `master` branch. There are\nbranches for past major/minor/maintenance releases and important features and bug fixes are often\nback-ported to them.\n\n## Policy for Fix Version in JIRA\n\nTo determine if a given fix is in a given release purely from the release numbers following rules\nare defined:\n\nFix version of X.Y.Z => fixed in all releases X.Y.Z' (where Z' = Z).\\\nFix version of X.Y.0 => fixed in all releases X.Y'.\\* (where Y' = Y).\\\nFix version of X.0.0 => fixed in all releases X'.\\*.\\* (where X' = X).\n\nBy this policy, fix version of 1.3.0 implies 1.4.0, but 1.3.2 does not imply 1.4.0 as we could not\ntell purely from the numbers which release came first.\n\n## Code Standards\n\n### Interface Classifications\n\nInterfaces are classified both by audience and by stability level.\nThese labels appear at the head of a class.\nThe conventions followed by HBase are inherited by its parent project, Hadoop.\n\nThe following interface classifications are commonly used:\n\n#### InterfaceAudience\n\n`@InterfaceAudience.Public`\\\nAPIs for users and HBase applications.\nThese APIs will be deprecated through major versions of HBase.\n\n`@InterfaceAudience.Private`\\\nAPIs for HBase internals developers.\nNo guarantees on compatibility or availability in future versions.\nPrivate interfaces do not need an `@InterfaceStability` classification.\n\n`@InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.COPROC)`\\\nAPIs for HBase coprocessor writers.\n\n**No `@InterfaceAudience` Classification**:\\\nPackages without an `@InterfaceAudience` label are considered private.\nMark your new packages if publicly accessible.\n\n<Callout type=\"info\" title=\"Excluding Non-Public Interfaces from API Documentation\">\n  Only interfaces classified `@InterfaceAudience.Public` should be included in API documentation\n  (Javadoc). Committers must add new package excludes `ExcludePackageNames` section of the *pom.xml*\n  for new packages which do not contain public classes.\n</Callout>\n\n#### @InterfaceStability\n\n`@InterfaceStability` is important for packages marked `@InterfaceAudience.Public`.\n\n`@InterfaceStability.Stable`\\\nPublic packages marked as stable cannot be changed without a deprecation path or a very good reason.\n\n`@InterfaceStability.Unstable`\\\nPublic packages marked as unstable can be changed without a deprecation path.\n\n`@InterfaceStability.Evolving`\\\nPublic packages marked as evolving may be changed, but it is discouraged.\n\n**No `@InterfaceStability` Label**:\nPublic classes with no `@InterfaceStability` label are discouraged, and should be considered implicitly unstable.\n\nIf you are unclear about how to mark packages, ask on the development list.\n\n### Code Formatting Conventions\n\nPlease adhere to the following guidelines so that your patches can be reviewed more quickly.\nThese guidelines have been developed based upon common feedback on patches from new contributors.\n\nSee the [Code Conventions for the Java Programming Language](http://www.oracle.com/technetwork/java/index-135089.html) for more information on coding conventions in Java.\nSee [Eclipse Code Formatting](/docs/building-and-developing#code-formatting) to setup Eclipse to check for some of\nthese guidelines automatically.\n\n#### Space Invaders\n\nDo not use extra spaces around brackets.\nUse the second style, rather than the first.\n\n```java\nif ( foo.equals( bar ) ) {     // don't do this\n```\n\n```java\nif (foo.equals(bar)) {\n```\n\n```java\nfoo = barArray[ i ];     // don't do this\n```\n\n```java\nfoo = barArray[i];\n```\n\n#### Auto Generated Code\n\nAuto-generated code in Eclipse often uses bad variable names such as `arg0`.\nUse more informative variable names.\nUse code like the second example here.\n\n```java\n public void readFields(DataInput arg0) throws IOException {    // don't do this\n   foo = arg0.readUTF();                                       // don't do this\n```\n\n```java\n public void readFields(DataInput di) throws IOException {\n   foo = di.readUTF();\n```\n\n#### Long Lines\n\nKeep lines less than 100 characters.\nYou can configure your IDE to do this automatically.\n\n```java\nBar bar = foo.veryLongMethodWithManyArguments(argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9);  // don't do this\n```\n\n```java\nBar bar = foo.veryLongMethodWithManyArguments(\n argument1, argument2, argument3,argument4, argument5, argument6, argument7, argument8, argument9);\n```\n\n#### Trailing Spaces\n\nBe sure there is a line break after the end of your code, and avoid lines with nothing but whitespace.\nThis makes diffs more meaningful.\nYou can configure your IDE to help with this.\n\n```java\nBar bar = foo.getBar();     <--- imagine there is an extra space(s) after the semicolon.\n```\n\n#### API Documentation (Javadoc)\n\nDon't forget Javadoc!\n\nJavadoc warnings are checked during precommit.\nIf the precommit tool gives you a '-1', please fix the javadoc issue.\nYour patch won't be committed if it adds such warnings.\n\nAlso, no `@author` tags - that's a rule.\n\n#### Findbugs\n\n`Findbugs` is used to detect common bugs pattern.\nIt is checked during the precommit build.\nIf errors are found, please fix them.\nYou can run findbugs locally with `mvn\n                            findbugs:findbugs`, which will generate the `findbugs` files locally.\nSometimes, you may have to write code smarter than `findbugs`.\nYou can annotate your code to tell `findbugs` you know what you're doing, by annotating your class with the following annotation:\n\n```java\n@edu.umd.cs.findbugs.annotations.SuppressWarnings(\nvalue=\"HE_EQUALS_USE_HASHCODE\",\njustification=\"I know what I'm doing\")\n```\n\nIt is important to use the Apache-licensed version of the annotations. That generally means using\nannotations in the `edu.umd.cs.findbugs.annotations` package so that we can rely on the cleanroom\nreimplementation rather than annotations in the `javax.annotations` package.\n\n#### Javadoc - Useless Defaults\n\nDon't just leave javadoc tags the way IDE generates them, or fill redundant information in them.\n\n```java\n  /**\n   * @param table                              <---- don't leave them empty!\n   * @param region An HRegion object.          <---- don't fill redundant information!\n   * @return Foo Object foo just created.      <---- Not useful information\n   * @throws SomeException                     <---- Not useful. Function declarations already tell that!\n   * @throws BarException when something went wrong  <---- really?\n   */\n  public Foo createFoo(Bar bar);\n```\n\nEither add something descriptive to the tags, or just remove them.\nThe preference is to add something descriptive and useful.\n\n#### One Thing At A Time, Folks\n\nIf you submit a patch for one thing, don't do auto-reformatting or unrelated reformatting of code on a completely different area of code.\n\nLikewise, don't add unrelated cleanup or refactorings outside the scope of your Jira.\n\n#### Ambiguous Unit Tests\n\nMake sure that you're clear about what you are testing in your unit tests and why.\n\n### Garbage-Collection Conserving Guidelines\n\nThe following guidelines were borrowed from [http://engineering.linkedin.com/performance/linkedin-feed-faster-less-jvm-garbage](http://engineering.linkedin.com/performance/linkedin-feed-faster-less-jvm-garbage).\nKeep them in mind to keep preventable garbage collection to a minimum. Have a look\nat the blog post for some great examples of how to refactor your code according to\nthese guidelines.\n\n* Be careful with Iterators\n* Estimate the size of a collection when initializing\n* Defer expression evaluation\n* Compile the regex patterns in advance\n* Cache it if you can\n* String Interns are useful but dangerous\n\n## Invariants\n\nWe don't have many but what we have we list below.\nAll are subject to challenge of course but until then, please hold to the rules of the road.\n\n### No permanent state in ZooKeeper\n\nZooKeeper state should transient (treat it like memory). If ZooKeeper state is deleted, hbase should be able to recover and essentially be in the same state.\n\n* .Exceptions: There are currently a few exceptions that we need to fix around whether a table is enabled or disabled.\n* Replication data is currently stored only in ZooKeeper.\n  Deleting ZooKeeper data related to replication may cause replication to be disabled.\n  Do not delete the replication tree, */hbase/replication/*.\n\n<Callout type=\"warning\">\n  Replication may be disrupted and data loss may occur if you delete the replication tree\n  (*/hbase/replication/*) from ZooKeeper. Follow progress on this issue at\n  [HBASE-10295](https://issues.apache.org/jira/browse/HBASE-10295).\n</Callout>\n\n## Running In-Situ\n\nIf you are developing Apache HBase, frequently it is useful to test your changes against a more-real cluster than what you find in unit tests.\nIn this case, HBase can be run directly from the source in local-mode.\nAll you need to do is run:\n\n```bash\n${HBASE_HOME}/bin/start-hbase.sh\n```\n\nThis will spin up a full local-cluster, just as if you had packaged up HBase and installed it on your machine.\n\nKeep in mind that you will need to have installed HBase into your local maven repository for the in-situ cluster to work properly.\nThat is, you will need to run:\n\n```bash\nmvn clean install -DskipTests\n```\n\nto ensure that maven can find the correct classpath and dependencies.\nGenerally, the above command is just a good thing to try running first, if maven is acting oddly.\n\n## Adding Metrics\n\nAfter adding a new feature a developer might want to add metrics.\nHBase exposes metrics using the Hadoop Metrics 2 system, so adding a new metric involves exposing that metric to the hadoop system.\nUnfortunately the API of metrics2 changed from hadoop 1 to hadoop 2.\nIn order to get around this a set of interfaces and implementations have to be loaded at runtime.\nTo get an in-depth look at the reasoning and structure of these classes you can read the blog post located [here](https://blogs.apache.org/hbase/entry/migration_to_the_new_metrics).\nTo add a metric to an existing MBean follow the short guide below:\n\n### Add Metric name and Function to Hadoop Compat Interface.\n\nInside of the source interface the corresponds to where the metrics are generated (eg MetricsMasterSource for things coming from HMaster) create new static strings for metric name and description.\nThen add a new method that will be called to add new reading.\n\n### Add the Implementation to Both Hadoop 1 and Hadoop 2 Compat modules.\n\nInside of the implementation of the source (eg.\nMetricsMasterSourceImpl in the above example) create a new histogram, counter, gauge, or stat in the init method.\nThen in the method that was added to the interface wire up the parameter passed in to the histogram.\n\nNow add tests that make sure the data is correctly exported to the metrics 2 system.\nFor this the MetricsAssertHelper is provided.\n\n## Git Best Practices\n\n**Avoid git merges.**\\\nUse `git pull --rebase` or `git fetch` followed by `git rebase`.\n\n**Do not use `git push --force`.**\\\nIf the push does not work, fix the problem or ask for help.\n\nPlease contribute to this document if you think of other Git best practices.\n\n### `rebase_all_git_branches.sh`\n\nThe *dev-support/rebase\\_all\\_git\\_branches.sh* script is provided to help keep your Git repository clean.\nUse the `-h` parameter to get usage instructions.\nThe script automatically refreshes your tracking branches, attempts an automatic rebase of each local branch against its remote branch, and gives you the option to delete any branch which represents a closed `HBASE-` JIRA.\nThe script has one optional configuration option, the location of your Git directory.\nYou can set a default by editing the script.\nOtherwise, you can pass the git directory manually by using the `-d` parameter, followed by an absolute or relative directory name, or even '.' for the current working directory.\nThe script checks the directory for sub-directory called *.git/*, before proceeding.\n\n## Submitting Patches\n\nIf you are new to submitting patches to open source or new to submitting patches to Apache, start by\nreading the [On Contributing Patches](https://commons.apache.org/patches.html) page from\n[Apache Commons Project](https://commons.apache.org/).\nIt provides a nice overview that applies equally to the Apache HBase Project.\n\nMake sure you review [Code Formatting Conventions](/docs/building-and-developing/developer-guidelines#code-formatting-conventions) for code style. If your patch\nwas generated incorrectly or your code does not adhere to the code formatting guidelines, you may\nbe asked to redo some work.\n\nHBase enforces code style via a maven plugin. After you've written up your changes, apply the\nformatter before committing.\n\n```bash\n$ mvn spotless:apply\n```\n\nWhen your commit is ready, present it to the community as a\n[GitHub Pull Request](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests).\n\n### Few general guidelines\n\n* Always patch against the master branch first, even if you want to patch in another branch.\n  HBase committers always apply patches first to the master branch, and backport as necessary. For\n  complex patches, you may be asked to perform the backport(s) yourself.\n* Submit one single PR for a single fix. If necessary, squash local commits to merge local commits\n  into a single one first. See this\n  [Stack Overflow\n  question](http://stackoverflow.com/questions/5308816/how-to-use-git-merge-squash) for more information about squashing commits.\n* Please understand that not every patch may get committed, and that feedback will likely be\n  provided on the patch.\n\n### Unit Tests\n\nAlways add and/or update relevant unit tests when making the changes.\nMake sure that new/changed unit tests pass locally before submitting the patch because it is faster\nthan waiting for presubmit result which runs full test suite. This will save your own time and\neffort.\nUse [Mockito](https://site.mockito.org/) to make mocks which are very useful for testing failure scenarios by\ninjecting appropriate failures.\n\nIf you are creating a new unit test class, notice how other unit test classes have\nclassification/sizing annotations before class name and a static methods for setup/teardown of\ntesting environment. Be sure to include annotations in any new unit test files.\nSee [Tests](/docs/building-and-developing/tests) for more information on tests.\n\n### Integration Tests\n\nSignificant new features should provide an integration test in addition to unit tests, suitable for exercising the new feature at different points in its configuration space.\n\n### ReviewBoard\n\nPatches larger than one screen, or patches that will be tricky to review, should go through [ReviewBoard](https://reviews.apache.org).\n\n**Procedure: Use ReviewBoard**\n\n<Steps>\n  <Step>\n    Register for an account if you don't already have one.\n    It does not use the credentials from [issues.apache.org](https://issues.apache.org).\n    Log in.\n  </Step>\n\n  <Step>\n    Click **New Review Request**.\n  </Step>\n\n  <Step>\n    Choose the `hbase-git` repository.\n    Click Choose File to select the diff and optionally a parent diff.\n    Click **Create Review Request**.\n  </Step>\n\n  <Step>\n    Fill in the fields as required.\n    At the minimum, fill in the **Summary** and choose `hbase` as the **Review Group**.\n    If you fill in the **Bugs** field, the review board links back to the relevant JIRA.\n    The more fields you fill in, the better.\n    Click **Publish** to make your review request public.\n    An email will be sent to everyone in the `hbase` group, to review the patch.\n  </Step>\n\n  <Step>\n    Back in your JIRA, click , and paste in the URL of your ReviewBoard request.\n    This attaches the ReviewBoard to the JIRA, for easy access.\n  </Step>\n\n  <Step>\n    To cancel the request, click .\n  </Step>\n</Steps>\n\nFor more information on how to use ReviewBoard, see [the ReviewBoard\ndocumentation](http://www.reviewboard.org/docs/manual/1.5/).\n\n### GitHub\n\nSubmitting [GitHub](https://github.com/apache/hbase) pull requests is another accepted form of\ncontributing patches. Refer to GitHub [documentation](https://help.github.com/) for details on\nhow to create pull requests.\n\n<Callout type=\"info\">\n  This section is incomplete and needs to be updated. Refer to\n  [HBASE-23557](https://issues.apache.org/jira/browse/HBASE-23557)\n</Callout>\n\n#### GitHub Tooling\n\n**Browser bookmarks**\n\nFollowing is a useful javascript based browser bookmark that redirects from GitHub pull\nrequests to the corresponding jira work item. This redirects based on the HBase jira ID mentioned\nin the issue title for the PR. Add the following javascript snippet as a browser bookmark to the\ntool bar. Clicking on it while you are on an HBase GitHub PR page redirects you to the corresponding\njira item.\n\n```js\nlocation.href =\n  \"https://issues.apache.org/jira/browse/\" +\n  document.getElementsByClassName(\"js-issue-title\")[0].innerHTML.match(/HBASE-\\d+/)[0];\n```\n\n### Guide for HBase Committers\n\n#### Becoming a committer\n\nCommitters are responsible for reviewing and integrating code changes, testing\nand voting on release candidates, weighing in on design discussions, as well as\nother types of project contributions. The PMC votes to make a contributor a\ncommitter based on an assessment of their contributions to the project. It is\nexpected that committers demonstrate a sustained history of high-quality\ncontributions to the project and community involvement.\n\nContributions can be made in many ways. There is no single path to becoming a\ncommitter, nor any expected timeline. Submitting features, improvements, and bug\nfixes is the most common avenue, but other methods are both recognized and\nencouraged (and may be even more important to the health of HBase as a project and a\ncommunity). A non-exhaustive list of potential contributions (in no particular\norder):\n\n* [Update the documentation](/docs/contributing-to-documentation) for new\n  changes, best practices, recipes, and other improvements.\n* Keep the website up to date.\n* Perform testing and report the results. For instance, scale testing and\n  testing non-standard configurations is always appreciated.\n* Maintain the shared Jenkins testing environment and other testing\n  infrastructure.\n* [Vote on release candidates](/docs/building-and-developing/voting) after performing validation, even if non-binding.\n  A non-binding vote is a vote by a non-committer.\n* Provide input for discussion threads on the link:/mail-lists.html\\[mailing lists] (which usually have\n  `[DISCUSS]` in the subject line).\n* Answer questions questions on the user or developer mailing lists and on\n  Slack.\n* Make sure the HBase community is a welcoming one and that we adhere to our\n  link:/coc.html\\[Code of conduct]. Alert the PMC if you\n  have concerns.\n* Review other people's work (both code and non-code) and provide public\n  feedback.\n* Report bugs that are found, or file new feature requests.\n* Triage issues and keep JIRA organized. This includes closing stale issues,\n  labeling new issues, updating metadata, and other tasks as needed.\n* Mentor new contributors of all sorts.\n* Give talks and write blogs about HBase. Add these to the link:/\\[News] section\n  of the website.\n* Provide UX feedback about HBase, the web UI, the CLI, APIs, and the website.\n* Write demo applications and scripts.\n* Help attract and retain a diverse community.\n* Interact with other projects in ways that benefit HBase and those other\n  projects.\n\nNot every individual is able to do all (or even any) of the items on this list.\nIf you think of other ways to contribute, go for it (and add them to the list).\nA pleasant demeanor and willingness to contribute are all you need to make a\npositive impact on the HBase project. Invitations to become a committer are the\nresult of steady interaction with the community over the long term, which builds\ntrust and recognition.\n\n#### New committers\n\nNew committers are encouraged to first read Apache's generic committer\ndocumentation:\n\n* [Apache New Committer Guide](https://www.apache.org/dev/new-committers-guide.html)\n* [Apache Committer FAQ](https://www.apache.org/dev/committers.html)\n\n#### Review\n\nHBase committers should, as often as possible, attempt to review patches\nsubmitted by others. Ideally every submitted patch will get reviewed by a\ncommitter *within a few days*. If a committer reviews a patch they have not\nauthored, and believe it to be of sufficient quality, then they can commit the\npatch. Otherwise the patch should be cancelled with a clear explanation for why\nit was rejected.\n\nThe list of submitted patches is in the\n[HBase Review Queue](https://issues.apache.org/jira/secure/IssueNavigator.jspa?mode=hide\\&requestId=12312392),\nwhich is ordered by time of last modification. Committers should scan the list\nfrom top to bottom, looking for patches that they feel qualified to review and\npossibly commit. If you see a patch you think someone else is better qualified\nto review, you can mention them by username in the JIRA.\n\nFor non-trivial changes, it is required that another committer review your\npatches before commit. **Self-commits of non-trivial patches are not allowed.**\nUse the **Submit Patch** button in JIRA, just like other contributors, and\nthen wait for a `+1` response from another committer before committing.\n\n#### Reject\n\nPatches which do not adhere to the guidelines in\n[HowToContribute](/docs/building-and-developing) and to the\n[code review checklist](https://cwiki.apache.org/confluence/display/HADOOP2/CodeReviewChecklist)\nshould be rejected. Committers should always be polite to contributors and try\nto instruct and encourage them to contribute better patches. If a committer\nwishes to improve an unacceptable patch, then it should first be rejected, and a\nnew patch should be attached by the committer for further review.\n\n#### Commit\n\nCommitters commit patches to the Apache HBase GIT repository.\n\n<Callout type=\"warn\" title=\"Before you commit!!!!\">\n  Make sure your local configuration is correct, especially your identity and email. Examine the\n  output of the `$ git config --list` command and be sure it is correct. See [Set Up\n  Git](https://help.github.com/articles/set-up-git) if you need pointers.\n</Callout>\n\nWhen you commit a patch:\n\n1. Include the Jira issue ID in the commit message along with a short description\n   of the change. Try to add something more than just the Jira title so that\n   someone looking at `git log` output doesn't have to go to Jira to discern what\n   the change is about. Be sure to get the issue ID right, because this causes\n   Jira to link to the change in Git (use the issue's \"All\" tab to see these\n   automatic links).\n\n2. Commit the patch to a new branch based off `master` or the other intended\n   branch. It's a good idea to include the JIRA ID in the name of this branch.\n   Check out the relevant target branch where you want to commit, and make sure\n   your local branch has all remote changes, by doing a `git pull --rebase` or\n   another similar command. Next, cherry-pick the change into each relevant\n   branch (such as master), and push the changes to the remote branch using\n   a command such as `git push <remote-server> <remote-branch>`.\n\n   <Callout type=\"warning\">\n     If you do not have all remote changes, the push will fail. If the push fails for any reason,\n     fix the problem or ask for help. Do not do a `git push --force`.\n   </Callout>\n\n   Before you can commit a patch, you need to determine how the patch was created.\n   The instructions and preferences around the way to create patches have changed,\n   and there will be a transition period.\n\n   **Determine How a Patch Was Created**\n\n   * If the first few lines of the patch look like the headers of an email, with a From, Date, and\n     Subject, it was created using `git format-patch`. This is the preferred way, because you can\n     reuse the submitter's commit message. If the commit message is not appropriate, you can still use\n     the commit, then run `git commit --amend` and reword as appropriate.\n\n   * If the first line of the patch looks similar to the following, it was created using +git diff+ without `--no-prefix`.\n     This is acceptable too.\n     Notice the `a` and `b` in front of the file names.\n     This is the indication that the patch was not created with `--no-prefix`.\n\n     ```diff\n     diff --git a/src/main/asciidoc/_chapters/developer.adoc b/src/main/asciidoc/_chapters/developer.adoc\n     ```\n\n   * If the first line of the patch looks similar to the following (without the `a` and `b`), the\n     patch was created with `git diff --no-prefix` and you need to add `-p0` to the `git apply` command\n     below.\n\n     ```diff\n     diff --git src/main/asciidoc/_chapters/developer.adoc src/main/asciidoc/_chapters/developer.adoc\n     ```\n\n   **Example of committing a Patch**\n\n   One thing you will notice with these examples is that there are a lot of\n   `git pull` commands. The only command that actually writes anything to the\n   remote repository is `git push`, and you need to make absolutely sure you have\n   the correct versions of everything and don't have any conflicts before pushing.\n   The extra `git pull` commands are usually redundant, but better safe than sorry.\n\n   The first example shows how to apply a patch that was generated with +git\n   format-patch+ and apply it to the `master` and `branch-1` branches.\n\n   The directive to use `git format-patch` rather than `git diff`, and not to use\n   `--no-prefix`, is a new one. See the second example for how to apply a patch\n   created with `git diff`, and educate the person who created the patch.\n\n   ```bash\n   $ git checkout -b HBASE-XXXX\n   $ git am ~/Downloads/HBASE-XXXX-v2.patch --signoff  # If you are committing someone else's patch.\n   $ git checkout master\n   $ git pull --rebase\n   $ git cherry-pick <sha-from-commit>\n   # Resolve conflicts if necessary or ask the submitter to do it\n   $ git pull --rebase          # Better safe than sorry\n   $ git push origin master\n\n   # Backport to branch-1\n   $ git checkout branch-1\n   $ git pull --rebase\n   $ git cherry-pick <sha-from-commit>\n   # Resolve conflicts if necessary\n   $ git pull --rebase          # Better safe than sorry\n   $ git push origin branch-1\n   $ git branch -D HBASE-XXXX\n   ```\n\n   This example shows how to commit a patch that was created using `git diff`\n   without `--no-prefix`. If the patch was created with `--no-prefix`, add `-p0` to\n   the `git apply` command.\n\n   ```bash\n   $ git apply ~/Downloads/HBASE-XXXX-v2.patch\n   $ git commit -m \"HBASE-XXXX Really Good Code Fix (Joe Schmo)\" --author=<contributor> -a  # This and next command is needed for patches created with 'git diff'\n   $ git commit --amend --signoff\n   $ git checkout master\n   $ git pull --rebase\n   $ git cherry-pick <sha-from-commit>\n   # Resolve conflicts if necessary or ask the submitter to do it\n   $ git pull --rebase          # Better safe than sorry\n   $ git push origin master\n\n   # Backport to branch-1\n   $ git checkout branch-1\n   $ git pull --rebase\n   $ git cherry-pick <sha-from-commit>\n   # Resolve conflicts if necessary or ask the submitter to do it\n   $ git pull --rebase           # Better safe than sorry\n   $ git push origin branch-1\n   $ git branch -D HBASE-XXXX\n   ```\n\n3. Resolve the issue as fixed, thanking the contributor.\n   Always set the \"Fix Version\" at this point, but only set a single fix version\n   for each branch where the change was committed, the earliest release in that\n   branch in which the change will appear.\n\n**Commit Message Format**\n\nThe commit message should contain the JIRA ID and a description of what the patch does.\nThe preferred commit message format is:\n\n```text\n<jira-id> <jira-title> (<contributor-name-if-not-commit-author>)\n```\n\n```text\nHBASE-12345 Fix All The Things (jane@example.com)\n```\n\nIf the contributor used `git format-patch` to generate the patch, their commit\nmessage is in their patch and you can use that, but be sure the JIRA ID is at\nthe front of the commit message, even if the contributor left it out.\n\n**Use GitHub's \"Co-authored-by\" when there are multiple authors**\n\nWe've established the practice of committing to master and then cherry picking back to branches whenever possible, unless\n\n* it's breaking compat: In which case, if it can go in minor releases, backport to branch-1 and branch-2.\n* it's a new feature: No for maintenance releases, For minor releases, discuss and arrive at consensus.\n\nThere are occasions when there are multiple author for a patch.\nFor example when there is a minor conflict we can fix it up and just proceed with the commit.\nThe amending author will be different from the original committer, so you should also attribute to the original author by\nadding one or more `Co-authored-by` trailers to the commit's message.\nSee [the GitHub documentation for \"Creating a commit with multiple authors\"](https://help.github.com/en/articles/creating-a-commit-with-multiple-authors/).\n\nIn short, these are the steps to add Co-authors that will be tracked by GitHub:\n\n1. Collect the name and email address for each co-author.\n2. Commit the change, but after your commit description, instead of a closing quotation, add two empty lines. (Do not close the commit message with a quotation mark)\n3. On the next line of the commit message, type `Co-authored-by: name <name@example.com>`. After the co-author information, add a closing quotation mark.\n\nHere is the example from the GitHub page, using 2 Co-authors:\n\n```bash\n$ git commit -m \"Refactor usability tests.\n>\n>\nCo-authored-by: name <name@example.com>\nCo-authored-by: another-name <another-name@example.com>\"\n```\n\nNote: `Amending-Author: Author <committer@apache>` was used prior to this\n[DISCUSSION](https://lists.apache.org/thread.html/f00b5f9b65570e777dbb31c37d7b0ffc55c5fc567aefdb456608a042@%3Cdev.hbase.apache.org%3E).\n\n**Close related GitHub PRs**\n\nAs a project we work to ensure there's a JIRA associated with each change, but we don't mandate any particular tool be used for reviews. Due to implementation details of the ASF's integration between hosted git repositories and GitHub, the PMC has no ability to directly close PRs on our GitHub repo. In the event that a contributor makes a Pull Request on GitHub, either because the contributor finds that easier than attaching a patch to JIRA or because a reviewer prefers that UI for examining changes, it's important to make note of the PR in the commit that goes to the master branch so that PRs are kept up to date.\n\nTo read more about the details of what kinds of commit messages will work with the GitHub \"close via keyword in commit\" mechanism see [the GitHub documentation for \"Closing issues using keywords\"](https://help.github.com/articles/closing-issues-using-keywords/). In summary, you should include a line with the phrase \"closes #XXX\", where the XXX is the pull request id. The pull request id is usually given in the GitHub UI in grey at the end of the subject heading.\n\n**Committers are responsible for making sure commits do not break the build or tests**\n\nIf a committer commits a patch, it is their responsibility to make sure it passes the test suite.\nIt is helpful if contributors keep an eye out that their patch does not break the hbase build and/or tests, but ultimately, a contributor cannot be expected to be aware of all the particular vagaries and interconnections that occur in a project like HBase.\nA committer should.\n\n**Patching Etiquette**\n\nIn the thread [HBase, mail # dev - ANNOUNCEMENT: Git Migration In Progress (WAS =>\nRe: Git Migration)](https://lists.apache.org/thread.html/186fcd5eb71973a7b282ecdba41606d3d221efd505d533bb729e1fad%401400648690%40%3Cdev.hbase.apache.org%3E), it was agreed on the following patch flow\n\n1. Develop and commit the patch against master first.\n2. Try to cherry-pick the patch when backporting if possible.\n3. If this does not work, manually commit the patch to the branch.\n\n**Merge Commits**\n\nAvoid merge commits, as they create problems in the git history.\n\n**Committing Documentation**\n\nSee [appendix contributing to documentation](/docs/contributing-to-documentation).\n\n**How to re-trigger github Pull Request checks/re-build**\n\nA Pull Request (PR) submission triggers the hbase yetus checks. The checks make\nsure the patch doesn't break the build or introduce test failures. The checks take\naround four hours to run (They are the same set run when you submit a patch via\nHBASE JIRA). When finished, they add a report to the PR as a comment. If a problem\nw/ the patch — failed compile, checkstyle violation, or an added findbugs --\nthe original author makes fixes and pushes a new patch. This re-runs the checks\nto produce a new report.\n\nSometimes though, the patch is good but a flakey, unrelated test has the report vote -1\non the patch. In this case, **committers** can retrigger the check run by doing a force push of the\nexact same patch. Or, click on the `Console output` link which shows toward the end\nof the report (For example `https://builds.apache.org/job/HBase-PreCommit-GitHub-PR/job/PR-289/1/console`).\nThis will take you to `builds.apache.org`, to the build run that failed. See the\n\"breadcrumbs\" along the top (where breadcrumbs is the listing of the directories that\ngets us to this particular build page). It'll look something like\n`Jenkins > HBase-PreCommit-GitHub-PR > PR-289 > #1`. Click on the\nPR number — i.e. PR-289 in our example — and then, when you've arrived at the PR page,\nfind the 'Build with Parameters' menu-item (along top left-hand menu). Click here and\nthen `Build` leaving the JIRA\\_ISSUE\\_KEY empty. This will re-run your checks.\n\n### Dialog\n\nCommitters should hang out in the #hbase room on irc.freenode.net for real-time discussions.\nHowever any substantive discussion (as with any off-list project-related discussion) should be re-iterated in Jira or on the developer list.\n\n### Do not edit JIRA comments\n\nMisspellings and/or bad grammar is preferable to the disruption a JIRA comment edit.\n\n## The hbase-thirdparty dependency and shading/relocation\n\nA new project was created for the release of hbase-2.0.0. It was called\n`hbase-thirdparty`. This project exists only to provide the main hbase\nproject with relocated — or shaded — versions of popular thirdparty\nlibraries such as guava, netty, and protobuf. The mainline HBase project\nrelies on the relocated versions of these libraries gotten from hbase-thirdparty\nrather than on finding these classes in their usual locations. We do this so\nwe can specify whatever the version we wish. If we don't relocate, we must\nharmonize our version to match that which hadoop, spark, and other projects use.\n\nFor developers, this means you need to be careful referring to classes from\nnetty, guava, protobuf, gson, etc. (see the hbase-thirdparty pom.xml for what\nit provides). Devs must refer to the hbase-thirdparty provided classes. In\npractice, this is usually not an issue (though it can be a bit of a pain). You\nwill have to hunt for the relocated version of your particular class. You'll\nfind it by prepending the general relocation prefix of `org.apache.hbase.thirdparty.`.\nFor example if you are looking for `com.google.protobuf.Message`, the relocated\nversion used by HBase internals can be found at\n`org.apache.hbase.thirdparty.com.google.protobuf.Message`.\n\nFor a few thirdparty libs, like protobuf (see the protobuf chapter in this book\nfor the why), your IDE may give you both options — the `com.google.protobuf.*`\nand the `org.apache.hbase.thirdparty.com.google.protobuf.*` — because both\nclasses are on your CLASSPATH. Unless you are doing the particular juggling\nrequired in Coprocessor Endpoint development (again see above cited protobuf\nchapter), you'll want to use the shaded version, always.\n\nThe `hbase-thirdparty` project has groupid of `org.apache.hbase.thirdparty`.\nAs of this writing, it provides three jars; one for netty with an artifactid of\n`hbase-thirdparty-netty`, one for protobuf at `hbase-thirdparty-protobuf` and then\na jar for all else — gson, guava — at `hbase-thirdpaty-miscellaneous`.\n\nThe hbase-thirdparty artifacts are a product produced by the Apache HBase\nproject under the aegis of the HBase Project Management Committee. Releases\nare done via the usual voting project on the hbase dev mailing list. If issue\nin the hbase-thirdparty, use the hbase JIRA and mailing lists to post notice.\n\n## Development of HBase-related Maven archetypes\n\nThe development of HBase-related Maven archetypes was begun with\n[HBASE-14876](https://issues.apache.org/jira/browse/HBASE-14876).\nFor an overview of the hbase-archetypes infrastructure and instructions\nfor developing new HBase-related Maven archetypes, please see\n`hbase/hbase-archetypes/README.md`.\n\n***\n\n# Unit Testing HBase Applications\n\nMuch of the information comes from [a community blog post about testing HBase applications](http://blog.cloudera.com/blog/2013/09/how-to-test-hbase-applications-using-popular-tools/).\nFor information on unit tests for HBase itself, see [hbase.tests](/docs/building-and-developing/tests).\n\nStarting from HBase 2.5.0, HBaseTestingUtility is deprecated and should only be used when writing UTs inside HBase.\nEnd users should use org.apache.hadoop.hbase.testing.TestingHBaseCluster instead.\n\n## JUnit\n\nHBase uses [JUnit](http://junit.org) for unit tests\n\nThis example will add unit tests to the following example class:\n\n```java\npublic class MyHBaseDAO {\n\n    public static void insertRecord(Table.getTable(table), HBaseTestObj obj)\n    throws Exception {\n        Put put = createPut(obj);\n        table.put(put);\n    }\n\n    private static Put createPut(HBaseTestObj obj) {\n        Put put = new Put(Bytes.toBytes(obj.getRowKey()));\n        put.add(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-1\"),\n                    Bytes.toBytes(obj.getData1()));\n        put.add(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-2\"),\n                    Bytes.toBytes(obj.getData2()));\n        return put;\n    }\n}\n```\n\nThe first step is to add JUnit dependencies to your Maven POM file:\n\n```xml\n<dependency>\n  <groupId>junit</groupId>\n  <artifactId>junit</artifactId>\n  <version>4.11</version>\n  <scope>test</scope>\n</dependency>\n```\n\nNext, add some unit tests to your code.\nTests are annotated with `@Test`.\nHere, the unit tests are in bold.\n\n```java\npublic class TestMyHbaseDAOData {\n  @Test\n  public void testCreatePut() throws Exception {\n  HBaseTestObj obj = new HBaseTestObj();\n  obj.setRowKey(\"ROWKEY-1\");\n  obj.setData1(\"DATA-1\");\n  obj.setData2(\"DATA-2\");\n  Put put = MyHBaseDAO.createPut(obj);\n  assertEquals(obj.getRowKey(), Bytes.toString(put.getRow()));\n  assertEquals(obj.getData1(), Bytes.toString(put.get(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-1\")).get(0).getValue()));\n  assertEquals(obj.getData2(), Bytes.toString(put.get(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-2\")).get(0).getValue()));\n  }\n}\n```\n\nThese tests ensure that your `createPut` method creates, populates, and returns a `Put` object with expected values.\nOf course, JUnit can do much more than this.\nFor an introduction to JUnit, see [https://github.com/junit-team/junit/wiki/Getting-started](https://github.com/junit-team/junit/wiki/Getting-started).\n\n## Mockito\n\nMockito is a mocking framework.\nIt goes further than JUnit by allowing you to test the interactions between objects without having to replicate the entire environment.\nYou can read more about Mockito at its project site, [https://code.google.com/p/mockito/](https://code.google.com/p/mockito/).\n\nYou can use Mockito to do unit testing on smaller units.\nFor instance, you can mock a `org.apache.hadoop.hbase.Server` instance or a `org.apache.hadoop.hbase.master.MasterServices` interface reference rather than a full-blown `org.apache.hadoop.hbase.master.HMaster`.\n\nThis example builds upon the example code in [unit.tests](/docs/unit-testing), to test the `insertRecord` method.\n\nFirst, add a dependency for Mockito to your Maven POM file.\n\n```xml\n<dependency>\n    <groupId>org.mockito</groupId>\n    <artifactId>mockito-core</artifactId>\n    <version>2.1.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\nNext, add a `@RunWith` annotation to your test class, to direct it to use Mockito.\n\n```java\n@RunWith(MockitoJUnitRunner.class)\npublic class TestMyHBaseDAO{\n  @Mock\n  Configuration config = HBaseConfiguration.create();\n  @Mock\n  Connection connection = ConnectionFactory.createConnection(config);\n  @Mock\n  private Table table;\n  @Captor\n  private ArgumentCaptor putCaptor;\n\n  @Test\n  public void testInsertRecord() throws Exception {\n    //return mock table when getTable is called\n    when(connection.getTable(TableName.valueOf(\"tablename\")).thenReturn(table);\n    //create test object and make a call to the DAO that needs testing\n    HBaseTestObj obj = new HBaseTestObj();\n    obj.setRowKey(\"ROWKEY-1\");\n    obj.setData1(\"DATA-1\");\n    obj.setData2(\"DATA-2\");\n    MyHBaseDAO.insertRecord(table, obj);\n    verify(table).put(putCaptor.capture());\n    Put put = putCaptor.getValue();\n\n    assertEquals(Bytes.toString(put.getRow()), obj.getRowKey());\n    assert(put.has(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-1\")));\n    assert(put.has(Bytes.toBytes(\"CF\"), Bytes.toBytes(\"CQ-2\")));\n    assertEquals(Bytes.toString(put.get(Bytes.toBytes(\"CF\"),Bytes.toBytes(\"CQ-1\")).get(0).getValue()), \"DATA-1\");\n    assertEquals(Bytes.toString(put.get(Bytes.toBytes(\"CF\"),Bytes.toBytes(\"CQ-2\")).get(0).getValue()), \"DATA-2\");\n  }\n}\n```\n\nThis code populates `HBaseTestObj` with \"ROWKEY-1\", \"DATA-1\", \"DATA-2\" as values.\nIt then inserts the record into the mocked table.\nThe Put that the DAO would have inserted is captured, and values are tested to verify that they are what you expected them to be.\n\nThe key here is to manage Connection and Table instance creation outside the DAO.\nThis allows you to mock them cleanly and test Puts as shown above.\nSimilarly, you can now expand into other operations such as Get, Scan, or Delete.\n\n## MRUnit\n\n[Apache MRUnit](https://mrunit.apache.org/) is a library that allows you to unit-test MapReduce jobs.\nYou can use it to test HBase jobs in the same way as other MapReduce jobs.\n\nGiven a MapReduce job that writes to an HBase table called `MyTest`, which has one column family called `CF`, the reducer of such a job could look like the following:\n\n```java\npublic class MyReducer extends TableReducer<Text, Text, ImmutableBytesWritable> {\n   public static final byte[] CF = \"CF\".getBytes();\n   public static final byte[] QUALIFIER = \"CQ-1\".getBytes();\n   public void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException {\n     //bunch of processing to extract data to be inserted, in our case, let's say we are simply\n     //appending all the records we receive from the mapper for this particular\n     //key and insert one record into HBase\n     StringBuffer data = new StringBuffer();\n     Put put = new Put(Bytes.toBytes(key.toString()));\n     for (Text val : values) {\n         data = data.append(val);\n     }\n     put.add(CF, QUALIFIER, Bytes.toBytes(data.toString()));\n     //write to HBase\n     context.write(new ImmutableBytesWritable(Bytes.toBytes(key.toString())), put);\n   }\n }\n```\n\nTo test this code, the first step is to add a dependency to MRUnit to your Maven POM file.\n\n```xml\n<dependency>\n   <groupId>org.apache.mrunit</groupId>\n   <artifactId>mrunit</artifactId>\n   <version>1.0.0 </version>\n   <scope>test</scope>\n</dependency>\n```\n\nNext, use the ReducerDriver provided by MRUnit, in your Reducer job.\n\n```java\npublic class MyReducerTest {\n    ReduceDriver<Text, Text, ImmutableBytesWritable, Writable> reduceDriver;\n    byte[] CF = \"CF\".getBytes();\n    byte[] QUALIFIER = \"CQ-1\".getBytes();\n\n    @Before\n    public void setUp() {\n      MyReducer reducer = new MyReducer();\n      reduceDriver = ReduceDriver.newReduceDriver(reducer);\n    }\n\n   @Test\n   public void testHBaseInsert() throws IOException {\n      String strKey = \"RowKey-1\", strValue = \"DATA\", strValue1 = \"DATA1\",\nstrValue2 = \"DATA2\";\n      List<Text> list = new ArrayList<Text>();\n      list.add(new Text(strValue));\n      list.add(new Text(strValue1));\n      list.add(new Text(strValue2));\n      //since in our case all that the reducer is doing is appending the records that the mapper\n      //sends it, we should get the following back\n      String expectedOutput = strValue + strValue1 + strValue2;\n     //Setup Input, mimic what mapper would have passed\n      //to the reducer and run test\n      reduceDriver.withInput(new Text(strKey), list);\n      //run the reducer and get its output\n      List<Pair<ImmutableBytesWritable, Writable>> result = reduceDriver.run();\n\n      //extract key from result and verify\n      assertEquals(Bytes.toString(result.get(0).getFirst().get()), strKey);\n\n      //extract value for CF/QUALIFIER and verify\n      Put a = (Put)result.get(0).getSecond();\n      String c = Bytes.toString(a.get(CF, QUALIFIER).get(0).getValue());\n      assertEquals(expectedOutput,c );\n   }\n}\n```\n\nYour MRUnit test verifies that the output is as expected, the Put that is inserted into HBase has the correct value, and the ColumnFamily and ColumnQualifier have the correct values.\n\nMRUnit includes a MapperDriver to test mapping jobs, and you can use MRUnit to test other operations, including reading from HBase, processing data, or writing to HDFS,\n\n## Integration Testing with an HBase Mini-Cluster\n\nHBase ships with HBaseTestingUtility, which makes it easy to write integration tests using a *mini-cluster*.\nThe first step is to add some dependencies to your Maven POM file.\nCheck the versions to be sure they are appropriate.\n\n```xml\n<properties>\n  <hbase.version>2.0.0-SNAPSHOT</hbase.version>\n</properties>\n\n<dependencies>\n  <dependency>\n    <groupId>org.apache.hbase</groupId>\n    <artifactId>hbase-testing-util</artifactId>\n    <version>${hbase.version}</version>\n    <scope>test</scope>\n  </dependency>\n</dependencies>\n```\n\nThis code represents an integration test for the MyDAO insert shown in [unit.tests](/docs/unit-testing).\n\n```java\npublic class MyHBaseIntegrationTest {\n    private static HBaseTestingUtility utility;\n    byte[] CF = \"CF\".getBytes();\n    byte[] CQ1 = \"CQ-1\".getBytes();\n    byte[] CQ2 = \"CQ-2\".getBytes();\n\n    @Before\n    public void setup() throws Exception {\n        utility = new HBaseTestingUtility();\n        utility.startMiniCluster();\n    }\n\n    @Test\n    public void testInsert() throws Exception {\n        Table table = utility.createTable(Bytes.toBytes(\"MyTest\"), CF);\n        HBaseTestObj obj = new HBaseTestObj();\n        obj.setRowKey(\"ROWKEY-1\");\n        obj.setData1(\"DATA-1\");\n        obj.setData2(\"DATA-2\");\n        MyHBaseDAO.insertRecord(table, obj);\n        Get get1 = new Get(Bytes.toBytes(obj.getRowKey()));\n        get1.addColumn(CF, CQ1);\n        Result result1 = table.get(get1);\n        assertEquals(Bytes.toString(result1.getRow()), obj.getRowKey());\n        assertEquals(Bytes.toString(result1.value()), obj.getData1());\n        Get get2 = new Get(Bytes.toBytes(obj.getRowKey()));\n        get2.addColumn(CF, CQ2);\n        Result result2 = table.get(get2);\n        assertEquals(Bytes.toString(result2.getRow()), obj.getRowKey());\n        assertEquals(Bytes.toString(result2.value()), obj.getData2());\n    }\n}\n```\n\nStarting from HBase 2.5.0, it is recommended to use TestingHBaseCluster instead.\n\n```java\npublic class MyHBaseIntegrationTest {\n\n  private TestingHBaseCluster cluster;\n\n  private Connection conn;\n\n  private Admin admin;\n\n  private TableName tableName = TableName.valueOf(\"MyTest\");\n\n  byte[] CF = \"CF\".getBytes();\n  byte[] CQ1 = \"CQ-1\".getBytes();\n  byte[] CQ2 = \"CQ-2\".getBytes();\n\n  @Before\n  public void setUp() throws Exception {\n    cluster = TestingHBaseCluster.create(TestingHBaseClusterOption.builder().build());\n    cluster.start();\n    conn = ConnectionFactory.createConnection(cluster.getConf());\n    admin = conn.getAdmin();\n    admin.createTable(TableDescriptorBuilder.newBuilder(tableName)\n      .setColumnFamily(ColumnFamilyDescriptorBuilder.of(CF)).build());\n  }\n\n  @After\n  public void tearDown() throws Exception {\n    admin.close();\n    conn.close();\n    cluster.stop();\n  }\n\n  @Test\n  public void testInsert() throws Exception {\n    try (Table table = conn.getTable(tableName)) {\n      HBaseTestObj obj = new HBaseTestObj();\n      obj.setRowKey(\"ROWKEY-1\");\n      obj.setData1(\"DATA-1\");\n      obj.setData2(\"DATA-2\");\n      MyHBaseDAO.insertRecord(table, obj);\n      Get get1 = new Get(Bytes.toBytes(obj.getRowKey()));\n      get1.addColumn(CF, CQ1);\n      Result result1 = table.get(get1);\n      assertEquals(Bytes.toString(result1.getRow()), obj.getRowKey());\n      assertEquals(Bytes.toString(result1.value()), obj.getData1());\n      Get get2 = new Get(Bytes.toBytes(obj.getRowKey()));\n      get2.addColumn(CF, CQ2);\n      Result result2 = table.get(get2);\n      assertEquals(Bytes.toString(result2.getRow()), obj.getRowKey());\n      assertEquals(Bytes.toString(result2.value()), obj.getData2());\n    }\n  }\n}\n```\n\nThis code creates an HBase mini-cluster and starts it.\nNext, it creates a table called `MyTest` with one column family, `CF`.\nA record is inserted, a Get is performed from the same table, and the insertion is verified.\n\n<Callout type=\"info\">\n  Starting the mini-cluster takes about 20-30 seconds, but that should be appropriate for\n  integration testing.\n</Callout>\n\nSee the paper at [HBase Case-Study: Using HBaseTestingUtility for Local Testing and Development](https://web.archive.org/web/20160214165147/http://blog.sematext.com/2010/08/30/hbase-case-study-using-hbasetestingutility-for-local-testing-development/) (2010) for more information about HBaseTestingUtility.\n\n***\n\n# Protobuf in HBase\n\n## Protobuf\n\nHBase uses Google's [protobufs](https://developers.google.com/protocol-buffers/) wherever\nit persists metadata — in the tail of hfiles or Cells written by\nHBase into the system hbase:meta table or when HBase writes znodes\nto zookeeper, etc. — and when it passes objects over the wire making\n[RPCs](/docs/rpc). HBase uses protobufs to describe the RPC\nInterfaces (Services) we expose to clients, for example the `Admin` and `Client`\nInterfaces that the RegionServer fields,\nor specifying the arbitrary extensions added by developers via our\n[Coprocessor Endpoint](/docs/cp) mechanism.\n\nWith protobuf, you describe serializations and services in a `.protos` file.\nYou then feed these descriptors to a protobuf tool, the `protoc` binary,\nto generate classes that can marshall and unmarshall the described serializations\nand field the specified Services.\n\nSee the `README.txt` in the HBase sub-modules for details on how\nto run the class generation on a per-module basis;\ne.g. see `hbase-protocol/README.txt` for how to generate protobuf classes\nin the hbase-protocol module.\n\nIn HBase, `.proto` files are either in the `hbase-protocol` module; a module\ndedicated to hosting the common proto files and the protoc generated classes\nthat HBase uses internally serializing metadata. For extensions to hbase\nsuch as REST or Coprocessor Endpoints that need their own descriptors; their\nprotos are located inside the function's hosting module: e.g. `hbase-rest`\nis home to the REST proto files and the `hbase-rsgroup` table grouping\nCoprocessor Endpoint has all protos that have to do with table grouping.\n\nProtos are hosted by the module that makes use of them. While\nthis makes it so generation of protobuf classes is distributed, done\nper module, we do it this way so modules encapsulate all to do with\nthe functionality they bring to hbase.\n\nExtensions whether REST or Coprocessor Endpoints will make use\nof core HBase protos found back in the hbase-protocol module. They'll\nuse these core protos when they want to serialize a Cell or a Put or\nrefer to a particular node via ServerName, etc., as part of providing the\nCPEP Service. Going forward, after the release of hbase-2.0.0, this\npractice needs to whither. We'll explain why in the later\n[hbase-2.0.0](/docs/protobuf#hbase-200-and-the-shading-of-protobufs-hbase-15638) section.\n\n### hbase-2.0.0 and the shading of protobufs (HBASE-15638)\n\nAs of hbase-2.0.0, our protobuf usage gets a little more involved. HBase\ncore protobuf references are offset so as to refer to a private,\nbundled protobuf. Core stops referring to protobuf\nclasses at com.google.protobuf.\\_ and instead references protobuf at\nthe HBase-specific offset\norg.apache.hadoop.hbase.shaded.com.google.protobuf.\\_. We do this indirection\nso hbase core can evolve its protobuf version independent of whatever our\ndependencies rely on. For instance, HDFS serializes using protobuf.\nHDFS is on our CLASSPATH. Without the above described indirection, our\nprotobuf versions would have to align. HBase would be stuck\non the HDFS protobuf version until HDFS decided to upgrade. HBase\nand HDFS versions would be tied.\n\nWe had to move on from protobuf-2.5.0 because we need facilities\nadded in protobuf-3.1.0; in particular being able to save on\ncopies and avoiding bringing protobufs onheap for\nserialization/deserialization.\n\nIn hbase-2.0.0, we introduced a new module, `hbase-protocol-shaded`\ninside which we contained all to do with protobuf and its subsequent\nrelocation/shading. This module is in essence a copy of much of the old\n`hbase-protocol` but with an extra shading/relocation step.\nCore was moved to depend on this new module.\n\nThat said, a complication arises around Coprocessor Endpoints (CPEPs).\nCPEPs depend on public HBase APIs that reference protobuf classes at\n`com.google.protobuf.*` explicitly. For example, in our Table Interface\nwe have the below as the means by which you obtain a CPEP Service\nto make invocations against:\n\n```java\n...\n  <T extends com.google.protobuf.Service,R> Map<byte[],R> coprocessorService(\n   Class<T> service, byte[] startKey, byte[] endKey,\n     org.apache.hadoop.hbase.client.coprocessor.Batch.Call<T,R> callable)\n  throws com.google.protobuf.ServiceException, Throwable\n```\n\nExisting CPEPs will have made reference to core HBase protobufs\nspecifying ServerNames or carrying Mutations.\nSo as to continue being able to service CPEPs and their references\nto `com.google.protobuf.*` across the upgrade to hbase-2.0.0 and beyond,\nHBase needs to be able to deal with both\n`com.google.protobuf.*` references and its internal offset\n`org.apache.hadoop.hbase.shaded.com.google.protobuf.*` protobufs.\n\nThe `hbase-protocol-shaded` module hosts all\nprotobufs used by HBase core.\n\nBut for the vestigial CPEP references to the (non-shaded) content of\n`hbase-protocol`, we keep around most of this module going forward\njust so it is available to CPEPs. Retaining the most of `hbase-protocol`\nmakes for overlapping, 'duplicated' proto instances where some exist as\nnon-shaded/non-relocated here in their old module\nlocation but also in the new location, shaded under\n`hbase-protocol-shaded`. In other words, there is an instance\nof the generated protobuf class\n`org.apache.hadoop.hbase.protobuf.generated.ServerName`\nin hbase-protocol and another generated instance that is the same in all\nregards except its protobuf references are to the internal shaded\nversion at `org.apache.hadoop.hbase.shaded.protobuf.generated.ServerName`\n(note the 'shaded' addition in the middle of the package name).\n\nIf you extend a proto in `hbase-protocol-shaded` for internal use,\nconsider extending it also in\n`hbase-protocol` (and regenerating).\n\nGoing forward, we will provide a new module of common types for use\nby CPEPs that will have the same guarantees against change as does our\npublic API. TODO.\n\n### protobuf changes for hbase-3.0.0 (HBASE-23797)\n\nSince hadoop(start from 3.3.x) also shades protobuf and bumps the version to\n3.x, there is no reason for us to stay on protobuf 2.5.0 any more.\n\nIn HBase 3.0.0, the hbase-protocol module has been purged, the CPEP\nimplementation should use the protos in hbase-protocol-shaded module, and also\nmake use of the shaded protobuf in hbase-thirdparty. In general, we will keep\nthe protobuf version compatible for a whole major release, unless there are\ncritical problems, for example, a critical CVE on protobuf.\n\nAdd this dependency to your pom:\n\n```xml\n<dependency>\n  <groupId>org.apache.hbase.thirdparty</groupId>\n  <artifactId>hbase-shaded-protobuf</artifactId>\n  <!-- use the version that your target hbase cluster uses -->\n  <version>${hbase-thirdparty.version}</version>\n  <scope>provided</scope>\n</dependency>\n```\n\nAnd typically you also need to add this plugin to your pom to make your\ngenerated protobuf code also use the shaded and relocated protobuf version\nin hbase-thirdparty.\n\n```xml\n<plugin>\n  <groupId>com.google.code.maven-replacer-plugin</groupId>\n  <artifactId>replacer</artifactId>\n  <version>1.5.3</version>\n  <executions>\n    <execution>\n      <phase>process-sources</phase>\n      <goals>\n        <goal>replace</goal>\n      </goals>\n    </execution>\n  </executions>\n  <configuration>\n    <basedir>${basedir}/target/generated-sources/</basedir>\n      <includes>\n        <include>**/*.java</include>\n      </includes>\n      <!-- Ignore errors when missing files, because it means this build\n           was run with -Dprotoc.skip and there is no -Dreplacer.skip -->\n      <ignoreErrors>true</ignoreErrors>\n      <replacements>\n        <replacement>\n          <token>([^\\.])com.google.protobuf</token>\n          <value>$1org.apache.hbase.thirdparty.com.google.protobuf</value>\n        </replacement>\n        <replacement>\n          <token>(public)(\\W+static)?(\\W+final)?(\\W+class)</token>\n          <value>@javax.annotation.Generated(\"proto\") $1$2$3$4</value>\n        </replacement>\n        <!-- replacer doesn't support anchoring or negative lookbehind -->\n        <replacement>\n          <token>(@javax.annotation.Generated\\(\"proto\"\\) ){2}</token>\n          <value>$1</value>\n        </replacement>\n      </replacements>\n  </configuration>\n</plugin>\n```\n\nIn hbase-examples module, we have some examples under the\n`org.apache.hadoop.hbase.coprocessor.example` package. You can see\n`BulkDeleteEndpoint` and `BulkDelete.proto` for more details, and you can also\ncheck the `pom.xml` of hbase-examples module to see how to make use of the above\nplugin.\n\n***\n\n# Procedure Framework (Pv2)\n\nSee [HBASE-12439](https://issues.apache.org/jira/browse/HBASE-12439) for the original implementation.\n\nWith Pv2 you can build and run state machines. It was built by Matteo to make distributed state transitions in HBase resilient in the face of process failures. Previous to Pv2, state transition handling was spread about the codebase with implementation varying by transition-type and context. Pv2 was inspired by [FATE](https://accumulo.apache.org/1.8/accumulo_user_manual.html#_fault_tolerant_executor_fate), of Apache Accumulo.\n\nEarly Pv2 aspects have been shipping in HBase with a good while now but it has continued to evolve as it takes on more involved scenarios. What we have now is powerful but intricate in operation and incomplete, in need of cleanup and hardening. In this doc we have given overview on the system so you can make use of it (and help with its polishing).\n\nThis system has the awkward name of Pv2 because HBase already had the notion of a Procedure used in snapshots (see hbase-server *org.apache.hadoop.hbase.procedure* as opposed to hbase-procedure *org.apache.hadoop.hbase.procedure2*). Pv2 supercedes and is to replace Procedure.\n\n## Procedures\n\nA Procedure is a transform made on an HBase entity. Examples of HBase entities would be Regions and Tables.\nProcedures are run by a ProcedureExecutor instance. Procedure current state is kept in the ProcedureStore.\nThe ProcedureExecutor has but a primitive view on what goes on inside a Procedure. From its PoV, Procedures are submitted and then the ProcedureExecutor keeps calling *#execute(Object)* until the Procedure is done. Execute may be called multiple times in the case of failure or restart, so Procedure code must be idempotent yielding the same result each time it run. Procedure code can also implement *rollback* so steps can be undone if failure. A call to *execute()* can result in one of following possibilities:\n\n* *execute()* returns\n  * *null*: indicates we are done.\n  * *this*: indicates there is more to do so, persist current procedure state and re-*execute()*.\n  * *Array* of sub-procedures: indicates a set of procedures needed to be run to completion before we can proceed (after which we expect the framework to call our execute again).\n* *execute()* throws exception\n  * *suspend*: indicates execution of procedure is suspended and can be resumed due to some external event. The procedure state is persisted.\n  * *yield*: procedure is added back to scheduler. The procedure state is not persisted.\n  * *interrupted*: currently same as *yield*.\n  * Any *exception* not listed above: Procedure *state* is changed to *FAILED* (after which we expect the framework will attempt rollback).\n\nThe ProcedureExecutor stamps the frameworks notions of Procedure State into the Procedure itself; e.g. it marks Procedures as INITIALIZING on submit. It moves the state to RUNNABLE when it goes to execute. When done, a Procedure gets marked FAILED or SUCCESS depending. Here is the list of all states as of this writing:\n\n* ***INITIALIZING*** Procedure in construction, not yet added to the executor\n* ***RUNNABLE*** Procedure added to the executor, and ready to be executed.\n* ***WAITING*** The procedure is waiting on children (subprocedures) to be completed\n* ***WAITING\\_TIMEOUT*** The procedure is waiting a timeout or an external event\n* ***ROLLEDBACK*** The procedure failed and was rolledback.\n* ***SUCCESS*** The procedure execution completed successfully.\n* ***FAILED*** The procedure execution failed, may need to rollback.\n\nAfter each execute, the Procedure state is persisted to the ProcedureStore. Hooks are invoked on Procedures so they can preserve custom state. Post-fault, the ProcedureExecutor re-hydrates its pre-crash state by replaying the content of the ProcedureStore. This makes the Procedure Framework resilient against process failure.\n\n### Implementation\n\nIn implementation, Procedures tend to divide transforms into finer-grained tasks and while some of these work items are handed off to sub-procedures,\nthe bulk are done as processing *steps* in-Procedure; each invocation of the execute is used to perform a single step, and then the Procedure relinquishes returning to the framework. The Procedure does its own tracking of where it is in the processing.\n\nWhat comprises a sub-task, or *step* in the execution is up to the Procedure author but generally it is a small piece of work that cannot be further decomposed and that moves the processing forward toward its end state. Having procedures made of many small steps rather than a few large ones allows the Procedure framework give out insight on where we are in the processing. It also allows the framework be more fair in its execution. As stated per above, each step may be called multiple times (failure/restart) so steps must be implemented idempotent.\nIt is easy to confuse the state that the Procedure itself is keeping with that of the Framework itself. Try to keep them distinct.\n\n### Rollback\n\nRollback is called when the procedure or one of the sub-procedures has failed. The rollback step is supposed to cleanup the resources created during the execute() step. In case of failure and restart, rollback() may be called multiple times, so again the code must be idempotent.\n\n### Metrics\n\nThere are hooks for collecting metrics on submit of the procedure and on finish.\n\n* updateMetricsOnSubmit()\n* updateMetricsOnFinish()\n\nIndividual procedures can override these methods to collect procedure specific metrics. The default implementations of these methods try to get an object implementing an interface ProcedureMetrics which encapsulates following set of generic metrics:\n\n* SubmittedCount (Counter): Total number of procedure instances submitted of a type.\n* Time (Histogram): Histogram of runtime for procedure instances.\n* FailedCount (Counter): Total number of failed procedure instances.\n\nIndividual procedures can implement this object and define these generic set of metrics.\n\n### Baggage\n\nProcedures can carry baggage. One example is the *step* the procedure last attained (see previous section); procedures persist the enum that marks where they are currently. Other examples might be the Region or Server name the Procedure is currently working. After each call to execute, the Procedure#serializeStateData is called. Procedures can persist whatever.\n\n### Result/State and Queries\n\n(From Matteo's [ProcedureV2 and Notification Bus](https://issues.apache.org/jira/secure/attachment/12693273/Procedurev2Notification-Bus.pdf) doc)\\\nIn the case of asynchronous operations, the result must be kept around until the client asks for it. Once we receive a \"get\" of the result we can schedule the delete of the record. For some operations the result may be \"unnecessary\" especially in case of failure (e.g. if the create table fail, we can query the operation result or we can just do a list table to see if it was created) so in some cases we can schedule the delete after a timeout. On the client side the operation will return a \"Procedure ID\", this ID can be used to wait until the procedure is completed and get the result/exception.\n\n```\nAdmin.doOperation() { longprocId=master.doOperation(); master.waitCompletion(procId); }\n```\n\nIf the master goes down while performing the operation the backup master will pickup the half in­progress operation and complete it. The client will not notice the failure.\n\n## Subprocedures\n\nSubprocedures are *Procedure* instances created and returned by *#execute(Object)* method of a procedure instance (parent procedure). As subprocedures are of type *Procedure*, they can instantiate their own subprocedures. As its a recursive, procedure stack is maintained by the framework. The framework makes sure that the parent procedure does not proceed till all sub-procedures and their subprocedures in a procedure stack are successfully finished.\n\n## ProcedureExecutor\n\n*ProcedureExecutor* uses *ProcedureStore* and *ProcedureScheduler* and executes procedures submitted to it. Some of the basic operations supported are:\n\n* *abort(procId)*: aborts specified procedure if its not finished\n* *submit(Procedure)*: submits procedure for execution\n* *retrieve:* list of get methods to get *Procedure* instances and results\n* *register/ unregister* listeners: for listening on Procedure related notifications\n\nWhen *ProcedureExecutor* starts it loads procedure instances persisted in *ProcedureStore* from previous run. All unfinished procedures are resumed from the last stored state.\n\n## Nonces\n\nYou can pass the nonce that came in with the RPC to the Procedure on submit at the executor. This nonce will then be serialized along w/ the Procedure on persist. If a crash, on reload, the nonce will be put back into a map of nonces to pid in case a client tries to run same procedure for a second time (it will be rejected). See the base Procedure and how nonce is a base data member.\n\n## Wait/Wake/Suspend/Yield\n\n'suspend' means stop processing a procedure because we can make no more progress until a condition changes; i.e. we sent RPC and need to wait on response. The way this works is that a Procedure throws a suspend exception from down in its guts as a GOTO the end-of-the-current-processing step. Suspend also puts the Procedure back on the scheduler. Problematic is we do some accounting on our way out even on suspend making it so it can take time exiting (We have to update state in the WAL).\n\nRegionTransitionProcedure#reportTransition is called on receipt of a report from a RS. For Assign and Unassign, this event response from the server we sent an RPC wakes up suspended Assign/Unassigns.\n\n## Locking\n\nProcedure Locks are not about concurrency! They are about giving a Procedure read/write access to an HBase Entity such as a Table or Region so that is possible to shut out other Procedures from making modifications to an HBase Entity state while the current one is running.\n\nLocking is optional, up to the Procedure implementor but if an entity is being operated on by a Procedure, all transforms need to be done via Procedures using the same locking scheme else havoc.\n\nTwo ProcedureExecutor Worker threads can actually end up both processing the same Procedure instance. If it happens, the threads are meant to be running different parts of the one Procedure — changes that do not stamp on each other (This gets awkward around the procedure frameworks notion of ‘suspend'. More on this below).\n\nLocks optionally may be held for the life of a Procedure. For example, if moving a Region, you probably want to have exclusive access to the HBase Region until the Region completes (or fails). This is used in conjunction with \\{@link #holdLock(Object)}. If \\{@link #holdLock(Object)} returns true, the procedure executor will call acquireLock() once and thereafter not call \\{@link #releaseLock(Object)} until the Procedure is done (Normally, it calls release/acquire around each invocation of \\{@link #execute(Object)}.\n\nLocks also may live the life of a procedure; i.e. once an Assign Procedure starts, we do not want another procedure meddling w/ the region under assignment. Procedures that hold the lock for the life of the procedure set Procedure#holdLock to true. AssignProcedure does this as do Split and Move (If in the middle of a Region move, you do not want it Splitting).\n\nLocking can be for life of Procedure.\n\nSome locks have a hierarchy. For example, taking a region lock also takes (read) lock on its containing table and namespace to prevent another Procedure obtaining an exclusive lock on the hosting table (or namespace).\n\n## Procedure Types\n\n### StateMachineProcedure\n\nOne can consider each call to *#execute(Object)* method as transitioning from one state to another in a state machine. Abstract class *StateMachineProcedure* is wrapper around base *Procedure* class which provides constructs for implementing a state machine as a *Procedure*. After each state transition current state is persisted so that, in case of crash/ restart, the state transition can be resumed from the previous state of a procedure before crash/ restart. Individual procedures need to define initial and terminus states and hooks *executeFromState()* and *setNextState()* are provided for state transitions.\n\n### RemoteProcedureDispatcher\n\nA new RemoteProcedureDispatcher (+ subclass RSProcedureDispatcher) primitive takes care of running the Procedure-based Assignments 'remote' component. This dispatcher knows about 'servers'. It does aggregation of assignments by time on a time/count basis so can send procedures in batches rather than one per RPC. Procedure status comes back on the back of the RegionServer heartbeat reporting online/offline regions (No more notifications via ZK). The response is passed to the AMv2 to 'process'. It will check against the in-memory state. If there is a mismatch, it fences out the RegionServer on the assumption that something went wrong on the RS side. Timeouts trigger retries (Not Yet Implemented!). The Procedure machine ensures only one operation at a time on any one Region/Table using entity *locking* and smarts about what is serial and what can be run concurrently (Locking was zk-based — you'd put a znode in zk for a table — but now has been converted to be procedure-based as part of this project).\n\n## References\n\n* Matteo had a slide deck on what it the Procedure Framework would look like and the problems it addresses initially [attached to the Pv2 issue.](https://issues.apache.org/jira/secure/attachment/12845124/ProcedureV2b.pdf)\n* [A good doc by Matteo](https://issues.apache.org/jira/secure/attachment/12693273/Procedurev2Notification-Bus.pdf) on problem and how Pv2 addresses it w/ roadmap (from the Pv2 JIRA). We should go back to the roadmap to do the Notification Bus, convertion of log splitting to Pv2, etc.\n\n***\n\n# AMv2 Description for Devs\n\nThe AMv2 project is a redo of Assignment in an attempt at addressing the root cause of many of our operational issues in production, namely slow assignment and problematic accounting such that Regions are misplaced stuck offline in the notorious *Regions-In-Transition (RIT)* limbo state.\n\nBelow are notes for devs on key aspects of AMv2 in no particular order.\n\n## Background\n\nAssignment in HBase 1.x has been problematic in operation. It is not hard to see why. Region state is kept at the other end of an RPC in ZooKeeper (Terminal states — i.e. OPEN or CLOSED — are published to the *hbase:meta* table). In HBase-1.x.x, state has multiple writers with Master and RegionServers all able to make state edits concurrently (in *hbase:meta* table and out on ZooKeeper). If clocks are awry or watchers missed, state changes can be skipped or overwritten. Locking of HBase Entities — tables, regions — is not comprehensive so a table operation — disable/enable — could clash with a region-level operation; a split or merge. Region state is distributed and hard to reason about and test. Assignment is slow in operation because each assign involves moving remote znodes through transitions. Cluster size tends to top out at a couple of hundred thousand regions; beyond this, cluster start/stop takes hours and is prone to corruption.\n\nAMv2 (AssignmentManager Version 2) is a refactor ([HBASE-14350](https://issues.apache.org/jira/browse/HBASE-14350)) of the hbase-1.x AssignmentManager putting it up on a [ProcedureV2 (HBASE-12439)](https://issues.apache.org/jira/browse/HBASE-12439) basis. ProcedureV2 (Pv2), is an awkwardly named system that allows describing and running multi-step state machines. It is performant and persists all state to a Store which is recoverable post crash. See the companion chapter on [Procedure Framework (Pv2)](/docs/pv2), to learn more about the ProcedureV2 system.\n\nIn AMv2, all assignment, crash handling, splits and merges are recast as Procedures(v2). ZooKeeper is purged from the mix. As before, the final assignment state gets published to *hbase:meta* for non-Master participants to read (all-clients) with intermediate state kept in the local Pv2 WAL-based 'store' but only the active Master, a single-writer, evolves state. The Master's in-memory cluster image is the authority and if disagreement, RegionServers are forced to comply. Pv2 adds shared/exclusive locking of all core HBase Entities — namespace, tables, and regions — to ensure one actor at a time access and to prevent operations contending over resources (move/split, disable/assign, etc.).\n\nThis redo of AM atop of a purposed, performant state machine with all operations taking on the common Procedure form with a single state writer only moves our AM to a new level of resilience and scale.\n\n## New System\n\nEach Region Assign or Unassign of a Region is now a Procedure. A Move (Region) Procedure is a compound of Procedures; it is the running of an Unassign Procedure followed by an Assign Procedure. The Move Procedure spawns the Assign and Unassign in series and then waits on their completions.\n\nAnd so on. ServerCrashProcedure spawns the WAL splitting tasks and then the reassign of all regions that were hosted on the crashed server as subprocedures.\n\nAMv2 Procedures are run by the Master in a ProcedureExecutor instance. All Procedures make use of utility provided by the Pv2 framework.\n\nFor example, Procedures persist each state transition to the frameworks' Procedure Store. The default implementation is done as a WAL kept on HDFS. On crash, we reopen the Store and rerun all WALs of Procedure transitions to put the Assignment State Machine back into the attitude it had just before crash. We then continue Procedure execution.\n\nIn the new system, the Master is the Authority on all things Assign. Previous we were ambiguous; e.g. the RegionServer was in charge of Split operations. Master keeps an in-memory image of Region states and servers. If disagreement, the Master always prevails; at an extreme it will kill the RegionServer that is in disagreement.\n\nA new RegionStateStore class takes care of publishing the terminal Region state, whether OPEN or CLOSED, out to the *hbase:meta* table.\n\nRegionServers now report their run version on Connection. This version is available inside the AM for use running migrating rolling restarts.\n\n## Procedures Detail\n\n### Assign/Unassign\n\nAssign and Unassign subclass a common RegionTransitionProcedure. There can only be one RegionTransitionProcedure per region running at a time since the RTP instance takes a lock on the region. The RTP base Procedure has three steps; a store the procedure step (REGION\\_TRANSITION\\_QUEUE); a dispatch of the procedure open or close followed by a suspend waiting on the remote regionserver to report successful open or fail (REGION\\_TRANSITION\\_DISPATCH) or notification that the server fielding the request crashed; and finally registration of the successful open/close in hbase:meta (REGION\\_TRANSITION\\_FINISH).\n\nHere is how the assign of a region 56f985a727afe80a184dac75fbf6860c looks in the logs. The assign was provoked by a Server Crash (Process ID 1176 or pid=1176 which when it is the parent of a procedure, it is identified as ppid=1176). The assign is pid=1179, the second region of the two being assigned by this Server Crash.\n\n```\n2017-05-23 12:04:24,175 INFO  [ProcExecWrkr-30] procedure2.ProcedureExecutor: Initialized subprocedures=[{pid=1178, ppid=1176, state=RUNNABLE:REGION_TRANSITION_QUEUE; AssignProcedure table=IntegrationTestBigLinkedList, region=bfd57f0b72fd3ca77e9d3c5e3ae48d76, target=ve0540.halxg.example.org,16020,1495525111232}, {pid=1179, ppid=1176, state=RUNNABLE:REGION_TRANSITION_QUEUE; AssignProcedure table=IntegrationTestBigLinkedList, region=56f985a727afe80a184dac75fbf6860c, target=ve0540.halxg.example.org,16020,1495525111232}]\n```\n\nNext we start the assign by queuing ('registering') the Procedure with the framework.\n\n```\n2017-05-23 12:04:24,241 INFO  [ProcExecWrkr-30] assignment.AssignProcedure: Start pid=1179, ppid=1176, state=RUNNABLE:REGION_TRANSITION_QUEUE; AssignProcedure table=IntegrationTestBigLinkedList, region=56f985a727afe80a184dac75fbf6860c, target=ve0540.halxg.example.org,16020,1495525111232; rit=OFFLINE, location=ve0540.halxg.example.org,16020,1495525111232; forceNewPlan=false, retain=false\n```\n\nTrack the running of Procedures in logs by tracing their process id — here pid=1179.\n\nNext we move to the dispatch phase where we update hbase:meta table setting the region state as OPENING on server ve540. We then dispatch an rpc to ve540 asking it to open the region. Thereafter we suspend the Assign until we get a message back from ve540 on whether it has opened the region successfully (or not).\n\n```\n2017-05-23 12:04:24,494 INFO  [ProcExecWrkr-38] assignment.RegionStateStore: pid=1179 updating hbase:meta row=IntegrationTestBigLinkedList,H\\xE3@\\x8D\\x964\\x9D\\xDF\\x8F@9\\x0F\\xC8\\xCC\\xC2,1495566261066.56f985a727afe80a184dac75fbf6860c., regionState=OPENING, regionLocation=ve0540.halxg.example.org,16020,1495525111232\n2017-05-23 12:04:24,498 INFO  [ProcExecWrkr-38] assignment.RegionTransitionProcedure: Dispatch pid=1179, ppid=1176, state=RUNNABLE:REGION_TRANSITION_DISPATCH; AssignProcedure table=IntegrationTestBigLinkedList, region=56f985a727afe80a184dac75fbf6860c, target=ve0540.halxg.example.org,16020,1495525111232; rit=OPENING, location=ve0540.halxg.example.org,16020,1495525111232\n```\n\nBelow we log the incoming report that the region opened successfully on ve540. The Procedure is woken up (you can tell it the procedure is running by the name of the thread, its a ProcedureExecutor thread, ProcExecWrkr-9). The woken up Procedure updates state in hbase:meta to denote the region as open on ve0540. It then reports finished and exits.\n\n```\n2017-05-23 12:04:26,643 DEBUG [RpcServer.default.FPBQ.Fifo.handler=46,queue=1,port=16000] assignment.RegionTransitionProcedure: Received report OPENED seqId=11984985, pid=1179, ppid=1176, state=RUNNABLE:REGION_TRANSITION_DISPATCH; AssignProcedure table=IntegrationTestBigLinkedList, region=56f985a727afe80a184dac75fbf6860c, target=ve0540.halxg.example.org,16020,1495525111232; rit=OPENING, location=ve0540.halxg.example.org,16020,1495525111232\n2017-05-23 12:04:26,643 INFO  [ProcExecWrkr-9] assignment.RegionStateStore: pid=1179 updating hbase:meta row=IntegrationTestBigLinkedList,H\\xE3@\\x8D\\x964\\x9D\\xDF\\x8F@9\\x0F\\xC8\\xCC\\xC2,1495566261066.56f985a727afe80a184dac75fbf6860c., regionState=OPEN, openSeqNum=11984985, regionLocation=ve0540.halxg.example.org,16020,1495525111232\n2017-05-23 12:04:26,836 INFO  [ProcExecWrkr-9] procedure2.ProcedureExecutor: Finish suprocedure pid=1179, ppid=1176, state=SUCCESS; AssignProcedure table=IntegrationTestBigLinkedList, region=56f985a727afe80a184dac75fbf6860c, target=ve0540.halxg.example.org,16020,1495525111232\n```\n\nUnassign looks similar given it is based on the base RegionTransitionProcedure. It has the same state transitions and does basically the same steps but with different state name (CLOSING, CLOSED).\n\nMost other procedures are subclasses of a Pv2 StateMachine implementation. We have both Table and Region focused StateMachines types.\n\n## UI\n\nAlong the top-bar on the Master, you can now find a 'Procedures\\&Locks' tab which takes you to a page that is ugly but useful. It dumps currently running procedures and framework locks. Look at this when you can't figure what stuff is stuck; it will at least identify problematic procedures (take the pid and grep the logs...). Look for ROLLEDBACK or pids that have been RUNNING for a long time.\n\n## Logging\n\nProcedures log their process ids as pid= and their parent ids (ppid=) everywhere. Work has been done so you can grep the pid and see history of a procedure operation.\n\n## Implementation Notes\n\nIn this section we note some idiosyncrasies of operation as an attempt at saving you some head-scratching.\n\n### Region Transition RPC and RS Heartbeat can arrive at \\~same time on Master\n\nReporting Region Transition on a RegionServer is now a RPC distinct from RS heartbeating ('RegionServerServices' Service). An heartbeat and a status update can arrive at the Master at about the same time. The Master will update its internal state for a Region but this same state is checked when heartbeat processing. We may find the unexpected; i.e. a Region just reported as CLOSED so heartbeat is surprised to find region OPEN on the back of the RS report. In the new system, all slaves must cow to the Masters' understanding of cluster state; the Master will kill/close any misaligned entities.\n\nTo address the above, we added a lastUpdate for in-memory Master state. Let a region state have some vintage before we act on it (one second currently).\n\n### Master as RegionServer or as RegionServer that just does system tables\n\nAMv2 enforces current master branch default of HMaster carrying system tables only; i.e. the Master in an HBase cluster acts also as a RegionServer only it is the exclusive host for tables such as *hbase:meta*, *hbase:namespace*, etc., the core system tables. This is causing a couple of test failures as AMv1, though it is not supposed to, allows moving hbase:meta off Master while AMv2 does not.\n\n## New Configs\n\nThese configs all need doc on when you'd change them.\n\n#### hbase.procedure.remote.dispatcher.threadpool.size \\[!toc]\n\nDefaults 128\n\n#### hbase.procedure.remote.dispatcher.delay.msec \\[!toc]\n\nDefault 150ms\n\n#### hbase.procedure.remote.dispatcher.max.queue.size \\[!toc]\n\nDefault 32\n\n#### hbase.regionserver.rpc.startup.waittime \\[!toc]\n\nDefault 60 seconds.\n\n## Tools\n\nHBASE-15592 Print Procedure WAL Content\n\nPatch in [HBASE-18152](https://issues.apache.org/jira/browse/HBASE-18152) \\[AMv2] Corrupt Procedure WAL file; procedure data stored out of order [https://issues.apache.org/jira/secure/attachment/12871066/reading\\_bad\\_wal.patch](https://issues.apache.org/jira/secure/attachment/12871066/reading_bad_wal.patch)\n\n### MasterProcedureSchedulerPerformanceEvaluation\n\nTool to test performance of locks and queues in procedure scheduler independently from other framework components. Run this after any substantial changes in proc system. Prints nice output:\n\n```text\n******************************************\nTime - addBack     : 5.0600sec\nOps/sec - addBack  : 1.9M\nTime - poll        : 19.4590sec\nOps/sec - poll     : 501.9K\nNum Operations     : 10000000\n\nCompleted          : 10000006\nYield              : 22025876\n\nNum Tables         : 5\nRegions per table  : 10\nOperations type    : both\nThreads            : 10\n******************************************\nRaw format for scripts\n\nRESULT [num_ops=10000000, ops_type=both, num_table=5, regions_per_table=10, threads=10, num_yield=22025876, time_addback_ms=5060, time_poll_ms=19459]\n```\n\n***\n\n# ZooKeeper\n\nApache HBase by default manages a ZooKeeper \"cluster\" for you.\nIt will start and stop the ZooKeeper ensemble as part of the HBase start/stop process.\nYou can also manage the ZooKeeper ensemble independent of HBase and just point HBase at the cluster it should use.\nTo toggle HBase management of ZooKeeper, use the `HBASE_MANAGES_ZK` variable in *conf/hbase-env.sh*.\nThis variable, which defaults to `true`, tells HBase whether to start/stop the ZooKeeper ensemble servers as part of HBase start/stop.\n\nWhen HBase manages the ZooKeeper ensemble, you can specify ZooKeeper configuration directly in *conf/hbase-site.xml*.\nA ZooKeeper configuration option can be set as a property in the HBase *hbase-site.xml* XML configuration file by prefacing the ZooKeeper option name with `hbase.zookeeper.property`.\nFor example, the `clientPort` setting in ZooKeeper can be changed by setting the `hbase.zookeeper.property.clientPort` property.\nFor all default values used by HBase, including ZooKeeper configuration, see [hbase default configurations](/docs/configuration/default#configuration-default-hbase-default-configuration).\nLook for the `hbase.zookeeper.property` prefix.\nFor the full list of ZooKeeper configurations, see ZooKeeper's *zoo.cfg*.\nHBase does not ship with a *zoo.cfg* so you will need to browse the *conf* directory in an appropriate ZooKeeper download.\n\nYou must at least list the ensemble servers in *hbase-site.xml* using the `hbase.zookeeper.quorum` property.\nThis property defaults to a single ensemble member at `localhost` which is not suitable for a fully distributed HBase.\n(It binds to the local machine only and remote clients will not be able to connect).\n\n<Callout type=\"info\" title=\"How many ZooKeepers should I run?\">\n  You can run a ZooKeeper ensemble that comprises 1 node only but in production it is recommended that you run a ZooKeeper ensemble of 3, 5 or 7 machines; the more members an ensemble has, the more tolerant the ensemble is of host failures.\n  Also, run an odd number of machines.\n  In ZooKeeper, an even number of peers is supported, but it is normally not used because an even sized ensemble requires, proportionally, more peers to form a quorum than an odd sized ensemble requires.\n  For example, an ensemble with 4 peers requires 3 to form a quorum, while an ensemble with 5 also requires 3 to form a quorum.\n  Thus, an ensemble of 5 allows 2 peers to fail, and thus is more fault tolerant than the ensemble of 4, which allows only 1 down peer.\n\n  Give each ZooKeeper server around 1GB of RAM, and if possible, its own dedicated disk (A dedicated disk is the best thing you can do to ensure a performant ZooKeeper ensemble). For very heavily loaded clusters, run ZooKeeper servers on separate machines from RegionServers (DataNodes and TaskTrackers).\n</Callout>\n\nFor example, to have HBase manage a ZooKeeper quorum on nodes *rs\\{1,2,3,4,5}.example.com*, bound to port 2222 (the default is 2181) ensure `HBASE_MANAGE_ZK` is commented out or set to `true` in *conf/hbase-env.sh* and then edit *conf/hbase-site.xml* and set `hbase.zookeeper.property.clientPort` and `hbase.zookeeper.quorum`.\nYou should also set `hbase.zookeeper.property.dataDir` to other than the default as the default has ZooKeeper persist data under */tmp* which is often cleared on system restart.\nIn the example below we have ZooKeeper persist to */user/local/zookeeper*.\n\n```xml\n<configuration>\n  ...\n  <property>\n    <name>hbase.zookeeper.property.clientPort</name>\n    <value>2222</value>\n    <description>Property from ZooKeeper's config zoo.cfg.\n    The port at which the clients will connect.\n    </description>\n  </property>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>rs1.example.com,rs2.example.com,rs3.example.com,rs4.example.com,rs5.example.com</value>\n    <description>Comma separated list of servers in the ZooKeeper Quorum.\n    For example, \"host1.mydomain.com,host2.mydomain.com,host3.mydomain.com\".\n    By default this is set to localhost for local and pseudo-distributed modes\n    of operation. For a fully-distributed setup, this should be set to a full\n    list of ZooKeeper quorum servers. If HBASE_MANAGES_ZK is set in hbase-env.sh\n    this is the list of servers which we will start/stop ZooKeeper on.\n    </description>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.dataDir</name>\n    <value>/usr/local/zookeeper</value>\n    <description>Property from ZooKeeper's config zoo.cfg.\n    The directory where the snapshot is stored.\n    </description>\n  </property>\n  ...\n</configuration>\n```\n\n<Callout type=\"warn\" title=\"What version of ZooKeeper should I use?\">\n  The newer version, the better. ZooKeeper 3.4.x is required as of HBase 1.0.0\n</Callout>\n\n<Callout type=\"warn\" title=\"ZooKeeper Maintenance\">\n  Be sure to set up the data dir cleaner described under [ZooKeeper\n  Maintenance](https://zookeeper.apache.org/doc/r3.1.2/zookeeperAdmin.html#sc_maintenance) else you\n  could have 'interesting' problems a couple of months in; i.e. zookeeper could start dropping\n  sessions if it has to run through a directory of hundreds of thousands of logs which is wont to do\n  around leader reelection time — a process rare but run on occasion whether because a machine is\n  dropped or happens to hiccup.\n</Callout>\n\n## Using existing ZooKeeper ensemble\n\nTo point HBase at an existing ZooKeeper cluster, one that is not managed by HBase, set `HBASE_MANAGES_ZK` in *conf/hbase-env.sh* to false\n\n```bash\n  ...\n  # Tell HBase whether it should manage its own instance of ZooKeeper or not.\n  export HBASE_MANAGES_ZK=false\n```\n\nNext set ensemble locations and client port, if non-standard, in *hbase-site.xml*.\n\nWhen HBase manages ZooKeeper, it will start/stop the ZooKeeper servers as a part of the regular start/stop scripts.\nIf you would like to run ZooKeeper yourself, independent of HBase start/stop, you would do the following\n\n```bash\n${HBASE_HOME}/bin/hbase-daemons.sh {start,stop} zookeeper\n```\n\nNote that you can use HBase in this manner to spin up a ZooKeeper cluster, unrelated to HBase.\nJust make sure to set `HBASE_MANAGES_ZK` to `false` if you want it to stay up across HBase restarts so that when HBase shuts down, it doesn't take ZooKeeper down with it.\n\nFor more information about running a distinct ZooKeeper cluster, see the ZooKeeper [Getting Started Guide](https://zookeeper.apache.org/doc/current/zookeeperStarted.html).\nAdditionally, see the [ZooKeeper Wiki](https://cwiki.apache.org/confluence/display/HADOOP2/ZooKeeper+FAQ#ZooKeeperFAQ-7) or the [ZooKeeper documentation](https://zookeeper.apache.org/doc/r3.4.10/zookeeperAdmin.html#sc_zkMulitServerSetup) for more information on ZooKeeper sizing.\n\n## SASL Authentication with ZooKeeper\n\nNewer releases of Apache HBase (>= 0.92) will support connecting to a ZooKeeper Quorum that supports SASL authentication (which is available in ZooKeeper versions 3.4.0 or later).\n\nThis describes how to set up HBase to mutually authenticate with a ZooKeeper Quorum.\nZooKeeper/HBase mutual authentication ([HBASE-2418](https://issues.apache.org/jira/browse/HBASE-2418)) is required as part of a complete secure HBase configuration ([HBASE-3025](https://issues.apache.org/jira/browse/HBASE-3025)). For simplicity of explication, this section ignores additional configuration required (Secure HDFS and Coprocessor configuration). It's recommended to begin with an HBase-managed ZooKeeper configuration (as opposed to a standalone ZooKeeper quorum) for ease of learning.\n\n### Operating System Prerequisites\n\nYou need to have a working Kerberos KDC setup.\nFor each `$HOST` that will run a ZooKeeper server, you should have a principle `zookeeper/$HOST`.\nFor each such host, add a service key (using the `kadmin` or `kadmin.local` tool's `ktadd` command) for `zookeeper/$HOST` and copy this file to `$HOST`, and make it readable only to the user that will run zookeeper on `$HOST`.\nNote the location of this file, which we will use below as *\\$PATH\\_TO\\_ZOOKEEPER\\_KEYTAB*.\n\nSimilarly, for each `$HOST` that will run an HBase server (master or regionserver), you should have a principle: `hbase/$HOST`.\nFor each host, add a keytab file called *hbase.keytab* containing a service key for `hbase/$HOST`, copy this file to `$HOST`, and make it readable only to the user that will run an HBase service on `$HOST`.\nNote the location of this file, which we will use below as *\\$PATH\\_TO\\_HBASE\\_KEYTAB*.\n\nEach user who will be an HBase client should also be given a Kerberos principal.\nThis principal should usually have a password assigned to it (as opposed to, as with the HBase servers, a keytab file) which only this user knows.\nThe client's principal's `maxrenewlife` should be set so that it can be renewed enough so that the user can complete their HBase client processes.\nFor example, if a user runs a long-running HBase client process that takes at most 3 days, we might create this user's principal within `kadmin` with: `addprinc -maxrenewlife 3days`.\nThe ZooKeeper client and server libraries manage their own ticket refreshment by running threads that wake up periodically to do the refreshment.\n\nOn each host that will run an HBase client (e.g. `hbase shell`), add the following file to the HBase home directory's *conf* directory:\n\n```java\nClient {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useKeyTab=false\n  useTicketCache=true;\n};\n```\n\nWe'll refer to this JAAS configuration file as *\\$CLIENT\\_CONF* below.\n\n### HBase-managed ZooKeeper Configuration\n\nOn each node that will run a zookeeper, a master, or a regionserver, create a [JAAS](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jgss/tutorials/LoginConfigFile.html) configuration file in the conf directory of the node's *HBASE\\_HOME* directory that looks like the following:\n\n```java\nServer {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useKeyTab=true\n  keyTab=\"$PATH_TO_ZOOKEEPER_KEYTAB\"\n  storeKey=true\n  useTicketCache=false\n  principal=\"zookeeper/$HOST\";\n};\nClient {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useKeyTab=true\n  useTicketCache=false\n  keyTab=\"$PATH_TO_HBASE_KEYTAB\"\n  principal=\"hbase/$HOST\";\n};\n```\n\nwhere the *\\$PATH\\_TO\\_HBASE\\_KEYTAB* and *\\$PATH\\_TO\\_ZOOKEEPER\\_KEYTAB* files are what you created above, and `$HOST` is the hostname for that node.\n\nThe `Server` section will be used by the ZooKeeper quorum server, while the `Client` section will be used by the HBase master and regionservers.\nThe path to this file should be substituted for the text *\\$HBASE\\_SERVER\\_CONF* in the *hbase-env.sh* listing below.\n\nThe path to this file should be substituted for the text *\\$CLIENT\\_CONF* in the *hbase-env.sh* listing below.\n\nModify your *hbase-env.sh* to include the following:\n\n```bash\nexport HBASE_OPTS=\"-Djava.security.auth.login.config=$CLIENT_CONF\"\nexport HBASE_MANAGES_ZK=true\nexport HBASE_ZOOKEEPER_OPTS=\"-Djava.security.auth.login.config=$HBASE_SERVER_CONF\"\nexport HBASE_MASTER_OPTS=\"-Djava.security.auth.login.config=$HBASE_SERVER_CONF\"\nexport HBASE_REGIONSERVER_OPTS=\"-Djava.security.auth.login.config=$HBASE_SERVER_CONF\"\n```\n\nwhere *\\$HBASE\\_SERVER\\_CONF* and *\\$CLIENT\\_CONF* are the full paths to the JAAS configuration files created above.\n\nModify your *hbase-site.xml* on each node that will run zookeeper, master or regionserver to contain:\n\n```xml\n<configuration>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>$ZK_NODES</value>\n  </property>\n  <property>\n    <name>hbase.cluster.distributed</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.authProvider.1</name>\n    <value>org.apache.zookeeper.server.auth.SASLAuthenticationProvider</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.kerberos.removeHostFromPrincipal</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.kerberos.removeRealmFromPrincipal</name>\n    <value>true</value>\n  </property>\n</configuration>\n```\n\nwhere `$ZK_NODES` is the comma-separated list of hostnames of the ZooKeeper Quorum hosts.\n\nStart your hbase cluster by running one or more of the following set of commands on the appropriate hosts:\n\n```bash\nbin/hbase zookeeper start\nbin/hbase master start\nbin/hbase regionserver start\n```\n\n### External ZooKeeper Configuration\n\nAdd a JAAS configuration file that looks like:\n\n```java\nClient {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useKeyTab=true\n  useTicketCache=false\n  keyTab=\"$PATH_TO_HBASE_KEYTAB\"\n  principal=\"hbase/$HOST\";\n};\n```\n\nwhere the *\\$PATH\\_TO\\_HBASE\\_KEYTAB* is the keytab created above for HBase services to run on this host, and `$HOST` is the hostname for that node.\nPut this in the HBase home's configuration directory.\nWe'll refer to this file's full pathname as *\\$HBASE\\_SERVER\\_CONF* below.\n\nModify your hbase-env.sh to include the following:\n\n```bash\nexport HBASE_OPTS=\"-Djava.security.auth.login.config=$CLIENT_CONF\"\nexport HBASE_MANAGES_ZK=false\nexport HBASE_MASTER_OPTS=\"-Djava.security.auth.login.config=$HBASE_SERVER_CONF\"\nexport HBASE_REGIONSERVER_OPTS=\"-Djava.security.auth.login.config=$HBASE_SERVER_CONF\"\n```\n\nModify your *hbase-site.xml* on each node that will run a master or regionserver to contain:\n\n```xml\n<configuration>\n  <property>\n    <name>hbase.zookeeper.quorum</name>\n    <value>$ZK_NODES</value>\n  </property>\n  <property>\n    <name>hbase.cluster.distributed</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.authProvider.1</name>\n    <value>org.apache.zookeeper.server.auth.SASLAuthenticationProvider</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.kerberos.removeHostFromPrincipal</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.kerberos.removeRealmFromPrincipal</name>\n    <value>true</value>\n  </property>\n</configuration>\n```\n\nwhere `$ZK_NODES` is the comma-separated list of hostnames of the ZooKeeper Quorum hosts.\n\nAlso on each of these hosts, create a JAAS configuration file containing:\n\n```java\nServer {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useKeyTab=true\n  keyTab=\"$PATH_TO_ZOOKEEPER_KEYTAB\"\n  storeKey=true\n  useTicketCache=false\n  principal=\"zookeeper/$HOST\";\n};\n```\n\nwhere `$HOST` is the hostname of each Quorum host.\nWe will refer to the full pathname of this file as *\\$ZK\\_SERVER\\_CONF* below.\n\nStart your ZooKeepers on each ZooKeeper Quorum host with:\n\n```bash\nSERVER_JVMFLAGS=\"-Djava.security.auth.login.config=$ZK_SERVER_CONF\" bin/zkServer start\n```\n\nStart your HBase cluster by running one or more of the following set of commands on the appropriate nodes:\n\n```bash\nbin/hbase master start\nbin/hbase regionserver start\n```\n\n### ZooKeeper Server Authentication Log Output\n\nIf the configuration above is successful, you should see something similar to the following in your ZooKeeper server logs:\n\n```\n11/12/05 22:43:39 INFO zookeeper.Login: successfully logged in.\n11/12/05 22:43:39 INFO server.NIOServerCnxnFactory: binding to port 0.0.0.0/0.0.0.0:2181\n11/12/05 22:43:39 INFO zookeeper.Login: TGT refresh thread started.\n11/12/05 22:43:39 INFO zookeeper.Login: TGT valid starting at:        Mon Dec 05 22:43:39 UTC 2011\n11/12/05 22:43:39 INFO zookeeper.Login: TGT expires:                  Tue Dec 06 22:43:39 UTC 2011\n11/12/05 22:43:39 INFO zookeeper.Login: TGT refresh sleeping until: Tue Dec 06 18:36:42 UTC 2011\n..\n11/12/05 22:43:59 INFO auth.SaslServerCallbackHandler:\n  Successfully authenticated client: authenticationID=hbase/ip-10-166-175-249.us-west-1.compute.internal@HADOOP.LOCALDOMAIN;\n  authorizationID=hbase/ip-10-166-175-249.us-west-1.compute.internal@HADOOP.LOCALDOMAIN.\n11/12/05 22:43:59 INFO auth.SaslServerCallbackHandler: Setting authorizedID: hbase\n11/12/05 22:43:59 INFO server.ZooKeeperServer: adding SASL authorization for authorizationID: hbase\n```\n\n### ZooKeeper Client Authentication Log Output\n\nOn the ZooKeeper client side (HBase master or regionserver), you should see something similar to the following:\n\n```\n11/12/05 22:43:59 INFO zookeeper.ZooKeeper: Initiating client connection, connectString=ip-10-166-175-249.us-west-1.compute.internal:2181 sessionTimeout=180000 watcher=master:60000\n11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Opening socket connection to server /10.166.175.249:2181\n11/12/05 22:43:59 INFO zookeeper.RecoverableZooKeeper: The identifier of this process is 14851@ip-10-166-175-249\n11/12/05 22:43:59 INFO zookeeper.Login: successfully logged in.\n11/12/05 22:43:59 INFO client.ZooKeeperSaslClient: Client will use GSSAPI as SASL mechanism.\n11/12/05 22:43:59 INFO zookeeper.Login: TGT refresh thread started.\n11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Socket connection established to ip-10-166-175-249.us-west-1.compute.internal/10.166.175.249:2181, initiating session\n11/12/05 22:43:59 INFO zookeeper.Login: TGT valid starting at:        Mon Dec 05 22:43:59 UTC 2011\n11/12/05 22:43:59 INFO zookeeper.Login: TGT expires:                  Tue Dec 06 22:43:59 UTC 2011\n11/12/05 22:43:59 INFO zookeeper.Login: TGT refresh sleeping until: Tue Dec 06 18:30:37 UTC 2011\n11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Session establishment complete on server ip-10-166-175-249.us-west-1.compute.internal/10.166.175.249:2181, sessionid = 0x134106594320000, negotiated timeout = 180000\n```\n\n### Configuration from Scratch\n\nThis has been tested on the current standard Amazon Linux AMI.\nFirst setup KDC and principals as described above.\nNext checkout code and run a sanity check.\n\n```bash\ngit clone https://gitbox.apache.org/repos/asf/hbase.git\ncd hbase\nmvn clean test -Dtest=TestZooKeeperACL\n```\n\nThen configure HBase as described above.\nManually edit target/cached\\_classpath.txt (see below):\n\n```bash\nbin/hbase zookeeper &\nbin/hbase master &\nbin/hbase regionserver &\n```\n\n### Future improvements\n\n#### Fix target/cached\\_classpath.txt\n\nYou must override the standard hadoop-core jar file from the `target/cached_classpath.txt` file with the version containing the HADOOP-7070 fix.\nYou can use the following script to do this:\n\n```bash\necho `find ~/.m2 -name \"*hadoop-core*7070*SNAPSHOT.jar\"` ':' `cat target/cached_classpath.txt` | sed 's/ //g' > target/tmp.txt\nmv target/tmp.txt target/cached_classpath.txt\n```\n\n#### Set JAAS configuration programmatically\n\nThis would avoid the need for a separate Hadoop jar that fixes [HADOOP-7070](https://issues.apache.org/jira/browse/HADOOP-7070).\n\n#### Elimination of `kerberos.removeHostFromPrincipal` and`kerberos.removeRealmFromPrincipal`\n\n## TLS connection to ZooKeeper\n\nApache ZooKeeper also supports SSL/TLS client connections to encrypt the data in transmission. This is particularly\nuseful when the ZooKeeper ensemble is running on a host different from HBase and data has to be sent\nover the wire.\n\n### Java system properties\n\nThe ZooKeeper client supports the following Java system properties to set up TLS connection:\n\n```properties\nzookeeper.client.secure=true\nzookeeper.clientCnxnSocket=org.apache.zookeeper.ClientCnxnSocketNetty\nzookeeper.ssl.keyStore.location=\"/path/to/your/keystore\"\nzookeeper.ssl.keyStore.password=\"keystore_password\"\nzookeeper.ssl.trustStore.location=\"/path/to/your/truststore\"\nzookeeper.ssl.trustStore.password=\"truststore_password\"\n```\n\nSetting up KeyStore is optional and only required if ZooKeeper server requests for client certificate.\n\nFind more detailed information in the [ZooKeeper SSL User Guide](https://cwiki.apache.org/confluence/display/ZOOKEEPER/ZooKeeper+SSL+User+Guide).\n\n<Callout type=\"warn\">\n  These're standard Java properties which should be set in the HBase command line and are effective\n  in the entire Java process. All ZooKeeper clients running in the same process will pick them up\n  including co-processors.\n</Callout>\n\n<Callout type=\"info\">\n  Since ZooKeeper version 3.8 the following two properties are useful to store the keystore and\n  truststore passwords in protected text files rather than exposing them in the command line.\n</Callout>\n\n```properties\nzookeeper.ssl.keyStore.passwordPath=/path/to/secure/file\nzookeeper.ssl.trustStore.passwordPath=/path/to/secure/file\n```\n\n### HBase configuration\n\nBy adding [HBASE-28038](https://issues.apache.org/jira/browse/HBASE-28038), ZooKeeper client TLS\nsettings are also available in *hbase-site.xml* via `hbase.zookeeper.property` prefix. In contrast\nto Java system properties this could be more convenient under some circumstances.\n\n```xml\n<configuration>\n  <property>\n    <name>hbase.zookeeper.property.client.secure</name>\n    <value>true</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.clientCnxnSocket</name>\n    <value>org.apache.zookeeper.ClientCnxnSocketNetty</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.ssl.trustStore.location</name>\n    <value>/path/to/your/truststore</value>\n  </property>\n  ...\n</configuration>\n```\n\n<Callout type=\"info\">\n  These settings are eventually transformed into Java system properties, it's just a convenience\n  feature. So, the same rules that mentioned in the previous point, applies to them as well.\n</Callout>\n\n***\n\n# Community\n\n## Decisions\n\n### Feature Branches\n\nFeature Branches are easy to make. You do not have to be a committer to make one. Just request the name of your branch be added to JIRA up on the developer's mailing list and a committer will add it for you. Thereafter you can file issues against your feature branch in Apache HBase JIRA. Your code you keep elsewhere — it should be public so it can be observed — and you can update dev mailing list on progress. When the feature is ready for commit, 3 +1s from committers will get your feature merged. See [HBase, mail # dev - Thoughts about large feature dev branches](https://lists.apache.org/thread.html/200513c7e7e4df23c8b9134eeee009d61205c79314e77f222d396006%401346870308%40%3Cdev.hbase.apache.org%3E)\n\n### How to set fix version in JIRA on issue resolve\n\nHere is how we agreed to set versions in JIRA when we resolve an issue. If master is going to be 3.0.0, branch-2 will be 2.4.0, and branch-1 will be 1.7.0 then:\n\n* Commit only to master (i.e., backward-incompatible new feature): Mark with 3.0.0\n* Commit only to master and branch-2 (i.e., backward-compatible new feature, applicable only to 2.x+): Mark with 3.0.0 and 2.4.0\n* Commit to master, branch-2, and branch-1 (i.e., backward-compatible new feature, applicable everywhere): Mark with 3.0.0, 2.4.0, and 1.7.0\n* Commit to master, branch-2, and branch-2.3, branch-1, branch-1.4 (i.e., bug fix applicable to all active release lines): Mark with 3.0.0, 2.4.0, 2.3.x, 1.7.0, and 1.4.x\n* Commit a fix to the website: no version\n\n### Policy on when to set a RESOLVED JIRA as CLOSED\n\nWe agreed that for issues that list multiple releases in their *Fix Version/s* field, CLOSE the issue on the release of any of the versions listed; subsequent change to the issue must happen in a new JIRA.\n\n### Only transient state in ZooKeeper!\n\nYou should be able to kill the data in zookeeper and hbase should ride over it recreating the zk content as it goes. This is an old adage around these parts. We just made note of it now. We also are currently in violation of this basic tenet — replication at least keeps permanent state in zk — but we are working to undo this breaking of a golden rule.\n\n## Community Roles\n\n### Release Managers\n\nEach maintained release branch has a release manager, who volunteers to coordinate new features and bug fixes are backported to that release. The release managers are [committers](/team). If you would like your feature or bug fix to be included in a given release, communicate with that release manager. If this list goes out of date or you can't reach the listed person, reach out to someone else on the list.\n\n**Release Managers:**\n\n| Release | Release Manager   | Latest Release                        | EOL            |\n| ------- | ----------------- | ------------------------------------- | -------------- |\n| 0.94    | Lars Hofhansl     | 0.94.27                               | April 2017     |\n| 0.96    | Michael Stack     | 0.96.2                                | September 2014 |\n| 0.98    | Andrew Purtell    | 0.98.24                               | April 2017     |\n| 1.0     | Enis Soztutar     | 1.0.3                                 | January 2016   |\n| 1.1     | Nick Dimiduk      | 1.1.13                                | December 2017  |\n| 1.2     | Sean Busbey       | 1.2.12                                | June 2019      |\n| 1.3     | Mikhail Antonov   | 1.3.6                                 | August 2020    |\n| 1.4     | Andrew Purtell    | 1.4.14                                | October 2021   |\n| 1.5     | Andrew Purtell    | 1.5.0                                 | October 2019   |\n| 1.6     | Andrew Purtell    | 1.6.0                                 | February 2020  |\n| 1.7     | Reid Chan         | 1.7.2                                 | August 2022    |\n| 2.0     | Michael Stack     | 2.0.6                                 | September 2019 |\n| 2.1     | Duo Zhang         | 2.1.10                                | May 2020       |\n| 2.2     | Guanghao Zhang    | 2.2.7                                 | April 2021     |\n| 2.3     | Nick Dimiduk      | 2.3.7                                 | October 2021   |\n| 2.4     | Andrew Purtell    | 2.4.18                                | June 2024      |\n| 2.5     | Andrew Purtell    | Check the [download](/downloads) page | **NOT YET**    |\n| 2.6     | Bryan Beaudreault | Check the [download](/downloads) page | **NOT YET**    |\n\n## Commit Message format\n\nWe agreed to the following Git commit message format:\n\n```text\nHBASE-xxxxx <title>. (<contributor>)\n```\n\nIf the person making the commit is the contributor, leave off the '(\\<contributor>)' element.\n\n***\n\n# hbtop\n\n## Usage\n\nYou can run hbtop with the following command:\n\n```bash\n$ hbase hbtop\n```\n\nIn this case, the values of `hbase.client.zookeeper.quorum` and `zookeeper.znode.parent` in `hbase-site.xml` in the classpath or the default values of them are used to connect.\n\nOr, you can specify your own zookeeper quorum and znode parent as follows:\n\n```bash\n$ hbase hbtop -Dhbase.client.zookeeper.quorum=<zookeeper quorum> -Dzookeeper.znode.parent=<znode parent>\n```\n\n<img alt=\"Top screen\" src={__img20} />\n\nThe top screen consists of a summary part and of a metrics part.\nIn the summary part, you can see `HBase Version`, `Cluster ID`, `The number of region servers`, `Region count`, `Average Cluster Load` and `Aggregated Request/s`.\nIn the metrics part, you can see metrics per Region/Namespace/Table/RegionServer depending on the selected mode.\nThe top screen is refreshed in a certain period – 3 seconds by default.\n\n### Scrolling metric records\n\nYou can scroll the metric records in the metrics part.\n\n<img alt=\"Scrolling metric records\" src={__img21} />\n\n### Command line arguments\n\n| Argument                        | Description                                                                                                                                                                                                                                                |\n| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| -d,--delay `<arg>`              | The refresh delay (in seconds); default is 3 seconds                                                                                                                                                                                                       |\n| -h,--help                       | Print usage; for help while the tool is running press `h` key                                                                                                                                                                                              |\n| -m,--mode `<arg>`               | The mode; `n` (Namespace)\\| `t` (Table)\\| `r` (Region)\\| `s` (RegionServer), default is `r`                                                                                                                                                                |\n| -n,--numberOfIterations `<arg>` | The number of iterations                                                                                                                                                                                                                                   |\n| -O,--outputFieldNames           | Print each of the available field names on a separate line, then quit                                                                                                                                                                                      |\n| -f,--fields `<arg>`             | Show only the given fields. Specify comma separated fields to show multiple fields                                                                                                                                                                         |\n| -s,--sortField `<arg>`          | The initial sort field. You can prepend a `+` or `-` to the field name to also override the sort direction. A leading `+` will force sorting high to low, whereas a `-` will ensure a low to high ordering                                                 |\n| -i,--filters `<arg>`            | The initial filters. Specify comma separated filters to set multiple filters                                                                                                                                                                               |\n| -b,--batchMode                  | Starts hbtop in Batch mode, which could be useful for sending output from hbtop to other programs or to a file. In this mode, hbtop will not accept input and runs until the iterations limit you've set with the `-n` command-line option or until killed |\n\n### Modes\n\nThere are the following modes in hbtop:\n\n| Mode         | Description                              |\n| ------------ | ---------------------------------------- |\n| Region       | Showing metric records per region        |\n| Namespace    | Showing metric records per namespace     |\n| Table        | Showing metric records per table         |\n| RegionServer | Showing metric records per region server |\n| User         | Showing metric records per user          |\n| Client       | Showing metric records per client        |\n\n#### Region mode\n\nIn Region mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field        | Description                            | Displayed by default |\n| ------------ | -------------------------------------- | -------------------- |\n| RNAME        | Region Name                            | false                |\n| NAMESPACE    | Namespace Name                         | true                 |\n| TABLE        | Table Name                             | true                 |\n| SCODE        | Start Code                             | false                |\n| REPID        | Replica ID                             | false                |\n| REGION       | Encoded Region Name                    | true                 |\n| RS           | Short Region Server Name               | true                 |\n| LRS          | Long Region Server Name                | false                |\n| #REQ/S       | Request Count per second               | true                 |\n| #READ/S      | Read Request Count per second          | true                 |\n| #FREAD/S     | Filtered Read Request Count per second | true                 |\n| #WRITE/S     | Write Request Count per second         | true                 |\n| SF           | StoreFile Size                         | true                 |\n| USF          | Uncompressed StoreFile Size            | false                |\n| #SF          | Number of StoreFiles                   | true                 |\n| MEMSTORE     | MemStore Size                          | true                 |\n| LOCALITY     | Block Locality                         | true                 |\n| SKEY         | Start Key                              | false                |\n| #COMPingCELL | Compacting Cell Count                  | false                |\n| #COMPedCELL  | Compacted Cell Count                   | false                |\n| %COMP        | Compaction Progress                    | false                |\n| LASTMCOMP    | Last Major Compaction Time             | false                |\n\n#### Namespace mode\n\nIn Namespace mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field     | Description                            | Displayed by default |\n| --------- | -------------------------------------- | -------------------- |\n| NAMESPACE | Namespace Name                         | true                 |\n| #REGION   | Region Count                           | true                 |\n| #REQ/S    | Request Count per second               | true                 |\n| #READ/S   | Read Request Count per second          | true                 |\n| #FREAD/S  | Filtered Read Request Count per second | true                 |\n| #WRITE/S  | Write Request Count per second         | true                 |\n| SF        | StoreFile Size                         | true                 |\n| USF       | Uncompressed StoreFile Size            | false                |\n| #SF       | Number of StoreFiles                   | true                 |\n| MEMSTORE  | MemStore Size                          | true                 |\n\n#### Table mode\n\nIn Table mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field     | Description                            | Displayed by default |\n| --------- | -------------------------------------- | -------------------- |\n| NAMESPACE | Namespace Name                         | true                 |\n| TABLE     | Table Name                             | true                 |\n| #REGION   | Region Count                           | true                 |\n| #REQ/S    | Request Count per second               | true                 |\n| #READ/S   | Read Request Count per second          | true                 |\n| #FREAD/S  | Filtered Read Request Count per second | true                 |\n| #WRITE/S  | Write Request Count per second         | true                 |\n| SF        | StoreFile Size                         | true                 |\n| USF       | Uncompressed StoreFile Size            | false                |\n| #SF       | Number of StoreFiles                   | true                 |\n| MEMSTORE  | MemStore Size                          | true                 |\n\n#### RegionServer mode\n\nIn RegionServer mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field    | Description                            | Displayed by default |\n| -------- | -------------------------------------- | -------------------- |\n| RS       | Short Region Server Name               | true                 |\n| LRS      | Long Region Server Name                | false                |\n| #REGION  | Region Count                           | true                 |\n| #REQ/S   | Request Count per second               | true                 |\n| #READ/S  | Read Request Count per second          | true                 |\n| #FREAD/S | Filtered Read Request Count per second | true                 |\n| #WRITE/S | Write Request Count per second         | true                 |\n| SF       | StoreFile Size                         | true                 |\n| USF      | Uncompressed StoreFile Size            | false                |\n| #SF      | Number of StoreFiles                   | true                 |\n| MEMSTORE | MemStore Size                          | true                 |\n| UHEAP    | Used Heap Size                         | true                 |\n| MHEAP    | Max Heap Size                          | true                 |\n\n#### User mode\n\nIn User mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field    | Description                            | Displayed by default |\n| -------- | -------------------------------------- | -------------------- |\n| USER     | user Name                              | true                 |\n| #CLIENT  | Client Count                           | true                 |\n| #REQ/S   | Request Count per second               | true                 |\n| #READ/S  | Read Request Count per second          | true                 |\n| #WRITE/S | Write Request Count per second         | true                 |\n| #FREAD/S | Filtered Read Request Count per second | true                 |\n\n#### Client mode\n\nIn Client mode, the default sort field is `#REQ/S`.\n\nThe fields in this mode are as follows:\n\n| Field    | Description                            | Displayed by default |\n| -------- | -------------------------------------- | -------------------- |\n| CLIENT   | Client Hostname                        | true                 |\n| #USER    | User Count                             | true                 |\n| #REQ/S   | Request Count per second               | true                 |\n| #READ/S  | Read Request Count per second          | true                 |\n| #WRITE/S | Write Request Count per second         | true                 |\n| #FREAD/S | Filtered Read Request Count per second | true                 |\n\n### Changing mode\n\nYou can change mode by pressing `m` key in the top screen.\n\n<img alt=\"Changing mode\" src={__img22} />\n\n### Changing the refresh delay\n\nYou can change the refresh by pressing `d` key in the top screen.\n\n<img alt=\"Changing the refresh delay\" src={__img23} />\n\n### Changing the displayed fields\n\nYou can move to the field screen by pressing `f` key in the top screen. In the fields screen, you can change the displayed fields by choosing a field and pressing `d` key or `space` key.\n\n<img alt=\"Changing the displayed fields\" src={__img24} />\n\n### Changing the sort field\n\nYou can move to the fields screen by pressing `f` key in the top screen. In the field screen, you can change the sort field by choosing a field and pressing `s`. Also, you can change the sort order (ascending or descending) by pressing `R` key.\n\n<img alt=\"Changing the sort field\" src={__img25} />\n\n### Changing the order of the fields\n\nYou can move to the fields screen by pressing `f` key in the top screen. In the field screen, you can change the order of the fields.\n\n<img alt=\"Changing the sort field\" src={__img26} />\n\n### Filters\n\nYou can filter the metric records with the filter feature. We can add filters by pressing `o` key for ignoring case or `O` key for case sensitive.\n\n<img alt=\"Adding filters\" src={__img27} />\n\nThe syntax is as follows:\n\n```\n<Field><Operator><Value>\n```\n\nFor example, we can add filters like the following:\n\n```\nNAMESPACE==default\nREQ/S>1000\n```\n\nThe operators we can specify are as follows:\n\n| Operator | Description              |\n| -------- | ------------------------ |\n| =        | Partial match            |\n| ==       | Exact match              |\n| >        | Greater than             |\n| >=       | Greater than or equal to |\n| \\<       | Less than                |\n| \\<=      | Less than and equal to   |\n\nYou can see the current filters by pressing `^o` key and clear them by pressing `=` key.\n\n<img alt=\"Showing and clearing filters\" src={__img28} />\n\n### Drilling down\n\nYou can drill down the metric record by choosing a metric record that you want to drill down and pressing `i` key in the top screen. With this feature, you can find hot regions easily in a top-down manner.\n\n<img alt=\"Drilling down\" src={__img29} />\n\n### Help screen\n\nYou can see the help screen by pressing `h` key in the top screen.\n\n<img alt=\"Help screen\" src={__img30} />\n\n## Others\n\n### How hbtop gets the metrics data\n\nhbtop gets the metrics from ClusterMetrics which is returned as the result of a call to Admin#getClusterMetrics() on the current HMaster. To add metrics to hbtop, they will need to be exposed via ClusterMetrics.\n\n***\n\n# Tracing\n\n## Overview\n\nThe basic support for tracing has been done, where we added tracing for async client, rpc, region read/write/scan operation, and WAL. We use opentelemetry-api to implement the tracing support manually by code, as our code base is way too complicated to be instrumented through a java agent. But notice that you still need to attach the opentelemetry java agent to enable tracing. Please see the official site for [OpenTelemetry](https://opentelemetry.io/) and the documentation for [opentelemetry-java-instrumentation](https://github.com/open-telemetry/opentelemetry-java-instrumentation) for more details on how to properly configure opentelemetry instrumentation.\n\n## Usage\n\n### Enable Tracing\n\nSee this section in hbase-env.sh\n\n```\n# Uncomment to enable trace, you can change the options to use other exporters such as jaeger or\n# zipkin. See https://github.com/open-telemetry/opentelemetry-java-instrumentation on how to\n# configure exporters and other components through system properties.\n# export HBASE_TRACE_OPTS=\"-Dotel.resource.attributes=service.name=HBase -Dotel.traces.exporter=logging otel.metrics.exporter=none\"\n```\n\nUncomment this line to enable tracing. The default config is to output the tracing data to log. Please see the documentation for [opentelemetry-java-instrumentation](https://github.com/open-telemetry/opentelemetry-java-instrumentation) for more details on how to export tracing data to other tracing system such as OTel collector, jaeger or zipkin, what does the *service.name* mean, and how to change the sampling rate, etc.\n\n<Callout type=\"info\">\n  The\n  [LoggingSpanExporter](https://github.com/open-telemetry/opentelemetry-java/blob/v1.0.1/exporters/logging/src/main/java/io/opentelemetry/exporter/logging/LoggingSpanExporter.java)\n  uses java.util.logging(jul) for logging tracing data, and the logger is initialized in\n  opentelemetry java agent, which seems to be ahead of our jul to slf4j bridge initialization, so it\n  will always log the tracing data to console. We highly suggest that you use other tracing systems\n  to collect and view tracing data instead of logging.\n</Callout>\n\n### Performance Impact\n\nAccording to the result in [HBASE-25658](https://issues.apache.org/jira/browse/HBASE-25658), the performance impact is minimal. Of course the test cluster is not under heavy load, so if you find out that enabling tracing would impact the performance, try to lower the sampling rate. See documentation for configuring [sampler](https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk-extensions/autoconfigure/README.md#sampler) for more details.\n\n***\n\n# Store File Tracking\n\n## Overview\n\nHistorically, HBase internals have relied on creating hfiles on temporary directories first, renaming\nthose files to the actual store directory at operation commit time. That's a simple and convenient\nway to separate transient from already finalised files that are ready to serve client reads with data.\nThis approach works well with strong consistent file systems, but with the popularity of less consistent\nfile systems, mainly Object Store which can be used like file systems, dependency on atomic rename operations starts to introduce performance penalties. The Amazon S3 Object Store, in particular, has been the most affected deployment,\ndue to its lack of atomic renames. The HBase community temporarily bypassed this problem by building a distributed locking layer called HBOSS, to guarantee atomicity of operations against S3.\n\nWith **Store File Tracking**, decision on where to originally create new hfiles and how to proceed upon\ncommit is delegated to the specific Store File Tracking implementation.\nThe implementation can be set at the HBase service leve in **hbase-site.xml** or at the\nTable or Column Family via the TableDescriptor configuration.\n\n<Callout type=\"info\">\n  When the store file tracking implementation is specified in **hbase\\_site.xml**, this configuration\n  is also propagated into a tables configuration at table creation time. This is to avoid dangerous\n  configuration mismatches between processes, which could potentially lead to data loss.\n</Callout>\n\n## Available Implementations\n\nStore File Tracking initial version provides three builtin implementations:\n\n* DEFAULT\n* FILE\n* MIGRATION\n\n### DEFAULT\n\nAs per the name, this is the Store File Tracking implementation used by default when no explicit\nconfiguration has been defined. The DEFAULT tracker implements the standard approach using temporary\ndirectories and renames. This is how all previous (implicit) implementation that HBase used to track store files.\n\n### FILE\n\nA file tracker implementation that creates new files straight in the store directory, avoiding the\nneed for rename operations. It keeps a list of committed hfiles in memory, backed by meta files, in\neach store directory. Whenever a new hfile is committed, the list of *tracked files* in the given\nstore is updated and a new meta file is written with this list contents, discarding the previous\nmeta file now containing an out dated list.\n\n### MIGRATION\n\nA special implementation to be used when swapping between Store File Tracking implementations on\npre-existing tables that already contain data, and therefore, files being tracked under an specific\nlogic.\n\n## Usage\n\nFor fresh deployments that don't yet contain any user data, **FILE** implementation can be just set as\nvalue for **hbase.store.file-tracker.impl** property in global **hbase-site.xml** configuration, prior\nto the first hbase start. Omitting this property sets the **DEFAULT** implementation.\n\nFor clusters with data that are upgraded to a version of HBase containing the store file tracking\nfeature, the Store File Tracking implementation can only be changed with the **MIGRATION**\nimplementation, so that the *new tracker* can safely build its list of tracked files based on the\nlist of the *current tracker*.\n\n<Callout type=\"info\">\n  MIGRATION tracker should NOT be set at global configuration. To use it, follow below section about\n  setting Store File Tacking at Table or Column Family configuration.\n</Callout>\n\n### Configuring for Table or Column Family\n\nSetting Store File Tracking configuration globally may not always be possible or desired, for example,\nin the case of upgraded clusters with pre-existing user data.\nStore File Tracking can be set at Table or Column Family level configuration.\nFor example, to specify **FILE** implementation in the table configuration at table creation time,\nthe following should be applied:\n\n```bash\ncreate 'my-table', 'f1', 'f2', {CONFIGURATION => {'hbase.store.file-tracker.impl' => 'FILE'}}\n```\n\nTo define **FILE** for an specific Column Family:\n\n```bash\ncreate 'my-table', {NAME=> '1', CONFIGURATION => {'hbase.store.file-tracker.impl' => 'FILE'}}\n```\n\n### Switching trackers at Table or Column Family\n\nA very common scenario is to set Store File Tracking on pre-existing HBase deployments that have\nbeen upgraded to a version that supports this feature. To apply the FILE tracker, tables effectively\nneed to be migrated from the DEFAULT tracker to the FILE tracker. As explained previously, such\nprocess requires the usage of the special MIGRATION tracker implementation, which can only be\nspecified at table or Column Family level.\n\nFor example, to switch *tracker* from **DEFAULT** to **FILE** in a table configuration:\n\n```bash\nalter 'my-table', CONFIGURATION => {'hbase.store.file-tracker.impl' => 'MIGRATION',\n'hbase.store.file-tracker.migration.src.impl' => 'DEFAULT',\n'hbase.store.file-tracker.migration.dst.impl' => 'FILE'}\n```\n\nTo apply similar switch at column family level configuration:\n\n```bash\nalter 'my-table', {NAME => 'f1', CONFIGURATION => {'hbase.store.file-tracker.impl' => 'MIGRATION',\n'hbase.store.file-tracker.migration.src.impl' => 'DEFAULT',\n'hbase.store.file-tracker.migration.dst.impl' => 'FILE'}}\n```\n\nOnce all table regions have been onlined again, don't forget to disable MIGRATION, by now setting\n**hbase.store.file-tracker.migration.dst.impl** value as the **hbase.store.file-tracker.impl**. In the above\nexample, that would be as follows:\n\n```bash\nalter 'my-table', CONFIGURATION => {'hbase.store.file-tracker.impl' => 'FILE'}\n```\n\n### Specifying trackers during snapshot recovery\n\nIt's also possible to specify a given store file tracking implementation when recovering a snapshot\nusing the *CLONE\\_SFT* option of *clone\\_snasphot* command. This is useful when recovering old\nsnapshots, taken prior to a change in the global configuration, or if the snapshot has been\nimported from a different cluster that had a different store file tracking setting.\nBecause snapshots preserve table and colum family descriptors, a simple restore would reload\nthe original configuration, requiring the additional steps described above to convert the\ntable/column family to the desired tracker implementation.\nAn example of how to use *clone\\_snapshot* to specify the **FILE** tracker implementation\nis shown below:\n\n```bash\nclone_snapshot 'snapshotName', 'namespace:tableName', {CLONE_SFT=>'FILE'}\n```\n\n<Callout type=\"info\">\n  The option to specify the tracker during snapshot recovery is only available for the\n  *clone\\_snapshot* command. The *restore\\_snapshot* command does not support this parameter.\n</Callout>\n\n***\n\n# Bulk Data Generator Tool\n\n## Usage\n\n```bash\nusage: hbase org.apache.hadoop.hbase.util.bulkdatagenerator.BulkDataGeneratorTool <OPTIONS> [-D<property=value>]*\n -d,--delete-if-exist         If it's set, the table will be deleted if already exist.\n -h,--help                    Show help message for the tool\n -mc,--mapper-count <arg>     The number of mapper containers to be launched.\n -o,--table-options <arg>     Table options to be set while creating the table.\n -r,--rows-per-mapper <arg>   The number of rows to be generated PER mapper.\n -sc,--split-count <arg>      The number of regions/pre-splits to be created for the table.\n -t,--table <arg>             The table name for which data need to be generated.\n```\n\nExamples:\n\n```bash\nhbase org.apache.hadoop.hbase.util.bulkdatagenerator.BulkDataGeneratorTool -t TEST_TABLE -mc 10 -r 100 -sc 10\n\nhbase org.apache.hadoop.hbase.util.bulkdatagenerator.BulkDataGeneratorTool -t TEST_TABLE -mc 10 -r 100 -sc 10 -d -o \"BACKUP=false,NORMALIZATION_ENABLED=false\"\n\nhbase org.apache.hadoop.hbase.util.bulkdatagenerator.BulkDataGeneratorTool -t TEST_TABLE -mc 10 -r 100 -sc 10 -Dmapreduce.map.memory.mb=8192\n```\n\n## Overview\n\n### Table Schema\n\nTool generates a HBase table with single column family, i.e. **cf** and 9 columns i.e.\n\n```\nORG_ID, TOOL_EVENT_ID, EVENT_ID, VEHICLE_ID, SPEED, LATITUDE, LONGITUDE, LOCATION, TIMESTAMP\n```\n\nwith row key as\n\n```\n<TOOL_EVENT_ID>:<ORGANIZATION_ID>\n```\n\n### Table Creation\n\nTool creates a pre-splited HBase Table having \"**split-count**\" splits (i.e. **split-count** + 1 regions) with sequential 6 digit region boundary prefix.\nExample: If a table is generated with \"**split-count**\" as 10, it will have (10+1) regions with following start-end keys.\n\n```\n(-000001, 000001-000002, 000002-000003, ...., 000009-000010, 0000010-)\n```\n\n### Data Generation\n\nTool creates and run a MR job to generate the HFiles, which are bulk loaded to table regions via `org.apache.hadoop.hbase.tool.BulkLoadHFilesTool`.\nThe number of mappers is defined in input as \"**mapper-count**\". Each mapper generates \"**records-per-mapper**\" rows.\n\n`org.apache.hadoop.hbase.util.bulkdatageneratorBulkDataGeneratorRecordReader` ensures that each record generated by mapper is associated with index (added to the key) ranging from 1 to \"**records-per-mapper**\".\n\nThe TOOL\\_EVENT\\_ID column for each row has a 6 digit prefix as\n\n```\n(index) mod (\"split-count\" + 1)\n```\n\nExample, if 10 records are to be generated by each mapper and \"**split-count**\" is 4, the TOOL\\_EVENT\\_IDs for each record will have a prefix as\n\n| Record Index | TOOL\\_EVENT\\_ID's first six characters |\n| ------------ | -------------------------------------- |\n| 1            | 000001                                 |\n| 2            | 000002                                 |\n| 3            | 000003                                 |\n| 4            | 000004                                 |\n| 5            | 000000                                 |\n| 6            | 000001                                 |\n| 7            | 000002                                 |\n| 8            | 000003                                 |\n| 9            | 000004                                 |\n| 10           | 000005                                 |\n\nSince TOOL\\_EVENT\\_ID is first attribute of row key and table region boundaries are also having start-end keys as 6 digit sequential prefixes, this ensures that each mapper generates (nearly) same number of rows for each region, making the data uniformly distributed.\nTOOL\\_EVENT\\_ID suffix and other columns of the row are populated with random data.\n\nNumber of rows generated is\n\n```\nrows-per-mapper * mapper-count\n```\n\nSize of each rows is (approximately)\n\n```\n850 B\n```\n\n### Experiments\n\nThese results are from a 11 node cluster having HBase and Hadoop service running within self-managed test environment\n\n| Data Size | Time to Generate Data (mins) |\n| --------- | ---------------------------- |\n| 100 GB    | 6 minutes                    |\n| 340 GB    | 13 minutes                   |\n| 3.5 TB    | 3 hours 10 minutes           |\n\n***\n\n# Appendix: Contributing to Documentation\n\n## Contributing to Documentation\n\nThe Apache HBase project welcomes contributions to all aspects of the project, including the documentation.\n\nIn HBase, documentation includes the following areas, and probably some others:\n\n* The [HBase Reference Guide](/docs) (this book)\n* The [HBase website](/)\n* API documentation\n* Command-line utility output and help text\n* Web UI strings, explicit help text, context-sensitive strings, and others\n* Log messages\n* Comments in source files, configuration files, and others\n* Localization of any of the above into target languages other than English\n\nNo matter which area you want to help out with, the first step is almost always to download (typically by cloning the Git repository) and familiarize yourself with the HBase source code. For information on downloading and building the source, see [developer](/docs/building-and-developing).\n\n## Contributing to Documentation or Other Strings\n\nIf you spot an error in a string in a UI, utility, script, log message, or elsewhere, or you think something could be made more clear, or you think text needs to be added where it doesn't currently exist, the first step is to file a JIRA. Be sure to set the component to `Documentation` in addition to any other involved components. Most components have one or more default owners, who monitor new issues which come into those queues. Regardless of whether you feel able to fix the bug, you should still file bugs where you see them.\n\nIf you want to try your hand at fixing your newly-filed bug, assign it to yourself. You will need to clone the HBase Git repository to your local system and work on the issue there. When you have developed a potential fix, submit it for review. If it addresses the issue and is seen as an improvement, one of the HBase committers will commit it to one or more branches, as appropriate.\n\n### Procedure: Suggested Work flow for Submitting Patches\n\nThis procedure goes into more detail than Git pros will need, but is included in this appendix so that people unfamiliar with Git can feel confident contributing to HBase while they learn.\n\n<Steps>\n  <Step>\n    If you have not already done so, clone the Git repository locally. You only need to do this once.\n  </Step>\n\n  <Step>\n    Fairly often, pull remote changes into your local repository by using the `git pull` command,\n    while your tracking branch is checked out.\n  </Step>\n\n  <Step>\n    For each issue you work on, create a new branch. One convention that works well for naming the branches is to name a given branch the same as the JIRA it relates to:\n\n    ```bash\n    $ git checkout -b HBASE-123456\n    ```\n  </Step>\n\n  <Step>\n    Make your suggested changes on your branch, committing your changes to your local repository\n    often. If you need to switch to working on a different issue, remember to check out the\n    appropriate branch.\n  </Step>\n\n  <Step>\n    When you are ready to submit your patch, first be sure that HBase builds cleanly and behaves as\n    expected in your modified branch.\n  </Step>\n\n  <Step>\n    If you have made documentation or website changes, verify that the site builds correctly by\n    running the development server from the `hbase-website/` directory.\n  </Step>\n\n  <Step>\n    If it takes you several days or weeks to implement your fix, or you know that the area of the code you are working in has had a lot of changes lately, make sure you rebase your branch against the remote master and take care of any conflicts before submitting your patch.\n\n    ```bash\n    $ git checkout HBASE-123456\n    $ git rebase origin/master\n    ```\n  </Step>\n\n  <Step>\n    Generate your patch against the remote master. Run the following command from the top level of your git repository (usually called `hbase`):\n\n    ```bash\n    $ git format-patch --stdout origin/master > HBASE-123456.patch\n    ```\n\n    The name of the patch should contain the JIRA ID.\n  </Step>\n\n  <Step>\n    Look over the patch file to be sure that you did not change any additional files by accident and\n    that there are no other surprises.\n  </Step>\n\n  <Step>\n    When you are satisfied, attach the patch to the JIRA and click the **Patch Available** button. A\n    reviewer will review your patch.\n  </Step>\n\n  <Step>\n    If you need to submit a new version of the patch, leave the old one on the JIRA and add a version\n    number to the name of the new patch.\n  </Step>\n\n  <Step>\n    After a change has been committed, there is no need to keep your local branch around.\n  </Step>\n</Steps>\n\n## Editing the HBase Website and Documentation\n\nThe HBase website and documentation are now part of a single application built with Remix and Fumadocs. The source files are located in the `hbase-website/` directory:\n\n* **Documentation pages**: `hbase-website/app/pages/_docs/docs/_mdx/(multi-page)/` - individual MDX files for each documentation section\n* **Single-page view**: `hbase-website/app/pages/_docs/docs/_mdx/single-page/index.mdx` - combines all documentation into one page\n* **Website components**: `hbase-website/app/components/` - React components used throughout the site\n* **Images**: `hbase-website/public/` - static assets including images\n\nYou can edit MDX files in any text editor or IDE. To preview your changes locally, run the development server from the `hbase-website/` directory and navigate to the documentation pages in your browser. When you are satisfied with your changes, follow the procedure in [submit doc patch procedure](/docs/contributing-to-documentation#procedure-suggested-work-flow-for-submitting-patches) to submit your patch.\n\n## Publishing the HBase Website and Documentation\n\nThe HBase website and documentation are built and deployed as a single Remix application. The deployment process is managed through the project's CI/CD pipeline, which builds the site from the `hbase-website/` directory and deploys it automatically when changes are merged to the main branch.\n\n## MDX and Fumadocs Components\n\nThe HBase documentation is written in MDX (Markdown with JSX), which allows you to use standard Markdown syntax along with React components. For comprehensive documentation on Markdown formatting and MDX features, refer to:\n\n* [Fumadocs Markdown Documentation](https://www.fumadocs.dev/docs/markdown) - Complete guide to MDX syntax and Fumadocs features\n* [CommonMark specification](https://commonmark.org/) - Standard Markdown syntax reference\n* [GFM (GitHub Flavored Markdown)](https://github.github.com/gfm) - GitHub-style Markdown extensions\n\n### Fumadocs Components\n\nFumadocs provides several components that enhance the documentation:\n\n#### Steps Component\n\nUse `<Steps>` to create numbered step-by-step instructions:\n\n```mdx\n<Steps>\n\n<Step>First, do this thing.</Step>\n\n<Step>Then, do this other thing.</Step>\n\n</Steps>\n```\n\n**Example output:**\n\n<Steps>\n  <Step>\n    First, do this thing.\n  </Step>\n\n  <Step>\n    Then, do this other thing.\n  </Step>\n</Steps>\n\n#### Callout Component\n\nUse `<Callout>` for notes, warnings, and important information:\n\n```mdx\n<Callout type=\"info\">This is an informational callout.</Callout>\n\n<Callout type=\"warning\">This is a warning callout.</Callout>\n```\n\n**Example output:**\n\n<Callout type=\"info\">\n  This is an informational callout.\n</Callout>\n\n<Callout type=\"warning\">\n  This is a warning callout.\n</Callout>\n\n#### Include Directive\n\nThe single-page documentation view uses `<include>` tags to combine multiple MDX files:\n\n```mdx\n<include>../(multi-page)/getting-started.mdx</include>\n```\n\nSee `hbase-website/app/pages/_docs/docs/_mdx/single-page/index.mdx` for examples of how all documentation sections are included in the single-page view.\n\n## Auto-Generated Content\n\nSome parts of the HBase documentation, such as the [default configuration](/docs/configuration/default), are generated automatically to stay in sync with the code. The configuration documentation is generated from the `hbase-common/src/main/resources/hbase-default.xml` file.\n\nTo add or modify configuration parameters, update the source XML file. To regenerate the documentation from the updated configuration, run:\n\n```bash\nnpm run extract-hbase-config\n```\n\nThis command is also executed automatically when you run `npm ci`.\n\n## Images in the Documentation\n\nYou can include images in the HBase documentation using standard Markdown syntax. Always include descriptive alt text for accessibility:\n\n```markdown\n![Alt text describing the image](/path/to/image.png)\n```\n\nSave images to the `hbase-website/public/` directory or an appropriate subdirectory. Reference them in your MDX files using absolute paths from the public directory:\n\n```markdown\n![Architecture diagram](/images/architecture-diagram.png)\n```\n\nWhen submitting a patch that includes images, attach the images to the JIRA issue.\n\n## Adding a New Section to the Documentation\n\nTo add a new section to the HBase documentation:\n\n1. Create a new MDX file in `hbase-website/app/pages/_docs/docs/_mdx/(multi-page)/` with a descriptive name (e.g., `my-new-section.mdx`)\n2. Add frontmatter at the top of the file with a title and description:\n\n```mdx\n---\ntitle: \"My New Section\"\ndescription: \"Brief description of what this section covers\"\n---\n\n## My New Section\n\nYour content here...\n```\n\n3. Add your new file to `hbase-website/app/pages/_docs/docs/_mdx/(multi-page)/meta.json` in the appropriate location within the `pages` array (without the `.mdx` extension):\n\n```json\n{\n  \"pages\": [\n    \"---My Category---\",\n    \"my-new-section\",\n    ...\n  ]\n}\n```\n\n4. Add an `<include>` directive to `hbase-website/app/pages/_docs/docs/_mdx/single-page/index.mdx` in the appropriate location:\n\n```mdx\n<include>../(multi-page)/my-new-section.mdx</include>\n```\n\n5. Add your new file to Git before creating your patch.\n\n## Unique Headings Requirement\n\nSince all documentation files are merged into a single-page view, **all heading IDs must be unique across the entire documentation**. A test will fail during the build if duplicate heading IDs are detected, marking the problematic headings.\n\nHeadings don't have to be visually unique, but their link IDs must be unique. You can customize the heading ID using Fumadocs syntax:\n\n```markdown\n## Configuration [#server-configuration]\n```\n\nThis creates a heading that displays as \"Configuration\" but has the unique ID `#server-configuration` for linking purposes.\n\n### Hiding Headings from Table of Contents\n\nYou can hide specific headings from the right-side table of contents:\n\n```markdown\n## Internal Implementation Details [!toc]\n```\n\nThis heading will still appear in the document but won't show up in the table of contents navigation.\n\n<Callout type=\"warning\">\n  Note: `[!toc]` becomes part of the heading ID. For example, `## Usage [!toc]` will have the ID\n  `#usage-toc`.\n</Callout>\n\n### Combining Custom IDs and TOC Hiding\n\nYou can combine both attributes:\n\n```markdown\n## Configuration Details [#server-config] [!toc]\n```\n\n## Common Documentation Issues\n\nThe following documentation issues come up often:\n\n1. **Isolate Changes for Easy Diff Review**\n\n   Avoid reformatting entire files when making content changes. If you need to reformat a file, do that in a separate JIRA where you do not change any content.\n\n2. **Syntax Highlighting**\n\n   MDX supports syntax highlighting for code blocks. Specify the language after the opening triple backticks:\n\n   ````markdown\n   ```java\n   public class Example {\n       // your code here\n   }\n   ```\n   ````\n\n3. **Component Syntax**\n\n   Remember to properly close Fumadocs components. Components like `<Steps>` and `<Callout>` must be properly closed:\n\n   ```mdx\n   <Callout>Your content here</Callout>\n   ```\n\n4. **Unique Heading IDs**\n\n   Ensure all heading IDs are unique across the entire documentation. If you get a test failure about duplicate headings, customize the heading ID using `[#custom-id]` syntax as described in the [Unique Headings Requirement](#unique-headings-requirement) section.\n\n***\n\n# FAQ\n\n## General\n\n#### When should I use HBase?\n\nSee [Overview](/docs/architecture/overview) in the Architecture chapter.\n\n#### Does HBase support SQL?\n\nNot really. SQL-ish support for HBase via [Hive](https://hive.apache.org/) is in development, however Hive is based on MapReduce which is not generally suitable for low-latency requests. See the [Data Model](/docs/datamodel) section for examples on the HBase client.\n\n#### How can I find examples of NoSQL/HBase?\n\nSee the link to the BigTable paper in [Other Information About HBase](/docs/other-info), as well as the other papers.\n\n#### What is the history of HBase?\n\nSee [HBase History](/docs/hbase-history).\n\n#### Why are the cells above 10MB not recommended for HBase?\n\nLarge cells don't fit well into HBase's approach to buffering data. First, the large cells bypass the MemStoreLAB when they are written. Then, they cannot be cached in the L2 block cache during read operations. Instead, HBase has to allocate on-heap memory for them each time. This can have a significant impact on the garbage collector within the RegionServer process.\n\n## Upgrading\n\n#### How do I upgrade Maven-managed projects from HBase 0.94 to HBase 0.96+?\n\nIn HBase 0.96, the project moved to a modular structure. Adjust your project's dependencies to rely upon the `hbase-client` module or another module as appropriate, rather than a single JAR. You can model your Maven dependency after one of the following, depending on your targeted version of HBase. See Section 3.5, \"Upgrading from 0.94.x to 0.96.x\" or Section 3.3, \"Upgrading from 0.96.x to 0.98.x\" for more information.\n\n**Maven Dependency for HBase 0.98**\n\n```xml\n<dependency>\n  <groupId>org.apache.hbase</groupId>\n  <artifactId>hbase-client</artifactId>\n  <version>0.98.5-hadoop2</version>\n</dependency>\n```\n\n**Maven Dependency for HBase 0.96**\n\n```xml\n<dependency>\n  <groupId>org.apache.hbase</groupId>\n  <artifactId>hbase-client</artifactId>\n  <version>0.96.2-hadoop2</version>\n</dependency>\n```\n\n**Maven Dependency for HBase 0.94**\n\n```xml\n<dependency>\n  <groupId>org.apache.hbase</groupId>\n  <artifactId>hbase</artifactId>\n  <version>0.94.3</version>\n</dependency>\n```\n\n## Architecture\n\n#### How does HBase handle Region-RegionServer assignment and locality?\n\nSee [Regions](/docs/architecture/regions).\n\n## Configuration\n\n#### How can I get started with my first cluster?\n\nSee [Quick Start - Standalone HBase](/docs/getting-started#quick-start---standalone-hbase).\n\n#### Where can I learn about the rest of the configuration options?\n\nSee [Apache HBase Configuration](/docs/configuration).\n\n## Schema Design / Data Access\n\n#### How should I design my schema in HBase?\n\nSee [Data Model](/docs/datamodel) and [HBase and Schema Design](/docs/schema-design).\n\n#### How can I store (fill in the blank) in HBase?\n\nSee [Supported Datatypes](/docs/regionserver-sizing#supported-datatypes).\n\n#### How can I handle secondary indexes in HBase?\n\nSee [Secondary Indexes and Alternate Query Paths](/docs/regionserver-sizing#secondary-indexes-and-alternate-query-paths).\n\n#### Can I change a table's rowkeys?\n\nThis is a very common question. You can't. See [Immutability of Rowkeys](/docs/regionserver-sizing#immutability-of-rowkeys).\n\n#### What APIs does HBase support?\n\nSee [Data Model](/docs/datamodel), [Client](/docs/architecture/client), and [Apache HBase External APIs](/docs/external-apis).\n\n## MapReduce\n\n#### How can I use MapReduce with HBase?\n\nSee [HBase and MapReduce](/docs/mapreduce).\n\n## Performance and Troubleshooting\n\n#### How can I improve HBase cluster performance?\n\nSee [Apache HBase Performance Tuning](/docs/performance).\n\n#### How can I troubleshoot my HBase cluster?\n\nSee [Troubleshooting and Debugging Apache HBase](/docs/troubleshooting).\n\n## Amazon EC2\n\n#### I am running HBase on Amazon EC2 and...\n\nEC2 issues are a special case. See [Amazon EC2](/docs/troubleshooting#troubleshooting-amazon-ec2) and [Amazon EC2](/docs/performance#performance-amazon-ec2).\n\n## Operations\n\n#### How do I manage my HBase cluster?\n\nSee [Apache HBase Operational Management](/docs/operational-management).\n\n#### How do I back up my HBase cluster?\n\nSee [HBase Backup](/docs/operational-management/backup-and-snapshots#hbase-backup).\n\n## HBase in Action\n\n#### Where can I find interesting videos and presentations on HBase?\n\nSee [Other Information About HBase](/docs/other-info).\n\n***\n\n# Access Control Matrix\n\n## Interpreting the ACL Matrix Table\n\nThe following conventions are used in the ACL Matrix table:\n\n### Scopes\n\nPermissions are evaluated starting at the widest scope and working to the narrowest scope.\n\nA scope corresponds to a level of the data model. From broadest to narrowest, the scopes are as follows:\n\n#### Scopes\n\n* Global\n* Namespace (NS)\n* Table\n* Column Family (CF)\n* Column Qualifier (CQ)\n* Cell\n\nFor instance, a permission granted at table level dominates any grants done at the Column Family, Column Qualifier, or cell level. The user can do what that grant implies at any location in the table. A permission granted at global scope dominates all: the user is always allowed to take that action everywhere.\n\n### Permissions\n\nPossible permissions include the following:\n\n#### Permissions\n\n* Superuser - a special user that belongs to group \"supergroup\" and has unlimited access\n* Admin (A)\n* Create (C)\n* Write (W)\n* Read (R)\n* Execute (X)\n\nFor the most part, permissions work in an expected way, with the following caveats:\n\n**Having Write permission does not imply Read permission.**\\\nIt is possible and sometimes desirable for a user to be able to write data that same user cannot read. One such example is a log-writing process.\n\n**The `hbase:meta` table is readable by every user, regardless of the user's other grants or restrictions.**\\\nThis is a requirement for HBase to function correctly.\n\n**`CheckAndPut` and `CheckAndDelete` operations will fail if the user does not have both Write and Read permission.**\\\n**`Increment` and `Append` operations do not require Read access.**\\\n**The `superuser`, as the name suggests has permissions to perform all possible operations.**\\\n**And for the operations marked with \\*, the checks are done in post hook and only subset of results satisfying access checks are returned back to the user.**\\\nThe following table is sorted by the interface that provides each operation.\nIn case the table goes out of date, the unit tests which check for accuracy of permissions can be found in *hbase-server/src/test/java/org/apache/hadoop/hbase/security/access/TestAccessController.java*, and the access controls themselves can be examined in *hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java*.\n\n## ACL Matrix\n\n| Interface        | Operation                           | Permissions                                                                                         |\n| ---------------- | ----------------------------------- | --------------------------------------------------------------------------------------------------- |\n| Master           | createTable                         | superuser\\|global(C)\\|NS(C)                                                                         |\n|                  | modifyTable                         | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | deleteTable                         | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | truncateTable                       | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | addColumn                           | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | modifyColumn                        | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)\\|column(A)\\|column(C) |\n|                  | deleteColumn                        | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)\\|column(A)\\|column(C) |\n|                  | enableTable                         | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | disableTable                        | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | disableAclTable                     | Not allowed                                                                                         |\n|                  | move                                | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | assign                              | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | unassign                            | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | regionOffline                       | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | balance                             | superuser\\|global(A)                                                                                |\n|                  | balanceSwitch                       | superuser\\|global(A)                                                                                |\n|                  | shutdown                            | superuser\\|global(A)                                                                                |\n|                  | stopMaster                          | superuser\\|global(A)                                                                                |\n|                  | snapshot                            | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | listSnapshot                        | superuser\\|global(A)\\|SnapshotOwner                                                                 |\n|                  | cloneSnapshot                       | superuser\\|global(A)\\|(SnapshotOwner & TableName matches)                                           |\n|                  | restoreSnapshot                     | superuser\\|global(A)\\|SnapshotOwner & (NS(A)\\|TableOwner\\|table(A))                                 |\n|                  | deleteSnapshot                      | superuser\\|global(A)\\|SnapshotOwner                                                                 |\n|                  | createNamespace                     | superuser\\|global(A)                                                                                |\n|                  | deleteNamespace                     | superuser\\|global(A)                                                                                |\n|                  | modifyNamespace                     | superuser\\|global(A)                                                                                |\n|                  | getNamespaceDescriptor              | superuser\\|global(A)\\|NS(A)                                                                         |\n|                  | listNamespaceDescriptors\\*          | superuser\\|global(A)\\|NS(A)                                                                         |\n|                  | flushTable                          | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | getTableDescriptors\\*               | superuser\\|global(A)\\|global(C)\\|NS(A)\\|NS(C)\\|TableOwner\\|table(A)\\|table(C)                       |\n|                  | getTableNames\\*                     | superuser\\|TableOwner\\|Any global or table perm                                                     |\n|                  | setUserQuota(global level)          | superuser\\|global(A)                                                                                |\n|                  | setUserQuota(namespace level)       | superuser\\|global(A)                                                                                |\n|                  | setUserQuota(Table level)           | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | setTableQuota                       | superuser\\|global(A)\\|NS(A)\\|TableOwner\\|table(A)                                                   |\n|                  | setNamespaceQuota                   | superuser\\|global(A)                                                                                |\n|                  | addReplicationPeer                  | superuser\\|global(A)                                                                                |\n|                  | removeReplicationPeer               | superuser\\|global(A)                                                                                |\n|                  | enableReplicationPeer               | superuser\\|global(A)                                                                                |\n|                  | disableReplicationPeer              | superuser\\|global(A)                                                                                |\n|                  | getReplicationPeerConfig            | superuser\\|global(A)                                                                                |\n|                  | updateReplicationPeerConfig         | superuser\\|global(A)                                                                                |\n|                  | listReplicationPeers                | superuser\\|global(A)                                                                                |\n|                  | getClusterStatus                    | any user                                                                                            |\n| Region           | openRegion                          | superuser\\|global(A)                                                                                |\n|                  | closeRegion                         | superuser\\|global(A)                                                                                |\n|                  | flush                               | superuser\\|global(A)\\|global(C)\\|TableOwner\\|table(A)\\|table(C)                                     |\n|                  | split                               | superuser\\|global(A)\\|TableOwner\\|TableOwner\\|table(A)                                              |\n|                  | compact                             | superuser\\|global(A)\\|global(C)\\|TableOwner\\|table(A)\\|table(C)                                     |\n|                  | getClosestRowBefore                 | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | getOp                               | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | exists                              | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | put                                 | superuser\\|global(W)\\|NS(W)\\|table(W)\\|TableOwner\\|CF(W)\\|CQ(W)                                     |\n|                  | delete                              | superuser\\|global(W)\\|NS(W)\\|table(W)\\|TableOwner\\|CF(W)\\|CQ(W)                                     |\n|                  | batchMutate                         | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | checkAndPut                         | superuser\\|global(RW)\\|NS(RW)\\|TableOwner\\|table(RW)\\|CF(RW)\\|CQ(RW)                                |\n|                  | checkAndPutAfterRowLock             | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|Table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | checkAndDelete                      | superuser\\|global(RW)\\|NS(RW)\\|TableOwner\\|table(RW)\\|CF(RW)\\|CQ(RW)                                |\n|                  | checkAndDeleteAfterRowLock          | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | incrementColumnValue                | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | append                              | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | appendAfterRowLock                  | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | increment                           | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | incrementAfterRowLock               | superuser\\|global(W)\\|NS(W)\\|TableOwner\\|table(W)\\|CF(W)\\|CQ(W)                                     |\n|                  | scannerOpen                         | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | scannerNext                         | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | scannerClose                        | superuser\\|global(R)\\|NS(R)\\|TableOwner\\|table(R)\\|CF(R)\\|CQ(R)                                     |\n|                  | bulkLoadHFile                       | superuser\\|global(C)\\|TableOwner\\|table(C)\\|CF(C)                                                   |\n|                  | prepareBulkLoad                     | superuser\\|global(C)\\|TableOwner\\|table(C)\\|CF(C)                                                   |\n|                  | cleanupBulkLoad                     | superuser\\|global(C)\\|TableOwner\\|table(C)\\|CF(C)                                                   |\n| Endpoint         | invoke                              | superuser\\|global(X)\\|NS(X)\\|TableOwner\\|table(X)                                                   |\n| AccessController | grant(global level)                 | global(A)                                                                                           |\n|                  | grant(namespace level)              | global(A)\\|NS(A)                                                                                    |\n|                  | grant(table level)                  | global(A)\\|NS(A)\\|TableOwner\\|table(A)\\|CF(A)\\|CQ(A)                                                |\n|                  | revoke(global level)                | global(A)                                                                                           |\n|                  | revoke(namespace level)             | global(A)\\|NS(A)                                                                                    |\n|                  | revoke(table level)                 | global(A)\\|NS(A)\\|TableOwner\\|table(A)\\|CF(A)\\|CQ(A)                                                |\n|                  | getUserPermissions(global level)    | global(A)                                                                                           |\n|                  | getUserPermissions(namespace level) | global(A)\\|NS(A)                                                                                    |\n|                  | getUserPermissions(table level)     | global(A)\\|NS(A)\\|TableOwner\\|table(A)\\|CF(A)\\|CQ(A)                                                |\n|                  | hasPermission(table level)          | global(A)\\|SelfUserCheck                                                                            |\n| RegionServer     | stopRegionServer                    | superuser\\|global(A)                                                                                |\n|                  | mergeRegions                        | superuser\\|global(A)                                                                                |\n|                  | rollWALWriterRequest                | superuser\\|global(A)                                                                                |\n|                  | replicateLogEntries                 | superuser\\|global(W)                                                                                |\n| RSGroup          | addRSGroup                          | superuser\\|global(A)                                                                                |\n|                  | balanceRSGroup                      | superuser\\|global(A)                                                                                |\n|                  | getRSGroupInfo                      | superuser\\|global(A)                                                                                |\n|                  | getRSGroupInfoOfTable               | superuser\\|global(A)                                                                                |\n|                  | getRSGroupOfServer                  | superuser\\|global(A)                                                                                |\n|                  | listRSGroups                        | superuser\\|global(A)                                                                                |\n|                  | moveServers                         | superuser\\|global(A)                                                                                |\n|                  | moveServersAndTables                | superuser\\|global(A)                                                                                |\n|                  | moveTables                          | superuser\\|global(A)                                                                                |\n|                  | removeRSGroup                       | superuser\\|global(A)                                                                                |\n|                  | removeServers                       | superuser\\|global(A)                                                                                |\n\n***\n\n# Compression and Data Block Encoding In HBase\n\n<Callout type=\"info\">\n  Codecs mentioned in this section are for encoding and decoding data blocks or row keys. For\n  information about replication codecs, see\n  [cluster.replication.preserving.tags](/docs/operational-management/cluster-replication#life-of-a-wal-edit).\n</Callout>\n\nHBase supports several different compression algorithms which can be enabled on a ColumnFamily.\nData block encoding attempts to limit duplication of information in keys, taking advantage of some of the fundamental designs and patterns of HBase, such as sorted row keys and the schema of a given table.\nCompressors reduce the size of large, opaque byte arrays in cells, and can significantly reduce the storage space needed to store uncompressed data.\n\nCompressors and data block encoding can be used together on the same ColumnFamily.\n\n## Changes Take Effect Upon Compaction\n\nIf you change compression or encoding for a ColumnFamily, the changes take effect during compaction.\n\nSome codecs take advantage of capabilities built into Java, such as GZip compression.\nOthers rely on native libraries. Native libraries may be available via codec dependencies installed into\nHBase's library directory, or, if you are utilizing Hadoop codecs, as part of Hadoop. Hadoop codecs\ntypically have a native code component so follow instructions for installing Hadoop native binary\nsupport at [Making use of Hadoop Native Libraries in HBase](/docs/compression#making-use-of-hadoop-native-libraries-in-hbase).\n\nThis section discusses common codecs that are used and tested with HBase.\n\nNo matter what codec you use, be sure to test that it is installed correctly and is available on all nodes in your cluster.\nExtra operational steps may be necessary to be sure that codecs are available on newly-deployed nodes.\nYou can use the [compression.test](/docs/compression#compressiontest) utility to check that a given codec is correctly installed.\n\nTo configure HBase to use a compressor, see [compressor.install](/docs/compression#compressor-configuration-installation-and-use).\nTo enable a compressor for a ColumnFamily, see [changing.compression](/docs/compression#enable-compression-on-a-columnfamily).\nTo enable data block encoding for a ColumnFamily, see [data.block.encoding.enable](/docs/compression#enable-data-block-encoding).\n\n## Block Compressors\n\n* **NONE**\\\n  This compression type constant selects no compression, and is the default.\n* **BROTLI**\\\n  [Brotli](https://en.wikipedia.org/wiki/Brotli) is a generic-purpose lossless compression algorithm\n  that compresses data using a combination of a modern variant of the LZ77 algorithm, Huffman\n  coding, and 2nd order context modeling, with a compression ratio comparable to the best currently\n  available general-purpose compression methods. It is similar in speed with GZ but offers more\n  dense compression.\n* **BZIP2**\\\n  [Bzip2](https://en.wikipedia.org/wiki/Bzip2) compresses files using the Burrows-Wheeler block\n  sorting text compression algorithm and Huffman coding. Compression is generally considerably\n  better than that achieved by the dictionary- (LZ-) based compressors, but both compression and\n  decompression can be slow in comparison to other options.\n* **GZ**\\\n  gzip is based on the [DEFLATE](https://en.wikipedia.org/wiki/Deflate) algorithm, which is a\n  combination of LZ77 and Huffman coding. It is universally available in the Java Runtime\n  Environment so is a good lowest common denominator option. However in comparison to more modern\n  algorithms like Zstandard it is quite slow.\n* **LZ4**\\\n  [LZ4](https://en.wikipedia.org/wiki/LZ4_\\(compression_algorithm\\)) is a lossless data compression\n  algorithm that is focused on compression and decompression speed. It belongs to the LZ77 family\n  of compression algorithms, like Brotli, DEFLATE, Zstandard, and others. In our microbenchmarks\n  LZ4 is the fastest option for both compression and decompression in that family, and is our\n  universally recommended option.\n* **LZMA**\\\n  [LZMA](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm) is a\n  dictionary compression scheme somewhat similar to the LZ77 algorithm that achieves very high\n  compression ratios with a computationally expensive predictive model and variable size\n  compression dictionary, while still maintaining decompression speed similar to other commonly used\n  compression algorithms. LZMA is superior to all other options in general compression ratio but as\n  a compressor it can be extremely slow, especially when configured to operate at higher levels of\n  compression.\n* **LZO**\\\n  [LZO](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Oberhumer) is another LZ-variant\n  data compression algorithm, with an implementation focused on decompression speed. It is almost\n  but not quite as fast as LZ4.\n* **SNAPPY**\\\n  [Snappy](https://en.wikipedia.org/wiki/Snappy_\\(compression\\)) is based on ideas from LZ77 but is\n  optimized for very high compression speed, achieving only a \"reasonable\" compression in trade.\n  It is as fast as LZ4 but does not compress quite as well. We offer a pure Java Snappy codec\n  that can be used instead of GZ as the universally available option for any Java runtime on any\n  hardware architecture.\n* **ZSTD**\\\n  [Zstandard](https://en.wikipedia.org/wiki/Zstd) combines a dictionary-matching stage (LZ77) with\n  a large search window and a fast entropy coding stage, using both Finite State Entropy and\n  Huffman coding. Compression speed can vary by a factor of 20 or more between the fastest and\n  slowest levels, while decompression is uniformly fast, varying by less than 20% between the\n  fastest and slowest levels.\\\n  ZStandard is the most flexible of the available compression codec options, offering a compression\n  ratio similar to LZ4 at level 1 (but with slightly less performance), compression ratios\n  comparable to DEFLATE at mid levels (but with better performance), and LZMA-alike dense\n  compression (and LZMA-alike compression speeds) at high levels; while providing universally fast\n  decompression.\n\n## Data Block Encoding Types\n\n### Prefix\n\nOften, keys are very similar. Specifically, keys often share a common prefix and only differ near the end. For instance, one key might be `RowKey:Family:Qualifier0` and the next key might be `RowKey:Family:Qualifier1`.\nIn Prefix encoding, an extra column is added which holds the length of the prefix shared between the current key and the previous key. Assuming the first key here is totally different from the key before, its prefix length is 0.\n\nThe second key's prefix length is `23`, since they have the first 23 characters in common.\n\nObviously if the keys tend to have nothing in common, Prefix will not provide much benefit.\n\nThe following image shows a hypothetical ColumnFamily with no data block encoding.\n\n<img alt=\"ColumnFamily with No Encoding\" src={__img31} placeholder=\"blur\" />\n\nHere is the same data with prefix data encoding.\n\n<img alt=\"ColumnFamily with Prefix Encoding\" src={__img32} placeholder=\"blur\" />\n\n### Diff\n\nDiff encoding expands upon Prefix encoding.\nInstead of considering the key sequentially as a monolithic series of bytes, each key field is split so that each part of the key can be compressed more efficiently.\n\nTwo new fields are added: timestamp and type.\n\nIf the ColumnFamily is the same as the previous row, it is omitted from the current row.\n\nIf the key length, value length or type are the same as the previous row, the field is omitted.\n\nIn addition, for increased compression, the timestamp is stored as a Diff from the previous row's timestamp, rather than being stored in full.\nGiven the two row keys in the Prefix example, and given an exact match on timestamp and the same type, neither the value length, or type needs to be stored for the second row, and the timestamp value for the second row is just 0, rather than a full timestamp.\n\nDiff encoding is disabled by default because writing and scanning are slower but more data is cached.\n\nThis image shows the same ColumnFamily from the previous images, with Diff encoding.\n\n<img alt=\"ColumnFamily with Diff Encoding\" src={__img33} placeholder=\"blur\" />\n\n### Fast Diff\n\nFast Diff works similar to Diff, but uses a faster implementation. It also adds another field which stores a single bit to track whether the data itself is the same as the previous row. If it is, the data is not stored again.\n\nFast Diff is the recommended codec to use if you have long keys or many columns.\n\nThe data format is nearly identical to Diff encoding, so there is not an image to illustrate it.\n\n### Prefix Tree\n\nPrefix tree encoding was introduced as an experimental feature in HBase 0.96.\nIt provides similar memory savings to the Prefix, Diff, and Fast Diff encoder, but provides faster random access at a cost of slower encoding speed.\nIt was removed in hbase-2.0.0. It was a good idea but little uptake. If interested in reviving this effort, write the hbase dev list.\n\n## Which Compressor or Data Block Encoder To Use\n\nThe compression or codec type to use depends on the characteristics of your data. Choosing the wrong type could cause your data to take more space rather than less, and can have performance implications.\n\nIn general, you need to weigh your options between smaller size and faster compression/decompression. Following are some general guidelines, expanded from a discussion at [Documenting Guidance on compression and codecs](https://lists.apache.org/thread.html/481e67a61163efaaf4345510447a9244871a8d428244868345a155ff%401378926618%40%3Cdev.hbase.apache.org%3E).\n\n* In most cases, enabling LZ4 or Snappy by default is a good choice, because they have a low\n  performance overhead and provide reasonable space savings. A fast compression algorithm almost\n  always improves overall system performance by trading some increased CPU usage for better I/O\n  efficiency.\n* If the values are large (and not pre-compressed, such as images), use a data block compressor.\n* For *cold data*, which is accessed infrequently, depending on your use case, it might\n  make sense to opt for Zstandard at its higher compression levels, or LZMA, especially for high\n  entropy binary data, or Brotli for data similar in characteristics to web data. Bzip2 might also\n  be a reasonable option but Zstandard is very likely to offer superior decompression speed.\n* For *hot data*, which is accessed frequently, you almost certainly want only LZ4,\n  Snappy, LZO, or Zstandard at a low compression level. These options will not provide as high of\n  a compression ratio but will in trade not unduly impact system performance.\n* If you have long keys (compared to the values) or many columns, use a prefix encoder.\n  FAST\\_DIFF is recommended.\n* If enabling WAL value compression, consider LZ4 or SNAPPY compression, or Zstandard at\n  level 1. Reading and writing the WAL is performance critical. That said, the I/O\n  savings of these compression options can improve overall system performance.\n\n## Making use of Hadoop Native Libraries in HBase\n\nThe Hadoop shared library has a bunch of facility including compression libraries and fast crc'ing — hardware crc'ing if your chipset supports it.\nTo make this facility available to HBase, do the following. HBase/Hadoop will fall back to use alternatives if it cannot find the native library\nversions — or fail outright if you asking for an explicit compressor and there is no alternative available.\n\nFirst make sure of your Hadoop. Fix this message if you are seeing it starting Hadoop processes:\n\n```\n16/02/09 22:40:24 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable\n```\n\nIt means is not properly pointing at its native libraries or the native libs were compiled for another platform.\nFix this first.\n\nThen if you see the following in your HBase logs, you know that HBase was unable to locate the Hadoop native libraries:\n\n```\n2014-08-07 09:26:20,139 WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable\n```\n\nIf the libraries loaded successfully, the WARN message does not show. Usually this means you are good to go but read on.\n\nLet's presume your Hadoop shipped with a native library that suits the platform you are running HBase on.\nTo check if the Hadoop native library is available to HBase, run the following tool (available in Hadoop 2.1 and greater):\n\n```bash\n$ ./bin/hbase --config ~/conf_hbase org.apache.hadoop.util.NativeLibraryChecker\n2014-08-26 13:15:38,717 WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable\nNative library checking:\nhadoop: false\nzlib:   false\nsnappy: false\nlz4:    false\nbzip2:  false\n2014-08-26 13:15:38,863 INFO  [main] util.ExitUtil: Exiting with status 1\n```\n\nAbove shows that the native hadoop library is not available in HBase context.\n\nThe above NativeLibraryChecker tool may come back saying all is hunky-dory\n— i.e. all libs show 'true', that they are available — but follow the below\npresecription anyways to ensure the native libs are available in HBase context,\nwhen it goes to use them.\n\nTo fix the above, either copy the Hadoop native libraries local or symlink to them if the Hadoop and HBase stalls are adjacent in the filesystem.\nYou could also point at their location by setting the `LD_LIBRARY_PATH` environment variable in your hbase-env.sh.\n\nWhere the JVM looks to find native libraries is \"system dependent\" (See `java.lang.System#loadLibrary(name)`). On linux, by default, is going to look in *lib/native/PLATFORM* where `PLATFORM` is the label for the platform your HBase is installed on.\nOn a local linux machine, it seems to be the concatenation of the java properties `os.name` and `os.arch` followed by whether 32 or 64 bit.\nHBase on startup prints out all of the java system properties so find the os.name and os.arch in the log.\nFor example:\n\n```\n...\n2014-08-06 15:27:22,853 INFO  [main] zookeeper.ZooKeeper: Client environment:os.name=Linux\n2014-08-06 15:27:22,853 INFO  [main] zookeeper.ZooKeeper: Client environment:os.arch=amd64\n...\n```\n\nSo in this case, the PLATFORM string is `Linux-amd64-64`.\nCopying the Hadoop native libraries or symlinking at *lib/native/Linux-amd64-64* will ensure they are found.\nRolling restart after you have made this change.\n\nHere is an example of how you would set up the symlinks.\nLet the hadoop and hbase installs be in your home directory. Assume your hadoop native libs\nare at \\~/hadoop/lib/native. Assume you are on a Linux-amd64-64 platform. In this case,\nyou would do the following to link the hadoop native lib so hbase could find them.\n\n```bash\n...\n$ mkdir -p ~/hbaseLinux-amd64-64 -> /home/stack/hadoop/lib/native/lib/native/\n$ cd ~/hbase/lib/native/\n$ ln -s ~/hadoop/lib/native Linux-amd64-64\n$ ls -la\n# Linux-amd64-64 -> /home/USER/hadoop/lib/native\n...\n```\n\nIf you see PureJavaCrc32C in a stack track or if you see something like the below in a perf trace, then native is not working; you are using the java CRC functions rather than native:\n\n```\n  5.02%  perf-53601.map      [.] Lorg/apache/hadoop/util/PureJavaCrc32C;.update\n```\n\nSee [HBASE-11927 Use Native Hadoop Library for HFile checksum (And flip default from CRC32 to CRC32C)](https://issues.apache.org/jira/browse/HBASE-11927),\nfor more on native checksumming support. See in particular the release note for how to check if your hardware to see if your processor has support for hardware CRCs.\nOr checkout the Apache [Checksums in HBase](https://blogs.apache.org/hbase/entry/saving_cpu_using_native_hadoop) blog post.\n\nHere is example of how to point at the Hadoop libs with `LD_LIBRARY_PATH` environment variable:\n\n```bash\n$ LD_LIBRARY_PATH=~/hadoop-2.5.0-SNAPSHOT/lib/native ./bin/hbase --config ~/conf_hbase org.apache.hadoop.util.NativeLibraryChecker\n2014-08-26 13:42:49,332 INFO  [main] bzip2.Bzip2Factory: Successfully loaded & initialized native-bzip2 library system-native\n2014-08-26 13:42:49,337 INFO  [main] zlib.ZlibFactory: Successfully loaded & initialized native-zlib library\nNative library checking:\nhadoop: true /home/stack/hadoop-2.5.0-SNAPSHOT/lib/native/libhadoop.so.1.0.0\nzlib:   true /lib64/libz.so.1\nsnappy: true /usr/lib64/libsnappy.so.1\nlz4:    true revision:99\nbzip2:  true /lib64/libbz2.so.1\n```\n\nSet in *hbase-env.sh* the LD\\_LIBRARY\\_PATH environment variable when starting your HBase.\n\n## Compressor Configuration, Installation, and Use\n\n### Configure HBase For Compressors\n\nCompression codecs are provided either by HBase compressor modules or by Hadoop's native compression\nsupport. As described above you choose a compression type in table or column family schema or in\nsite configuration using its short label, e.g. *snappy* for Snappy, or *zstd* for ZStandard. Which\ncodec implementation is dynamically loaded to support what label is configurable by way of site\nconfiguration.\n\n| Algorithm label | Codec implementation configuration key | Default value                                               |\n| --------------- | -------------------------------------- | ----------------------------------------------------------- |\n| BROTLI          | hbase.io.compress.brotli.codec         | org.apache.hadoop.hbase.io.compress.brotli.BrotliCodec      |\n| BZIP2           | hbase.io.compress.bzip2.codec          | org.apache.hadoop.io.compress.BZip2Codec                    |\n| GZ              | hbase.io.compress.gz.codec             | org.apache.hadoop.hbase.io.compress.ReusableStreamGzipCodec |\n| LZ4             | hbase.io.compress.lz4.codec            | org.apache.hadoop.io.compress.Lz4Codec                      |\n| LZMA            | hbase.io.compress.lzma.codec           | org.apache.hadoop.hbase.io.compress.xz.LzmaCodec            |\n| LZO             | hbase.io.compress.lzo.codec            | com.hadoop.compression.lzo.LzoCodec                         |\n| SNAPPY          | hbase.io.compress.snappy.codec         | org.apache.hadoop.io.compress.SnappyCodec                   |\n| ZSTD            | hbase.io.compress.zstd.codec           | org.apache.hadoop.io.compress.ZStandardCodec                |\n\nThe available codec implementation options are:\n\n| Label  | Codec implementation class                                    | Notes                                                                                                                         |\n| ------ | ------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |\n| BROTLI | org.apache.hadoop.hbase.io.compress.brotli.BrotliCodec        | Implemented with [Brotli4j](https://github.com/hyperxpro/Brotli4j)                                                            |\n| BZIP2  | org.apache.hadoop.io.compress.BZip2Codec                      | Hadoop native codec                                                                                                           |\n| GZ     | org.apache.hadoop.hbase.io.compress.ReusableStreamGzipCodec   | Requires the Hadoop native GZ codec                                                                                           |\n| LZ4    | org.apache.hadoop.io.compress.Lz4Codec                        | Hadoop native codec                                                                                                           |\n| LZ4    | org.apache.hadoop.hbase.io.compress.aircompressor.Lz4Codec    | Pure Java implementation                                                                                                      |\n| LZ4    | org.apache.hadoop.hbase.io.compress.lz4.Lz4Codec              | Implemented with [lz4-java](https://github.com/lz4/lz4-java)                                                                  |\n| LZMA   | org.apache.hadoop.hbase.io.compress.xz.LzmaCodec              | Implemented with [XZ For Java](https://tukaani.org/xz/java.html)                                                              |\n| LZO    | com.hadoop.compression.lzo.LzoCodec                           | Hadoop native codec, requires GPL licensed native dependencies                                                                |\n| LZO    | org.apache.hadoop.io.compress.LzoCodec                        | Hadoop native codec, requires GPL licensed native dependencies                                                                |\n| LZO    | org.apache.hadoop.hbase.io.compress.aircompressor.LzoCodec    | Pure Java implementation                                                                                                      |\n| SNAPPY | org.apache.hadoop.io.compress.SnappyCodec                     | Hadoop native codec                                                                                                           |\n| SNAPPY | org.apache.hadoop.hbase.io.compress.aircompressor.SnappyCodec | Pure Java implementation                                                                                                      |\n| SNAPPY | org.apache.hadoop.hbase.io.compress.xerial.SnappyCodec        | Implemented with [snappy-java](https://github.com/xerial/snappy-java)                                                         |\n| ZSTD   | org.apache.hadoop.io.compress.ZStandardCodec                  | Hadoop native codec                                                                                                           |\n| ZSTD   | org.apache.hadoop.hbase.io.compress.aircompressor.ZstdCodec   | Pure Java implementation, limited to a fixed compression level, not data compatible with the Hadoop zstd codec                |\n| ZSTD   | org.apache.hadoop.hbase.io.compress.zstd.ZstdCodec            | Implemented with [zstd-jni](https://github.com/luben/zstd-jni), supports all compression levels, supports custom dictionaries |\n\nSpecify which codec implementation option you prefer for a given compression algorithm\nin site configuration, like so:\n\n```xml\n...\n<property>\n  <name>hbase.io.compress.lz4.codec</name>\n  <value>org.apache.hadoop.hbase.io.compress.lz4.Lz4Codec</value>\n</property>\n...\n```\n\n#### Compressor Microbenchmarks\n\nSee [https://github.com/apurtell/jmh-compression-tests](https://github.com/apurtell/jmh-compression-tests)\n\n256MB (258,126,022 bytes exactly) of block data was extracted from two HFiles containing Common\nCrawl data ingested using IntegrationLoadTestCommonCrawl, 2,680 blocks in total. This data was\nprocessed by each new codec implementation as if the block data were being compressed again for\nwrite into an HFile, but without writing any data, comparing only the CPU time and resource demand\nof the codec itself. Absolute performance numbers will vary depending on hardware and software\nparticulars of your deployment. The relative differences are what are interesting. Measured time\nis the average time in milliseconds required to compress all blocks of the 256MB file. This is\nhow long it would take to write the HFile containing these contents, minus the I/O overhead of\nblock encoding and actual persistence.\n\nThese are the results:\n\n| Codec                   | Level         | Time (milliseconds)  | Result (bytes) | Improvement |\n| ----------------------- | ------------- | -------------------- | -------------- | ----------- |\n| AirCompressor LZ4       | -             | 349.989 ± 2.835      | 76,999,408     | 70.17%      |\n| AirCompressor LZO       | -             | 334.554 ± 3.243      | 79,369,805     | 69.25%      |\n| AirCompressor Snappy    | -             | 364.153 ± 19.718     | 80,201,763     | 68.93%      |\n| AirCompressor Zstandard | 3 (effective) | 1108.267 ± 8.969     | 55,129,189     | 78.64%      |\n| Brotli                  | 1             | 593.107 ± 2.376      | 58,672,319     | 77.27%      |\n| Brotli                  | 3             | 1345.195 ± 27.327    | 53,917,438     | 79.11%      |\n| Brotli                  | 6             | 2812.411 ± 25.372    | 48,696,441     | 81.13%      |\n| Brotli                  | 10            | 74615.936 ± 224.854  | 44,970,710     | 82.58%      |\n| LZ4 (lz4-java)          | -             | 303.045 ± 0.783      | 76,974,364     | 70.18%      |\n| LZMA                    | 1             | 6410.428 ± 115.065   | 49,948,535     | 80.65%      |\n| LZMA                    | 3             | 8144.620 ± 152.119   | 49,109,363     | 80.97%      |\n| LZMA                    | 6             | 43802.576 ± 382.025  | 46,951,810     | 81.81%      |\n| LZMA                    | 9             | 49821.979 ± 580.110  | 46,951,810     | 81.81%      |\n| Snappy (xerial)         | -             | 360.225 ± 2.324      | 80,749,937     | 68.72%      |\n| Zstd (zstd-jni)         | 1             | 654.699 ± 16.839     | 56,719,994     | 78.03%      |\n| Zstd (zstd-jni)         | 3             | 839.160 ± 24.906     | 54,573,095     | 78.86%      |\n| Zstd (zstd-jni)         | 5             | 1594.373 ± 22.384    | 52,025,485     | 79.84%      |\n| Zstd (zstd-jni)         | 7             | 2308.705 ± 24.744    | 50,651,554     | 80.38%      |\n| Zstd (zstd-jni)         | 9             | 3659.677 ± 58.018    | 50,208,425     | 80.55%      |\n| Zstd (zstd-jni)         | 12            | 8705.294 ± 58.080    | 49,841,446     | 80.69%      |\n| Zstd (zstd-jni)         | 15            | 19785.646 ± 278.080  | 48,499,508     | 81.21%      |\n| Zstd (zstd-jni)         | 18            | 47702.097 ± 442.670  | 48,319,879     | 81.28%      |\n| Zstd (zstd-jni)         | 22            | 97799.695 ± 1106.571 | 48,212,220     | 81.32%      |\n\n#### Compressor Support On the Master\n\nA new configuration setting was introduced in HBase 0.95, to check the Master to determine which data block encoders are installed and configured on it, and assume that the entire cluster is configured the same.\nThis option, `hbase.master.check.compression`, defaults to `true`.\nThis prevents the situation described in [HBASE-6370](https://issues.apache.org/jira/browse/HBASE-6370), where a table is created or modified to support a codec that a region server does not support, leading to failures that take a long time to occur and are difficult to debug.\n\nIf `hbase.master.check.compression` is enabled, libraries for all desired compressors need to be installed and configured on the Master, even if the Master does not run a region server.\n\n#### Install GZ Support Via Native Libraries\n\nHBase uses Java's built-in GZip support unless the native Hadoop libraries are available on the CLASSPATH.\nThe recommended way to add libraries to the CLASSPATH is to set the environment variable `HBASE_LIBRARY_PATH` for the user running HBase.\nIf native libraries are not available and Java's GZIP is used, `Got brand-new compressor` reports will be present in the logs.\nSee [brand.new.compressor](/docs/troubleshooting#logs-flooded-with-2011-01-10-124048407-info-orgapachehadoopiocompresscodecpool-gotbrand-new-compressor-messages)).\n\n#### Install Hadoop Native LZO Support\n\nHBase cannot ship with the Hadoop native LZO codc because of incompatibility between HBase, which uses an Apache Software License (ASL) and LZO, which uses a GPL license.\nSee the [Hadoop-LZO at Twitter](https://github.com/twitter/hadoop-lzo/blob/master/README.md) for information on configuring LZO support for HBase.\n\nIf you depend upon LZO compression, consider using the pure Java and ASL licensed\nAirCompressor LZO codec option instead of the Hadoop native default, or configure your\nRegionServers to fail to start if native LZO support is not available.\nSee [hbase.regionserver.codecs](/docs/compression#enforce-compression-settings-on-a-regionserver).\n\n#### Configure Hadoop Native LZ4 Support\n\nLZ4 support is bundled with Hadoop and is the default LZ4 codec implementation.\nIt is not required that you make use of the Hadoop LZ4 codec. Our LZ4 codec implemented\nwith lz4-java offers superior performance, and the AirCompressor LZ4 codec offers a\npure Java option for use where native support is not available.\n\nThat said, if you prefer the Hadoop option, make sure the hadoop shared library\n(libhadoop.so) is accessible when you start HBase.\nAfter configuring your platform (see [hadoop.native.lib](/docs/compression#making-use-of-hadoop-native-libraries-in-hbase)), you can\nmake a symbolic link from HBase to the native Hadoop libraries. This assumes the two\nsoftware installs are colocated. For example, if my 'platform' is Linux-amd64-64:\n\n```bash\n$ cd $HBASE_HOME\n$ mkdir lib/native\n$ ln -s $HADOOP_HOME/lib/native lib/native/Linux-amd64-64\n```\n\nUse the compression tool to check that LZ4 is installed on all nodes.\nStart up (or restart) HBase.\nAfterward, you can create and alter tables to enable LZ4 as a compression codec.:\n\n```ruby\nhbase(main):003:0> alter 'TestTable', {NAME => 'info', COMPRESSION => 'LZ4'}\n```\n\n#### Install Hadoop native Snappy Support\n\nSnappy support is bundled with Hadoop and is the default Snappy codec implementation.\nIt is not required that you make use of the Hadoop Snappy codec. Our Snappy codec\nimplemented with Xerial Snappy offers superior performance, and the AirCompressor\nSnappy codec offers a pure Java option for use where native support is not available.\n\nThat said, if you prefer the Hadoop codec option, you can install Snappy binaries (for\ninstance, by using +yum install snappy+ on CentOS) or build Snappy from source.\nAfter installing Snappy, search for the shared library, which will be called *libsnappy.so.X* where X is a number.\nIf you built from source, copy the shared library to a known location on your system, such as */opt/snappy/lib/*.\n\nIn addition to the Snappy library, HBase also needs access to the Hadoop shared library, which will be called something like *libhadoop.so.X.Y*, where X and Y are both numbers.\nMake note of the location of the Hadoop library, or copy it to the same location as the Snappy library.\n\n<Callout type=\"info\">\n  The Snappy and Hadoop libraries need to be available on each node of your cluster.\n  See [compression.test](/docs/compression#compressiontest) to find out how to test that this is the case.\n\n  See [hbase.regionserver.codecs](/docs/compression#enforce-compression-settings-on-a-regionserver) to configure your RegionServers to fail to start if a given compressor is not available.\n</Callout>\n\nEach of these library locations need to be added to the environment variable `HBASE_LIBRARY_PATH` for the operating system user that runs HBase.\nYou need to restart the RegionServer for the changes to take effect.\n\n#### CompressionTest\n\nYou can use the CompressionTest tool to verify that your compressor is available to HBase:\n\n```bash\n $ hbase org.apache.hadoop.hbase.util.CompressionTest hdfs://host/path/to/hbase snappy\n```\n\n#### Enforce Compression Settings On a RegionServer\n\nYou can configure a RegionServer so that it will fail to restart if compression is configured incorrectly, by adding the option hbase.regionserver.codecs to the *hbase-site.xml*, and setting its value to a comma-separated list of codecs that need to be available.\nFor example, if you set this property to `lzo,gz`, the RegionServer would fail to start if both compressors were not available.\nThis would prevent a new server from being added to the cluster without having codecs configured properly.\n\n### Enable Compression On a ColumnFamily\n\nTo enable compression for a ColumnFamily, use an `alter` command.\nYou do not need to re-create the table or copy data.\nIf you are changing codecs, be sure the old codec is still available until all the old StoreFiles have been compacted.\n\n#### Enabling Compression on a ColumnFamily of an Existing Table using HBaseShell\n\n```ruby\nhbase> alter 'test', {NAME => 'cf', COMPRESSION => 'GZ'}\n```\n\n#### Creating a New Table with Compression On a ColumnFamily\n\n```ruby\nhbase> create 'test2', { NAME => 'cf2', COMPRESSION => 'SNAPPY' }\n```\n\n#### Verifying a ColumnFamily's Compression Settings\n\n```ruby\nhbase> describe 'test'\nDESCRIPTION                                          ENABLED\n 'test', {NAME => 'cf', DATA_BLOCK_ENCODING => 'NONE false\n ', BLOOMFILTER => 'ROW', REPLICATION_SCOPE => '0',\n VERSIONS => '1', COMPRESSION => 'GZ', MIN_VERSIONS\n => '0', TTL => 'FOREVER', KEEP_DELETED_CELLS => 'fa\n lse', BLOCKSIZE => '65536', IN_MEMORY => 'false', B\n LOCKCACHE => 'true'}\n1 row(s) in 0.1070 seconds\n```\n\n### Testing Compression Performance\n\nHBase includes a tool called LoadTestTool which provides mechanisms to test your compression performance.\nYou must specify either `-write` or `-update-read` as your first parameter, and if you do not specify another parameter, usage advice is printed for each option.\n\n**`LoadTestTool` Usage**\n\n```bash\n$ bin/hbase org.apache.hadoop.hbase.util.LoadTestTool -h\nusage: bin/hbase org.apache.hadoop.hbase.util.LoadTestTool <options>\nOptions:\n -batchupdate                 Whether to use batch as opposed to separate\n                              updates for every column in a row\n -bloom <arg>                 Bloom filter type, one of [NONE, ROW, ROWCOL]\n -compression <arg>           Compression type, one of [LZO, GZ, NONE, SNAPPY,\n                              LZ4]\n -data_block_encoding <arg>   Encoding algorithm (e.g. prefix compression) to\n                              use for data blocks in the test column family, one\n                              of [NONE, PREFIX, DIFF, FAST_DIFF, ROW_INDEX_V1].\n -encryption <arg>            Enables transparent encryption on the test table,\n                              one of [AES]\n -generator <arg>             The class which generates load for the tool. Any\n                              args for this class can be passed as colon\n                              separated after class name\n -h,--help                    Show usage\n -in_memory                   Tries to keep the HFiles of the CF inmemory as far\n                              as possible.  Not guaranteed that reads are always\n                              served from inmemory\n -init_only                   Initialize the test table only, don't do any\n                              loading\n -key_window <arg>            The 'key window' to maintain between reads and\n                              writes for concurrent write/read workload. The\n                              default is 0.\n -max_read_errors <arg>       The maximum number of read errors to tolerate\n                              before terminating all reader threads. The default\n                              is 10.\n -multiput                    Whether to use multi-puts as opposed to separate\n                              puts for every column in a row\n -num_keys <arg>              The number of keys to read/write\n -num_tables <arg>            A positive integer number. When a number n is\n                              speicfied, load test tool  will load n table\n                              parallely. -tn parameter value becomes table name\n                              prefix. Each table name is in format\n                              <tn>_1...<tn>_n\n -read <arg>                  <verify_percent>[:#threads=20]\n -regions_per_server <arg>    A positive integer number. When a number n is\n                              specified, load test tool will create the test\n                              table with n regions per server\n -skip_init                   Skip the initialization; assume test table already\n                              exists\n -start_key <arg>             The first key to read/write (a 0-based index). The\n                              default value is 0.\n -tn <arg>                    The name of the table to read or write\n -update <arg>                <update_percent>[:#threads=20][:#whether to\n                              ignore nonce collisions=0]\n -write <arg>                 <avg_cols_per_key>:<avg_data_size>[:#threads=20]\n -zk <arg>                    ZK quorum as comma-separated host names without\n                              port numbers\n -zk_root <arg>               name of parent znode in zookeeper\n```\n\n#### Example Usage of LoadTestTool\n\n```bash\n$ hbase org.apache.hadoop.hbase.util.LoadTestTool -write 1:10:100 -num_keys 1000000 \\\n      -read 100:30 -num_tables 1 -data_block_encoding NONE -tn load_test_tool_NONE\n```\n\n## Enable Data Block Encoding\n\nCodecs are built into HBase so no extra configuration is needed.\nCodecs are enabled on a table by setting the `DATA_BLOCK_ENCODING` property.\nDisable the table before altering its DATA\\_BLOCK\\_ENCODING setting.\nFollowing is an example using HBase Shell:\n\n#### Enable Data Block Encoding On a Table\n\n```ruby\nhbase> alter 'test', { NAME => 'cf', DATA_BLOCK_ENCODING => 'FAST_DIFF' }\nUpdating all regions with the new schema...\n0/1 regions updated.\n1/1 regions updated.\nDone.\n0 row(s) in 2.2820 seconds\n```\n\n#### Verifying a ColumnFamily's Data Block Encoding\n\n```ruby\nhbase> describe 'test'\nDESCRIPTION                                          ENABLED\n 'test', {NAME => 'cf', DATA_BLOCK_ENCODING => 'FAST true\n _DIFF', BLOOMFILTER => 'ROW', REPLICATION_SCOPE =>\n '0', VERSIONS => '1', COMPRESSION => 'GZ', MIN_VERS\n IONS => '0', TTL => 'FOREVER', KEEP_DELETED_CELLS =\n > 'false', BLOCKSIZE => '65536', IN_MEMORY => 'fals\n e', BLOCKCACHE => 'true'}\n1 row(s) in 0.0650 seconds\n```\n\n***\n\n# SQL over HBase\n\n[Apache Phoenix](https://phoenix.apache.org)\n\n[Trafodion: Transactional SQL-on-HBase](https://trafodion.incubator.apache.org/)\n\n***\n\n# YCSB\n\n[YCSB: The Yahoo! Cloud Serving Benchmark](https://github.com/brianfrankcooper/YCSB/) and HBase\n\nTODO: Describe how YCSB is poor for putting up a decent cluster load.\n\nTODO: Describe setup of YCSB for HBase. In particular, presplit your tables before you start a run. See [HBASE-4163 Create Split Strategy for YCSB Benchmark](https://issues.apache.org/jira/browse/HBASE-4163) for why and a little shell command for how to do it.\n\n***\n\n# HFile Format\n\n## HBase File Format (version 1)\n\nAs we will be discussing changes to the HFile format, it is useful to give a short overview of the original (HFile version 1) format.\n\n### Overview of Version 1\n\nAn HFile in version 1 format is structured as follows:\n\n<img alt=\"HFile V1 Format\" src={__img34} placeholder=\"blur\" />\n\n### Block index format in version 1\n\nThe block index in version 1 is very straightforward.\nFor each entry, it contains:\n\n1. Offset (long)\n2. Uncompressed size (int)\n3. Key (a serialized byte array written using Bytes.writeByteArray)\n   * Key length as a variable-length integer (VInt)\n   * Key bytes\n\nThe number of entries in the block index is stored in the fixed file trailer, and has to be passed in to the method that reads the block index.\nOne of the limitations of the block index in version 1 is that it does not provide the compressed size of a block, which turns out to be necessary for decompression.\nTherefore, the HFile reader has to infer this compressed size from the offset difference between blocks.\nWe fix this limitation in version 2, where we store on-disk block size instead of uncompressed size, and get uncompressed size from the block header.\n\n## HBase file format with inline blocks (version 2)\n\nNote: this feature was introduced in HBase 0.92\n\n### Motivation\n\nWe found it necessary to revise the HFile format after encountering high memory usage and slow startup times caused by large Bloom filters and block indexes in the region server.\nBloom filters can get as large as 100 MB per HFile, which adds up to 2 GB when aggregated over 20 regions.\nBlock indexes can grow as large as 6 GB in aggregate size over the same set of regions.\nA region is not considered opened until all of its block index data is loaded.\nLarge Bloom filters produce a different performance problem: the first get request that requires a Bloom filter lookup will incur the latency of loading the entire Bloom filter bit array.\n\nTo speed up region server startup we break Bloom filters and block indexes into multiple blocks and write those blocks out as they fill up, which also reduces the HFile writer's memory footprint.\nIn the Bloom filter case, \"filling up a block\" means accumulating enough keys to efficiently utilize a fixed-size bit array, and in the block index case we accumulate an \"index block\" of the desired size.\nBloom filter blocks and index blocks (we call these \"inline blocks\") become interspersed with data blocks, and as a side effect we can no longer rely on the difference between block offsets to determine data block length, as it was done in version 1.\n\nHFile is a low-level file format by design, and it should not deal with application-specific details such as Bloom filters, which are handled at StoreFile level.\nTherefore, we call Bloom filter blocks in an HFile \"inline\" blocks.\nWe also supply HFile with an interface to write those inline blocks.\n\nAnother format modification aimed at reducing the region server startup time is to use a contiguous \"load-on-open\" section that has to be loaded in memory at the time an HFile is being opened.\nCurrently, as an HFile opens, there are separate seek operations to read the trailer, data/meta indexes, and file info.\nTo read the Bloom filter, there are two more seek operations for its \"data\" and \"meta\" portions.\nIn version 2, we seek once to read the trailer and seek again to read everything else we need to open the file from a contiguous block.\n\n### Overview of Version 2\n\nThe version of HBase introducing the above features reads both version 1 and 2 HFiles, but only writes version 2 HFiles.\nA version 2 HFile is structured as follows:\n\n<img alt=\"HFile Version 2 Structure\" src={__img35} placeholder=\"blur\" />\n\n### Unified version 2 block format\n\nIn the version 2 every block in the data section contains the following fields:\n\n1. 8 bytes: Block type, a sequence of bytes equivalent to version 1's \"magic records\". Supported block types are:\n   * DATA – data blocks\n   * LEAF\\_INDEX – leaf-level index blocks in a multi-level-block-index\n   * BLOOM\\_CHUNK – Bloom filter chunks\n   * META – meta blocks (not used for Bloom filters in version 2 anymore)\n   * INTERMEDIATE\\_INDEX – intermediate-level index blocks in a multi-level blockindex\n   * ROOT\\_INDEX – root-level index blocks in a multi-level block index\n   * FILE\\_INFO – the \"file info\" block, a small key-value map of metadata\n   * BLOOM\\_META – a Bloom filter metadata block in the load-on-open section\n   * TRAILER – a fixed-size file trailer. As opposed to the above, this is not an HFile v2 block but a fixed-size (for each HFile version) data structure\n   * INDEX\\_V1 – this block type is only used for legacy HFile v1 block\n2. Compressed size of the block's data, not including the header (int).\\\n   Can be used for skipping the current data block when scanning HFile data.\n3. Uncompressed size of the block's data, not including the header (int)\\\n   This is equal to the compressed size if the compression algorithm is NONE\n4. File offset of the previous block of the same type (long)\\\n   Can be used for seeking to the previous data/index block\n5. Compressed data (or uncompressed data if the compression algorithm is NONE).\n\nThe above format of blocks is used in the following HFile sections:\n\n#### Scanned block section\n\nThe section is named so because it contains all data blocks that need to be read when an HFile is scanned sequentially.\nAlso contains Leaf index blocks and Bloom chunk blocks.\n\n#### Non-scanned block section\n\nThis section still contains unified-format v2 blocks but it does not have to be read when doing a sequential scan.\nThis section contains \"meta\" blocks and intermediate-level index blocks.\n\nWe are supporting \"meta\" blocks in version 2 the same way they were supported in version 1, even though we do not store Bloom filter data in these blocks anymore.\n\n### Block index in version 2\n\nThere are three types of block indexes in HFile version 2, stored in two different formats (root and non-root):\n\n1. Data index — version 2 multi-level block index, consisting of:\n   * Version 2 root index, stored in the data block index section of the file\n   * Optionally, version 2 intermediate levels, stored in the non-root format in the data index section of the file. Intermediate levels can only be present if leaf level blocks are present\n   * Optionally, version 2 leaf levels, stored in the non-root format inline with data blocks\n2. Meta index — version 2 root index format only, stored in the meta index section of the file\n3. Bloom index — version 2 root index format only, stored in the \"load-on-open\" section as part of Bloom filter metadata.\n\n### Root block index format in version 2\n\nThis format applies to:\n\n1. Root level of the version 2 data index\n2. Entire meta and Bloom indexes in version 2, which are always single-level.\n\nA version 2 root index block is a sequence of entries of the following format, similar to entries of a version 1 block index, but storing on-disk size instead of uncompressed size.\n\n1. Offset (long)\\\n   This offset may point to a data block or to a deeper-level index block.\n2. On-disk size (int)\n3. Key (a serialized byte array stored using Bytes.writeByteArray)\n4. Key (VInt)\n5. Key bytes\n\nA single-level version 2 block index consists of just a single root index block.\nTo read a root index block of version 2, one needs to know the number of entries.\nFor the data index and the meta index the number of entries is stored in the trailer, and for the Bloom index it is stored in the compound Bloom filter metadata.\n\nFor a multi-level block index we also store the following fields in the root index block in the load-on-open section of the HFile, in addition to the data structure described above:\n\n* Middle leaf index block offset\n* Middle leaf block on-disk size (meaning the leaf index block containing the reference to the \"middle\" data block of the file)\n* The index of the mid-key (defined below) in the middle leaf-level block.\n\nThese additional fields are used to efficiently retrieve the mid-key of the HFile used in HFile splits, which we define as the first key of the block with a zero-based index of (n – 1) / 2, if the total number of blocks in the HFile is n.\nThis definition is consistent with how the mid-key was determined in HFile version 1, and is reasonable in general, because blocks are likely to be the same size on average, but we don't have any estimates on individual key/value pair sizes.\n\nWhen writing a version 2 HFile, the total number of data blocks pointed to by every leaf-level index block is kept track of.\nWhen we finish writing and the total number of leaf-level blocks is determined, it is clear which leaf-level block contains the mid-key, and the fields listed above are computed.\nWhen reading the HFile and the mid-key is requested, we retrieve the middle leaf index block (potentially from the block cache) and get the mid-key value from the appropriate position inside that leaf block.\n\n### Non-root block index format in version 2\n\nThis format applies to intermediate-level and leaf index blocks of a version 2 multi-level data block index.\nEvery non-root index block is structured as follows.\n\n1. numEntries: the number of entries (int).\n2. entryOffsets: the \"secondary index\" of offsets of entries in the block, to facilitate\n   a quick binary search on the key (`numEntries + 1` int values). The last value\n   is the total length of all entries in this index block. For example, in a non-root\n   index block with entry sizes 60, 80, 50 the \"secondary index\" will contain the\n   following int array: `{0, 60, 140, 190}`.\n3. Entries. Each entry contains:\n   * Offset of the block referenced by this entry in the file (long)\n   * On-disk size of the referenced block (int)\n   * Key. The length can be calculated from entryOffsets.\n\n### Bloom filters in version 2\n\nIn contrast with version 1, in a version 2 HFile Bloom filter metadata is stored in the load-on-open section of the HFile for quick startup.\n\n* A compound Bloom filter.\n* Bloom filter version = 3 (int). There used to be a DynamicByteBloomFilter class that had the Bloom filter version number 2\n* The total byte size of all compound Bloom filter chunks (long)\n* Number of hash functions (int)\n* Type of hash functions (int)\n* The total key count inserted into the Bloom filter (long)\n* The maximum total number of keys in the Bloom filter (long)\n* The number of chunks (int)\n* Comparator class used for Bloom filter keys, a UTF-8 encoded string stored using Bytes.writeByteArray\n* Bloom block index in the version 2 root block index format\n\n### File Info format in versions 1 and 2\n\nThe file info block is a serialized map from byte arrays to byte arrays, with the following keys, among others.\nStoreFile-level logic adds more keys to this.\n\n| Key                   | Description                                |\n| --------------------- | ------------------------------------------ |\n| hfile.LASTKEY         | The last key of the file (byte array)      |\n| hfile.AVG\\_KEY\\_LEN   | The average key length in the file (int)   |\n| hfile.AVG\\_VALUE\\_LEN | The average value length in the file (int) |\n\nIn version 2, we did not change the file format, but we moved the file info to\nthe final section of the file, which can be loaded as one block when the HFile\nis being opened.\n\nAlso, we do not store the comparator in the version 2 file info anymore.\nInstead, we store it in the fixed file trailer.\nThis is because we need to know the comparator at the time of parsing the load-on-open section of the HFile.\n\n### Fixed file trailer format differences between versions 1 and 2\n\nThe following table shows common and different fields between fixed file trailers in versions 1 and 2.\nNote that the size of the trailer is different depending on the version, so it is \"fixed\" only within one version.\nHowever, the version is always stored as the last four-byte integer in the file.\n\n#### Differences between HFile Versions 1 and 2\n\n| Version 1                                                                                                       | Version 2                                                                                                                                                      |\n| --------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n|                                                                                                                 | File info offset (long)                                                                                                                                        |\n| Data index offset (long)                                                                                        | loadOnOpenOffset (long) *The offset of the section that we need to load when opening the file.*                                                                |\n|                                                                                                                 | Number of data index entries (int)                                                                                                                             |\n| metaIndexOffset (long) *This field is not being used by the version 1 reader, so we removed it from version 2.* | uncompressedDataIndexSize (long) *The total uncompressed size of the whole data block index, including root-level, intermediate-level, and leaf-level blocks.* |\n|                                                                                                                 | Number of meta index entries (int)                                                                                                                             |\n|                                                                                                                 | Total uncompressed bytes (long)                                                                                                                                |\n| numEntries (int)                                                                                                | numEntries (long)                                                                                                                                              |\n| Compression codec: 0 = LZO, 1 = GZ, 2 = NONE (int)                                                              | Compression codec: 0 = LZO, 1 = GZ, 2 = NONE (int)                                                                                                             |\n|                                                                                                                 | The number of levels in the data block index (int)                                                                                                             |\n|                                                                                                                 | firstDataBlockOffset (long) *The offset of the first data block. Used when scanning.*                                                                          |\n|                                                                                                                 | lastDataBlockEnd (long) *The offset of the first byte after the last key/value data block. We don't need to go beyond this offset when scanning.*              |\n| Version: 1 (int)                                                                                                | Version: 2 (int)                                                                                                                                               |\n\n### getShortMidpointKey (an optimization for data index block)\n\nNote: this optimization was introduced in HBase 0.95+\n\nHFiles contain many blocks that contain a range of sorted Cells.\nEach cell has a key.\nTo save IO when reading Cells, the HFile also has an index that maps a Cell's start key to the offset of the beginning of a particular block.\nPrior to this optimization, HBase would use the key of the first cell in each data block as the index key.\n\nIn HBASE-7845, we generate a new key that is lexicographically larger than the last key of the previous block and lexicographically equal or smaller than the start key of the current block.\nWhile actual keys can potentially be very long, this \"fake key\" or \"virtual key\" can be much shorter.\nFor example, if the stop key of previous block is \"the quick brown fox\", the start key of current block is \"the who\", we could use \"the r\" as our virtual key in our hfile index.\n\nThere are two benefits to this:\n\n* having shorter keys reduces the hfile index size, (allowing us to keep more indexes in memory), and\n* using something closer to the end key of the previous block allows us to avoid a potential extra IO when the target key lives in between the \"virtual key\" and the key of the first element in the target block.\n\nThis optimization (implemented by the getShortMidpointKey method) is inspired by LevelDB's ByteWiseComparatorImpl::FindShortestSeparator() and FindShortSuccessor().\n\n## HBase File Format with Security Enhancements (version 3)\n\nNote: this feature was introduced in HBase 0.98\n\n### Motivation\n\nVersion 3 of HFile makes changes needed to ease management of encryption at rest and cell-level metadata (which in turn is needed for cell-level ACLs and cell-level visibility labels). For more information see [hbase.encryption.server](/docs/security/data-access#transparent-encryption-of-data-at-rest), [hbase.tags](/docs/security/data-access#tags), [hbase.accesscontrol.configuration](/docs/hbase-incompatibilities#interface-accesscontrolconstants), and [hbase.visibility.labels](/docs/security/data-access#visibility-labels).\n\n### Overview\n\nThe version of HBase introducing the above features reads HFiles in versions 1, 2, and 3 but only writes version 3 HFiles.\nVersion 3 HFiles are structured the same as version 2 HFiles.\nFor more information see [hfilev2.overview](/docs/hfile-format#overview-of-version-2).\n\n### File Info Block in Version 3\n\nVersion 3 added two additional pieces of information to the reserved keys in the file info block.\n\n| Key                    | Description                                                                                                                     |\n| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------- |\n| hfile.MAX\\_TAGS\\_LEN   | The maximum number of bytes needed to store the serialized tags for any single cell in this hfile (int)                         |\n| hfile.TAGS\\_COMPRESSED | Does the block encoder for this hfile compress tags? (boolean). Should only be present if hfile.MAX\\_TAGS\\_LEN is also present. |\n\nWhen reading a Version 3 HFile the presence of `MAX_TAGS_LEN` is used to determine how to deserialize the cells within a data block.\nTherefore, consumers must read the file's info block prior to reading any data blocks.\n\nWhen writing a Version 3 HFile, HBase will always include `MAX_TAGS_LEN` when flushing the memstore to underlying filesystem.\n\nWhen compacting extant files, the default writer will omit `MAX_TAGS_LEN` if all of the files selected do not themselves contain any cells with tags.\n\nSee [compaction](/docs/architecture/regions#compaction) for details on the compaction file selection algorithm.\n\n### Data Blocks in Version 3\n\nWithin an HFile, HBase cells are stored in data blocks as a sequence of KeyValues (see [hfilev1.overview](/docs/hfile-format#overview-of-version-1), or [Lars George's\nexcellent introduction to HBase Storage](http://www.larsgeorge.com/2009/10/hbase-architecture-101-storage.html)). In version 3, these KeyValue optionally will include a set of 0 or more tags:\n\n|                        | Version 1 & 2, Version 3 without MAX\\_TAGS\\_LEN | Version 3 with MAX\\_TAGS\\_LEN |\n| ---------------------- | ----------------------------------------------- | ----------------------------- |\n| Key Length (4 bytes)   | ✓                                               | ✓                             |\n| Value Length (4 bytes) | ✓                                               | ✓                             |\n| Key bytes (variable)   | ✓                                               | ✓                             |\n| Value bytes (variable) | ✓                                               | ✓                             |\n| Tags Length (2 bytes)  |                                                 | ✓                             |\n| Tags bytes (variable)  |                                                 | ✓                             |\n\nIf the info block for a given HFile contains an entry for `MAX_TAGS_LEN` each cell will have the length of that cell's tags included, even if that length is zero.\nThe actual tags are stored as a sequence of tag length (2 bytes), tag type (1 byte), tag bytes (variable). The format an individual tag's bytes depends on the tag type.\n\nNote that the dependence on the contents of the info block implies that prior to reading any data blocks you must first process a file's info block.\nIt also implies that prior to writing a data block you must know if the file's info block will include `MAX_TAGS_LEN`.\n\n### Fixed File Trailer in Version 3\n\nThe fixed file trailers written with HFile version 3 are always serialized with protocol buffers.\nAdditionally, it adds an optional field to the version 2 protocol buffer named encryption\\_key.\nIf HBase is configured to encrypt HFiles this field will store a data encryption key for this particular HFile, encrypted with the current cluster master key using AES.\nFor more information see [hbase.encryption.server](/docs/security/data-access#transparent-encryption-of-data-at-rest).\n\n***\n\n# Other Information About HBase\n\n## HBase Videos\n\n* [Introduction to HBase](https://vimeo.com/23400732) by Todd Lipcon (Chicago Data Summit 2011).\n\n* [Building Real Time Services at Facebook with HBase](https://www.youtube.com/watch?v=DdGKAorSSZ0) by Jonathan Gray (Berlin buzzwords 2011)\n\n## HBase Presentations (Slides)\n\n[Advanced HBase Schema Design](https://www.slideshare.net/cloudera/hadoop-world-2011-advanced-hbase-schema-design-lars-george-cloudera) by Lars George (Hadoop World 2011).\n\n[Introduction to HBase](http://www.slideshare.net/cloudera/chicago-data-summit-apache-hbase-an-introduction) by Todd Lipcon (Chicago Data Summit 2011).\n\n[Getting The Most From Your HBase Install](http://www.slideshare.net/cloudera/hw09-practical-h-base-getting-the-most-from-your-h-base-install) by Ryan Rawson, Jonathan Gray (Hadoop World 2009).\n\n## HBase Papers\n\n[BigTable](http://research.google.com/archive/bigtable.html) by Google (2006).\n\n[HBase and HDFS Locality](http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html) by Lars George (2010).\n\n[No Relation: The Mixed Blessings of Non-Relational Databases](http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf) by Ian Varley (2009).\n\n## HBase Sites\n\n[Cloudera's HBase Blog](https://blog.cloudera.com/blog/category/hbase/) has a lot of links to useful HBase information.\n\n[CAP Confusion](https://blog.cloudera.com/blog/2010/04/cap-confusion-problems-with-partition-tolerance/) is a relevant entry for background information on distributed storage systems.\n\n[HBase RefCard](http://refcardz.dzone.com/refcardz/hbase) from DZone.\n\n## HBase Books\n\n[HBase: The Definitive Guide](http://shop.oreilly.com/product/0636920014348.do) by Lars George.\n\n## Hadoop Books\n\n[Hadoop: The Definitive Guide](http://shop.oreilly.com/product/9780596521981.do) by Tom White.\n\n***\n\n# HBase History\n\n* 2006: [BigTable](http://research.google.com/archive/bigtable.html) paper published by Google.\n* 2006 (end of year): HBase development starts.\n* 2008: HBase becomes Hadoop sub-project.\n* 2010: HBase becomes Apache top-level project.\n\n***\n\n# Apache Software Foundation\n\n## ASF Development Process\n\nSee the [Apache Development Process page](https://www.apache.org/dev/#committers) for all sorts of information on how the ASF is structured (e.g., PMC, committers, contributors), to tips on contributing and getting involved, and how open-source works at ASF.\n\n## ASF Board Reporting\n\nOnce a quarter, each project in the ASF portfolio submits a report to the ASF board. This is done by the HBase project lead and the committers. See [ASF board reporting](https://www.apache.org/foundation/board/reporting) for more information.\n\n***\n\n# Apache HBase Orca\n\nDefault:\n<img alt=\"Apache HBase Orca Logo\" src={__img36} />\n\nFor dark theme:\n<img alt=\"Apache HBase Orca Logo for dark theme\" src={__img37} />\n\n[An Orca is the Apache HBase mascot.](https://issues.apache.org/jira/browse/HBASE-4920) See NOTICES.txt. Our Orca logo we got here: [http://www.vectorfree.com/jumping-orca](http://www.vectorfree.com/jumping-orca) It is licensed Creative Commons Attribution 3.0. See [https://creativecommons.org/licenses/by/3.0/us/](https://creativecommons.org/licenses/by/3.0/us/) We changed the logo by stripping the colored background, inverting it and then rotating it some.\n\nThe 'official' HBase color is \"International Orange (Engineering)\", the color of the [Golden Gate bridge](https://en.wikipedia.org/wiki/International_orange) in San Francisco and for space suits used by NASA.\n\nOur 'font' is [Bitsumishi](http://www.dafont.com/bitsumishi.font).\n\n***\n\n# 0.95 RPC Specification\n\nIn 0.95, all client/server communication is done with [protobuf'ed](https://developers.google.com/protocol-buffers/) Messages rather than with [Hadoop Writables](https://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/Writable.html).\nOur RPC wire format therefore changes.\nThis document describes the client/server request/response protocol and our new RPC wire-format.\n\nFor what RPC is like in 0.94 and previous, see Benoît/Tsuna's [Unofficial Hadoop / HBase RPC protocol documentation](https://github.com/OpenTSDB/asynchbase/blob/master/src/HBaseRpc.java#L164).\nFor more background on how we arrived at this spec., see [HBase RPC: WIP](https://docs.google.com/document/d/1WCKwgaLDqBw2vpux0jPsAu2WPTRISob7HGCO8YhfDTA/edit#)\n\n## Goals\n\n1. A wire-format we can evolve\n2. A format that does not require our rewriting server core or radically changing its current architecture (for later).\n\n## TODO\n\n1. List of problems with currently specified format and where we would like to go in a version2, etc.\n   For example, what would we have to change if anything to move server async or to support streaming/chunking?\n2. Diagram on how it works\n3. A grammar that succinctly describes the wire-format.\n   Currently we have these words and the content of the rpc protobuf idl but a grammar for the back and forth would help with groking rpc.\n   Also, a little state machine on client/server interactions would help with understanding (and ensuring correct implementation).\n\n## RPC\n\nThe client will send setup information on connection establish.\nThereafter, the client invokes methods against the remote server sending a protobuf Message and receiving a protobuf Message in response.\nCommunication is synchronous.\nAll back and forth is preceded by an int that has the total length of the request/response.\nOptionally, Cells(KeyValues) can be passed outside of protobufs in follow-behind Cell blocks\n(because [we can't protobuf megabytes of KeyValues](https://docs.google.com/document/d/1WEtrq-JTIUhlnlnvA0oYRLp0F8MKpEBeBSCFcQiacdw/edit#) or Cells). These CellBlocks are encoded and optionally compressed.\n\nFor more detail on the protobufs involved, see the\n[RPC.proto](https://github.com/apache/hbase/blob/master/hbase-protocol-shaded/src/main/protobuf/rpc/RPC.proto) file in master.\n\n### Connection Setup\n\nClient initiates connection.\n\n#### Client\n\nOn connection setup, client sends a preamble followed by a connection header.\n\n`<preamble>`\n\n```text\n<MAGIC 4 byte integer> <1 byte RPC Format Version> <1 byte auth type>\n```\n\nWe need the auth method spec.\nhere so the connection header is encoded if auth enabled.\\\nE.g.: HBas0x000x50 — 4 bytes of MAGIC — \\`HBas' — plus one-byte of version, 0 in this case, and one byte, 0x50 (SIMPLE). of an auth type.\n\n`<Protobuf ConnectionHeader Message>`\\\nHas user info, and \"protocol\", as well as the encoders and compression the client will use sending CellBlocks.\nCellBlock encoders and compressors are for the life of the connection.\nCellBlock encoders implement org.apache.hadoop.hbase.codec.Codec.\nCellBlocks may then also be compressed.\nCompressors implement org.apache.hadoop.io.compress.CompressionCodec.\nThis protobuf is written using writeDelimited so is prefaced by a pb varint with its serialized length\n\n#### Server\n\nAfter client sends preamble and connection header, server does NOT respond if successful connection setup.\nNo response means server is READY to accept requests and to give out response.\nIf the version or authentication in the preamble is not agreeable or the server has trouble parsing the preamble, it will throw a org.apache.hadoop.hbase.ipc.FatalConnectionException explaining the error and will then disconnect.\nIf the client in the connection header — i.e.\nthe protobuf'd Message that comes after the connection preamble — asks for a Service the server does not support or a codec the server does not have, again we throw a FatalConnectionException with explanation.\n\n### Request\n\nAfter a Connection has been set up, client makes requests.\nServer responds.\n\nA request is made up of a protobuf RequestHeader followed by a protobuf Message parameter.\nThe header includes the method name and optionally, metadata on the optional CellBlock that may be following.\nThe parameter type suits the method being invoked: i.e.\nif we are doing a getRegionInfo request, the protobuf Message param will be an instance of GetRegionInfoRequest.\nThe response will be a GetRegionInfoResponse.\nThe CellBlock is optionally used ferrying the bulk of the RPC data: i.e. Cells/KeyValues.\n\n#### Request Parts\n\n`<Total Length>`\\\nThe request is prefaced by an int that holds the total length of what follows.\n\n`<Protobuf RequestHeader Message>`\\\nWill have call.id, trace.id, and method name, etc.\nincluding optional Metadata on the Cell block IFF one is following.\nData is protobuf'd inline in this pb Message or optionally comes in the following CellBlock\n\n`<Protobuf Param Message>`\\\nIf the method being invoked is getRegionInfo, if you study the Service descriptor for the client to regionserver protocol, you will find that the request sends a GetRegionInfoRequest protobuf Message param in this position.\n\n`<CellBlock>`\\\nAn encoded and optionally compressed Cell block.\n\n### Response\n\nSame as Request, it is a protobuf ResponseHeader followed by a protobuf Message response where the Message response type suits the method invoked.\nBulk of the data may come in a following CellBlock.\n\n#### Response Parts\n\n`<Total Length>`\\\nThe response is prefaced by an int that holds the total length of what follows.\n\n`<Protobuf ResponseHeader Message>`\\\nWill have call.id, etc.\nWill include exception if failed processing.\nOptionally includes metadata on optional, IFF there is a CellBlock following.\n\n`<Protobuf Response Message>`\\\nReturn or may be nothing if exception.\nIf the method being invoked is getRegionInfo, if you study the Service descriptor for the client to regionserver protocol, you will find that the response sends a GetRegionInfoResponse protobuf Message param in this position.\n\n`<CellBlock>`\\\nAn encoded and optionally compressed Cell block.\n\n### Exceptions\n\nThere are two distinct types.\nThere is the request failed which is encapsulated inside the response header for the response.\nThe connection stays open to receive new requests.\nThe second type, the FatalConnectionException, kills the connection.\n\nExceptions can carry extra information.\nSee the ExceptionResponse protobuf type.\nIt has a flag to indicate do-no-retry as well as other miscellaneous payload to help improve client responsiveness.\n\n### CellBlocks\n\nThese are not versioned.\nServer can do the codec or it cannot.\nIf new version of a codec with say, tighter encoding, then give it a new class name.\nCodecs will live on the server for all time so old clients can connect.\n\n## Notes\n\n### Constraints\n\nIn some part, current wire-format — i.e.\nall requests and responses preceded by a length — has been dictated by current server non-async architecture.\n\n### One fat pb request or header+param\n\nWe went with pb header followed by pb param making a request and a pb header followed by pb response for now.\nDoing header+param rather than a single protobuf Message with both header and param content:\n\n1. Is closer to what we currently have\n2. Having a single fat pb requires extra copying putting the already pb'd param into the body of the fat request pb (and same making result)\n3. We can decide whether to accept the request or not before we read the param; for example, the request might be low priority.\n   As is, we read header+param in one go as server is currently implemented so this is a TODO.\n\nThe advantages are minor.\nIf later, fat request has clear advantage, can roll out a v2 later.\n\n### RPC Configurations\n\n#### CellBlock Codecs\n\nTo enable a codec other than the default `KeyValueCodec`, set `hbase.client.rpc.codec` to the name of the Codec class to use.\nCodec must implement hbase's `Codec` Interface.\nAfter connection setup, all passed cellblocks will be sent with this codec.\nThe server will return cellblocks using this same codec as long as the codec is on the servers' CLASSPATH (else you will get `UnsupportedCellCodecException`).\n\nTo change the default codec, set `hbase.client.default.rpc.codec`.\n\nTo disable cellblocks completely and to go pure protobuf, set the default to the empty String and do not specify a codec in your Configuration.\nSo, set `hbase.client.default.rpc.codec` to the empty string and do not set `hbase.client.rpc.codec`.\nThis will cause the client to connect to the server with no codec specified.\nIf a server sees no codec, it will return all responses in pure protobuf.\nRunning pure protobuf all the time will be slower than running with cellblocks.\n\n#### Compression\n\nUses hadoop's compression codecs.\nTo enable compressing of passed CellBlocks, set `hbase.client.rpc.compressor` to the name of the Compressor to use.\nCompressor must implement Hadoop's CompressionCodec Interface.\nAfter connection setup, all passed cellblocks will be sent compressed.\nThe server will return cellblocks compressed using this same compressor as long as the compressor is on its CLASSPATH (else you will get `UnsupportedCompressionCodecException`).\n\n***\n\n# Known Incompatibilities Among HBase Versions\n\n## HBase 2.0 Incompatible Changes\n\nThis appendix describes incompatible changes from earlier versions of HBase against HBase 2.0.\nThis list is not meant to be wholly encompassing of all possible incompatibilities.\nInstead, this content is intended to give insight into some obvious incompatibilities which most\nusers will face coming from HBase 1.x releases.\n\n### List of Major Changes for HBase 2.0\n\n* HBASE-1912- HBCK is an HBase database checking tool for capturing the inconsistency. As an HBase administrator, you should not use HBase version 1.0 hbck tool to check the HBase 2.0 database. Doing so will break the database and throw an exception error.\n* HBASE-16189 and HBASE-18945- You cannot open the HBase 2.0 hfiles through HBase 1.0 version. If you are an admin or an HBase user who is using HBase version 1.x, you must first do a rolling upgrade to the latest version of HBase 1.x and then upgrade to HBase 2.0.\n* HBASE-18240 - Changed the ReplicationEndpoint Interface. It also introduces a new hbase-third party 1.0 that packages all the third party utilities, which are expected to run in the hbase cluster.\n\n### Coprocessor API changes\n\n* HBASE-16769 - Deprecated PB references from MasterObserver and RegionServerObserver.\n* HBASE-17312 - \\[JDK8] Use default method for Observer Coprocessors. The interface classes of BaseMasterAndRegionObserver, BaseMasterObserver, BaseRegionObserver, BaseRegionServerObserver and BaseWALObserver uses JDK8's 'default' keyword to provide empty and no-op implementations.\n* Interface HTableInterface\n  HBase 2.0 introduces following changes to the methods listed below:\n\n#### interface CoprocessorEnvironment changes\n\n| Change                                                                    | Result                                                              |\n| ------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method getTable ( TableName ) has been removed.                  | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getTable ( TableName, ExecutorService ) has been removed. | A client program may be interrupted by NoSuchMethodError exception. |\n\n* Public Audience\n\nThe following tables describes the coprocessor changes.\n\n**class CoprocessorRpcChannel**\n\n| Change                           | Result                                                                                                                                    |\n| -------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| This class has become interface. | A client program may be interrupted by IncompatibleClassChangeError or InstantiationError exception depending on the usage of this class. |\n\n**Class CoprocessorHost\\<E>**\n\nClasses that were Audience Private but were removed.\n\n| Change                                                                                                                   | Result                                                             |\n| ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------ |\n| Type of field coprocessors has been changed from java.util.SortedSet\\<E> to org.apache.hadoop.hbase.util.SortedList\\<E>. | A client program may be interrupted by NoSuchFieldError exception. |\n\n#### MasterObserver\n\nHBase 2.0 introduces following changes to the MasterObserver interface.\n\n**interface MasterObserver**\n\n| Change                                                                                                                                                                              | Result                                                              |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method voidpostCloneSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface.   | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostCreateTable ( ObserverContext\\<MasterCoprocessorEnvironment>, HTableDescriptor, HRegionInfo\\[ ] ) has been removed from this interface.                     | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpostDeleteSnapshot (ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription ) has been removed from this interface.                     | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpostGetTableDescriptors ( ObserverContext\\<MasterCoprocessorEnvironment>, List\\<HTableDescriptor> ) has been removed from this interface.                       | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpostModifyTable ( ObserverContext\\<MasterCoprocessorEnvironment>, TableName, HTableDescriptor ) has been removed from this interface.                           | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpostRestoreSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpostSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface.        | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreCloneSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface.    | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreCreateTable ( ObserverContext\\<MasterCoprocessorEnvironment>, HTableDescriptor, HRegionInfo\\[ ] ) has been removed from this interface.                      | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreDeleteSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription ) has been removed from this interface.                     | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreGetTableDescriptors ( ObserverContext\\<MasterCoprocessorEnvironment>, List\\<TableName>, List\\<HTableDescriptor> ) has been removed from this interface.      | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreModifyTable ( ObserverContext\\<MasterCoprocessorEnvironment>, TableName, HTableDescriptor ) has been removed from this interface.                            | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreRestoreSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface.  | A client program may be interrupted by NoSuchMethodErrorexception.  |\n| Abstract method voidpreSnapshot ( ObserverContext\\<MasterCoprocessorEnvironment>, HBaseProtos.SnapshotDescription, HTableDescriptor ) has been removed from this interface.         | A client program may be interrupted by NoSuchMethodErrorexception.  |\n\n#### RegionObserver\n\nHBase 2.0 introduces following changes to the RegionObserver interface.\n\n**interface RegionObserver**\n\n| Change                                                                                                                                                                                                                                       | Result                                                              |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method voidpostCloseRegionOperation ( ObserverContext\\<RegionCoprocessorEnvironment>, HRegion.Operation ) has been removed from this interface.                                                                                     | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostCompactSelection ( ObserverContext\\<RegionCoprocessorEnvironment>, Store, ImmutableList\\<StoreFile> ) has been removed from this interface.                                                                          | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostCompactSelection ( ObserverContext\\<RegionCoprocessorEnvironment>, Store, ImmutableList\\<StoreFile>, CompactionRequest ) has been removed from this interface.                                                       | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostGetClosestRowBefore ( ObserverContext\\<RegionCoprocessorEnvironment>, byte\\[ ], byte\\[ ], Result ) has been removed from this interface.                                                                             | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method DeleteTrackerpostInstantiateDeleteTracker ( ObserverContext\\<RegionCoprocessorEnvironment>, DeleteTracker ) has been removed from this interface.                                                                            | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostSplit ( ObserverContext\\<RegionCoprocessorEnvironment>, HRegion, HRegion ) has been removed from this interface.                                                                                                     | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostStartRegionOperation ( ObserverContext\\<RegionCoprocessorEnvironment>, HRegion.Operation ) has been removed from this interface.                                                                                     | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method StoreFile.ReaderpostStoreFileReaderOpen ( ObserverContext\\<RegionCoprocessorEnvironment>, FileSystem, Path, FSDataInputStreamWrapper, long, CacheConfig, Reference, StoreFile.Reader ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpostWALRestore ( ObserverContext\\<RegionCoprocessorEnvironment>, HRegionInfo, HLogKey, WALEdit ) has been removed from this interface.                                                                                   | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method InternalScannerpreFlushScannerOpen ( ObserverContext\\<RegionCoprocessorEnvironment>, Store, KeyValueScanner, InternalScanner ) has been removed from this interface.                                                         | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpreGetClosestRowBefore ( ObserverContext\\<RegionCoprocessorEnvironment>, byte\\[ ], byte\\[ ], Result ) has been removed from this interface.                                                                              | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method StoreFile.ReaderpreStoreFileReaderOpen ( ObserverContext\\<RegionCoprocessorEnvironment>, FileSystem, Path, FSDataInputStreamWrapper, long, CacheConfig, Reference, StoreFile.Reader ) has been removed from this interface.  | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method voidpreWALRestore ( ObserverContext\\<RegionCoprocessorEnvironment>, HRegionInfo, HLogKey, WALEdit ) has been removed from this interface.                                                                                    | A client program may be interrupted by NoSuchMethodError exception. |\n\n#### WALObserver\n\nHBase 2.0 introduces following changes to the WALObserver interface.\n\n**interface WALObserver**\n\n| Change                                                                                                                                                  | Result                                                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method voidpostWALWrite ( ObserverContext\\<WALCoprocessorEnvironment>, HRegionInfo, HLogKey, WALEdit ) has been removed from this interface.   | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method booleanpreWALWrite ( ObserverContext\\<WALCoprocessorEnvironment>, HRegionInfo, HLogKey, WALEdit ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Miscellaneous\n\nHBase 2.0 introduces changes to the following classes:\n\nhbase-server-1.0.0.jar, OnlineRegions.class package org.apache.hadoop.hbase.regionserver\n\n**OnlineRegions.getFromOnlineRegions ( String p1 ) \\[abstract] : HRegion**\\\norg/apache/hadoop/hbase/regionserver/OnlineRegions.getFromOnlineRegions:(Ljava/lang/String;)Lorg/apache/hadoop/hbase/regionserver/HRegion;\n\n| Change                                                    | Result                                                                                                                                                    |\n| --------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from Region to Region. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\nhbase-server-1.0.0.jar, RegionCoprocessorEnvironment.class package org.apache.hadoop.hbase.coprocessor\n\n**RegionCoprocessorEnvironment.getRegion ( ) \\[abstract] : HRegion**\\\norg/apache/hadoop/hbase/coprocessor/RegionCoprocessorEnvironment.getRegion:()Lorg/apache/hadoop/hbase/regionserver/HRegion;\n\n| Change                                                                                                                               | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.regionserver.HRegion to org.apache.hadoop.hbase.regionserver.Region. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\nhbase-server-1.0.0.jar, RegionCoprocessorHost.class package org.apache.hadoop.hbase.regionserver\n\n**RegionCoprocessorHost.postAppend ( Append append, Result result ) : void**\\\norg/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.postAppend:(Lorg/apache/hadoop/hbase/client/Append;Lorg/apache/hadoop/hbase/client/Result;)V\n\n| Change                                                                                 | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to org.apache.hadoop.hbase.client.Result. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n**RegionCoprocessorHost.preStoreFileReaderOpen ( FileSystem fs, Path p, FSDataInputStreamWrapper in, long size,CacheConfig cacheConf, Reference r ) : StoreFile.Reader**\\\norg/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.preStoreFileReaderOpen:(Lorg/apache/hadoop/fs/FileSystem;Lorg/apache/hadoop/fs/Path;Lorg/apache/hadoop/hbase/io/FSDataInputStreamWrapper;JLorg/apache/hadoop/hbase/io/hfile/CacheConfig;Lorg/apache/hadoop/hbase/io/Reference;)Lorg/apache/hadoop/hbase/regionserver/StoreFile\\$Reader;\n\n| Change                                                                       | Result                                                                                                                                                    |\n| ---------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from StoreFile.Reader to StoreFileReader. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### IPC\n\n#### Scheduler changes:\n\n1. Following methods became abstract:\n\npackage org.apache.hadoop.hbase.ipc\n\n**class RpcScheduler**\n\n| Change                                                                         | Result                                                              |\n| ------------------------------------------------------------------------------ | ------------------------------------------------------------------- |\n| Abstract method void dispatch ( CallRunner ) has been removed from this class. | A client program may be interrupted by NoSuchMethodError exception. |\n\nhbase-server-1.0.0.jar, RpcScheduler.class package org.apache.hadoop.hbase.ipc\n\n**RpcScheduler.dispatch ( CallRunner p1 ) \\[abstract] : void 1**\n\norg/apache/hadoop/hbase/ipc/RpcScheduler.dispatch:(Lorg/apache/hadoop/hbase/ipc/CallRunner;)V\n\n| Change                                                   | Result                                                                                                                                                    |\n| -------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to boolean. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n2. Following abstract methods have been removed:\n\n**interface PriorityFunction**\n\n| Change                                                                                                     | Result                                                              |\n| ---------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method longgetDeadline ( RPCProtos.RequestHeader, Message ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method int getPriority ( RPCProtos.RequestHeader, Message ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Server API changes:\n\n**class RpcServer**\n\n| Change                                                                                                                 | Result                                                                                              |\n| ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |\n| Type of field CurCall has been changed from java.lang.ThreadLocal\\<RpcServer.Call> to java.lang.ThreadLocal\\<RpcCall>. | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| This class became abstract.                                                                                            | A client program may be interrupted by InstantiationError exception.                                |\n| Abstract method int getNumOpenConnections ( ) has been added to this class.                                            | This class became abstract and a client program may be interrupted by InstantiationError exception. |\n| Field callQueueSize of type org.apache.hadoop.hbase.util.Counter has been removed from this class.                     | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field connectionList of type java.util.List\\<RpcServer.Connection> has been removed from this class.                   | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field maxIdleTime of type int has been removed from this class.                                                        | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field numConnections of type int has been removed from this class.                                                     | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field port of type int has been removed from this class.                                                               | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field purgeTimeout of type long has been removed from this class.                                                      | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field responder of type RpcServer.Responder has been removed from this class.                                          | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field socketSendBufferSize of type int has been removed from this class.                                               | A client program may be interrupted by NoSuchFieldError exception.                                  |\n| Field thresholdIdleConnections of type int has been removed from this class.                                           | A client program may be interrupted by NoSuchFieldError exception.                                  |\n\nFollowing abstract method has been removed:\n\n| Change                                                                                                                                                                                  | Result                                                              |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method Pair\\<Message,CellScanner>call ( BlockingService, Descriptors.MethodDescriptor, Message, CellScanner, long, MonitoredRPCHandler ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n\n### Replication and WAL changes:\n\nHBASE-18733: WALKey has been purged completely in HBase 2.0.\nFollowing are the changes to the WALKey:\n\n#### classWALKey \\[!toc]\n\n| Change                                                                               | Result                                                               |\n| ------------------------------------------------------------------------------------ | -------------------------------------------------------------------- |\n| Access level of field clusterIds has been changed from protected to private.         | A client program may be interrupted by IllegalAccessError exception. |\n| Access level of field compressionContext has been changed from protected to private. | A client program may be interrupted by IllegalAccessError exception. |\n| Access level of field encodedRegionName has been changed from protected to private.  | A client program may be interrupted by IllegalAccessError exception. |\n| Access level of field tablename has been changed from protectedto private.           | A client program may be interrupted by IllegalAccessError exception. |\n| Access level of field writeTime has been changed from protectedto private.           | A client program may be interrupted by IllegalAccessError exception. |\n\nFollowing fields have been removed:\n\n| Change                                                                             | Result                                                             |\n| ---------------------------------------------------------------------------------- | ------------------------------------------------------------------ |\n| Field LOG of type org.apache.commons.logging.Log has been removed from this class. | A client program may be interrupted by NoSuchFieldError exception. |\n| Field VERSION of type WALKey.Version has been removed from this class.             | A client program may be interrupted by NoSuchFieldError exception. |\n| Field logSeqNum of type long has been removed from this class.                     | A client program may be interrupted by NoSuchFieldError exception. |\n\nFollowing are the changes to the WALEdit.class:\nhbase-server-1.0.0.jar, WALEdit.class package org.apache.hadoop.hbase.regionserver.wal\n\n#### WALEdit.getCompaction ( Cell kv ) \\[static] : WALProtos.CompactionDescriptor \\[!toc]\n\norg/apache/hadoop/hbase/regionserver/wal/WALEdit.getCompaction:(Lorg/apache/hadoop/hbase/Cell;)Lorg/apache/hadoop/hbase/protobuf/generated/WALProtos\\$CompactionDescriptor;\n\n| Change                                                                                                                                                                                                 | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.WALProtos.CompactionDescriptor to org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.CompactionDescriptor. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### WALEdit.getFlushDescriptor ( Cell cell ) \\[static] : WALProtos.FlushDescriptor \\[!toc]\n\norg/apache/hadoop/hbase/regionserver/wal/WALEdit.getFlushDescriptor:(Lorg/apache/hadoop/hbase/Cell;)Lorg/apache/hadoop/hbase/protobuf/generated/WALProtos\\$FlushDescriptor;\n\n| Change                                                                                                                                                                                       | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.WALProtos.FlushDescriptor to org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.FlushDescriptor. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### WALEdit.getRegionEventDescriptor ( Cell cell ) \\[static] : WALProtos.RegionEventDescriptor \\[!toc]\n\norg/apache/hadoop/hbase/regionserver/wal/WALEdit.getRegionEventDescriptor:(Lorg/apache/hadoop/hbase/Cell;)Lorg/apache/hadoop/hbase/protobuf/generated/WALProtos\\$RegionEventDescriptor;\n\n| Change                                                                                                                                                                                                   | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.WALProtos.RegionEventDescriptor to org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.RegionEventDescriptor. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\nFollowing is the change to the WALKey.class:\npackage org.apache.hadoop.hbase.wal\n\n#### WALKey.getBuilder ( WALCellCodec.ByteStringCompressor compressor ) : WALProtos.WALKey.Builder \\[!toc]\n\norg/apache/hadoop/hbase/wal/WALKey.getBuilder:(Lorg/apache/hadoop/hbase/regionserver/wal/WALCellCodec\\$ByteStringCompressor;)Lorg/apache/hadoop/hbase/protobuf/generated/WALProtos\\$WALKey\\$Builder;\n\n| Change                                                                                                                                                                                     | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.WALProtos.WALKey.Builder to org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.WALKey.Builder. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### Deprecated APIs or coprocessor:\n\nHBASE-16769 - PB references from MasterObserver and RegionServerObserver has been removed.\n\n### Admin Interface API changes:\n\nYou cannot administer an HBase 2.0 cluster with an HBase 1.0 client that includes RelicationAdmin, ACC, Thrift and REST usage of Admin ops. Methods returning protobufs have been changed to return POJOs instead. pb is not used in the APIs anymore. Returns have changed from void to Future for async methods.\nHBASE-18106 - Admin.listProcedures and Admin.listLocks were renamed to getProcedures and getLocks.\nMapReduce makes use of Admin doing following admin.getClusterStatus() to calcluate Splits.\n\n* Thrift usage of Admin API:\n  compact(ByteBuffer)\n  createTable(ByteBuffer, List\\<ColumnDescriptor>)\n  deleteTable(ByteBuffer)\n  disableTable(ByteBuffer)\n  enableTable(ByteBuffer)\n  getTableNames()\n  majorCompact(ByteBuffer)\n\n* REST usage of Admin API: hbase-rest org.apache.hadoop.hbase.rest RootResource getTableList() TableName\\[] tableNames = servlet.getAdmin().listTableNames(); SchemaResource delete(UriInfo) Admin admin = servlet.getAdmin(); update(TableSchemaModel, boolean, UriInfo) Admin admin = servlet.getAdmin(); StorageClusterStatusResource get(UriInfo) ClusterStatus status = servlet.getAdmin().getClusterStatus(); StorageClusterVersionResource get(UriInfo) model.setVersion(servlet.getAdmin().getClusterStatus().getHBaseVersion()); TableResource exists() return servlet.getAdmin().tableExists(TableName.valueOf(table));\n\nFollowing are the changes to the Admin interface:\n\n#### interface Admin \\[!toc]\n\n| Change                                                                                                                     | Result                                                              |\n| -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method createTableAsync ( HTableDescriptor, byte\\[ ]\\[ ] ) has been removed from this interface.                  | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method disableTableAsync ( TableName ) has been removed from this interface.                                      | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method enableTableAsync ( TableName ) has been removed from this interface.                                       | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getCompactionState ( TableName ) has been removed from this interface.                                     | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getCompactionStateForRegion ( byte\\[ ] ) has been removed from this interface.                             | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method isSnapshotFinished ( HBaseProtos.SnapshotDescription ) has been removed from this interface.               | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method snapshot ( String, TableName, HBaseProtos.SnapshotDescription.Type ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method snapshot ( HBaseProtos.SnapshotDescription ) has been removed from this interface.                         | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method takeSnapshotAsync ( HBaseProtos.SnapshotDescription ) has been removed from this interface.                | A client program may be interrupted by NoSuchMethodError exception. |\n\nFollowing are the changes to the Admin.class:\nhbase-client-1.0.0.jar, Admin.class package org.apache.hadoop.hbase.client\n\n#### Admin.createTableAsync ( HTableDescriptor p1, byte\\[ ]\\[ ] p2 ) \\[abstract] : void 1 \\[!toc]\n\norg/apache/hadoop/hbase/client/Admin.createTableAsync:(Lorg/apache/hadoop/hbase/HTableDescriptor;\\[\\[B)V\n\n| Change                                                                                        | Result                                                                                                                                                    |\n| --------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to java.util.concurrent.Future\\<java.lang.Void>. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Admin.disableTableAsync ( TableName p1 ) \\[abstract] : void 1 \\[!toc]\n\norg/apache/hadoop/hbase/client/Admin.disableTableAsync:(Lorg/apache/hadoop/hbase/TableName;)V\n\n| Change                                                                                        | Result                                                                                                                                                    |\n| --------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to java.util.concurrent.Future\\<java.lang.Void>. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Admin.enableTableAsync ( TableName p1 ) \\[abstract] : void \\[!toc]\n\norg/apache/hadoop/hbase/client/Admin.enableTableAsync:(Lorg/apache/hadoop/hbase/TableName;)V\n\n| Change                                                                                        | Result                                                                                                                                                    |\n| --------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to java.util.concurrent.Future\\<java.lang.Void>. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Admin.getCompactionState ( TableName p1 ) \\[abstract] : AdminProtos.GetRegionInfoResponse.CompactionState 1 \\[!toc]\n\norg/apache/hadoop/hbase/client/Admin.getCompactionState:(Lorg/apache/hadoop/hbase/TableName;)Lorg/apache/hadoop/hbase/protobuf/generated/AdminProtos\\$GetRegionInfoResponse\\$CompactionState;\n\n| Change                                                                                                                                                   | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.AdminProtos.GetRegionInfoResponse.CompactionState to CompactionState. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### Admin.getCompactionStateForRegion ( byte\\[ ] p1 ) \\[abstract] : AdminProtos.GetRegionInfoResponse.CompactionState 1 \\[!toc]\n\norg/apache/hadoop/hbase/client/Admin.getCompactionStateForRegion:(\\[B)Lorg/apache/hadoop/hbase/protobuf/generated/AdminProtos\\$GetRegionInfoResponse\\$CompactionState;\n\n| Change                                                                                                                                                   | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.AdminProtos.GetRegionInfoResponse.CompactionState to CompactionState. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### HTableDescriptor and HColumnDescriptor changes\n\nHTableDescriptor and HColumnDescriptor has become interfaces and you can create it through Builders. HCD has become CFD. It no longer implements writable interface.\npackage org.apache.hadoop.hbase\n\n#### class HColumnDescriptor \\[!toc]\n\n| Change                                                                               | Result                                                              |\n| ------------------------------------------------------------------------------------ | ------------------------------------------------------------------- |\n| Removed super-interface org.apache.hadoop.io.WritableComparable\\<HColumnDescriptor>. | A client program may be interrupted by NoSuchMethodError exception. |\n\nHColumnDescriptor in 1.0.0\n\n```java\n@InterfaceAudience.Public\n@InterfaceStability.Evolving\npublic class HColumnDescriptor implements WritableComparable<HColumnDescriptor> {\n```\n\nHColumnDescriptor in 2.0\n\n```java\n@InterfaceAudience.Public\n@Deprecated // remove it in 3.0\npublic class HColumnDescriptor implements ColumnFamilyDescriptor, Comparable<HColumnDescriptor> {\n```\n\nFor META\\_TABLEDESC, the maker method had been deprecated already in HTD in 1.0.0. OWNER\\_KEY is still in HTD.\n\n#### class HTableDescriptor \\[!toc]\n\n| Change                                                                              | Result                                                              |\n| ----------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Removed super-interface org.apache.hadoop.io.WritableComparable\\<HTableDescriptor>. | A client program may be interrupted by NoSuchMethodError exception. |\n| Field META\\_TABLEDESC of type HTableDescriptor has been removed from this class.    | A client program may be interrupted by NoSuchFieldError exception.  |\n\nhbase-client-1.0.0.jar, HTableDescriptor.class package org.apache.hadoop.hbase\n\n**HTableDescriptor.getColumnFamilies ( ) : HColumnDescriptor\\[ ]**\\\norg/apache/hadoop/hbase/HTableDescriptor.getColumnFamilies:()\\[Lorg/apache/hadoop/hbase/HColumnDescriptor;\n\n**class HColumnDescriptor**\n\n| Change                                                                                           | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from HColumnDescriptor\\[]to client.ColumnFamilyDescriptor\\[]. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n**HTableDescriptor.getCoprocessors ( ) : List\\<String>**\\\norg/apache/hadoop/hbase/HTableDescriptor.getCoprocessors:()Ljava/util/List;\n\n| Change                                                                                             | Result                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from java.util.List\\<java.lang.String> to java.util.Collection. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-12990 MetaScanner is removed and it is replaced by MetaTableAccessor.\n\n#### HTableWrapper changes: \\[!toc]\n\nhbase-server-1.0.0.jar, HTableWrapper.class package org.apache.hadoop.hbase.client\n\n**HTableWrapper.createWrapper ( List\\<HTableInterface> openTables, TableName tableName, CoprocessorHost.Environment env, ExecutorService pool ) \\[static] : HTableInterface 1**\n\norg/apache/hadoop/hbase/client/HTableWrapper.createWrapper:(Ljava/util/List;Lorg/apache/hadoop/hbase/TableName;Lorg/apache/hadoop/hbase/coprocessor/CoprocessorHost\\$Environment;Ljava/util/concurrent/ExecutorService;)Lorg/apache/hadoop/hbase/client/HTableInterface;\n\n| Change                                                            | Result                                                                                                                                                    |\n| ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from HTableInterface to Table. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-12586: Delete all public HTable constructors and delete ConnectionManager#\\{delete,get}Connection.\n* HBASE-9117: Remove HTablePool and all HConnection pooling related APIs.\n* HBASE-13214: Remove deprecated and unused methods from HTable class\n  Following are the changes to the Table interface:\n\n**interface Table**\n\n| Change                                                                                              | Result                                                              |\n| --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method batch ( List\\<?> ) has been removed from this interface.                            | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method batchCallback ( List\\<?>, Batch.Callback\\<R> )has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getWriteBufferSize ( ) has been removed from this interface.                        | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method setWriteBufferSize ( long ) has been removed from this interface.                   | A client program may be interrupted by NoSuchMethodError exception. |\n\n### Deprecated buffer methods in Table (in 1.0.1) and removed in 2.0.0\n\n* HBASE-13298- Clarify if Table.\\{set|get}WriteBufferSize() is deprecated or not.\n* LockTimeoutException and OperationConflictException classes have been removed.\n\n#### class OperationConflictException \\[!toc]\n\n| Change                       | Result                                                                |\n| ---------------------------- | --------------------------------------------------------------------- |\n| This class has been removed. | A client program may be interrupted by NoClassDefFoundErrorexception. |\n\n#### class class LockTimeoutException \\[!toc]\n\n| Change                       | Result                                                                |\n| ---------------------------- | --------------------------------------------------------------------- |\n| This class has been removed. | A client program may be interrupted by NoClassDefFoundErrorexception. |\n\n### Filter API changes:\n\nFollowing methods have been removed:\npackage org.apache.hadoop.hbase.filter\n\n#### class Filter \\[!toc]\n\n| Change                                                                        | Result                                                              |\n| ----------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| Abstract method getNextKeyHint ( KeyValue ) has been removed from this class. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method transform ( KeyValue ) has been removed from this class.      | A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-12296 Filters should work with ByteBufferedCell.\n* HConnection is removed in HBase 2.0.\n* RegionLoad and ServerLoad internally moved to shaded PB.\n\n#### class RegionLoad \\[!toc]\n\n| Change                                                                                                                                                          | Result                                                             |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |\n| Type of field regionLoadPB has been changed from protobuf.generated.ClusterStatusProtos.RegionLoad to shaded.protobuf.generated.ClusterStatusProtos.RegionLoad. | A client program may be interrupted by NoSuchFieldError exception. |\n\n* HBASE-15783:AccessControlConstants#OP\\_ATTRIBUTE\\_ACL\\_STRATEGY\\_CELL\\_FIRST is not used any more.\n  package org.apache.hadoop.hbase.security.access\n\n#### interface AccessControlConstants \\[!toc]\n\n| Change                                                                                                | Result                                                             |\n| ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |\n| Field OP\\_ATTRIBUTE\\_ACL\\_STRATEGY of type java.lang.Stringhas been removed from this interface.      | A client program may be interrupted by NoSuchFieldError exception. |\n| Field OP\\_ATTRIBUTE\\_ACL\\_STRATEGY\\_CELL\\_FIRST of type byte\\[] has been removed from this interface. | A client program may be interrupted by NoSuchFieldError exception. |\n| Field OP\\_ATTRIBUTE\\_ACL\\_STRATEGY\\_DEFAULT of type byte\\[] has been removed from this interface.     | A client program may be interrupted by NoSuchFieldError exception. |\n\n#### ServerLoad returns long instead of int 1 \\[!toc]\n\nhbase-client-1.0.0.jar, ServerLoad.class package org.apache.hadoop.hbase\n\n#### ServerLoad.getNumberOfRequests ( ) : int 1 \\[!toc]\n\norg/apache/hadoop/hbase/ServerLoad.getNumberOfRequests:()I\n\n| Change                                               | Result                                                                                                                                                    |\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from int to long. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### ServerLoad.getReadRequestsCount ( ) : int 1 \\[!toc]\n\norg/apache/hadoop/hbase/ServerLoad.getReadRequestsCount:()I\n\n| Change                                               | Result                                                                                                                                                    |\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from int to long. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### ServerLoad.getTotalNumberOfRequests ( ) : int 1 \\[!toc]\n\norg/apache/hadoop/hbase/ServerLoad.getTotalNumberOfRequests:()I\n\n| Change                                               | Result                                                                                                                                                    |\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from int to long. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n#### ServerLoad.getWriteRequestsCount ( ) : int 1 \\[!toc]\n\norg/apache/hadoop/hbase/ServerLoad.getWriteRequestsCount:()I\n\n| Change                                               | Result                                                                                                                                                    |\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from int to long. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-13636 Remove deprecation for HBASE-4072 (Reading of zoo.cfg)\n* HConstants are removed. HBASE-16040 Remove configuration \"hbase.replication\"\n\n#### class HConstants \\[!toc]\n\n| Change                                                                                                  | Result                                                             |\n| ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |\n| Field DEFAULT\\_HBASE\\_CONFIG\\_READ\\_ZOOKEEPER\\_CONFIG of type boolean has been removed from this class. | A client program may be interrupted by NoSuchFieldError exception. |\n| Field HBASE\\_CONFIG\\_READ\\_ZOOKEEPER\\_CONFIG of type java.lang.String has been removed from this class. | A client program may be interrupted by NoSuchFieldError exception. |\n| Field REPLICATION\\_ENABLE\\_DEFAULT of type boolean has been removed from this class.                    | A client program may be interrupted by NoSuchFieldError exception. |\n| Field REPLICATION\\_ENABLE\\_KEY of type java.lang.String has been removed from this class.               | A client program may be interrupted by NoSuchFieldError exception. |\n| Field ZOOKEEPER\\_CONFIG\\_NAME of type java.lang.String has been removed from this class.                | A client program may be interrupted by NoSuchFieldError exception. |\n| Field ZOOKEEPER\\_USEMULTI of type java.lang.String has been removed from this class.                    | A client program may be interrupted by NoSuchFieldError exception. |\n\n* HBASE-18732: \\[compat 1-2] HBASE-14047 removed Cell methods without deprecation cycle.\n\n#### interface Cell 5 \\[!toc]\n\n| Change                                                                   | Result                                                              |\n| ------------------------------------------------------------------------ | ------------------------------------------------------------------- |\n| Abstract method getFamily ( ) has been removed from this interface.      | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getMvccVersion ( ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getQualifier ( ) has been removed from this interface.   | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getRow ( ) has been removed from this interface.         | A client program may be interrupted by NoSuchMethodError exception. |\n| Abstract method getValue ( ) has been removed from this interface.       | A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-18795:Expose KeyValue.getBuffer() for tests alone. Allows KV#getBuffer in tests only that was deprecated previously.\n\n### Region scanner changes:\n\n#### interface RegionScanner \\[!toc]\n\n| Change                                                                                     | Result                                                              |\n| ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------- |\n| Abstract method boolean nextRaw ( List\\<Cell>, int ) has been removed from this interface. | A client program may be interrupted by NoSuchMethodError exception. |\n\n### StoreFile changes:\n\n#### class StoreFile \\[!toc]\n\n| Change                       | Result                                                                                                                                    |\n| ---------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| This class became interface. | A client program may be interrupted by IncompatibleClassChangeError or InstantiationError exception dependent on the usage of this class. |\n\n### Mapreduce changes:\n\nHFile\\*Format has been removed in HBase 2.0.\n\n### ClusterStatus changes:\n\nHBASE-15843: Replace RegionState.getRegionInTransition() Map with a Set\nhbase-client-1.0.0.jar, ClusterStatus.class package org.apache.hadoop.hbase\n\n#### ClusterStatus.getRegionsInTransition ( ) : Map\\<String,RegionState> 1 \\[!toc]\n\norg/apache/hadoop/hbase/ClusterStatus.getRegionsInTransition:()Ljava/util/Map;\n\n| Change                                                                                                                              | Result                                                                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from java.util.Map\\<java.lang.String,master.RegionState> to java.util.List\\<master.RegionState>. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\nOther changes in ClusterStatus include removal of convert methods that were no longer necessary after purge of PB from API.\n\n### Purge of PBs from API\n\nPBs have been deprecated in APIs in HBase 2.0.\n\n#### HBaseSnapshotException.getSnapshotDescription ( ) : HBaseProtos.SnapshotDescription 1 \\[!toc]\n\norg/apache/hadoop/hbase/snapshot/HBaseSnapshotException.getSnapshotDescription:()Lorg/apache/hadoop/hbase/protobuf/generated/HBaseProtos\\$SnapshotDescription;\n\n| Change                                                                                                                                                                    | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.HBaseProtos.SnapshotDescription to org.apache.hadoop.hbase.client.SnapshotDescription. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n* HBASE-15609: Remove PB references from Result, DoubleColumnInterpreter and any such public facing class for 2.0.\n  hbase-client-1.0.0.jar, Result.class package org.apache.hadoop.hbase.client\n\n#### Result.getStats ( ) : ClientProtos.RegionLoadStats 1 \\[!toc]\n\norg/apache/hadoop/hbase/client/Result.getStats:()Lorg/apache/hadoop/hbase/protobuf/generated/ClientProtos\\$RegionLoadStats;\n\n| Change                                                                                                                              | Result                                                                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.ClientProtos.RegionLoadStats to RegionLoadStats. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### REST changes:\n\nhbase-rest-1.0.0.jar, Client.class package org.apache.hadoop.hbase.rest.client\n\n#### Client.getHttpClient ( ) : HttpClient 1 \\[!toc]\n\norg/apache/hadoop/hbase/rest/client/Client.getHttpClient:()Lorg/apache/commons/httpclient/HttpClient\n\n| Change                                                                                                                 | Result                                                                                                                                                    |\n| ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.commons.httpclient.HttpClient to org.apache.http.client.HttpClient. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\nhbase-rest-1.0.0.jar, Response.class package org.apache.hadoop.hbase.rest.client\n\n#### Response.getHeaders ( ) : Header\\[ ] 1 \\[!toc]\n\norg/apache/hadoop/hbase/rest/client/Response.getHeaders:()\\[Lorg/apache/commons/httpclient/Header;\n\n| Change                                                                                                        | Result                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from org.apache.commons.httpclient.Header\\[] to org.apache.http.Header\\[]. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### PrettyPrinter changes:\n\nhbase-server-1.0.0.jar, HFilePrettyPrinter.class package org.apache.hadoop.hbase.io.hfile\n\n#### HFilePrettyPrinter.processFile ( Path file ) : void 1 \\[!toc]\n\norg/apache/hadoop/hbase/io/hfile/HFilePrettyPrinter.processFile:(Lorg/apache/hadoop/fs/Path;)V\n\n| Change                                               | Result                                                                                                                                                    |\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return value type has been changed from void to int. | This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception. |\n\n### AccessControlClient changes:\n\nHBASE-13171 Change AccessControlClient methods to accept connection object to reduce setup time. Parameters have been changed in the following methods:\n\n* hbase-client-1.2.7-SNAPSHOT.jar, AccessControlClient.class\n  package org.apache.hadoop.hbase.security.access\n  AccessControlClient.getUserPermissions ( Configuration conf, String tableRegex ) \\[static] : List\\<UserPermission> **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.getUserPermissions:(Lorg/apache/hadoop/conf/Configuration;Ljava/lang/String;)Ljava/util/List;\n\n* AccessControlClient.grant ( Configuration conf, String namespace, String userName, Permission.Action... actions )\\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.grant:(Lorg/apache/hadoop/conf/Configuration;Ljava/lang/String;Ljava/lang/String;\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* AccessControlClient.grant ( Configuration conf, String userName, Permission.Action... actions ) \\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.grant:(Lorg/apache/hadoop/conf/Configuration;Ljava/lang/String;\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* AccessControlClient.grant ( Configuration conf, TableName tableName, String userName, byte\\[ ] family, byte\\[ ] qual,Permission.Action... actions ) \\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.grant:(Lorg/apache/hadoop/conf/Configuration;Lorg/apache/hadoop/hbase/TableName;Ljava/lang/String;\\[B\\[B\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* AccessControlClient.isAccessControllerRunning ( Configuration conf ) \\[static] : boolean **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.isAccessControllerRunning:(Lorg/apache/hadoop/conf/Configuration;)Z\n\n* AccessControlClient.revoke ( Configuration conf, String namespace, String userName, Permission.Action... actions )\\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.revoke:(Lorg/apache/hadoop/conf/Configuration;Ljava/lang/String;Ljava/lang/String;\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* AccessControlClient.revoke ( Configuration conf, String userName, Permission.Action... actions ) \\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.revoke:(Lorg/apache/hadoop/conf/Configuration;Ljava/lang/String;\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* AccessControlClient.revoke ( Configuration conf, TableName tableName, String username, byte\\[ ] family, byte\\[ ] qualifier,Permission.Action... actions ) \\[static] : void **DEPRECATED**\n  org/apache/hadoop/hbase/security/access/AccessControlClient.revoke:(Lorg/apache/hadoop/conf/Configuration;Lorg/apache/hadoop/hbase/TableName;Ljava/lang/String;\\[B\\[B\\[Lorg/apache/hadoop/hbase/security/access/Permission\\$Action;)V\n\n* HBASE-18731: \\[compat 1-2] Mark protected methods of QuotaSettings that touch Protobuf internals as IA.Private\n"]
