import{j as e}from"./chunk-OIYGIGL5-BFuAKb0n.js";let s=`See [HBASE-12439](https://issues.apache.org/jira/browse/HBASE-12439) for the original implementation.

With Pv2 you can build and run state machines. It was built by Matteo to make distributed state transitions in HBase resilient in the face of process failures. Previous to Pv2, state transition handling was spread about the codebase with implementation varying by transition-type and context. Pv2 was inspired by [FATE](https://accumulo.apache.org/1.8/accumulo_user_manual.html#_fault_tolerant_executor_fate), of Apache Accumulo.

Early Pv2 aspects have been shipping in HBase with a good while now but it has continued to evolve as it takes on more involved scenarios. What we have now is powerful but intricate in operation and incomplete, in need of cleanup and hardening. In this doc we have given overview on the system so you can make use of it (and help with its polishing).

This system has the awkward name of Pv2 because HBase already had the notion of a Procedure used in snapshots (see hbase-server *org.apache.hadoop.hbase.procedure* as opposed to hbase-procedure *org.apache.hadoop.hbase.procedure2*). Pv2 supercedes and is to replace Procedure.

## Procedures

A Procedure is a transform made on an HBase entity. Examples of HBase entities would be Regions and Tables.
Procedures are run by a ProcedureExecutor instance. Procedure current state is kept in the ProcedureStore.
The ProcedureExecutor has but a primitive view on what goes on inside a Procedure. From its PoV, Procedures are submitted and then the ProcedureExecutor keeps calling *#execute(Object)* until the Procedure is done. Execute may be called multiple times in the case of failure or restart, so Procedure code must be idempotent yielding the same result each time it run. Procedure code can also implement *rollback* so steps can be undone if failure. A call to *execute()* can result in one of following possibilities:

* *execute()* returns
  * *null*: indicates we are done.
  * *this*: indicates there is more to do so, persist current procedure state and re-*execute()*.
  * *Array* of sub-procedures: indicates a set of procedures needed to be run to completion before we can proceed (after which we expect the framework to call our execute again).
* *execute()* throws exception
  * *suspend*: indicates execution of procedure is suspended and can be resumed due to some external event. The procedure state is persisted.
  * *yield*: procedure is added back to scheduler. The procedure state is not persisted.
  * *interrupted*: currently same as *yield*.
  * Any *exception* not listed above: Procedure *state* is changed to *FAILED* (after which we expect the framework will attempt rollback).

The ProcedureExecutor stamps the frameworks notions of Procedure State into the Procedure itself; e.g. it marks Procedures as INITIALIZING on submit. It moves the state to RUNNABLE when it goes to execute. When done, a Procedure gets marked FAILED or SUCCESS depending. Here is the list of all states as of this writing:

* ***INITIALIZING*** Procedure in construction, not yet added to the executor
* ***RUNNABLE*** Procedure added to the executor, and ready to be executed.
* ***WAITING*** The procedure is waiting on children (subprocedures) to be completed
* ***WAITING\\_TIMEOUT*** The procedure is waiting a timeout or an external event
* ***ROLLEDBACK*** The procedure failed and was rolledback.
* ***SUCCESS*** The procedure execution completed successfully.
* ***FAILED*** The procedure execution failed, may need to rollback.

After each execute, the Procedure state is persisted to the ProcedureStore. Hooks are invoked on Procedures so they can preserve custom state. Post-fault, the ProcedureExecutor re-hydrates its pre-crash state by replaying the content of the ProcedureStore. This makes the Procedure Framework resilient against process failure.

### Implementation

In implementation, Procedures tend to divide transforms into finer-grained tasks and while some of these work items are handed off to sub-procedures,
the bulk are done as processing *steps* in-Procedure; each invocation of the execute is used to perform a single step, and then the Procedure relinquishes returning to the framework. The Procedure does its own tracking of where it is in the processing.

What comprises a sub-task, or *step* in the execution is up to the Procedure author but generally it is a small piece of work that cannot be further decomposed and that moves the processing forward toward its end state. Having procedures made of many small steps rather than a few large ones allows the Procedure framework give out insight on where we are in the processing. It also allows the framework be more fair in its execution. As stated per above, each step may be called multiple times (failure/restart) so steps must be implemented idempotent.
It is easy to confuse the state that the Procedure itself is keeping with that of the Framework itself. Try to keep them distinct.

### Rollback

Rollback is called when the procedure or one of the sub-procedures has failed. The rollback step is supposed to cleanup the resources created during the execute() step. In case of failure and restart, rollback() may be called multiple times, so again the code must be idempotent.

### Metrics

There are hooks for collecting metrics on submit of the procedure and on finish.

* updateMetricsOnSubmit()
* updateMetricsOnFinish()

Individual procedures can override these methods to collect procedure specific metrics. The default implementations of these methods  try to get an object implementing an interface ProcedureMetrics which encapsulates following set of generic metrics:

* SubmittedCount (Counter): Total number of procedure instances submitted of a type.
* Time (Histogram): Histogram of runtime for procedure instances.
* FailedCount (Counter): Total number of failed procedure instances.

Individual procedures can implement this object and define these generic set of metrics.

### Baggage

Procedures can carry baggage. One example is the *step* the procedure last attained (see previous section); procedures persist the enum that marks where they are currently. Other examples might be the Region or Server name the Procedure is currently working. After each call to execute, the Procedure#serializeStateData is called. Procedures can persist whatever.

### Result/State and Queries

(From Matteo's [ProcedureV2 and Notification Bus](https://issues.apache.org/jira/secure/attachment/12693273/Procedurev2Notification-Bus.pdf) doc)\\
In the case of asynchronous operations, the result must be kept around until the client asks for it. Once we receive a "get" of the result we can schedule the delete of the record. For some operations the result may be "unnecessary" especially in case of failure (e.g. if the create table fail, we can query the operation result or we can just do a list table to see if it was created) so in some cases we can schedule the delete after a timeout. On the client side the operation will return a "Procedure ID", this ID can be used to wait until the procedure is completed and get the result/exception.

\`\`\`
Admin.doOperation() { longprocId=master.doOperation(); master.waitCompletion(procId); }
\`\`\`

If the master goes down while performing the operation the backup master will pickup the half in­progress operation and complete it. The client will not notice the failure.

## Subprocedures

Subprocedures are *Procedure* instances created and returned by *#execute(Object)* method of a procedure instance (parent procedure). As subprocedures are of type *Procedure*, they can instantiate their own subprocedures. As its a recursive, procedure stack is maintained by the framework. The framework makes sure that the parent procedure does not proceed till all sub-procedures and their subprocedures in a procedure stack are successfully finished.

## ProcedureExecutor

*ProcedureExecutor* uses *ProcedureStore* and *ProcedureScheduler* and executes procedures submitted to it. Some of the basic operations supported are:

* *abort(procId)*: aborts specified procedure if its not finished
* *submit(Procedure)*: submits procedure for execution
* *retrieve:* list of get methods to get *Procedure* instances and results
* *register/ unregister* listeners: for listening on Procedure related notifications

When *ProcedureExecutor* starts it loads procedure instances persisted in *ProcedureStore* from previous run. All unfinished procedures are resumed from the last stored state.

## Nonces

You can pass the nonce that came in with the RPC to the Procedure on submit at the executor. This nonce will then be serialized along w/ the Procedure on persist. If a crash, on reload, the nonce will be put back into a map of nonces to pid in case a client tries to run same procedure for a second time (it will be rejected). See the base Procedure and how nonce is a base data member.

## Wait/Wake/Suspend/Yield

'suspend' means stop processing a procedure because we can make no more progress until a condition changes; i.e. we sent RPC and need to wait on response. The way this works is that a Procedure throws a suspend exception from down in its guts as a GOTO the end-of-the-current-processing step. Suspend also puts the Procedure back on the scheduler. Problematic is we do some accounting on our way out even on suspend making it so it can take time exiting (We have to update state in the WAL).

RegionTransitionProcedure#reportTransition is called on receipt of a report from a RS. For Assign and Unassign, this event response from the server we sent an RPC wakes up suspended Assign/Unassigns.

## Locking

Procedure Locks are not about concurrency! They are about giving a Procedure read/write access to an HBase Entity such as a Table or Region so that is possible to shut out other Procedures from making modifications to an HBase Entity state while the current one is running.

Locking is optional, up to the Procedure implementor but if an entity is being operated on by a Procedure, all transforms need to be done via Procedures using the same locking scheme else havoc.

Two ProcedureExecutor Worker threads can actually end up both processing the same Procedure instance. If it happens, the threads are meant to be running different parts of the one Procedure — changes that do not stamp on each other (This gets awkward around the procedure frameworks notion of ‘suspend'. More on this below).

Locks optionally may be held for the life of a Procedure. For example, if moving a Region, you probably want to have exclusive access to the HBase Region until the Region completes (or fails). This is used in conjunction with \\{@link #holdLock(Object)}. If \\{@link #holdLock(Object)} returns true, the procedure executor will call acquireLock() once and thereafter not call \\{@link #releaseLock(Object)} until the Procedure is done (Normally, it calls release/acquire around each invocation of \\{@link #execute(Object)}.

Locks also may live the life of a procedure; i.e. once an Assign Procedure starts, we do not want another procedure meddling w/ the region under assignment. Procedures that hold the lock for the life of the procedure set Procedure#holdLock to true. AssignProcedure does this as do Split and Move (If in the middle of a Region move, you do not want it Splitting).

Locking can be for life of Procedure.

Some locks have a hierarchy. For example, taking a region lock also takes (read) lock on its containing table and namespace to prevent another Procedure obtaining an exclusive lock on the hosting table (or namespace).

## Procedure Types

### StateMachineProcedure

One can consider each call to *#execute(Object)* method as transitioning from one state to another in a state machine. Abstract class *StateMachineProcedure* is wrapper around base *Procedure* class which provides constructs for implementing a state machine as a *Procedure*. After each state transition current state is persisted so that, in case of crash/ restart, the state transition can be resumed from the previous state of a procedure before crash/ restart. Individual procedures need to define initial and terminus states and hooks *executeFromState()* and *setNextState()* are provided for state transitions.

### RemoteProcedureDispatcher

A new RemoteProcedureDispatcher (+ subclass RSProcedureDispatcher) primitive takes care of running the Procedure-based Assignments 'remote' component. This dispatcher knows about 'servers'. It does aggregation of assignments by time on a time/count basis so can send procedures in batches rather than one per RPC. Procedure status comes back on the back of the RegionServer heartbeat reporting online/offline regions (No more notifications via ZK). The response is passed to the AMv2 to 'process'. It will check against the in-memory state. If there is a mismatch, it fences out the RegionServer on the assumption that something went wrong on the RS side. Timeouts trigger retries (Not Yet Implemented!). The Procedure machine ensures only one operation at a time on any one Region/Table using entity *locking* and smarts about what is serial and what can be run concurrently (Locking was zk-based — you'd put a znode in zk for a table — but now has been converted to be procedure-based as part of this project).

## References

* Matteo had a slide deck on what it the Procedure Framework would look like and the problems it addresses initially [attached to the Pv2 issue.](https://issues.apache.org/jira/secure/attachment/12845124/ProcedureV2b.pdf)
* [A good doc by Matteo](https://issues.apache.org/jira/secure/attachment/12693273/Procedurev2Notification-Bus.pdf) on problem and how Pv2 addresses it w/ roadmap (from the Pv2 JIRA). We should go back to the roadmap to do the Notification Bus, convertion of log splitting to Pv2, etc.
`,a={title:"Procedure Framework (PV2)",description:"Procedure v2 ...aims to provide a unified way to build...multi-step procedures with a rollback/roll-forward ability in case of failure (e.g. create/delete table) — Matteo Bertozzi, the author of Pv2."},i=[{href:"https://issues.apache.org/jira/browse/HBASE-12439"},{href:"https://accumulo.apache.org/1.8/accumulo_user_manual.html#_fault_tolerant_executor_fate"},{href:"https://issues.apache.org/jira/secure/attachment/12693273/Procedurev2Notification-Bus.pdf"},{href:"https://issues.apache.org/jira/secure/attachment/12845124/ProcedureV2b.pdf"},{href:"https://issues.apache.org/jira/secure/attachment/12693273/Procedurev2Notification-Bus.pdf"}],c={contents:[{heading:void 0,content:"See HBASE-12439 for the original implementation."},{heading:void 0,content:"With Pv2 you can build and run state machines. It was built by Matteo to make distributed state transitions in HBase resilient in the face of process failures. Previous to Pv2, state transition handling was spread about the codebase with implementation varying by transition-type and context. Pv2 was inspired by FATE, of Apache Accumulo."},{heading:void 0,content:"Early Pv2 aspects have been shipping in HBase with a good while now but it has continued to evolve as it takes on more involved scenarios. What we have now is powerful but intricate in operation and incomplete, in need of cleanup and hardening. In this doc we have given overview on the system so you can make use of it (and help with its polishing)."},{heading:void 0,content:"This system has the awkward name of Pv2 because HBase already had the notion of a Procedure used in snapshots (see hbase-server org.apache.hadoop.hbase.procedure as opposed to hbase-procedure org.apache.hadoop.hbase.procedure2). Pv2 supercedes and is to replace Procedure."},{heading:"procedures",content:`A Procedure is a transform made on an HBase entity. Examples of HBase entities would be Regions and Tables.
Procedures are run by a ProcedureExecutor instance. Procedure current state is kept in the ProcedureStore.
The ProcedureExecutor has but a primitive view on what goes on inside a Procedure. From its PoV, Procedures are submitted and then the ProcedureExecutor keeps calling #execute(Object) until the Procedure is done. Execute may be called multiple times in the case of failure or restart, so Procedure code must be idempotent yielding the same result each time it run. Procedure code can also implement rollback so steps can be undone if failure. A call to execute() can result in one of following possibilities:`},{heading:"procedures",content:"execute() returns"},{heading:"procedures",content:"null: indicates we are done."},{heading:"procedures",content:"this: indicates there is more to do so, persist current procedure state and re-execute()."},{heading:"procedures",content:"Array of sub-procedures: indicates a set of procedures needed to be run to completion before we can proceed (after which we expect the framework to call our execute again)."},{heading:"procedures",content:"execute() throws exception"},{heading:"procedures",content:"suspend: indicates execution of procedure is suspended and can be resumed due to some external event. The procedure state is persisted."},{heading:"procedures",content:"yield: procedure is added back to scheduler. The procedure state is not persisted."},{heading:"procedures",content:"interrupted: currently same as yield."},{heading:"procedures",content:"Any exception not listed above: Procedure state is changed to FAILED (after which we expect the framework will attempt rollback)."},{heading:"procedures",content:"The ProcedureExecutor stamps the frameworks notions of Procedure State into the Procedure itself; e.g. it marks Procedures as INITIALIZING on submit. It moves the state to RUNNABLE when it goes to execute. When done, a Procedure gets marked FAILED or SUCCESS depending. Here is the list of all states as of this writing:"},{heading:"procedures",content:"INITIALIZING Procedure in construction, not yet added to the executor"},{heading:"procedures",content:"RUNNABLE Procedure added to the executor, and ready to be executed."},{heading:"procedures",content:"WAITING The procedure is waiting on children (subprocedures) to be completed"},{heading:"procedures",content:"WAITING_TIMEOUT The procedure is waiting a timeout or an external event"},{heading:"procedures",content:"ROLLEDBACK The procedure failed and was rolledback."},{heading:"procedures",content:"SUCCESS The procedure execution completed successfully."},{heading:"procedures",content:"FAILED The procedure execution failed, may need to rollback."},{heading:"procedures",content:"After each execute, the Procedure state is persisted to the ProcedureStore. Hooks are invoked on Procedures so they can preserve custom state. Post-fault, the ProcedureExecutor re-hydrates its pre-crash state by replaying the content of the ProcedureStore. This makes the Procedure Framework resilient against process failure."},{heading:"implementation",content:`In implementation, Procedures tend to divide transforms into finer-grained tasks and while some of these work items are handed off to sub-procedures,
the bulk are done as processing steps in-Procedure; each invocation of the execute is used to perform a single step, and then the Procedure relinquishes returning to the framework. The Procedure does its own tracking of where it is in the processing.`},{heading:"implementation",content:`What comprises a sub-task, or step in the execution is up to the Procedure author but generally it is a small piece of work that cannot be further decomposed and that moves the processing forward toward its end state. Having procedures made of many small steps rather than a few large ones allows the Procedure framework give out insight on where we are in the processing. It also allows the framework be more fair in its execution. As stated per above, each step may be called multiple times (failure/restart) so steps must be implemented idempotent.
It is easy to confuse the state that the Procedure itself is keeping with that of the Framework itself. Try to keep them distinct.`},{heading:"rollback",content:"Rollback is called when the procedure or one of the sub-procedures has failed. The rollback step is supposed to cleanup the resources created during the execute() step. In case of failure and restart, rollback() may be called multiple times, so again the code must be idempotent."},{heading:"pv2-procedures-metrics",content:"There are hooks for collecting metrics on submit of the procedure and on finish."},{heading:"pv2-procedures-metrics",content:"updateMetricsOnSubmit()"},{heading:"pv2-procedures-metrics",content:"updateMetricsOnFinish()"},{heading:"pv2-procedures-metrics",content:"Individual procedures can override these methods to collect procedure specific metrics. The default implementations of these methods  try to get an object implementing an interface ProcedureMetrics which encapsulates following set of generic metrics:"},{heading:"pv2-procedures-metrics",content:"SubmittedCount (Counter): Total number of procedure instances submitted of a type."},{heading:"pv2-procedures-metrics",content:"Time (Histogram): Histogram of runtime for procedure instances."},{heading:"pv2-procedures-metrics",content:"FailedCount (Counter): Total number of failed procedure instances."},{heading:"pv2-procedures-metrics",content:"Individual procedures can implement this object and define these generic set of metrics."},{heading:"baggage",content:"Procedures can carry baggage. One example is the step the procedure last attained (see previous section); procedures persist the enum that marks where they are currently. Other examples might be the Region or Server name the Procedure is currently working. After each call to execute, the Procedure#serializeStateData is called. Procedures can persist whatever."},{heading:"resultstate-and-queries",content:`(From Matteo's ProcedureV2 and Notification Bus doc)In the case of asynchronous operations, the result must be kept around until the client asks for it. Once we receive a "get" of the result we can schedule the delete of the record. For some operations the result may be "unnecessary" especially in case of failure (e.g. if the create table fail, we can query the operation result or we can just do a list table to see if it was created) so in some cases we can schedule the delete after a timeout. On the client side the operation will return a "Procedure ID", this ID can be used to wait until the procedure is completed and get the result/exception.`},{heading:"resultstate-and-queries",content:"If the master goes down while performing the operation the backup master will pickup the half in­progress operation and complete it. The client will not notice the failure."},{heading:"subprocedures",content:"Subprocedures are Procedure instances created and returned by #execute(Object) method of a procedure instance (parent procedure). As subprocedures are of type Procedure, they can instantiate their own subprocedures. As its a recursive, procedure stack is maintained by the framework. The framework makes sure that the parent procedure does not proceed till all sub-procedures and their subprocedures in a procedure stack are successfully finished."},{heading:"procedureexecutor",content:"ProcedureExecutor uses ProcedureStore and ProcedureScheduler and executes procedures submitted to it. Some of the basic operations supported are:"},{heading:"procedureexecutor",content:"abort(procId): aborts specified procedure if its not finished"},{heading:"procedureexecutor",content:"submit(Procedure): submits procedure for execution"},{heading:"procedureexecutor",content:"retrieve: list of get methods to get Procedure instances and results"},{heading:"procedureexecutor",content:"register/ unregister listeners: for listening on Procedure related notifications"},{heading:"procedureexecutor",content:"When ProcedureExecutor starts it loads procedure instances persisted in ProcedureStore from previous run. All unfinished procedures are resumed from the last stored state."},{heading:"nonces",content:"You can pass the nonce that came in with the RPC to the Procedure on submit at the executor. This nonce will then be serialized along w/ the Procedure on persist. If a crash, on reload, the nonce will be put back into a map of nonces to pid in case a client tries to run same procedure for a second time (it will be rejected). See the base Procedure and how nonce is a base data member."},{heading:"waitwakesuspendyield",content:"'suspend' means stop processing a procedure because we can make no more progress until a condition changes; i.e. we sent RPC and need to wait on response. The way this works is that a Procedure throws a suspend exception from down in its guts as a GOTO the end-of-the-current-processing step. Suspend also puts the Procedure back on the scheduler. Problematic is we do some accounting on our way out even on suspend making it so it can take time exiting (We have to update state in the WAL)."},{heading:"waitwakesuspendyield",content:"RegionTransitionProcedure#reportTransition is called on receipt of a report from a RS. For Assign and Unassign, this event response from the server we sent an RPC wakes up suspended Assign/Unassigns."},{heading:"locking",content:"Procedure Locks are not about concurrency! They are about giving a Procedure read/write access to an HBase Entity such as a Table or Region so that is possible to shut out other Procedures from making modifications to an HBase Entity state while the current one is running."},{heading:"locking",content:"Locking is optional, up to the Procedure implementor but if an entity is being operated on by a Procedure, all transforms need to be done via Procedures using the same locking scheme else havoc."},{heading:"locking",content:"Two ProcedureExecutor Worker threads can actually end up both processing the same Procedure instance. If it happens, the threads are meant to be running different parts of the one Procedure — changes that do not stamp on each other (This gets awkward around the procedure frameworks notion of ‘suspend'. More on this below)."},{heading:"locking",content:"Locks optionally may be held for the life of a Procedure. For example, if moving a Region, you probably want to have exclusive access to the HBase Region until the Region completes (or fails). This is used in conjunction with {@link #holdLock(Object)}. If {@link #holdLock(Object)} returns true, the procedure executor will call acquireLock() once and thereafter not call {@link #releaseLock(Object)} until the Procedure is done (Normally, it calls release/acquire around each invocation of {@link #execute(Object)}."},{heading:"locking",content:"Locks also may live the life of a procedure; i.e. once an Assign Procedure starts, we do not want another procedure meddling w/ the region under assignment. Procedures that hold the lock for the life of the procedure set Procedure#holdLock to true. AssignProcedure does this as do Split and Move (If in the middle of a Region move, you do not want it Splitting)."},{heading:"locking",content:"Locking can be for life of Procedure."},{heading:"locking",content:"Some locks have a hierarchy. For example, taking a region lock also takes (read) lock on its containing table and namespace to prevent another Procedure obtaining an exclusive lock on the hosting table (or namespace)."},{heading:"statemachineprocedure",content:"One can consider each call to #execute(Object) method as transitioning from one state to another in a state machine. Abstract class StateMachineProcedure is wrapper around base Procedure class which provides constructs for implementing a state machine as a Procedure. After each state transition current state is persisted so that, in case of crash/ restart, the state transition can be resumed from the previous state of a procedure before crash/ restart. Individual procedures need to define initial and terminus states and hooks executeFromState() and setNextState() are provided for state transitions."},{heading:"remoteproceduredispatcher",content:"A new RemoteProcedureDispatcher (+ subclass RSProcedureDispatcher) primitive takes care of running the Procedure-based Assignments 'remote' component. This dispatcher knows about 'servers'. It does aggregation of assignments by time on a time/count basis so can send procedures in batches rather than one per RPC. Procedure status comes back on the back of the RegionServer heartbeat reporting online/offline regions (No more notifications via ZK). The response is passed to the AMv2 to 'process'. It will check against the in-memory state. If there is a mismatch, it fences out the RegionServer on the assumption that something went wrong on the RS side. Timeouts trigger retries (Not Yet Implemented!). The Procedure machine ensures only one operation at a time on any one Region/Table using entity locking and smarts about what is serial and what can be run concurrently (Locking was zk-based — you'd put a znode in zk for a table — but now has been converted to be procedure-based as part of this project)."},{heading:"references",content:"Matteo had a slide deck on what it the Procedure Framework would look like and the problems it addresses initially attached to the Pv2 issue."},{heading:"references",content:"A good doc by Matteo on problem and how Pv2 addresses it w/ roadmap (from the Pv2 JIRA). We should go back to the roadmap to do the Notification Bus, convertion of log splitting to Pv2, etc."}],headings:[{id:"procedures",content:"Procedures"},{id:"implementation",content:"Implementation"},{id:"rollback",content:"Rollback"},{id:"pv2-procedures-metrics",content:"Metrics"},{id:"baggage",content:"Baggage"},{id:"resultstate-and-queries",content:"Result/State and Queries"},{id:"subprocedures",content:"Subprocedures"},{id:"procedureexecutor",content:"ProcedureExecutor"},{id:"nonces",content:"Nonces"},{id:"waitwakesuspendyield",content:"Wait/Wake/Suspend/Yield"},{id:"locking",content:"Locking"},{id:"procedure-types",content:"Procedure Types"},{id:"statemachineprocedure",content:"StateMachineProcedure"},{id:"remoteproceduredispatcher",content:"RemoteProcedureDispatcher"},{id:"references",content:"References"}]};const d=[{depth:2,url:"#procedures",title:e.jsx(e.Fragment,{children:"Procedures"})},{depth:3,url:"#implementation",title:e.jsx(e.Fragment,{children:"Implementation"})},{depth:3,url:"#rollback",title:e.jsx(e.Fragment,{children:"Rollback"})},{depth:3,url:"#pv2-procedures-metrics",title:e.jsx(e.Fragment,{children:"Metrics"})},{depth:3,url:"#baggage",title:e.jsx(e.Fragment,{children:"Baggage"})},{depth:3,url:"#resultstate-and-queries",title:e.jsx(e.Fragment,{children:"Result/State and Queries"})},{depth:2,url:"#subprocedures",title:e.jsx(e.Fragment,{children:"Subprocedures"})},{depth:2,url:"#procedureexecutor",title:e.jsx(e.Fragment,{children:"ProcedureExecutor"})},{depth:2,url:"#nonces",title:e.jsx(e.Fragment,{children:"Nonces"})},{depth:2,url:"#waitwakesuspendyield",title:e.jsx(e.Fragment,{children:"Wait/Wake/Suspend/Yield"})},{depth:2,url:"#locking",title:e.jsx(e.Fragment,{children:"Locking"})},{depth:2,url:"#procedure-types",title:e.jsx(e.Fragment,{children:"Procedure Types"})},{depth:3,url:"#statemachineprocedure",title:e.jsx(e.Fragment,{children:"StateMachineProcedure"})},{depth:3,url:"#remoteproceduredispatcher",title:e.jsx(e.Fragment,{children:"RemoteProcedureDispatcher"})},{depth:2,url:"#references",title:e.jsx(e.Fragment,{children:"References"})}];function o(r){const t={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...r.components};return e.jsxs(e.Fragment,{children:[e.jsxs(t.p,{children:["See ",e.jsx(t.a,{href:"https://issues.apache.org/jira/browse/HBASE-12439",children:"HBASE-12439"})," for the original implementation."]}),`
`,e.jsxs(t.p,{children:["With Pv2 you can build and run state machines. It was built by Matteo to make distributed state transitions in HBase resilient in the face of process failures. Previous to Pv2, state transition handling was spread about the codebase with implementation varying by transition-type and context. Pv2 was inspired by ",e.jsx(t.a,{href:"https://accumulo.apache.org/1.8/accumulo_user_manual.html#_fault_tolerant_executor_fate",children:"FATE"}),", of Apache Accumulo."]}),`
`,e.jsx(t.p,{children:"Early Pv2 aspects have been shipping in HBase with a good while now but it has continued to evolve as it takes on more involved scenarios. What we have now is powerful but intricate in operation and incomplete, in need of cleanup and hardening. In this doc we have given overview on the system so you can make use of it (and help with its polishing)."}),`
`,e.jsxs(t.p,{children:["This system has the awkward name of Pv2 because HBase already had the notion of a Procedure used in snapshots (see hbase-server ",e.jsx(t.em,{children:"org.apache.hadoop.hbase.procedure"})," as opposed to hbase-procedure ",e.jsx(t.em,{children:"org.apache.hadoop.hbase.procedure2"}),"). Pv2 supercedes and is to replace Procedure."]}),`
`,e.jsx(t.h2,{id:"procedures",children:"Procedures"}),`
`,e.jsxs(t.p,{children:[`A Procedure is a transform made on an HBase entity. Examples of HBase entities would be Regions and Tables.
Procedures are run by a ProcedureExecutor instance. Procedure current state is kept in the ProcedureStore.
The ProcedureExecutor has but a primitive view on what goes on inside a Procedure. From its PoV, Procedures are submitted and then the ProcedureExecutor keeps calling `,e.jsx(t.em,{children:"#execute(Object)"})," until the Procedure is done. Execute may be called multiple times in the case of failure or restart, so Procedure code must be idempotent yielding the same result each time it run. Procedure code can also implement ",e.jsx(t.em,{children:"rollback"})," so steps can be undone if failure. A call to ",e.jsx(t.em,{children:"execute()"})," can result in one of following possibilities:"]}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"execute()"})," returns",`
`,e.jsxs(t.ul,{children:[`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"null"}),": indicates we are done."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"this"}),": indicates there is more to do so, persist current procedure state and re-",e.jsx(t.em,{children:"execute()"}),"."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"Array"})," of sub-procedures: indicates a set of procedures needed to be run to completion before we can proceed (after which we expect the framework to call our execute again)."]}),`
`]}),`
`]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"execute()"})," throws exception",`
`,e.jsxs(t.ul,{children:[`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"suspend"}),": indicates execution of procedure is suspended and can be resumed due to some external event. The procedure state is persisted."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"yield"}),": procedure is added back to scheduler. The procedure state is not persisted."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"interrupted"}),": currently same as ",e.jsx(t.em,{children:"yield"}),"."]}),`
`,e.jsxs(t.li,{children:["Any ",e.jsx(t.em,{children:"exception"})," not listed above: Procedure ",e.jsx(t.em,{children:"state"})," is changed to ",e.jsx(t.em,{children:"FAILED"})," (after which we expect the framework will attempt rollback)."]}),`
`]}),`
`]}),`
`]}),`
`,e.jsx(t.p,{children:"The ProcedureExecutor stamps the frameworks notions of Procedure State into the Procedure itself; e.g. it marks Procedures as INITIALIZING on submit. It moves the state to RUNNABLE when it goes to execute. When done, a Procedure gets marked FAILED or SUCCESS depending. Here is the list of all states as of this writing:"}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:e.jsx(t.em,{children:"INITIALIZING"})})," Procedure in construction, not yet added to the executor"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:e.jsx(t.em,{children:"RUNNABLE"})})," Procedure added to the executor, and ready to be executed."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:e.jsx(t.em,{children:"WAITING"})})," The procedure is waiting on children (subprocedures) to be completed"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:e.jsx(t.em,{children:"WAITING_TIMEOUT"})})," The procedure is waiting a timeout or an external event"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:e.jsx(t.em,{children:"ROLLEDBACK"})})," The procedure failed and was rolledback."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:e.jsx(t.em,{children:"SUCCESS"})})," The procedure execution completed successfully."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:e.jsx(t.em,{children:"FAILED"})})," The procedure execution failed, may need to rollback."]}),`
`]}),`
`,e.jsx(t.p,{children:"After each execute, the Procedure state is persisted to the ProcedureStore. Hooks are invoked on Procedures so they can preserve custom state. Post-fault, the ProcedureExecutor re-hydrates its pre-crash state by replaying the content of the ProcedureStore. This makes the Procedure Framework resilient against process failure."}),`
`,e.jsx(t.h3,{id:"implementation",children:"Implementation"}),`
`,e.jsxs(t.p,{children:[`In implementation, Procedures tend to divide transforms into finer-grained tasks and while some of these work items are handed off to sub-procedures,
the bulk are done as processing `,e.jsx(t.em,{children:"steps"})," in-Procedure; each invocation of the execute is used to perform a single step, and then the Procedure relinquishes returning to the framework. The Procedure does its own tracking of where it is in the processing."]}),`
`,e.jsxs(t.p,{children:["What comprises a sub-task, or ",e.jsx(t.em,{children:"step"}),` in the execution is up to the Procedure author but generally it is a small piece of work that cannot be further decomposed and that moves the processing forward toward its end state. Having procedures made of many small steps rather than a few large ones allows the Procedure framework give out insight on where we are in the processing. It also allows the framework be more fair in its execution. As stated per above, each step may be called multiple times (failure/restart) so steps must be implemented idempotent.
It is easy to confuse the state that the Procedure itself is keeping with that of the Framework itself. Try to keep them distinct.`]}),`
`,e.jsx(t.h3,{id:"rollback",children:"Rollback"}),`
`,e.jsx(t.p,{children:"Rollback is called when the procedure or one of the sub-procedures has failed. The rollback step is supposed to cleanup the resources created during the execute() step. In case of failure and restart, rollback() may be called multiple times, so again the code must be idempotent."}),`
`,e.jsx(t.h3,{id:"pv2-procedures-metrics",children:"Metrics"}),`
`,e.jsx(t.p,{children:"There are hooks for collecting metrics on submit of the procedure and on finish."}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsx(t.li,{children:"updateMetricsOnSubmit()"}),`
`,e.jsx(t.li,{children:"updateMetricsOnFinish()"}),`
`]}),`
`,e.jsx(t.p,{children:"Individual procedures can override these methods to collect procedure specific metrics. The default implementations of these methods  try to get an object implementing an interface ProcedureMetrics which encapsulates following set of generic metrics:"}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsx(t.li,{children:"SubmittedCount (Counter): Total number of procedure instances submitted of a type."}),`
`,e.jsx(t.li,{children:"Time (Histogram): Histogram of runtime for procedure instances."}),`
`,e.jsx(t.li,{children:"FailedCount (Counter): Total number of failed procedure instances."}),`
`]}),`
`,e.jsx(t.p,{children:"Individual procedures can implement this object and define these generic set of metrics."}),`
`,e.jsx(t.h3,{id:"baggage",children:"Baggage"}),`
`,e.jsxs(t.p,{children:["Procedures can carry baggage. One example is the ",e.jsx(t.em,{children:"step"})," the procedure last attained (see previous section); procedures persist the enum that marks where they are currently. Other examples might be the Region or Server name the Procedure is currently working. After each call to execute, the Procedure#serializeStateData is called. Procedures can persist whatever."]}),`
`,e.jsx(t.h3,{id:"resultstate-and-queries",children:"Result/State and Queries"}),`
`,e.jsxs(t.p,{children:["(From Matteo's ",e.jsx(t.a,{href:"https://issues.apache.org/jira/secure/attachment/12693273/Procedurev2Notification-Bus.pdf",children:"ProcedureV2 and Notification Bus"})," doc)",e.jsx(t.br,{}),`
`,'In the case of asynchronous operations, the result must be kept around until the client asks for it. Once we receive a "get" of the result we can schedule the delete of the record. For some operations the result may be "unnecessary" especially in case of failure (e.g. if the create table fail, we can query the operation result or we can just do a list table to see if it was created) so in some cases we can schedule the delete after a timeout. On the client side the operation will return a "Procedure ID", this ID can be used to wait until the procedure is completed and get the result/exception.']}),`
`,e.jsx(e.Fragment,{children:e.jsx(t.pre,{className:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabIndex:"0",icon:'<svg viewBox="0 0 24 24"><path d="M 6,1 C 4.354992,1 3,2.354992 3,4 v 16 c 0,1.645008 1.354992,3 3,3 h 12 c 1.645008,0 3,-1.354992 3,-3 V 8 7 A 1.0001,1.0001 0 0 0 20.707031,6.2929687 l -5,-5 A 1.0001,1.0001 0 0 0 15,1 h -1 z m 0,2 h 7 v 3 c 0,1.645008 1.354992,3 3,3 h 3 v 11 c 0,0.564129 -0.435871,1 -1,1 H 6 C 5.4358712,21 5,20.564129 5,20 V 4 C 5,3.4358712 5.4358712,3 6,3 Z M 15,3.4140625 18.585937,7 H 16 C 15.435871,7 15,6.5641288 15,6 Z" fill="currentColor" /></svg>',children:e.jsx(t.code,{children:e.jsx(t.span,{className:"line",children:e.jsx(t.span,{children:"Admin.doOperation() { longprocId=master.doOperation(); master.waitCompletion(procId); }"})})})})}),`
`,e.jsx(t.p,{children:"If the master goes down while performing the operation the backup master will pickup the half in­progress operation and complete it. The client will not notice the failure."}),`
`,e.jsx(t.h2,{id:"subprocedures",children:"Subprocedures"}),`
`,e.jsxs(t.p,{children:["Subprocedures are ",e.jsx(t.em,{children:"Procedure"})," instances created and returned by ",e.jsx(t.em,{children:"#execute(Object)"})," method of a procedure instance (parent procedure). As subprocedures are of type ",e.jsx(t.em,{children:"Procedure"}),", they can instantiate their own subprocedures. As its a recursive, procedure stack is maintained by the framework. The framework makes sure that the parent procedure does not proceed till all sub-procedures and their subprocedures in a procedure stack are successfully finished."]}),`
`,e.jsx(t.h2,{id:"procedureexecutor",children:"ProcedureExecutor"}),`
`,e.jsxs(t.p,{children:[e.jsx(t.em,{children:"ProcedureExecutor"})," uses ",e.jsx(t.em,{children:"ProcedureStore"})," and ",e.jsx(t.em,{children:"ProcedureScheduler"})," and executes procedures submitted to it. Some of the basic operations supported are:"]}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"abort(procId)"}),": aborts specified procedure if its not finished"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"submit(Procedure)"}),": submits procedure for execution"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"retrieve:"})," list of get methods to get ",e.jsx(t.em,{children:"Procedure"})," instances and results"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.em,{children:"register/ unregister"})," listeners: for listening on Procedure related notifications"]}),`
`]}),`
`,e.jsxs(t.p,{children:["When ",e.jsx(t.em,{children:"ProcedureExecutor"})," starts it loads procedure instances persisted in ",e.jsx(t.em,{children:"ProcedureStore"})," from previous run. All unfinished procedures are resumed from the last stored state."]}),`
`,e.jsx(t.h2,{id:"nonces",children:"Nonces"}),`
`,e.jsx(t.p,{children:"You can pass the nonce that came in with the RPC to the Procedure on submit at the executor. This nonce will then be serialized along w/ the Procedure on persist. If a crash, on reload, the nonce will be put back into a map of nonces to pid in case a client tries to run same procedure for a second time (it will be rejected). See the base Procedure and how nonce is a base data member."}),`
`,e.jsx(t.h2,{id:"waitwakesuspendyield",children:"Wait/Wake/Suspend/Yield"}),`
`,e.jsx(t.p,{children:"'suspend' means stop processing a procedure because we can make no more progress until a condition changes; i.e. we sent RPC and need to wait on response. The way this works is that a Procedure throws a suspend exception from down in its guts as a GOTO the end-of-the-current-processing step. Suspend also puts the Procedure back on the scheduler. Problematic is we do some accounting on our way out even on suspend making it so it can take time exiting (We have to update state in the WAL)."}),`
`,e.jsx(t.p,{children:"RegionTransitionProcedure#reportTransition is called on receipt of a report from a RS. For Assign and Unassign, this event response from the server we sent an RPC wakes up suspended Assign/Unassigns."}),`
`,e.jsx(t.h2,{id:"locking",children:"Locking"}),`
`,e.jsx(t.p,{children:"Procedure Locks are not about concurrency! They are about giving a Procedure read/write access to an HBase Entity such as a Table or Region so that is possible to shut out other Procedures from making modifications to an HBase Entity state while the current one is running."}),`
`,e.jsx(t.p,{children:"Locking is optional, up to the Procedure implementor but if an entity is being operated on by a Procedure, all transforms need to be done via Procedures using the same locking scheme else havoc."}),`
`,e.jsx(t.p,{children:"Two ProcedureExecutor Worker threads can actually end up both processing the same Procedure instance. If it happens, the threads are meant to be running different parts of the one Procedure — changes that do not stamp on each other (This gets awkward around the procedure frameworks notion of ‘suspend'. More on this below)."}),`
`,e.jsx(t.p,{children:"Locks optionally may be held for the life of a Procedure. For example, if moving a Region, you probably want to have exclusive access to the HBase Region until the Region completes (or fails). This is used in conjunction with {@link #holdLock(Object)}. If {@link #holdLock(Object)} returns true, the procedure executor will call acquireLock() once and thereafter not call {@link #releaseLock(Object)} until the Procedure is done (Normally, it calls release/acquire around each invocation of {@link #execute(Object)}."}),`
`,e.jsx(t.p,{children:"Locks also may live the life of a procedure; i.e. once an Assign Procedure starts, we do not want another procedure meddling w/ the region under assignment. Procedures that hold the lock for the life of the procedure set Procedure#holdLock to true. AssignProcedure does this as do Split and Move (If in the middle of a Region move, you do not want it Splitting)."}),`
`,e.jsx(t.p,{children:"Locking can be for life of Procedure."}),`
`,e.jsx(t.p,{children:"Some locks have a hierarchy. For example, taking a region lock also takes (read) lock on its containing table and namespace to prevent another Procedure obtaining an exclusive lock on the hosting table (or namespace)."}),`
`,e.jsx(t.h2,{id:"procedure-types",children:"Procedure Types"}),`
`,e.jsx(t.h3,{id:"statemachineprocedure",children:"StateMachineProcedure"}),`
`,e.jsxs(t.p,{children:["One can consider each call to ",e.jsx(t.em,{children:"#execute(Object)"})," method as transitioning from one state to another in a state machine. Abstract class ",e.jsx(t.em,{children:"StateMachineProcedure"})," is wrapper around base ",e.jsx(t.em,{children:"Procedure"})," class which provides constructs for implementing a state machine as a ",e.jsx(t.em,{children:"Procedure"}),". After each state transition current state is persisted so that, in case of crash/ restart, the state transition can be resumed from the previous state of a procedure before crash/ restart. Individual procedures need to define initial and terminus states and hooks ",e.jsx(t.em,{children:"executeFromState()"})," and ",e.jsx(t.em,{children:"setNextState()"})," are provided for state transitions."]}),`
`,e.jsx(t.h3,{id:"remoteproceduredispatcher",children:"RemoteProcedureDispatcher"}),`
`,e.jsxs(t.p,{children:["A new RemoteProcedureDispatcher (+ subclass RSProcedureDispatcher) primitive takes care of running the Procedure-based Assignments 'remote' component. This dispatcher knows about 'servers'. It does aggregation of assignments by time on a time/count basis so can send procedures in batches rather than one per RPC. Procedure status comes back on the back of the RegionServer heartbeat reporting online/offline regions (No more notifications via ZK). The response is passed to the AMv2 to 'process'. It will check against the in-memory state. If there is a mismatch, it fences out the RegionServer on the assumption that something went wrong on the RS side. Timeouts trigger retries (Not Yet Implemented!). The Procedure machine ensures only one operation at a time on any one Region/Table using entity ",e.jsx(t.em,{children:"locking"})," and smarts about what is serial and what can be run concurrently (Locking was zk-based — you'd put a znode in zk for a table — but now has been converted to be procedure-based as part of this project)."]}),`
`,e.jsx(t.h2,{id:"references",children:"References"}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsxs(t.li,{children:["Matteo had a slide deck on what it the Procedure Framework would look like and the problems it addresses initially ",e.jsx(t.a,{href:"https://issues.apache.org/jira/secure/attachment/12845124/ProcedureV2b.pdf",children:"attached to the Pv2 issue."})]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.a,{href:"https://issues.apache.org/jira/secure/attachment/12693273/Procedurev2Notification-Bus.pdf",children:"A good doc by Matteo"})," on problem and how Pv2 addresses it w/ roadmap (from the Pv2 JIRA). We should go back to the roadmap to do the Notification Bus, convertion of log splitting to Pv2, etc."]}),`
`]})]})}function u(r={}){const{wrapper:t}=r.components||{};return t?e.jsx(t,{...r,children:e.jsx(o,{...r})}):o(r)}export{s as _markdown,u as default,i as extractedReferences,a as frontmatter,c as structuredData,d as toc};
